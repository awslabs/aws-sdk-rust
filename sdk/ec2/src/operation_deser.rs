// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_address_transfer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptAddressTransferOutput,
    crate::error::AcceptAddressTransferError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_address_transfer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptAddressTransferOutput,
    crate::error::AcceptAddressTransferError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_address_transfer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AcceptAddressTransferError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_instances_exchange_quote_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptReservedInstancesExchangeQuoteOutput,
    crate::error::AcceptReservedInstancesExchangeQuoteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptReservedInstancesExchangeQuoteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptReservedInstancesExchangeQuoteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_instances_exchange_quote_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptReservedInstancesExchangeQuoteOutput,
    crate::error::AcceptReservedInstancesExchangeQuoteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::accept_reserved_instances_exchange_quote_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_reserved_instances_exchange_quote(response.body().as_ref(), output).map_err(crate::error::AcceptReservedInstancesExchangeQuoteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_multicast_domain_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::AcceptTransitGatewayMulticastDomainAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_multicast_domain_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::AcceptTransitGatewayMulticastDomainAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_peering_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayPeeringAttachmentOutput,
    crate::error::AcceptTransitGatewayPeeringAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_peering_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayPeeringAttachmentOutput,
    crate::error::AcceptTransitGatewayPeeringAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::accept_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_vpc_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayVpcAttachmentOutput,
    crate::error::AcceptTransitGatewayVpcAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_vpc_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptTransitGatewayVpcAttachmentOutput,
    crate::error::AcceptTransitGatewayVpcAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::accept_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_endpoint_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptVpcEndpointConnectionsOutput,
    crate::error::AcceptVpcEndpointConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptVpcEndpointConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_endpoint_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptVpcEndpointConnectionsOutput,
    crate::error::AcceptVpcEndpointConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_vpc_endpoint_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AcceptVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_peering_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptVpcPeeringConnectionOutput,
    crate::error::AcceptVpcPeeringConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptVpcPeeringConnectionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_peering_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptVpcPeeringConnectionOutput,
    crate::error::AcceptVpcPeeringConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_vpc_peering_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AcceptVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_advertise_byoip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AdvertiseByoipCidrOutput,
    crate::error::AdvertiseByoipCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AdvertiseByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AdvertiseByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_advertise_byoip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AdvertiseByoipCidrOutput,
    crate::error::AdvertiseByoipCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::advertise_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_advertise_byoip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AdvertiseByoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AllocateAddressOutput, crate::error::AllocateAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AllocateAddressOutput, crate::error::AllocateAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_address_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_address(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateAddressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AllocateHostsOutput, crate::error::AllocateHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AllocateHostsOutput, crate::error::AllocateHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_hosts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateHostsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_ipam_pool_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateIpamPoolCidrOutput,
    crate::error::AllocateIpamPoolCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_ipam_pool_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateIpamPoolCidrOutput,
    crate::error::AllocateIpamPoolCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_ipam_pool_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateIpamPoolCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_security_groups_to_client_vpn_target_network_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplySecurityGroupsToClientVpnTargetNetworkOutput,
    crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_security_groups_to_client_vpn_target_network_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ApplySecurityGroupsToClientVpnTargetNetworkOutput,
    crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::apply_security_groups_to_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_apply_security_groups_to_client_vpn_target_network(response.body().as_ref(), output).map_err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_ipv6_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssignIpv6AddressesOutput,
    crate::error::AssignIpv6AddressesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssignIpv6AddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssignIpv6AddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_ipv6_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssignIpv6AddressesOutput,
    crate::error::AssignIpv6AddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_ipv6_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_assign_ipv6_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssignIpv6AddressesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_private_ip_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssignPrivateIpAddressesOutput,
    crate::error::AssignPrivateIpAddressesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssignPrivateIpAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssignPrivateIpAddressesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_private_ip_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssignPrivateIpAddressesOutput,
    crate::error::AssignPrivateIpAddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_private_ip_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_assign_private_ip_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssignPrivateIpAddressesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AssociateAddressOutput, crate::error::AssociateAddressError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AssociateAddressOutput, crate::error::AssociateAddressError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_address_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_address(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateAddressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_client_vpn_target_network_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateClientVpnTargetNetworkOutput,
    crate::error::AssociateClientVpnTargetNetworkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateClientVpnTargetNetworkError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_client_vpn_target_network_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateClientVpnTargetNetworkOutput,
    crate::error::AssociateClientVpnTargetNetworkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_associate_client_vpn_target_network(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AssociateClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_dhcp_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateDhcpOptionsOutput,
    crate::error::AssociateDhcpOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_dhcp_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateDhcpOptionsOutput,
    crate::error::AssociateDhcpOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_dhcp_options_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_enclave_certificate_iam_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateEnclaveCertificateIamRoleOutput,
    crate::error::AssociateEnclaveCertificateIamRoleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateEnclaveCertificateIamRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateEnclaveCertificateIamRoleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_enclave_certificate_iam_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateEnclaveCertificateIamRoleOutput,
    crate::error::AssociateEnclaveCertificateIamRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_enclave_certificate_iam_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_enclave_certificate_iam_role(response.body().as_ref(), output).map_err(crate::error::AssociateEnclaveCertificateIamRoleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_iam_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateIamInstanceProfileOutput,
    crate::error::AssociateIamInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateIamInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateIamInstanceProfileError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_iam_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateIamInstanceProfileOutput,
    crate::error::AssociateIamInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_iam_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_iam_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateIamInstanceProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_instance_event_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateInstanceEventWindowOutput,
    crate::error::AssociateInstanceEventWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateInstanceEventWindowError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_instance_event_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateInstanceEventWindowOutput,
    crate::error::AssociateInstanceEventWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_instance_event_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateInstanceEventWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateRouteTableOutput,
    crate::error::AssociateRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateRouteTableOutput,
    crate::error::AssociateRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_route_table(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_subnet_cidr_block_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateSubnetCidrBlockOutput,
    crate::error::AssociateSubnetCidrBlockError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateSubnetCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateSubnetCidrBlockError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_subnet_cidr_block_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateSubnetCidrBlockOutput,
    crate::error::AssociateSubnetCidrBlockError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_subnet_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_subnet_cidr_block(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateSubnetCidrBlockError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_multicast_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayMulticastDomainOutput,
    crate::error::AssociateTransitGatewayMulticastDomainError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_multicast_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayMulticastDomainOutput,
    crate::error::AssociateTransitGatewayMulticastDomainError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_policy_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayPolicyTableOutput,
    crate::error::AssociateTransitGatewayPolicyTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_policy_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayPolicyTableOutput,
    crate::error::AssociateTransitGatewayPolicyTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayRouteTableOutput,
    crate::error::AssociateTransitGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTransitGatewayRouteTableOutput,
    crate::error::AssociateTransitGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::associate_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trunk_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTrunkInterfaceOutput,
    crate::error::AssociateTrunkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateTrunkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTrunkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trunk_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTrunkInterfaceOutput,
    crate::error::AssociateTrunkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_trunk_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_trunk_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateTrunkInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_cidr_block_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVpcCidrBlockOutput,
    crate::error::AssociateVpcCidrBlockError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateVpcCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateVpcCidrBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_cidr_block_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVpcCidrBlockOutput,
    crate::error::AssociateVpcCidrBlockError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_vpc_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_vpc_cidr_block(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateVpcCidrBlockError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_classic_link_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachClassicLinkVpcOutput,
    crate::error::AttachClassicLinkVpcError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachClassicLinkVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachClassicLinkVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_classic_link_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachClassicLinkVpcOutput,
    crate::error::AttachClassicLinkVpcError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_classic_link_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_classic_link_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AttachClassicLinkVpcError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachInternetGatewayOutput,
    crate::error::AttachInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachInternetGatewayOutput,
    crate::error::AttachInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_network_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachNetworkInterfaceOutput,
    crate::error::AttachNetworkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_network_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachNetworkInterfaceOutput,
    crate::error::AttachNetworkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_network_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_network_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AttachNetworkInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_verified_access_trust_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachVerifiedAccessTrustProviderOutput,
    crate::error::AttachVerifiedAccessTrustProviderError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_verified_access_trust_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AttachVerifiedAccessTrustProviderOutput,
    crate::error::AttachVerifiedAccessTrustProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::attach_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::AttachVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachVolumeOutput, crate::error::AttachVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachVolumeOutput, crate::error::AttachVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_volume(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AttachVolumeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_vpn_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachVpnGatewayOutput, crate::error::AttachVpnGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AttachVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_vpn_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AttachVpnGatewayOutput, crate::error::AttachVpnGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_vpn_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_vpn_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AttachVpnGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_client_vpn_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeClientVpnIngressOutput,
    crate::error::AuthorizeClientVpnIngressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AuthorizeClientVpnIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeClientVpnIngressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_client_vpn_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeClientVpnIngressOutput,
    crate::error::AuthorizeClientVpnIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_client_vpn_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_client_vpn_ingress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeClientVpnIngressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_egress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSecurityGroupEgressOutput,
    crate::error::AuthorizeSecurityGroupEgressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AuthorizeSecurityGroupEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeSecurityGroupEgressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_egress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSecurityGroupEgressOutput,
    crate::error::AuthorizeSecurityGroupEgressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_security_group_egress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_security_group_egress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeSecurityGroupEgressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSecurityGroupIngressOutput,
    crate::error::AuthorizeSecurityGroupIngressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AuthorizeSecurityGroupIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeSecurityGroupIngressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSecurityGroupIngressOutput,
    crate::error::AuthorizeSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_security_group_ingress_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_authorize_security_group_ingress(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AuthorizeSecurityGroupIngressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_bundle_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BundleInstanceOutput, crate::error::BundleInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BundleInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::BundleInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_bundle_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BundleInstanceOutput, crate::error::BundleInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::bundle_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_bundle_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BundleInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_bundle_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelBundleTaskOutput, crate::error::CancelBundleTaskError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelBundleTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelBundleTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_bundle_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelBundleTaskOutput, crate::error::CancelBundleTaskError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_bundle_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_bundle_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelBundleTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelCapacityReservationOutput,
    crate::error::CancelCapacityReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelCapacityReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelCapacityReservationOutput,
    crate::error::CancelCapacityReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_capacity_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelCapacityReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelCapacityReservationFleetsOutput,
    crate::error::CancelCapacityReservationFleetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelCapacityReservationFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelCapacityReservationFleetsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelCapacityReservationFleetsOutput,
    crate::error::CancelCapacityReservationFleetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::cancel_capacity_reservation_fleets_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_cancel_capacity_reservation_fleets(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CancelCapacityReservationFleetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_conversion_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelConversionTaskOutput,
    crate::error::CancelConversionTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelConversionTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelConversionTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_conversion_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelConversionTaskOutput,
    crate::error::CancelConversionTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_conversion_task_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelExportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelExportTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_export_task_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_image_launch_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelImageLaunchPermissionOutput,
    crate::error::CancelImageLaunchPermissionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelImageLaunchPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelImageLaunchPermissionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_image_launch_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelImageLaunchPermissionOutput,
    crate::error::CancelImageLaunchPermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_image_launch_permission_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_image_launch_permission(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelImageLaunchPermissionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_import_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelImportTaskOutput, crate::error::CancelImportTaskError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelImportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelImportTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_import_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelImportTaskOutput, crate::error::CancelImportTaskError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_import_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_import_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelImportTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_reserved_instances_listing_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelReservedInstancesListingOutput,
    crate::error::CancelReservedInstancesListingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelReservedInstancesListingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelReservedInstancesListingError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_reserved_instances_listing_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelReservedInstancesListingOutput,
    crate::error::CancelReservedInstancesListingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::cancel_reserved_instances_listing_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_cancel_reserved_instances_listing(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CancelReservedInstancesListingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_fleet_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelSpotFleetRequestsOutput,
    crate::error::CancelSpotFleetRequestsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelSpotFleetRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelSpotFleetRequestsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_fleet_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelSpotFleetRequestsOutput,
    crate::error::CancelSpotFleetRequestsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_spot_fleet_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_spot_fleet_requests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelSpotFleetRequestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_instance_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelSpotInstanceRequestsOutput,
    crate::error::CancelSpotInstanceRequestsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelSpotInstanceRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelSpotInstanceRequestsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_instance_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CancelSpotInstanceRequestsOutput,
    crate::error::CancelSpotInstanceRequestsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_spot_instance_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_spot_instance_requests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelSpotInstanceRequestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_product_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmProductInstanceOutput,
    crate::error::ConfirmProductInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmProductInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ConfirmProductInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_product_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmProductInstanceOutput,
    crate::error::ConfirmProductInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_product_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_confirm_product_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmProductInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_fpga_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyFpgaImageOutput, crate::error::CopyFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CopyFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopyFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_fpga_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyFpgaImageOutput, crate::error::CopyFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_fpga_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyFpgaImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyImageOutput, crate::error::CopyImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CopyImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopyImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopyImageOutput, crate::error::CopyImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopySnapshotOutput, crate::error::CopySnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CopySnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopySnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CopySnapshotOutput, crate::error::CopySnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopySnapshotError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCapacityReservationOutput,
    crate::error::CreateCapacityReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCapacityReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCapacityReservationOutput,
    crate::error::CreateCapacityReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_capacity_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCapacityReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCapacityReservationFleetOutput,
    crate::error::CreateCapacityReservationFleetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCapacityReservationFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCapacityReservationFleetError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCapacityReservationFleetOutput,
    crate::error::CreateCapacityReservationFleetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_capacity_reservation_fleet_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_capacity_reservation_fleet(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateCapacityReservationFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_carrier_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCarrierGatewayOutput,
    crate::error::CreateCarrierGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCarrierGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCarrierGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_carrier_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCarrierGatewayOutput,
    crate::error::CreateCarrierGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_carrier_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_carrier_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCarrierGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClientVpnEndpointOutput,
    crate::error::CreateClientVpnEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClientVpnEndpointOutput,
    crate::error::CreateClientVpnEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_client_vpn_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClientVpnEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClientVpnRouteOutput,
    crate::error::CreateClientVpnRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateClientVpnRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateClientVpnRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClientVpnRouteOutput,
    crate::error::CreateClientVpnRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_client_vpn_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_client_vpn_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClientVpnRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCoipCidrOutput, crate::error::CreateCoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCoipCidrOutput, crate::error::CreateCoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_coip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_coip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCoipPoolOutput, crate::error::CreateCoipPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCoipPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCoipPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCoipPoolOutput, crate::error::CreateCoipPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_coip_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_coip_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCoipPoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_customer_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomerGatewayOutput,
    crate::error::CreateCustomerGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCustomerGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCustomerGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_customer_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomerGatewayOutput,
    crate::error::CreateCustomerGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_customer_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_customer_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCustomerGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_subnet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDefaultSubnetOutput,
    crate::error::CreateDefaultSubnetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDefaultSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDefaultSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_subnet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDefaultSubnetOutput,
    crate::error::CreateDefaultSubnetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_default_subnet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_default_subnet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDefaultSubnetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDefaultVpcOutput, crate::error::CreateDefaultVpcError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDefaultVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDefaultVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDefaultVpcOutput, crate::error::CreateDefaultVpcError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_default_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_default_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDefaultVpcError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dhcp_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDhcpOptionsOutput, crate::error::CreateDhcpOptionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dhcp_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDhcpOptionsOutput, crate::error::CreateDhcpOptionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_dhcp_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_dhcp_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDhcpOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_egress_only_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEgressOnlyInternetGatewayOutput,
    crate::error::CreateEgressOnlyInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEgressOnlyInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateEgressOnlyInternetGatewayError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_egress_only_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEgressOnlyInternetGatewayOutput,
    crate::error::CreateEgressOnlyInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_egress_only_internet_gateway_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_egress_only_internet_gateway(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateEgressOnlyInternetGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_fleet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_logs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFlowLogsOutput, crate::error::CreateFlowLogsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_logs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFlowLogsOutput, crate::error::CreateFlowLogsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_flow_logs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFlowLogsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fpga_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFpgaImageOutput, crate::error::CreateFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fpga_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateFpgaImageOutput, crate::error::CreateFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_fpga_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFpgaImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_event_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceEventWindowOutput,
    crate::error::CreateInstanceEventWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInstanceEventWindowError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_event_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceEventWindowOutput,
    crate::error::CreateInstanceEventWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_instance_event_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceEventWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_export_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceExportTaskOutput,
    crate::error::CreateInstanceExportTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInstanceExportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInstanceExportTaskError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_export_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceExportTaskOutput,
    crate::error::CreateInstanceExportTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_export_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_instance_export_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceExportTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInternetGatewayOutput,
    crate::error::CreateInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInternetGatewayOutput,
    crate::error::CreateInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_internet_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_internet_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInternetGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamOutput, crate::error::CreateIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamOutput, crate::error::CreateIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateIpamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamPoolOutput, crate::error::CreateIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamPoolOutput, crate::error::CreateIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateIpamPoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_scope_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamScopeOutput, crate::error::CreateIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_scope_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateIpamScopeOutput, crate::error::CreateIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam_scope(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateIpamScopeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_pair_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateKeyPairOutput, crate::error::CreateKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_pair_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateKeyPairOutput, crate::error::CreateKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_key_pair_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_key_pair(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateKeyPairError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLaunchTemplateOutput,
    crate::error::CreateLaunchTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLaunchTemplateOutput,
    crate::error::CreateLaunchTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_launch_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLaunchTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLaunchTemplateVersionOutput,
    crate::error::CreateLaunchTemplateVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLaunchTemplateVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLaunchTemplateVersionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLaunchTemplateVersionOutput,
    crate::error::CreateLaunchTemplateVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_launch_template_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_launch_template_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLaunchTemplateVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteOutput,
    crate::error::CreateLocalGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteOutput,
    crate::error::CreateLocalGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLocalGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableOutput,
    crate::error::CreateLocalGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLocalGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableOutput,
    crate::error::CreateLocalGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateLocalGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_virtual_interface_group_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput,
    crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(
        crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled,
    )?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(
        crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::generic(
            generic,
        ),
    )
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_virtual_interface_group_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput,
    crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_virtual_interface_group_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table_virtual_interface_group_association(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_vpc_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableVpcAssociationOutput,
    crate::error::CreateLocalGatewayRouteTableVpcAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_vpc_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateLocalGatewayRouteTableVpcAssociationOutput,
    crate::error::CreateLocalGatewayRouteTableVpcAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_vpc_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table_vpc_association(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_managed_prefix_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateManagedPrefixListOutput,
    crate::error::CreateManagedPrefixListError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_managed_prefix_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateManagedPrefixListOutput,
    crate::error::CreateManagedPrefixListError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_managed_prefix_list(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateManagedPrefixListError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_nat_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateNatGatewayOutput, crate::error::CreateNatGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNatGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNatGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_nat_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateNatGatewayOutput, crate::error::CreateNatGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_nat_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_nat_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNatGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateNetworkAclOutput, crate::error::CreateNetworkAclError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkAclError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateNetworkAclOutput, crate::error::CreateNetworkAclError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_acl_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_acl(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNetworkAclError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_entry_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkAclEntryOutput,
    crate::error::CreateNetworkAclEntryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_entry_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkAclEntryOutput,
    crate::error::CreateNetworkAclEntryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_access_scope_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInsightsAccessScopeOutput,
    crate::error::CreateNetworkInsightsAccessScopeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkInsightsAccessScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInsightsAccessScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_access_scope_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInsightsAccessScopeOutput,
    crate::error::CreateNetworkInsightsAccessScopeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_network_insights_access_scope_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_network_insights_access_scope(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateNetworkInsightsAccessScopeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInsightsPathOutput,
    crate::error::CreateNetworkInsightsPathError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkInsightsPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInsightsPathError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInsightsPathOutput,
    crate::error::CreateNetworkInsightsPathError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_insights_path_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_insights_path(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNetworkInsightsPathError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInterfaceOutput,
    crate::error::CreateNetworkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInterfaceOutput,
    crate::error::CreateNetworkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNetworkInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInterfacePermissionOutput,
    crate::error::CreateNetworkInterfacePermissionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkInterfacePermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInterfacePermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkInterfacePermissionOutput,
    crate::error::CreateNetworkInterfacePermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_network_interface_permission_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_network_interface_permission(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateNetworkInterfacePermissionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_placement_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePlacementGroupOutput,
    crate::error::CreatePlacementGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePlacementGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreatePlacementGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_placement_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePlacementGroupOutput,
    crate::error::CreatePlacementGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_placement_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_placement_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePlacementGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_ipv4_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicIpv4PoolOutput,
    crate::error::CreatePublicIpv4PoolError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePublicIpv4PoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreatePublicIpv4PoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_ipv4_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicIpv4PoolOutput,
    crate::error::CreatePublicIpv4PoolError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_public_ipv4_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_public_ipv4_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePublicIpv4PoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_replace_root_volume_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReplaceRootVolumeTaskOutput,
    crate::error::CreateReplaceRootVolumeTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateReplaceRootVolumeTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateReplaceRootVolumeTaskError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_replace_root_volume_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReplaceRootVolumeTaskOutput,
    crate::error::CreateReplaceRootVolumeTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_replace_root_volume_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_replace_root_volume_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateReplaceRootVolumeTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reserved_instances_listing_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReservedInstancesListingOutput,
    crate::error::CreateReservedInstancesListingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateReservedInstancesListingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateReservedInstancesListingError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reserved_instances_listing_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateReservedInstancesListingOutput,
    crate::error::CreateReservedInstancesListingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_reserved_instances_listing_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_reserved_instances_listing(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateReservedInstancesListingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_restore_image_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRestoreImageTaskOutput,
    crate::error::CreateRestoreImageTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRestoreImageTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRestoreImageTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_restore_image_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRestoreImageTaskOutput,
    crate::error::CreateRestoreImageTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_restore_image_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_restore_image_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRestoreImageTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRouteOutput, crate::error::CreateRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRouteOutput, crate::error::CreateRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRouteTableOutput, crate::error::CreateRouteTableError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRouteTableOutput, crate::error::CreateRouteTableError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_route_table(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSecurityGroupOutput,
    crate::error::CreateSecurityGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSecurityGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSecurityGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSecurityGroupOutput,
    crate::error::CreateSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_security_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_security_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSecurityGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSnapshotOutput, crate::error::CreateSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSnapshotOutput, crate::error::CreateSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSnapshotError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSnapshotsOutput, crate::error::CreateSnapshotsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSnapshotsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSnapshotsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSnapshotsOutput, crate::error::CreateSnapshotsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSnapshotsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_spot_datafeed_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSpotDatafeedSubscriptionOutput,
    crate::error::CreateSpotDatafeedSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSpotDatafeedSubscriptionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_spot_datafeed_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSpotDatafeedSubscriptionOutput,
    crate::error::CreateSpotDatafeedSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_spot_datafeed_subscription(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateSpotDatafeedSubscriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_store_image_task_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStoreImageTaskOutput,
    crate::error::CreateStoreImageTaskError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStoreImageTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateStoreImageTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_store_image_task_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStoreImageTaskOutput,
    crate::error::CreateStoreImageTaskError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_store_image_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_store_image_task(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateStoreImageTaskError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSubnetOutput, crate::error::CreateSubnetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSubnetOutput, crate::error::CreateSubnetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_subnet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_subnet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSubnetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_cidr_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubnetCidrReservationOutput,
    crate::error::CreateSubnetCidrReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSubnetCidrReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSubnetCidrReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_cidr_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSubnetCidrReservationOutput,
    crate::error::CreateSubnetCidrReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_subnet_cidr_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_subnet_cidr_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSubnetCidrReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_tags_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorFilterOutput,
    crate::error::CreateTrafficMirrorFilterError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficMirrorFilterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorFilterError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorFilterOutput,
    crate::error::CreateTrafficMirrorFilterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_filter_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_filter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficMirrorFilterError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorFilterRuleOutput,
    crate::error::CreateTrafficMirrorFilterRuleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorFilterRuleError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorFilterRuleOutput,
    crate::error::CreateTrafficMirrorFilterRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_filter_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorSessionOutput,
    crate::error::CreateTrafficMirrorSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorSessionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorSessionOutput,
    crate::error::CreateTrafficMirrorSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorTargetOutput,
    crate::error::CreateTrafficMirrorTargetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrafficMirrorTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorTargetError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrafficMirrorTargetOutput,
    crate::error::CreateTrafficMirrorTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_target_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_target(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrafficMirrorTargetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayOutput,
    crate::error::CreateTransitGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayOutput,
    crate::error::CreateTransitGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTransitGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayConnectOutput,
    crate::error::CreateTransitGatewayConnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayConnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayConnectError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayConnectOutput,
    crate::error::CreateTransitGatewayConnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_connect_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_connect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTransitGatewayConnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayConnectPeerOutput,
    crate::error::CreateTransitGatewayConnectPeerError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayConnectPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayConnectPeerError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayConnectPeerOutput,
    crate::error::CreateTransitGatewayConnectPeerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_connect_peer_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_connect_peer(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateTransitGatewayConnectPeerError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_multicast_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayMulticastDomainOutput,
    crate::error::CreateTransitGatewayMulticastDomainError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_multicast_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayMulticastDomainOutput,
    crate::error::CreateTransitGatewayMulticastDomainError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_peering_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPeeringAttachmentOutput,
    crate::error::CreateTransitGatewayPeeringAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_peering_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPeeringAttachmentOutput,
    crate::error::CreateTransitGatewayPeeringAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_policy_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPolicyTableOutput,
    crate::error::CreateTransitGatewayPolicyTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPolicyTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_policy_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPolicyTableOutput,
    crate::error::CreateTransitGatewayPolicyTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_policy_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_prefix_list_reference_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPrefixListReferenceOutput,
    crate::error::CreateTransitGatewayPrefixListReferenceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_prefix_list_reference_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayPrefixListReferenceOutput,
    crate::error::CreateTransitGatewayPrefixListReferenceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteOutput,
    crate::error::CreateTransitGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteOutput,
    crate::error::CreateTransitGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTransitGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteTableOutput,
    crate::error::CreateTransitGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteTableOutput,
    crate::error::CreateTransitGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_announcement_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteTableAnnouncementOutput,
    crate::error::CreateTransitGatewayRouteTableAnnouncementError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_announcement_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayRouteTableAnnouncementOutput,
    crate::error::CreateTransitGatewayRouteTableAnnouncementError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_route_table_announcement_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route_table_announcement(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_vpc_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayVpcAttachmentOutput,
    crate::error::CreateTransitGatewayVpcAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_vpc_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitGatewayVpcAttachmentOutput,
    crate::error::CreateTransitGatewayVpcAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessEndpointOutput,
    crate::error::CreateVerifiedAccessEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessEndpointError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessEndpointOutput,
    crate::error::CreateVerifiedAccessEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessGroupOutput,
    crate::error::CreateVerifiedAccessGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessGroupError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessGroupOutput,
    crate::error::CreateVerifiedAccessGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessInstanceOutput,
    crate::error::CreateVerifiedAccessInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessInstanceError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessInstanceOutput,
    crate::error::CreateVerifiedAccessInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_trust_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessTrustProviderOutput,
    crate::error::CreateVerifiedAccessTrustProviderError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_trust_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVerifiedAccessTrustProviderOutput,
    crate::error::CreateVerifiedAccessTrustProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::CreateVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVolumeOutput, crate::error::CreateVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVolumeOutput, crate::error::CreateVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_volume(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVolumeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcOutput, crate::error::CreateVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcOutput, crate::error::CreateVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVpcError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcEndpointOutput, crate::error::CreateVpcEndpointError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpcEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcEndpointOutput, crate::error::CreateVpcEndpointError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVpcEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_connection_notification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcEndpointConnectionNotificationOutput,
    crate::error::CreateVpcEndpointConnectionNotificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpcEndpointConnectionNotificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointConnectionNotificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_connection_notification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcEndpointConnectionNotificationOutput,
    crate::error::CreateVpcEndpointConnectionNotificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_vpc_endpoint_connection_notification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint_connection_notification(response.body().as_ref(), output).map_err(crate::error::CreateVpcEndpointConnectionNotificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_service_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcEndpointServiceConfigurationOutput,
    crate::error::CreateVpcEndpointServiceConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpcEndpointServiceConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointServiceConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_service_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcEndpointServiceConfigurationOutput,
    crate::error::CreateVpcEndpointServiceConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_vpc_endpoint_service_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint_service_configuration(response.body().as_ref(), output).map_err(crate::error::CreateVpcEndpointServiceConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcPeeringConnectionOutput,
    crate::error::CreateVpcPeeringConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcPeeringConnectionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpcPeeringConnectionOutput,
    crate::error::CreateVpcPeeringConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_peering_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpnConnectionOutput,
    crate::error::CreateVpnConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpnConnectionOutput,
    crate::error::CreateVpnConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpn_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVpnConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpnConnectionRouteOutput,
    crate::error::CreateVpnConnectionRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpnConnectionRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnConnectionRouteError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpnConnectionRouteOutput,
    crate::error::CreateVpnConnectionRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_connection_route_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpnGatewayOutput, crate::error::CreateVpnGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpnGatewayOutput, crate::error::CreateVpnGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpn_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVpnGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_carrier_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCarrierGatewayOutput,
    crate::error::DeleteCarrierGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCarrierGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCarrierGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_carrier_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCarrierGatewayOutput,
    crate::error::DeleteCarrierGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_carrier_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_carrier_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCarrierGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientVpnEndpointOutput,
    crate::error::DeleteClientVpnEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientVpnEndpointOutput,
    crate::error::DeleteClientVpnEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_client_vpn_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteClientVpnEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientVpnRouteOutput,
    crate::error::DeleteClientVpnRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteClientVpnRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteClientVpnRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientVpnRouteOutput,
    crate::error::DeleteClientVpnRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_client_vpn_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_client_vpn_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteClientVpnRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCoipCidrOutput, crate::error::DeleteCoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCoipCidrOutput, crate::error::DeleteCoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_coip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_coip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCoipPoolOutput, crate::error::DeleteCoipPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCoipPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCoipPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteCoipPoolOutput, crate::error::DeleteCoipPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_coip_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_coip_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCoipPoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_customer_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomerGatewayOutput,
    crate::error::DeleteCustomerGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCustomerGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCustomerGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_customer_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomerGatewayOutput,
    crate::error::DeleteCustomerGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_customer_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dhcp_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDhcpOptionsOutput, crate::error::DeleteDhcpOptionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dhcp_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDhcpOptionsOutput, crate::error::DeleteDhcpOptionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_dhcp_options_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_egress_only_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEgressOnlyInternetGatewayOutput,
    crate::error::DeleteEgressOnlyInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteEgressOnlyInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteEgressOnlyInternetGatewayError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_egress_only_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEgressOnlyInternetGatewayOutput,
    crate::error::DeleteEgressOnlyInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_egress_only_internet_gateway_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_egress_only_internet_gateway(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteEgressOnlyInternetGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFleetsOutput, crate::error::DeleteFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFleetsOutput, crate::error::DeleteFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_fleets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteFleetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_logs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFlowLogsOutput, crate::error::DeleteFlowLogsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_logs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFlowLogsOutput, crate::error::DeleteFlowLogsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_flow_logs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteFlowLogsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fpga_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFpgaImageOutput, crate::error::DeleteFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fpga_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFpgaImageOutput, crate::error::DeleteFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_fpga_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteFpgaImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_event_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceEventWindowOutput,
    crate::error::DeleteInstanceEventWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteInstanceEventWindowError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_event_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceEventWindowOutput,
    crate::error::DeleteInstanceEventWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_instance_event_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInstanceEventWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInternetGatewayOutput,
    crate::error::DeleteInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInternetGatewayOutput,
    crate::error::DeleteInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamOutput, crate::error::DeleteIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamOutput, crate::error::DeleteIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteIpamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamPoolOutput, crate::error::DeleteIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamPoolOutput, crate::error::DeleteIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteIpamPoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_scope_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamScopeOutput, crate::error::DeleteIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_scope_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIpamScopeOutput, crate::error::DeleteIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam_scope(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteIpamScopeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_pair_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteKeyPairOutput, crate::error::DeleteKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_pair_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteKeyPairOutput, crate::error::DeleteKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_key_pair_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLaunchTemplateOutput,
    crate::error::DeleteLaunchTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLaunchTemplateOutput,
    crate::error::DeleteLaunchTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_launch_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteLaunchTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLaunchTemplateVersionsOutput,
    crate::error::DeleteLaunchTemplateVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLaunchTemplateVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLaunchTemplateVersionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLaunchTemplateVersionsOutput,
    crate::error::DeleteLaunchTemplateVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_launch_template_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_launch_template_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteLaunchTemplateVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteOutput,
    crate::error::DeleteLocalGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteOutput,
    crate::error::DeleteLocalGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteLocalGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableOutput,
    crate::error::DeleteLocalGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLocalGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableOutput,
    crate::error::DeleteLocalGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteLocalGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_virtual_interface_group_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput,
    crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(
        crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled,
    )?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(
        crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::generic(
            generic,
        ),
    )
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_virtual_interface_group_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput,
    crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_virtual_interface_group_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table_virtual_interface_group_association(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_vpc_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableVpcAssociationOutput,
    crate::error::DeleteLocalGatewayRouteTableVpcAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_vpc_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteLocalGatewayRouteTableVpcAssociationOutput,
    crate::error::DeleteLocalGatewayRouteTableVpcAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_vpc_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table_vpc_association(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_managed_prefix_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteManagedPrefixListOutput,
    crate::error::DeleteManagedPrefixListError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_managed_prefix_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteManagedPrefixListOutput,
    crate::error::DeleteManagedPrefixListError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_managed_prefix_list(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteManagedPrefixListError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_nat_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteNatGatewayOutput, crate::error::DeleteNatGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNatGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNatGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_nat_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteNatGatewayOutput, crate::error::DeleteNatGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_nat_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_nat_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteNatGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteNetworkAclOutput, crate::error::DeleteNetworkAclError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkAclError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteNetworkAclOutput, crate::error::DeleteNetworkAclError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_acl_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_entry_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkAclEntryOutput,
    crate::error::DeleteNetworkAclEntryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_entry_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkAclEntryOutput,
    crate::error::DeleteNetworkAclEntryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAccessScopeOutput,
    crate::error::DeleteNetworkInsightsAccessScopeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInsightsAccessScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAccessScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAccessScopeOutput,
    crate::error::DeleteNetworkInsightsAccessScopeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_network_insights_access_scope_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_network_insights_access_scope(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteNetworkInsightsAccessScopeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_analysis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAccessScopeAnalysisOutput,
    crate::error::DeleteNetworkInsightsAccessScopeAnalysisError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_analysis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAccessScopeAnalysisOutput,
    crate::error::DeleteNetworkInsightsAccessScopeAnalysisError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_network_insights_access_scope_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_access_scope_analysis(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_analysis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAnalysisOutput,
    crate::error::DeleteNetworkInsightsAnalysisError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInsightsAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAnalysisError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_analysis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsAnalysisOutput,
    crate::error::DeleteNetworkInsightsAnalysisError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_analysis_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_network_insights_analysis(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteNetworkInsightsAnalysisError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_path_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsPathOutput,
    crate::error::DeleteNetworkInsightsPathError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInsightsPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsPathError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_path_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInsightsPathOutput,
    crate::error::DeleteNetworkInsightsPathError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_path_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_path(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteNetworkInsightsPathError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInterfaceOutput,
    crate::error::DeleteNetworkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInterfaceOutput,
    crate::error::DeleteNetworkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_interface_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInterfacePermissionOutput,
    crate::error::DeleteNetworkInterfacePermissionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkInterfacePermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInterfacePermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkInterfacePermissionOutput,
    crate::error::DeleteNetworkInterfacePermissionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_network_interface_permission_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_network_interface_permission(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteNetworkInterfacePermissionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_placement_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePlacementGroupOutput,
    crate::error::DeletePlacementGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePlacementGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeletePlacementGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_placement_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePlacementGroupOutput,
    crate::error::DeletePlacementGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_placement_group_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_ipv4_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePublicIpv4PoolOutput,
    crate::error::DeletePublicIpv4PoolError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePublicIpv4PoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeletePublicIpv4PoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_ipv4_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePublicIpv4PoolOutput,
    crate::error::DeletePublicIpv4PoolError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_public_ipv4_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_public_ipv4_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePublicIpv4PoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queued_reserved_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteQueuedReservedInstancesOutput,
    crate::error::DeleteQueuedReservedInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteQueuedReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteQueuedReservedInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queued_reserved_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteQueuedReservedInstancesOutput,
    crate::error::DeleteQueuedReservedInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_queued_reserved_instances_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_queued_reserved_instances(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteQueuedReservedInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRouteOutput, crate::error::DeleteRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRouteOutput, crate::error::DeleteRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_route_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRouteTableOutput, crate::error::DeleteRouteTableError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRouteTableOutput, crate::error::DeleteRouteTableError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_route_table_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSecurityGroupOutput,
    crate::error::DeleteSecurityGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSecurityGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSecurityGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSecurityGroupOutput,
    crate::error::DeleteSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_security_group_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSnapshotOutput, crate::error::DeleteSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSnapshotOutput, crate::error::DeleteSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_snapshot_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_spot_datafeed_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSpotDatafeedSubscriptionOutput,
    crate::error::DeleteSpotDatafeedSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSpotDatafeedSubscriptionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_spot_datafeed_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSpotDatafeedSubscriptionOutput,
    crate::error::DeleteSpotDatafeedSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSubnetOutput, crate::error::DeleteSubnetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSubnetOutput, crate::error::DeleteSubnetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_subnet_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_cidr_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSubnetCidrReservationOutput,
    crate::error::DeleteSubnetCidrReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSubnetCidrReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSubnetCidrReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_cidr_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSubnetCidrReservationOutput,
    crate::error::DeleteSubnetCidrReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_subnet_cidr_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_subnet_cidr_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteSubnetCidrReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_tags_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorFilterOutput,
    crate::error::DeleteTrafficMirrorFilterError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficMirrorFilterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorFilterError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorFilterOutput,
    crate::error::DeleteTrafficMirrorFilterError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_filter_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_filter(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTrafficMirrorFilterError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorFilterRuleOutput,
    crate::error::DeleteTrafficMirrorFilterRuleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorFilterRuleError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorFilterRuleOutput,
    crate::error::DeleteTrafficMirrorFilterRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_filter_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorSessionOutput,
    crate::error::DeleteTrafficMirrorSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorSessionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorSessionOutput,
    crate::error::DeleteTrafficMirrorSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_target_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorTargetOutput,
    crate::error::DeleteTrafficMirrorTargetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrafficMirrorTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorTargetError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_target_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrafficMirrorTargetOutput,
    crate::error::DeleteTrafficMirrorTargetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_target_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_target(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTrafficMirrorTargetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayOutput,
    crate::error::DeleteTransitGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayOutput,
    crate::error::DeleteTransitGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTransitGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayConnectOutput,
    crate::error::DeleteTransitGatewayConnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayConnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayConnectError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayConnectOutput,
    crate::error::DeleteTransitGatewayConnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_connect_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_connect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTransitGatewayConnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayConnectPeerOutput,
    crate::error::DeleteTransitGatewayConnectPeerError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayConnectPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayConnectPeerError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayConnectPeerOutput,
    crate::error::DeleteTransitGatewayConnectPeerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_connect_peer_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_connect_peer(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteTransitGatewayConnectPeerError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_multicast_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayMulticastDomainOutput,
    crate::error::DeleteTransitGatewayMulticastDomainError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_multicast_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayMulticastDomainOutput,
    crate::error::DeleteTransitGatewayMulticastDomainError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_peering_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPeeringAttachmentOutput,
    crate::error::DeleteTransitGatewayPeeringAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_peering_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPeeringAttachmentOutput,
    crate::error::DeleteTransitGatewayPeeringAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_policy_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPolicyTableOutput,
    crate::error::DeleteTransitGatewayPolicyTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPolicyTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_policy_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPolicyTableOutput,
    crate::error::DeleteTransitGatewayPolicyTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_policy_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_prefix_list_reference_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPrefixListReferenceOutput,
    crate::error::DeleteTransitGatewayPrefixListReferenceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_prefix_list_reference_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayPrefixListReferenceOutput,
    crate::error::DeleteTransitGatewayPrefixListReferenceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteOutput,
    crate::error::DeleteTransitGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteOutput,
    crate::error::DeleteTransitGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTransitGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteTableOutput,
    crate::error::DeleteTransitGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteTableError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteTableOutput,
    crate::error::DeleteTransitGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route_table(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_announcement_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteTableAnnouncementOutput,
    crate::error::DeleteTransitGatewayRouteTableAnnouncementError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_announcement_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayRouteTableAnnouncementOutput,
    crate::error::DeleteTransitGatewayRouteTableAnnouncementError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_route_table_announcement_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route_table_announcement(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_vpc_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayVpcAttachmentOutput,
    crate::error::DeleteTransitGatewayVpcAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_vpc_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTransitGatewayVpcAttachmentOutput,
    crate::error::DeleteTransitGatewayVpcAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessEndpointOutput,
    crate::error::DeleteVerifiedAccessEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessEndpointError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessEndpointOutput,
    crate::error::DeleteVerifiedAccessEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessGroupOutput,
    crate::error::DeleteVerifiedAccessGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessGroupError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessGroupOutput,
    crate::error::DeleteVerifiedAccessGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessInstanceOutput,
    crate::error::DeleteVerifiedAccessInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessInstanceError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessInstanceOutput,
    crate::error::DeleteVerifiedAccessInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_trust_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessTrustProviderOutput,
    crate::error::DeleteVerifiedAccessTrustProviderError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_trust_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVerifiedAccessTrustProviderOutput,
    crate::error::DeleteVerifiedAccessTrustProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::DeleteVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_volume_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpcOutput, crate::error::DeleteVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpcOutput, crate::error::DeleteVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_connection_notifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointConnectionNotificationsOutput,
    crate::error::DeleteVpcEndpointConnectionNotificationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpcEndpointConnectionNotificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointConnectionNotificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_connection_notifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointConnectionNotificationsOutput,
    crate::error::DeleteVpcEndpointConnectionNotificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_vpc_endpoint_connection_notifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoint_connection_notifications(response.body().as_ref(), output).map_err(crate::error::DeleteVpcEndpointConnectionNotificationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointsOutput,
    crate::error::DeleteVpcEndpointsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpcEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointsOutput,
    crate::error::DeleteVpcEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVpcEndpointsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_service_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointServiceConfigurationsOutput,
    crate::error::DeleteVpcEndpointServiceConfigurationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpcEndpointServiceConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointServiceConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_service_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcEndpointServiceConfigurationsOutput,
    crate::error::DeleteVpcEndpointServiceConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_vpc_endpoint_service_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoint_service_configurations(response.body().as_ref(), output).map_err(crate::error::DeleteVpcEndpointServiceConfigurationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcPeeringConnectionOutput,
    crate::error::DeleteVpcPeeringConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcPeeringConnectionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpcPeeringConnectionOutput,
    crate::error::DeleteVpcPeeringConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_peering_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpnConnectionOutput,
    crate::error::DeleteVpnConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpnConnectionOutput,
    crate::error::DeleteVpnConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_connection_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpnConnectionRouteOutput,
    crate::error::DeleteVpnConnectionRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpnConnectionRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnConnectionRouteError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpnConnectionRouteOutput,
    crate::error::DeleteVpnConnectionRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_connection_route_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpnGatewayOutput, crate::error::DeleteVpnGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpnGatewayOutput, crate::error::DeleteVpnGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_byoip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionByoipCidrOutput,
    crate::error::DeprovisionByoipCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeprovisionByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_byoip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionByoipCidrOutput,
    crate::error::DeprovisionByoipCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deprovision_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deprovision_byoip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeprovisionByoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_ipam_pool_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionIpamPoolCidrOutput,
    crate::error::DeprovisionIpamPoolCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeprovisionIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_ipam_pool_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionIpamPoolCidrOutput,
    crate::error::DeprovisionIpamPoolCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deprovision_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deprovision_ipam_pool_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeprovisionIpamPoolCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_public_ipv4_pool_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionPublicIpv4PoolCidrOutput,
    crate::error::DeprovisionPublicIpv4PoolCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeprovisionPublicIpv4PoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionPublicIpv4PoolCidrError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_public_ipv4_pool_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeprovisionPublicIpv4PoolCidrOutput,
    crate::error::DeprovisionPublicIpv4PoolCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::deprovision_public_ipv4_pool_cidr_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_deprovision_public_ipv4_pool_cidr(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeprovisionPublicIpv4PoolCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterImageOutput, crate::error::DeregisterImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterImageOutput, crate::error::DeregisterImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_image_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_event_notification_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterInstanceEventNotificationAttributesOutput,
    crate::error::DeregisterInstanceEventNotificationAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_event_notification_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterInstanceEventNotificationAttributesOutput,
    crate::error::DeregisterInstanceEventNotificationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_instance_event_notification_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::DeregisterInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_members_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTransitGatewayMulticastGroupMembersOutput,
    crate::error::DeregisterTransitGatewayMulticastGroupMembersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_members_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTransitGatewayMulticastGroupMembersOutput,
    crate::error::DeregisterTransitGatewayMulticastGroupMembersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_transit_gateway_multicast_group_members_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_transit_gateway_multicast_group_members(response.body().as_ref(), output).map_err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_sources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTransitGatewayMulticastGroupSourcesOutput,
    crate::error::DeregisterTransitGatewayMulticastGroupSourcesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_sources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeregisterTransitGatewayMulticastGroupSourcesOutput,
    crate::error::DeregisterTransitGatewayMulticastGroupSourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_transit_gateway_multicast_group_sources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_transit_gateway_multicast_group_sources(response.body().as_ref(), output).map_err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAccountAttributesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_account_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAddressesOutput, crate::error::DescribeAddressesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAddressesOutput, crate::error::DescribeAddressesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAddressesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAddressesAttributeOutput,
    crate::error::DescribeAddressesAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAddressesAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressesAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAddressesAttributeOutput,
    crate::error::DescribeAddressesAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_addresses_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_addresses_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAddressesAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_address_transfers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAddressTransfersOutput,
    crate::error::DescribeAddressTransfersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAddressTransfersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressTransfersError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_address_transfers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAddressTransfersOutput,
    crate::error::DescribeAddressTransfersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_address_transfers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_address_transfers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAddressTransfersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateIdFormatOutput,
    crate::error::DescribeAggregateIdFormatError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAggregateIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAggregateIdFormatError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAggregateIdFormatOutput,
    crate::error::DescribeAggregateIdFormatError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_aggregate_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_aggregate_id_format(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAggregateIdFormatError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_availability_zones_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailabilityZonesOutput,
    crate::error::DescribeAvailabilityZonesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAvailabilityZonesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAvailabilityZonesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_availability_zones_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAvailabilityZonesOutput,
    crate::error::DescribeAvailabilityZonesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_availability_zones_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_availability_zones(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAvailabilityZonesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aws_network_performance_metric_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput,
    crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aws_network_performance_metric_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput,
    crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_aws_network_performance_metric_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_aws_network_performance_metric_subscriptions(response.body().as_ref(), output).map_err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_bundle_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeBundleTasksOutput,
    crate::error::DescribeBundleTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeBundleTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeBundleTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_bundle_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeBundleTasksOutput,
    crate::error::DescribeBundleTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_bundle_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_bundle_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeBundleTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_byoip_cidrs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeByoipCidrsOutput,
    crate::error::DescribeByoipCidrsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeByoipCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeByoipCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_byoip_cidrs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeByoipCidrsOutput,
    crate::error::DescribeByoipCidrsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_byoip_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_byoip_cidrs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeByoipCidrsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservation_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCapacityReservationFleetsOutput,
    crate::error::DescribeCapacityReservationFleetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCapacityReservationFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCapacityReservationFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservation_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCapacityReservationFleetsOutput,
    crate::error::DescribeCapacityReservationFleetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_capacity_reservation_fleets_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_capacity_reservation_fleets(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeCapacityReservationFleetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCapacityReservationsOutput,
    crate::error::DescribeCapacityReservationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCapacityReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCapacityReservationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCapacityReservationsOutput,
    crate::error::DescribeCapacityReservationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_capacity_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_capacity_reservations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCapacityReservationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_carrier_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCarrierGatewaysOutput,
    crate::error::DescribeCarrierGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCarrierGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCarrierGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_carrier_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCarrierGatewaysOutput,
    crate::error::DescribeCarrierGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_carrier_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_carrier_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCarrierGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_classic_link_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClassicLinkInstancesOutput,
    crate::error::DescribeClassicLinkInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClassicLinkInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClassicLinkInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_classic_link_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClassicLinkInstancesOutput,
    crate::error::DescribeClassicLinkInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_classic_link_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_classic_link_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClassicLinkInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_authorization_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnAuthorizationRulesOutput,
    crate::error::DescribeClientVpnAuthorizationRulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClientVpnAuthorizationRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnAuthorizationRulesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_authorization_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnAuthorizationRulesOutput,
    crate::error::DescribeClientVpnAuthorizationRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_client_vpn_authorization_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_authorization_rules(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnAuthorizationRulesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnConnectionsOutput,
    crate::error::DescribeClientVpnConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClientVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnConnectionsOutput,
    crate::error::DescribeClientVpnConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClientVpnConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnEndpointsOutput,
    crate::error::DescribeClientVpnEndpointsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClientVpnEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnEndpointsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnEndpointsOutput,
    crate::error::DescribeClientVpnEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClientVpnEndpointsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_routes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnRoutesOutput,
    crate::error::DescribeClientVpnRoutesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClientVpnRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnRoutesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_routes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnRoutesOutput,
    crate::error::DescribeClientVpnRoutesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_routes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClientVpnRoutesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_target_networks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnTargetNetworksOutput,
    crate::error::DescribeClientVpnTargetNetworksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeClientVpnTargetNetworksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnTargetNetworksError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_target_networks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClientVpnTargetNetworksOutput,
    crate::error::DescribeClientVpnTargetNetworksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_client_vpn_target_networks_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_target_networks(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeClientVpnTargetNetworksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_coip_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeCoipPoolsOutput, crate::error::DescribeCoipPoolsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCoipPoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCoipPoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_coip_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeCoipPoolsOutput, crate::error::DescribeCoipPoolsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_coip_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_coip_pools(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCoipPoolsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conversion_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConversionTasksOutput,
    crate::error::DescribeConversionTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeConversionTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeConversionTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conversion_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConversionTasksOutput,
    crate::error::DescribeConversionTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_conversion_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_conversion_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConversionTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomerGatewaysOutput,
    crate::error::DescribeCustomerGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCustomerGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCustomerGatewaysError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomerGatewaysOutput,
    crate::error::DescribeCustomerGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_customer_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_customer_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCustomerGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_dhcp_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDhcpOptionsOutput,
    crate::error::DescribeDhcpOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_dhcp_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDhcpOptionsOutput,
    crate::error::DescribeDhcpOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_dhcp_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_dhcp_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDhcpOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_egress_only_internet_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEgressOnlyInternetGatewaysOutput,
    crate::error::DescribeEgressOnlyInternetGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEgressOnlyInternetGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeEgressOnlyInternetGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_egress_only_internet_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEgressOnlyInternetGatewaysOutput,
    crate::error::DescribeEgressOnlyInternetGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_egress_only_internet_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_egress_only_internet_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeEgressOnlyInternetGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_gpus_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeElasticGpusOutput,
    crate::error::DescribeElasticGpusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeElasticGpusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeElasticGpusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_gpus_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeElasticGpusOutput,
    crate::error::DescribeElasticGpusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_elastic_gpus_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_elastic_gpus(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeElasticGpusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_image_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportImageTasksOutput,
    crate::error::DescribeExportImageTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeExportImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeExportImageTasksError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_image_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportImageTasksOutput,
    crate::error::DescribeExportImageTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_export_image_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeExportImageTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeExportTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExportTasksOutput,
    crate::error::DescribeExportTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_export_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_launch_images_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFastLaunchImagesOutput,
    crate::error::DescribeFastLaunchImagesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFastLaunchImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFastLaunchImagesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_launch_images_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFastLaunchImagesOutput,
    crate::error::DescribeFastLaunchImagesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fast_launch_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fast_launch_images(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFastLaunchImagesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_snapshot_restores_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFastSnapshotRestoresOutput,
    crate::error::DescribeFastSnapshotRestoresError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFastSnapshotRestoresError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_snapshot_restores_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFastSnapshotRestoresOutput,
    crate::error::DescribeFastSnapshotRestoresError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fast_snapshot_restores(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFleetHistoryOutput,
    crate::error::DescribeFleetHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFleetHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFleetHistoryOutput,
    crate::error::DescribeFleetHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleet_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFleetHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFleetInstancesOutput,
    crate::error::DescribeFleetInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFleetInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFleetInstancesOutput,
    crate::error::DescribeFleetInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleet_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFleetInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFleetsOutput, crate::error::DescribeFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFleetsOutput, crate::error::DescribeFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFleetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_logs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFlowLogsOutput, crate::error::DescribeFlowLogsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_logs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeFlowLogsOutput, crate::error::DescribeFlowLogsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_flow_logs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFlowLogsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFpgaImageAttributeOutput,
    crate::error::DescribeFpgaImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFpgaImageAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFpgaImageAttributeOutput,
    crate::error::DescribeFpgaImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fpga_image_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFpgaImageAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_images_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFpgaImagesOutput,
    crate::error::DescribeFpgaImagesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFpgaImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFpgaImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_images_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFpgaImagesOutput,
    crate::error::DescribeFpgaImagesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fpga_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fpga_images(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFpgaImagesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservation_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostReservationOfferingsOutput,
    crate::error::DescribeHostReservationOfferingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHostReservationOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostReservationOfferingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservation_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostReservationOfferingsOutput,
    crate::error::DescribeHostReservationOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_host_reservation_offerings_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_host_reservation_offerings(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeHostReservationOfferingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostReservationsOutput,
    crate::error::DescribeHostReservationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHostReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostReservationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostReservationsOutput,
    crate::error::DescribeHostReservationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_host_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_host_reservations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHostReservationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeHostsOutput, crate::error::DescribeHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeHostsOutput, crate::error::DescribeHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_hosts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHostsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_iam_instance_profile_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIamInstanceProfileAssociationsOutput,
    crate::error::DescribeIamInstanceProfileAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIamInstanceProfileAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIamInstanceProfileAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_iam_instance_profile_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIamInstanceProfileAssociationsOutput,
    crate::error::DescribeIamInstanceProfileAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_iam_instance_profile_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_iam_instance_profile_associations(response.body().as_ref(), output).map_err(crate::error::DescribeIamInstanceProfileAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_identity_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIdentityIdFormatOutput,
    crate::error::DescribeIdentityIdFormatError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIdentityIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIdentityIdFormatError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_identity_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIdentityIdFormatOutput,
    crate::error::DescribeIdentityIdFormatError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_identity_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_identity_id_format(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIdentityIdFormatError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIdFormatOutput, crate::error::DescribeIdFormatError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIdFormatOutput, crate::error::DescribeIdFormatError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_id_format(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIdFormatError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImageAttributeOutput,
    crate::error::DescribeImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImageAttributeOutput,
    crate::error::DescribeImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_image_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImageAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_images_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_images_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_images(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImagesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_image_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImportImageTasksOutput,
    crate::error::DescribeImportImageTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImportImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImportImageTasksError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_image_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImportImageTasksOutput,
    crate::error::DescribeImportImageTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_import_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_import_image_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImportImageTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_snapshot_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImportSnapshotTasksOutput,
    crate::error::DescribeImportSnapshotTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImportSnapshotTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImportSnapshotTasksError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_snapshot_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImportSnapshotTasksOutput,
    crate::error::DescribeImportSnapshotTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_import_snapshot_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_import_snapshot_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImportSnapshotTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAttributeOutput,
    crate::error::DescribeInstanceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceAttributeOutput,
    crate::error::DescribeInstanceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_credit_specifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceCreditSpecificationsOutput,
    crate::error::DescribeInstanceCreditSpecificationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceCreditSpecificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceCreditSpecificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_credit_specifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceCreditSpecificationsOutput,
    crate::error::DescribeInstanceCreditSpecificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_credit_specifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_credit_specifications(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceCreditSpecificationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_notification_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceEventNotificationAttributesOutput,
    crate::error::DescribeInstanceEventNotificationAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_notification_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceEventNotificationAttributesOutput,
    crate::error::DescribeInstanceEventNotificationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_instance_event_notification_attributes_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_windows_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceEventWindowsOutput,
    crate::error::DescribeInstanceEventWindowsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceEventWindowsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceEventWindowsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_windows_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceEventWindowsOutput,
    crate::error::DescribeInstanceEventWindowsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_event_windows_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_event_windows(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceEventWindowsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceStatusOutput,
    crate::error::DescribeInstanceStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceStatusOutput,
    crate::error::DescribeInstanceStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_type_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceTypeOfferingsOutput,
    crate::error::DescribeInstanceTypeOfferingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceTypeOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceTypeOfferingsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_type_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceTypeOfferingsOutput,
    crate::error::DescribeInstanceTypeOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_type_offerings_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_instance_type_offerings(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeInstanceTypeOfferingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_types_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceTypesOutput,
    crate::error::DescribeInstanceTypesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInstanceTypesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceTypesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_types_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInstanceTypesOutput,
    crate::error::DescribeInstanceTypesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_types_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_types(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInstanceTypesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_internet_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInternetGatewaysOutput,
    crate::error::DescribeInternetGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInternetGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInternetGatewaysError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_internet_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInternetGatewaysOutput,
    crate::error::DescribeInternetGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_internet_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_internet_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInternetGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpamPoolsOutput, crate::error::DescribeIpamPoolsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIpamPoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamPoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpamPoolsOutput, crate::error::DescribeIpamPoolsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipam_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipam_pools(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIpamPoolsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipams_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpamsOutput, crate::error::DescribeIpamsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIpamsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipams_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpamsOutput, crate::error::DescribeIpamsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipams_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipams(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIpamsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_scopes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIpamScopesOutput,
    crate::error::DescribeIpamScopesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIpamScopesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamScopesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_scopes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeIpamScopesOutput,
    crate::error::DescribeIpamScopesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipam_scopes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipam_scopes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIpamScopesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipv6_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpv6PoolsOutput, crate::error::DescribeIpv6PoolsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeIpv6PoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpv6PoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipv6_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeIpv6PoolsOutput, crate::error::DescribeIpv6PoolsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipv6_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipv6_pools(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeIpv6PoolsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_key_pairs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeKeyPairsOutput, crate::error::DescribeKeyPairsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeKeyPairsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeKeyPairsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_key_pairs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeKeyPairsOutput, crate::error::DescribeKeyPairsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_key_pairs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_key_pairs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeKeyPairsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLaunchTemplatesOutput,
    crate::error::DescribeLaunchTemplatesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLaunchTemplatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLaunchTemplatesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLaunchTemplatesOutput,
    crate::error::DescribeLaunchTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_launch_templates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_launch_templates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLaunchTemplatesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_template_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLaunchTemplateVersionsOutput,
    crate::error::DescribeLaunchTemplateVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLaunchTemplateVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLaunchTemplateVersionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_template_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLaunchTemplateVersionsOutput,
    crate::error::DescribeLaunchTemplateVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_launch_template_versions_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_launch_template_versions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeLaunchTemplateVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_tables_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTablesOutput,
    crate::error::DescribeLocalGatewayRouteTablesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocalGatewayRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayRouteTablesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_tables_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTablesOutput,
    crate::error::DescribeLocalGatewayRouteTablesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_local_gateway_route_tables_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_tables(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeLocalGatewayRouteTablesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_virtual_interface_group_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput,
    crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(
        crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::generic(
            generic,
        ),
    )
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_virtual_interface_group_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput,
    crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_route_table_virtual_interface_group_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_table_virtual_interface_group_associations(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_vpc_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTableVpcAssociationsOutput,
    crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_vpc_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayRouteTableVpcAssociationsOutput,
    crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_route_table_vpc_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_table_vpc_associations(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewaysOutput,
    crate::error::DescribeLocalGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocalGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewaysOutput,
    crate::error::DescribeLocalGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLocalGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interface_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayVirtualInterfaceGroupsOutput,
    crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interface_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayVirtualInterfaceGroupsOutput,
    crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_local_gateway_virtual_interface_groups_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_virtual_interface_groups(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interfaces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayVirtualInterfacesOutput,
    crate::error::DescribeLocalGatewayVirtualInterfacesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocalGatewayVirtualInterfacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayVirtualInterfacesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interfaces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLocalGatewayVirtualInterfacesOutput,
    crate::error::DescribeLocalGatewayVirtualInterfacesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_local_gateway_virtual_interfaces_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_virtual_interfaces(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayVirtualInterfacesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_managed_prefix_lists_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeManagedPrefixListsOutput,
    crate::error::DescribeManagedPrefixListsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeManagedPrefixListsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeManagedPrefixListsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_managed_prefix_lists_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeManagedPrefixListsOutput,
    crate::error::DescribeManagedPrefixListsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_managed_prefix_lists_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_managed_prefix_lists(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeManagedPrefixListsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_moving_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMovingAddressesOutput,
    crate::error::DescribeMovingAddressesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMovingAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeMovingAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_moving_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMovingAddressesOutput,
    crate::error::DescribeMovingAddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_moving_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_moving_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMovingAddressesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_nat_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNatGatewaysOutput,
    crate::error::DescribeNatGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNatGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNatGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_nat_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNatGatewaysOutput,
    crate::error::DescribeNatGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_nat_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_nat_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNatGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_acls_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkAclsOutput,
    crate::error::DescribeNetworkAclsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkAclsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkAclsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_acls_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkAclsOutput,
    crate::error::DescribeNetworkAclsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_acls_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_acls(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNetworkAclsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scope_analyses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAccessScopeAnalysesOutput,
    crate::error::DescribeNetworkInsightsAccessScopeAnalysesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scope_analyses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAccessScopeAnalysesOutput,
    crate::error::DescribeNetworkInsightsAccessScopeAnalysesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_network_insights_access_scope_analyses_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_access_scope_analyses(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scopes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAccessScopesOutput,
    crate::error::DescribeNetworkInsightsAccessScopesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInsightsAccessScopesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAccessScopesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scopes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAccessScopesOutput,
    crate::error::DescribeNetworkInsightsAccessScopesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_network_insights_access_scopes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_access_scopes(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsAccessScopesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_analyses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAnalysesOutput,
    crate::error::DescribeNetworkInsightsAnalysesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInsightsAnalysesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAnalysesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_analyses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsAnalysesOutput,
    crate::error::DescribeNetworkInsightsAnalysesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_network_insights_analyses_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_network_insights_analyses(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeNetworkInsightsAnalysesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_paths_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsPathsOutput,
    crate::error::DescribeNetworkInsightsPathsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInsightsPathsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsPathsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_paths_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInsightsPathsOutput,
    crate::error::DescribeNetworkInsightsPathsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_insights_paths_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_paths(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNetworkInsightsPathsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfaceAttributeOutput,
    crate::error::DescribeNetworkInterfaceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfaceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfaceAttributeOutput,
    crate::error::DescribeNetworkInterfaceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_network_interface_attribute_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_network_interface_attribute(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeNetworkInterfaceAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfacePermissionsOutput,
    crate::error::DescribeNetworkInterfacePermissionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInterfacePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfacePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfacePermissionsOutput,
    crate::error::DescribeNetworkInterfacePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_network_interface_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_interface_permissions(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInterfacePermissionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interfaces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfacesOutput,
    crate::error::DescribeNetworkInterfacesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNetworkInterfacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfacesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interfaces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNetworkInterfacesOutput,
    crate::error::DescribeNetworkInterfacesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_interfaces_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_interfaces(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNetworkInterfacesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_placement_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePlacementGroupsOutput,
    crate::error::DescribePlacementGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePlacementGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePlacementGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_placement_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePlacementGroupsOutput,
    crate::error::DescribePlacementGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_placement_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_placement_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePlacementGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_prefix_lists_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePrefixListsOutput,
    crate::error::DescribePrefixListsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePrefixListsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePrefixListsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_prefix_lists_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePrefixListsOutput,
    crate::error::DescribePrefixListsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_prefix_lists_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_prefix_lists(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePrefixListsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_principal_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePrincipalIdFormatOutput,
    crate::error::DescribePrincipalIdFormatError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePrincipalIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePrincipalIdFormatError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_principal_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePrincipalIdFormatOutput,
    crate::error::DescribePrincipalIdFormatError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_principal_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_principal_id_format(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePrincipalIdFormatError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_public_ipv4_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePublicIpv4PoolsOutput,
    crate::error::DescribePublicIpv4PoolsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePublicIpv4PoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePublicIpv4PoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_public_ipv4_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePublicIpv4PoolsOutput,
    crate::error::DescribePublicIpv4PoolsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_public_ipv4_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_public_ipv4_pools(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePublicIpv4PoolsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_regions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeRegionsOutput, crate::error::DescribeRegionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeRegionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeRegionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_regions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeRegionsOutput, crate::error::DescribeRegionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_regions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_regions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeRegionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_replace_root_volume_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReplaceRootVolumeTasksOutput,
    crate::error::DescribeReplaceRootVolumeTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeReplaceRootVolumeTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReplaceRootVolumeTasksError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_replace_root_volume_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReplaceRootVolumeTasksOutput,
    crate::error::DescribeReplaceRootVolumeTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_replace_root_volume_tasks_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_replace_root_volume_tasks(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeReplaceRootVolumeTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesOutput,
    crate::error::DescribeReservedInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesOutput,
    crate::error::DescribeReservedInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReservedInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_listings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesListingsOutput,
    crate::error::DescribeReservedInstancesListingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeReservedInstancesListingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesListingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_listings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesListingsOutput,
    crate::error::DescribeReservedInstancesListingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_reserved_instances_listings_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_listings(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeReservedInstancesListingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_modifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesModificationsOutput,
    crate::error::DescribeReservedInstancesModificationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeReservedInstancesModificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesModificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_modifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesModificationsOutput,
    crate::error::DescribeReservedInstancesModificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_reserved_instances_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_modifications(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesModificationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesOfferingsOutput,
    crate::error::DescribeReservedInstancesOfferingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeReservedInstancesOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesOfferingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedInstancesOfferingsOutput,
    crate::error::DescribeReservedInstancesOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_reserved_instances_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_offerings(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesOfferingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_route_tables_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRouteTablesOutput,
    crate::error::DescribeRouteTablesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeRouteTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_route_tables_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRouteTablesOutput,
    crate::error::DescribeRouteTablesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_route_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_route_tables(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeRouteTablesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instance_availability_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledInstanceAvailabilityOutput,
    crate::error::DescribeScheduledInstanceAvailabilityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeScheduledInstanceAvailabilityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeScheduledInstanceAvailabilityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instance_availability_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledInstanceAvailabilityOutput,
    crate::error::DescribeScheduledInstanceAvailabilityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_scheduled_instance_availability_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_scheduled_instance_availability(response.body().as_ref(), output).map_err(crate::error::DescribeScheduledInstanceAvailabilityError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledInstancesOutput,
    crate::error::DescribeScheduledInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeScheduledInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledInstancesOutput,
    crate::error::DescribeScheduledInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_scheduled_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeScheduledInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_references_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupReferencesOutput,
    crate::error::DescribeSecurityGroupReferencesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSecurityGroupReferencesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupReferencesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_references_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupReferencesOutput,
    crate::error::DescribeSecurityGroupReferencesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_security_group_references_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_security_group_references(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeSecurityGroupReferencesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupRulesOutput,
    crate::error::DescribeSecurityGroupRulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSecurityGroupRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupRulesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupRulesOutput,
    crate::error::DescribeSecurityGroupRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_group_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_security_group_rules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSecurityGroupRulesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupsOutput,
    crate::error::DescribeSecurityGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSecurityGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityGroupsOutput,
    crate::error::DescribeSecurityGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_security_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSecurityGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotAttributeOutput,
    crate::error::DescribeSnapshotAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotAttributeOutput,
    crate::error::DescribeSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSnapshotAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSnapshotsOutput, crate::error::DescribeSnapshotsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSnapshotsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSnapshotsOutput, crate::error::DescribeSnapshotsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSnapshotsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_tier_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotTierStatusOutput,
    crate::error::DescribeSnapshotTierStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSnapshotTierStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotTierStatusError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_tier_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotTierStatusOutput,
    crate::error::DescribeSnapshotTierStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_tier_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_tier_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSnapshotTierStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_datafeed_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotDatafeedSubscriptionOutput,
    crate::error::DescribeSpotDatafeedSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotDatafeedSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_datafeed_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotDatafeedSubscriptionOutput,
    crate::error::DescribeSpotDatafeedSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_spot_datafeed_subscription(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeSpotDatafeedSubscriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetInstancesOutput,
    crate::error::DescribeSpotFleetInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotFleetInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetInstancesOutput,
    crate::error::DescribeSpotFleetInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_fleet_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSpotFleetInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_request_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetRequestHistoryOutput,
    crate::error::DescribeSpotFleetRequestHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotFleetRequestHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetRequestHistoryError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_request_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetRequestHistoryOutput,
    crate::error::DescribeSpotFleetRequestHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_spot_fleet_request_history_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_request_history(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeSpotFleetRequestHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetRequestsOutput,
    crate::error::DescribeSpotFleetRequestsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotFleetRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetRequestsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotFleetRequestsOutput,
    crate::error::DescribeSpotFleetRequestsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_fleet_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_requests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSpotFleetRequestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_instance_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotInstanceRequestsOutput,
    crate::error::DescribeSpotInstanceRequestsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotInstanceRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotInstanceRequestsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_instance_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotInstanceRequestsOutput,
    crate::error::DescribeSpotInstanceRequestsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_instance_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_instance_requests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSpotInstanceRequestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_price_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotPriceHistoryOutput,
    crate::error::DescribeSpotPriceHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpotPriceHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotPriceHistoryError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_price_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSpotPriceHistoryOutput,
    crate::error::DescribeSpotPriceHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_price_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_price_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSpotPriceHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stale_security_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStaleSecurityGroupsOutput,
    crate::error::DescribeStaleSecurityGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStaleSecurityGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStaleSecurityGroupsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stale_security_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStaleSecurityGroupsOutput,
    crate::error::DescribeStaleSecurityGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stale_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stale_security_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStaleSecurityGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_store_image_tasks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStoreImageTasksOutput,
    crate::error::DescribeStoreImageTasksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStoreImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStoreImageTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_store_image_tasks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStoreImageTasksOutput,
    crate::error::DescribeStoreImageTasksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_store_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_store_image_tasks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStoreImageTasksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subnets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSubnetsOutput, crate::error::DescribeSubnetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSubnetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSubnetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subnets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSubnetsOutput, crate::error::DescribeSubnetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_subnets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_subnets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSubnetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTagsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_filters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorFiltersOutput,
    crate::error::DescribeTrafficMirrorFiltersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrafficMirrorFiltersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorFiltersError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_filters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorFiltersOutput,
    crate::error::DescribeTrafficMirrorFiltersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_filters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_filters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTrafficMirrorFiltersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorSessionsOutput,
    crate::error::DescribeTrafficMirrorSessionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrafficMirrorSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorSessionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorSessionsOutput,
    crate::error::DescribeTrafficMirrorSessionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_sessions_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_sessions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeTrafficMirrorSessionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_targets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorTargetsOutput,
    crate::error::DescribeTrafficMirrorTargetsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrafficMirrorTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorTargetsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_targets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrafficMirrorTargetsOutput,
    crate::error::DescribeTrafficMirrorTargetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_targets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTrafficMirrorTargetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_attachments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayAttachmentsOutput,
    crate::error::DescribeTransitGatewayAttachmentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_attachments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayAttachmentsOutput,
    crate::error::DescribeTransitGatewayAttachmentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_attachments_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_attachments(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeTransitGatewayAttachmentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connect_peers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayConnectPeersOutput,
    crate::error::DescribeTransitGatewayConnectPeersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayConnectPeersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayConnectPeersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connect_peers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayConnectPeersOutput,
    crate::error::DescribeTransitGatewayConnectPeersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_connect_peers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_connect_peers(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayConnectPeersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayConnectsOutput,
    crate::error::DescribeTransitGatewayConnectsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayConnectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayConnectsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayConnectsOutput,
    crate::error::DescribeTransitGatewayConnectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_connects_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_connects(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeTransitGatewayConnectsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_multicast_domains_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayMulticastDomainsOutput,
    crate::error::DescribeTransitGatewayMulticastDomainsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayMulticastDomainsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayMulticastDomainsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_multicast_domains_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayMulticastDomainsOutput,
    crate::error::DescribeTransitGatewayMulticastDomainsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_multicast_domains_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_multicast_domains(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayMulticastDomainsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_peering_attachments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayPeeringAttachmentsOutput,
    crate::error::DescribeTransitGatewayPeeringAttachmentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_peering_attachments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayPeeringAttachmentsOutput,
    crate::error::DescribeTransitGatewayPeeringAttachmentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_peering_attachments_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_peering_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_policy_tables_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayPolicyTablesOutput,
    crate::error::DescribeTransitGatewayPolicyTablesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayPolicyTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayPolicyTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_policy_tables_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayPolicyTablesOutput,
    crate::error::DescribeTransitGatewayPolicyTablesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_policy_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_policy_tables(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayPolicyTablesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_table_announcements_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayRouteTableAnnouncementsOutput,
    crate::error::DescribeTransitGatewayRouteTableAnnouncementsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_table_announcements_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayRouteTableAnnouncementsOutput,
    crate::error::DescribeTransitGatewayRouteTableAnnouncementsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_route_table_announcements_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_route_table_announcements(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_tables_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayRouteTablesOutput,
    crate::error::DescribeTransitGatewayRouteTablesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayRouteTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_tables_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayRouteTablesOutput,
    crate::error::DescribeTransitGatewayRouteTablesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_route_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_route_tables(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayRouteTablesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewaysOutput,
    crate::error::DescribeTransitGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewaysOutput,
    crate::error::DescribeTransitGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTransitGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_vpc_attachments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayVpcAttachmentsOutput,
    crate::error::DescribeTransitGatewayVpcAttachmentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransitGatewayVpcAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayVpcAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_vpc_attachments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransitGatewayVpcAttachmentsOutput,
    crate::error::DescribeTransitGatewayVpcAttachmentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_transit_gateway_vpc_attachments_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_vpc_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayVpcAttachmentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trunk_interface_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrunkInterfaceAssociationsOutput,
    crate::error::DescribeTrunkInterfaceAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrunkInterfaceAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrunkInterfaceAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trunk_interface_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrunkInterfaceAssociationsOutput,
    crate::error::DescribeTrunkInterfaceAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_trunk_interface_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_trunk_interface_associations(response.body().as_ref(), output).map_err(crate::error::DescribeTrunkInterfaceAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessEndpointsOutput,
    crate::error::DescribeVerifiedAccessEndpointsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVerifiedAccessEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessEndpointsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessEndpointsOutput,
    crate::error::DescribeVerifiedAccessEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_verified_access_endpoints_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_verified_access_endpoints(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeVerifiedAccessEndpointsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessGroupsOutput,
    crate::error::DescribeVerifiedAccessGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVerifiedAccessGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessGroupsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessGroupsOutput,
    crate::error::DescribeVerifiedAccessGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVerifiedAccessGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instance_logging_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput,
    crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(
        crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::unhandled,
    )?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instance_logging_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput,
    crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_instance_logging_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_instance_logging_configurations(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessInstancesOutput,
    crate::error::DescribeVerifiedAccessInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVerifiedAccessInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessInstancesOutput,
    crate::error::DescribeVerifiedAccessInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_verified_access_instances_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_verified_access_instances(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeVerifiedAccessInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_trust_providers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessTrustProvidersOutput,
    crate::error::DescribeVerifiedAccessTrustProvidersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVerifiedAccessTrustProvidersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessTrustProvidersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_trust_providers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVerifiedAccessTrustProvidersOutput,
    crate::error::DescribeVerifiedAccessTrustProvidersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_verified_access_trust_providers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_trust_providers(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessTrustProvidersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumeAttributeOutput,
    crate::error::DescribeVolumeAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVolumeAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumeAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumeAttributeOutput,
    crate::error::DescribeVolumeAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volume_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volume_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVolumeAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVolumesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volumes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volumes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVolumesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_modifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumesModificationsOutput,
    crate::error::DescribeVolumesModificationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVolumesModificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumesModificationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_modifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumesModificationsOutput,
    crate::error::DescribeVolumesModificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volumes_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volumes_modifications(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVolumesModificationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumeStatusOutput,
    crate::error::DescribeVolumeStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVolumeStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumeStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVolumeStatusOutput,
    crate::error::DescribeVolumeStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volume_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volume_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVolumeStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcAttributeOutput,
    crate::error::DescribeVpcAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcAttributeOutput,
    crate::error::DescribeVpcAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpcAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcClassicLinkOutput,
    crate::error::DescribeVpcClassicLinkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcClassicLinkOutput,
    crate::error::DescribeVpcClassicLinkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_classic_link(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpcClassicLinkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_dns_support_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcClassicLinkDnsSupportOutput,
    crate::error::DescribeVpcClassicLinkDnsSupportError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcClassicLinkDnsSupportError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_dns_support_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcClassicLinkDnsSupportOutput,
    crate::error::DescribeVpcClassicLinkDnsSupportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_classic_link_dns_support(response.body().as_ref(), output).map_err(crate::error::DescribeVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connection_notifications_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointConnectionNotificationsOutput,
    crate::error::DescribeVpcEndpointConnectionNotificationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointConnectionNotificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointConnectionNotificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connection_notifications_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointConnectionNotificationsOutput,
    crate::error::DescribeVpcEndpointConnectionNotificationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_vpc_endpoint_connection_notifications_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_connection_notifications(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointConnectionNotificationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointConnectionsOutput,
    crate::error::DescribeVpcEndpointConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointConnectionsOutput,
    crate::error::DescribeVpcEndpointConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_connections(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointsOutput,
    crate::error::DescribeVpcEndpointsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointsOutput,
    crate::error::DescribeVpcEndpointsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpcEndpointsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServiceConfigurationsOutput,
    crate::error::DescribeVpcEndpointServiceConfigurationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointServiceConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServiceConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServiceConfigurationsOutput,
    crate::error::DescribeVpcEndpointServiceConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_vpc_endpoint_service_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_service_configurations(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointServiceConfigurationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServicePermissionsOutput,
    crate::error::DescribeVpcEndpointServicePermissionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointServicePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServicePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServicePermissionsOutput,
    crate::error::DescribeVpcEndpointServicePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_vpc_endpoint_service_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_service_permissions(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointServicePermissionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_services_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServicesOutput,
    crate::error::DescribeVpcEndpointServicesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcEndpointServicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServicesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_services_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcEndpointServicesOutput,
    crate::error::DescribeVpcEndpointServicesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_services_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_services(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpcEndpointServicesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcPeeringConnectionsOutput,
    crate::error::DescribeVpcPeeringConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcPeeringConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpcPeeringConnectionsOutput,
    crate::error::DescribeVpcPeeringConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_peering_connections_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_vpc_peering_connections(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpcs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVpcsOutput, crate::error::DescribeVpcsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpcsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpcs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeVpcsOutput, crate::error::DescribeVpcsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpcs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpcs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpcsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpnConnectionsOutput,
    crate::error::DescribeVpnConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpnConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpnConnectionsOutput,
    crate::error::DescribeVpnConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpn_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpn_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpnConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpnGatewaysOutput,
    crate::error::DescribeVpnGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVpnGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpnGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVpnGatewaysOutput,
    crate::error::DescribeVpnGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpn_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpn_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVpnGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_classic_link_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachClassicLinkVpcOutput,
    crate::error::DetachClassicLinkVpcError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachClassicLinkVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachClassicLinkVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_classic_link_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachClassicLinkVpcOutput,
    crate::error::DetachClassicLinkVpcError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_classic_link_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_classic_link_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DetachClassicLinkVpcError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_internet_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachInternetGatewayOutput,
    crate::error::DetachInternetGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_internet_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachInternetGatewayOutput,
    crate::error::DetachInternetGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_network_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachNetworkInterfaceOutput,
    crate::error::DetachNetworkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_network_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachNetworkInterfaceOutput,
    crate::error::DetachNetworkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_network_interface_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_verified_access_trust_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachVerifiedAccessTrustProviderOutput,
    crate::error::DetachVerifiedAccessTrustProviderError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_verified_access_trust_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetachVerifiedAccessTrustProviderOutput,
    crate::error::DetachVerifiedAccessTrustProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::detach_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::DetachVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachVolumeOutput, crate::error::DetachVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachVolumeOutput, crate::error::DetachVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_volume(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DetachVolumeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_vpn_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachVpnGatewayOutput, crate::error::DetachVpnGatewayError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetachVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_vpn_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetachVpnGatewayOutput, crate::error::DetachVpnGatewayError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_vpn_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_address_transfer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableAddressTransferOutput,
    crate::error::DisableAddressTransferError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_address_transfer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableAddressTransferOutput,
    crate::error::DisableAddressTransferError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_address_transfer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableAddressTransferError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_aws_network_performance_metric_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableAwsNetworkPerformanceMetricSubscriptionOutput,
    crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_aws_network_performance_metric_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableAwsNetworkPerformanceMetricSubscriptionOutput,
    crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_aws_network_performance_metric_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_aws_network_performance_metric_subscription(response.body().as_ref(), output).map_err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ebs_encryption_by_default_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableEbsEncryptionByDefaultOutput,
    crate::error::DisableEbsEncryptionByDefaultError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableEbsEncryptionByDefaultError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ebs_encryption_by_default_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableEbsEncryptionByDefaultOutput,
    crate::error::DisableEbsEncryptionByDefaultError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disable_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disable_ebs_encryption_by_default(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisableEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_launch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DisableFastLaunchOutput, crate::error::DisableFastLaunchError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableFastLaunchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableFastLaunchError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_launch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DisableFastLaunchOutput, crate::error::DisableFastLaunchError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_fast_launch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_fast_launch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableFastLaunchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_snapshot_restores_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableFastSnapshotRestoresOutput,
    crate::error::DisableFastSnapshotRestoresError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableFastSnapshotRestoresError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_snapshot_restores_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableFastSnapshotRestoresOutput,
    crate::error::DisableFastSnapshotRestoresError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_fast_snapshot_restores(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_image_deprecation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableImageDeprecationOutput,
    crate::error::DisableImageDeprecationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableImageDeprecationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableImageDeprecationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_image_deprecation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableImageDeprecationOutput,
    crate::error::DisableImageDeprecationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_image_deprecation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_image_deprecation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableImageDeprecationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ipam_organization_admin_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableIpamOrganizationAdminAccountOutput,
    crate::error::DisableIpamOrganizationAdminAccountError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableIpamOrganizationAdminAccountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableIpamOrganizationAdminAccountError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ipam_organization_admin_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableIpamOrganizationAdminAccountOutput,
    crate::error::DisableIpamOrganizationAdminAccountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disable_ipam_organization_admin_account_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_ipam_organization_admin_account(response.body().as_ref(), output).map_err(crate::error::DisableIpamOrganizationAdminAccountError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_serial_console_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSerialConsoleAccessOutput,
    crate::error::DisableSerialConsoleAccessError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableSerialConsoleAccessError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableSerialConsoleAccessError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_serial_console_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSerialConsoleAccessOutput,
    crate::error::DisableSerialConsoleAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_serial_console_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_serial_console_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableSerialConsoleAccessError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_transit_gateway_route_table_propagation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableTransitGatewayRouteTablePropagationOutput,
    crate::error::DisableTransitGatewayRouteTablePropagationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableTransitGatewayRouteTablePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableTransitGatewayRouteTablePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_transit_gateway_route_table_propagation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableTransitGatewayRouteTablePropagationOutput,
    crate::error::DisableTransitGatewayRouteTablePropagationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disable_transit_gateway_route_table_propagation_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_transit_gateway_route_table_propagation(response.body().as_ref(), output).map_err(crate::error::DisableTransitGatewayRouteTablePropagationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vgw_route_propagation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVgwRoutePropagationOutput,
    crate::error::DisableVgwRoutePropagationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableVgwRoutePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVgwRoutePropagationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vgw_route_propagation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVgwRoutePropagationOutput,
    crate::error::DisableVgwRoutePropagationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_vgw_route_propagation_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVpcClassicLinkOutput,
    crate::error::DisableVpcClassicLinkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVpcClassicLinkOutput,
    crate::error::DisableVpcClassicLinkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_vpc_classic_link(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableVpcClassicLinkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_dns_support_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVpcClassicLinkDnsSupportOutput,
    crate::error::DisableVpcClassicLinkDnsSupportError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVpcClassicLinkDnsSupportError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_dns_support_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableVpcClassicLinkDnsSupportOutput,
    crate::error::DisableVpcClassicLinkDnsSupportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disable_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disable_vpc_classic_link_dns_support(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisableVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateAddressOutput,
    crate::error::DisassociateAddressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateAddressOutput,
    crate::error::DisassociateAddressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_address_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_client_vpn_target_network_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateClientVpnTargetNetworkOutput,
    crate::error::DisassociateClientVpnTargetNetworkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateClientVpnTargetNetworkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_client_vpn_target_network_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateClientVpnTargetNetworkOutput,
    crate::error::DisassociateClientVpnTargetNetworkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_client_vpn_target_network(response.body().as_ref(), output).map_err(crate::error::DisassociateClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_enclave_certificate_iam_role_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateEnclaveCertificateIamRoleOutput,
    crate::error::DisassociateEnclaveCertificateIamRoleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateEnclaveCertificateIamRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateEnclaveCertificateIamRoleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_enclave_certificate_iam_role_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateEnclaveCertificateIamRoleOutput,
    crate::error::DisassociateEnclaveCertificateIamRoleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_enclave_certificate_iam_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_enclave_certificate_iam_role(response.body().as_ref(), output).map_err(crate::error::DisassociateEnclaveCertificateIamRoleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_iam_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateIamInstanceProfileOutput,
    crate::error::DisassociateIamInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateIamInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateIamInstanceProfileError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_iam_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateIamInstanceProfileOutput,
    crate::error::DisassociateIamInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_iam_instance_profile_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disassociate_iam_instance_profile(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisassociateIamInstanceProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_instance_event_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateInstanceEventWindowOutput,
    crate::error::DisassociateInstanceEventWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateInstanceEventWindowError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_instance_event_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateInstanceEventWindowOutput,
    crate::error::DisassociateInstanceEventWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_instance_event_window_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disassociate_instance_event_window(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisassociateInstanceEventWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateRouteTableOutput,
    crate::error::DisassociateRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateRouteTableOutput,
    crate::error::DisassociateRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_route_table_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_subnet_cidr_block_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateSubnetCidrBlockOutput,
    crate::error::DisassociateSubnetCidrBlockError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateSubnetCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateSubnetCidrBlockError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_subnet_cidr_block_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateSubnetCidrBlockOutput,
    crate::error::DisassociateSubnetCidrBlockError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_subnet_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_subnet_cidr_block(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateSubnetCidrBlockError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_multicast_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayMulticastDomainOutput,
    crate::error::DisassociateTransitGatewayMulticastDomainError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_multicast_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayMulticastDomainOutput,
    crate::error::DisassociateTransitGatewayMulticastDomainError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_policy_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayPolicyTableOutput,
    crate::error::DisassociateTransitGatewayPolicyTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_policy_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayPolicyTableOutput,
    crate::error::DisassociateTransitGatewayPolicyTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_route_table_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayRouteTableOutput,
    crate::error::DisassociateTransitGatewayRouteTableError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_route_table_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTransitGatewayRouteTableOutput,
    crate::error::DisassociateTransitGatewayRouteTableError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disassociate_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trunk_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTrunkInterfaceOutput,
    crate::error::DisassociateTrunkInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateTrunkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTrunkInterfaceError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trunk_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTrunkInterfaceOutput,
    crate::error::DisassociateTrunkInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_trunk_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_trunk_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateTrunkInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_cidr_block_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateVpcCidrBlockOutput,
    crate::error::DisassociateVpcCidrBlockError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateVpcCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateVpcCidrBlockError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_cidr_block_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateVpcCidrBlockOutput,
    crate::error::DisassociateVpcCidrBlockError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_vpc_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_vpc_cidr_block(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateVpcCidrBlockError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_address_transfer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableAddressTransferOutput,
    crate::error::EnableAddressTransferError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_address_transfer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableAddressTransferOutput,
    crate::error::EnableAddressTransferError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_address_transfer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableAddressTransferError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_aws_network_performance_metric_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableAwsNetworkPerformanceMetricSubscriptionOutput,
    crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_aws_network_performance_metric_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableAwsNetworkPerformanceMetricSubscriptionOutput,
    crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_aws_network_performance_metric_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_aws_network_performance_metric_subscription(response.body().as_ref(), output).map_err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ebs_encryption_by_default_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableEbsEncryptionByDefaultOutput,
    crate::error::EnableEbsEncryptionByDefaultError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableEbsEncryptionByDefaultError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ebs_encryption_by_default_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableEbsEncryptionByDefaultOutput,
    crate::error::EnableEbsEncryptionByDefaultError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_enable_ebs_encryption_by_default(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::EnableEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_launch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableFastLaunchOutput, crate::error::EnableFastLaunchError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableFastLaunchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableFastLaunchError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_launch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableFastLaunchOutput, crate::error::EnableFastLaunchError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_fast_launch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_fast_launch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableFastLaunchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_snapshot_restores_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableFastSnapshotRestoresOutput,
    crate::error::EnableFastSnapshotRestoresError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableFastSnapshotRestoresError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_snapshot_restores_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableFastSnapshotRestoresOutput,
    crate::error::EnableFastSnapshotRestoresError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_fast_snapshot_restores(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_image_deprecation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableImageDeprecationOutput,
    crate::error::EnableImageDeprecationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableImageDeprecationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableImageDeprecationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_image_deprecation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableImageDeprecationOutput,
    crate::error::EnableImageDeprecationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_image_deprecation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_image_deprecation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableImageDeprecationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ipam_organization_admin_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableIpamOrganizationAdminAccountOutput,
    crate::error::EnableIpamOrganizationAdminAccountError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableIpamOrganizationAdminAccountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableIpamOrganizationAdminAccountError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ipam_organization_admin_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableIpamOrganizationAdminAccountOutput,
    crate::error::EnableIpamOrganizationAdminAccountError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::enable_ipam_organization_admin_account_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_ipam_organization_admin_account(response.body().as_ref(), output).map_err(crate::error::EnableIpamOrganizationAdminAccountError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_reachability_analyzer_organization_sharing_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableReachabilityAnalyzerOrganizationSharingOutput,
    crate::error::EnableReachabilityAnalyzerOrganizationSharingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_reachability_analyzer_organization_sharing_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableReachabilityAnalyzerOrganizationSharingOutput,
    crate::error::EnableReachabilityAnalyzerOrganizationSharingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_reachability_analyzer_organization_sharing_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_reachability_analyzer_organization_sharing(response.body().as_ref(), output).map_err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_serial_console_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSerialConsoleAccessOutput,
    crate::error::EnableSerialConsoleAccessError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableSerialConsoleAccessError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableSerialConsoleAccessError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_serial_console_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSerialConsoleAccessOutput,
    crate::error::EnableSerialConsoleAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_serial_console_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_serial_console_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableSerialConsoleAccessError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_transit_gateway_route_table_propagation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableTransitGatewayRouteTablePropagationOutput,
    crate::error::EnableTransitGatewayRouteTablePropagationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableTransitGatewayRouteTablePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableTransitGatewayRouteTablePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_transit_gateway_route_table_propagation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableTransitGatewayRouteTablePropagationOutput,
    crate::error::EnableTransitGatewayRouteTablePropagationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::enable_transit_gateway_route_table_propagation_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_transit_gateway_route_table_propagation(response.body().as_ref(), output).map_err(crate::error::EnableTransitGatewayRouteTablePropagationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vgw_route_propagation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVgwRoutePropagationOutput,
    crate::error::EnableVgwRoutePropagationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableVgwRoutePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVgwRoutePropagationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vgw_route_propagation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVgwRoutePropagationOutput,
    crate::error::EnableVgwRoutePropagationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_vgw_route_propagation_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_volume_io_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableVolumeIoOutput, crate::error::EnableVolumeIOError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableVolumeIOError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVolumeIOError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_volume_io_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableVolumeIoOutput, crate::error::EnableVolumeIOError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_volume_io_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVpcClassicLinkOutput,
    crate::error::EnableVpcClassicLinkError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVpcClassicLinkOutput,
    crate::error::EnableVpcClassicLinkError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_vpc_classic_link(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableVpcClassicLinkError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_dns_support_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVpcClassicLinkDnsSupportOutput,
    crate::error::EnableVpcClassicLinkDnsSupportError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVpcClassicLinkDnsSupportError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_dns_support_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableVpcClassicLinkDnsSupportOutput,
    crate::error::EnableVpcClassicLinkDnsSupportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::enable_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_enable_vpc_classic_link_dns_support(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::EnableVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_certificate_revocation_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportClientVpnClientCertificateRevocationListOutput,
    crate::error::ExportClientVpnClientCertificateRevocationListError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ExportClientVpnClientCertificateRevocationListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportClientVpnClientCertificateRevocationListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_certificate_revocation_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportClientVpnClientCertificateRevocationListOutput,
    crate::error::ExportClientVpnClientCertificateRevocationListError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_client_vpn_client_certificate_revocation_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_client_vpn_client_certificate_revocation_list(response.body().as_ref(), output).map_err(crate::error::ExportClientVpnClientCertificateRevocationListError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportClientVpnClientConfigurationOutput,
    crate::error::ExportClientVpnClientConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ExportClientVpnClientConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportClientVpnClientConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportClientVpnClientConfigurationOutput,
    crate::error::ExportClientVpnClientConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::export_client_vpn_client_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_client_vpn_client_configuration(response.body().as_ref(), output).map_err(crate::error::ExportClientVpnClientConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExportImageOutput, crate::error::ExportImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ExportImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExportImageOutput, crate::error::ExportImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ExportImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_transit_gateway_routes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportTransitGatewayRoutesOutput,
    crate::error::ExportTransitGatewayRoutesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ExportTransitGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportTransitGatewayRoutesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_transit_gateway_routes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ExportTransitGatewayRoutesOutput,
    crate::error::ExportTransitGatewayRoutesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_transit_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_transit_gateway_routes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ExportTransitGatewayRoutesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_enclave_certificate_iam_roles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAssociatedEnclaveCertificateIamRolesOutput,
    crate::error::GetAssociatedEnclaveCertificateIamRolesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_enclave_certificate_iam_roles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAssociatedEnclaveCertificateIamRolesOutput,
    crate::error::GetAssociatedEnclaveCertificateIamRolesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_associated_enclave_certificate_iam_roles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_associated_enclave_certificate_iam_roles(response.body().as_ref(), output).map_err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_ipv6_pool_cidrs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAssociatedIpv6PoolCidrsOutput,
    crate::error::GetAssociatedIpv6PoolCidrsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAssociatedIpv6PoolCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAssociatedIpv6PoolCidrsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_ipv6_pool_cidrs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAssociatedIpv6PoolCidrsOutput,
    crate::error::GetAssociatedIpv6PoolCidrsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_associated_ipv6_pool_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_associated_ipv6_pool_cidrs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAssociatedIpv6PoolCidrsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aws_network_performance_data_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAwsNetworkPerformanceDataOutput,
    crate::error::GetAwsNetworkPerformanceDataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAwsNetworkPerformanceDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAwsNetworkPerformanceDataError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aws_network_performance_data_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAwsNetworkPerformanceDataOutput,
    crate::error::GetAwsNetworkPerformanceDataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_aws_network_performance_data_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_aws_network_performance_data(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetAwsNetworkPerformanceDataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_capacity_reservation_usage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCapacityReservationUsageOutput,
    crate::error::GetCapacityReservationUsageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCapacityReservationUsageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetCapacityReservationUsageError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_capacity_reservation_usage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCapacityReservationUsageOutput,
    crate::error::GetCapacityReservationUsageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_capacity_reservation_usage_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_capacity_reservation_usage(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCapacityReservationUsageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_coip_pool_usage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCoipPoolUsageOutput, crate::error::GetCoipPoolUsageError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCoipPoolUsageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetCoipPoolUsageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_coip_pool_usage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCoipPoolUsageOutput, crate::error::GetCoipPoolUsageError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_coip_pool_usage_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_coip_pool_usage(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCoipPoolUsageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_output_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetConsoleOutputOutput, crate::error::GetConsoleOutputError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetConsoleOutputError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetConsoleOutputError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_output_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetConsoleOutputOutput, crate::error::GetConsoleOutputError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_console_output_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_console_output(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConsoleOutputError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_screenshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConsoleScreenshotOutput,
    crate::error::GetConsoleScreenshotError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetConsoleScreenshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetConsoleScreenshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_screenshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConsoleScreenshotOutput,
    crate::error::GetConsoleScreenshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_console_screenshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_console_screenshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConsoleScreenshotError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_credit_specification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultCreditSpecificationOutput,
    crate::error::GetDefaultCreditSpecificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDefaultCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetDefaultCreditSpecificationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_credit_specification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDefaultCreditSpecificationOutput,
    crate::error::GetDefaultCreditSpecificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_default_credit_specification_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_default_credit_specification(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetDefaultCreditSpecificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_default_kms_key_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEbsDefaultKmsKeyIdOutput,
    crate::error::GetEbsDefaultKmsKeyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetEbsDefaultKmsKeyIdError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_default_kms_key_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEbsDefaultKmsKeyIdOutput,
    crate::error::GetEbsDefaultKmsKeyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ebs_default_kms_key_id(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_encryption_by_default_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEbsEncryptionByDefaultOutput,
    crate::error::GetEbsEncryptionByDefaultError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetEbsEncryptionByDefaultError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_encryption_by_default_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEbsEncryptionByDefaultOutput,
    crate::error::GetEbsEncryptionByDefaultError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ebs_encryption_by_default(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_flow_logs_integration_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFlowLogsIntegrationTemplateOutput,
    crate::error::GetFlowLogsIntegrationTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFlowLogsIntegrationTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetFlowLogsIntegrationTemplateError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_flow_logs_integration_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetFlowLogsIntegrationTemplateOutput,
    crate::error::GetFlowLogsIntegrationTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_flow_logs_integration_template_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_flow_logs_integration_template(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetFlowLogsIntegrationTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_for_capacity_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupsForCapacityReservationOutput,
    crate::error::GetGroupsForCapacityReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetGroupsForCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetGroupsForCapacityReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_for_capacity_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGroupsForCapacityReservationOutput,
    crate::error::GetGroupsForCapacityReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_groups_for_capacity_reservation_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_groups_for_capacity_reservation(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetGroupsForCapacityReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_host_reservation_purchase_preview_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostReservationPurchasePreviewOutput,
    crate::error::GetHostReservationPurchasePreviewError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetHostReservationPurchasePreviewError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetHostReservationPurchasePreviewError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_host_reservation_purchase_preview_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetHostReservationPurchasePreviewOutput,
    crate::error::GetHostReservationPurchasePreviewError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_host_reservation_purchase_preview_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_host_reservation_purchase_preview(response.body().as_ref(), output).map_err(crate::error::GetHostReservationPurchasePreviewError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_types_from_instance_requirements_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceTypesFromInstanceRequirementsOutput,
    crate::error::GetInstanceTypesFromInstanceRequirementsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInstanceTypesFromInstanceRequirementsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetInstanceTypesFromInstanceRequirementsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_types_from_instance_requirements_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceTypesFromInstanceRequirementsOutput,
    crate::error::GetInstanceTypesFromInstanceRequirementsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_instance_types_from_instance_requirements_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_instance_types_from_instance_requirements(response.body().as_ref(), output).map_err(crate::error::GetInstanceTypesFromInstanceRequirementsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_uefi_data_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceUefiDataOutput,
    crate::error::GetInstanceUefiDataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInstanceUefiDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetInstanceUefiDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_uefi_data_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceUefiDataOutput,
    crate::error::GetInstanceUefiDataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_uefi_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_instance_uefi_data(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInstanceUefiDataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_address_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamAddressHistoryOutput,
    crate::error::GetIpamAddressHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetIpamAddressHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamAddressHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_address_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamAddressHistoryOutput,
    crate::error::GetIpamAddressHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_address_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_address_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIpamAddressHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_allocations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamPoolAllocationsOutput,
    crate::error::GetIpamPoolAllocationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetIpamPoolAllocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamPoolAllocationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_allocations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamPoolAllocationsOutput,
    crate::error::GetIpamPoolAllocationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_pool_allocations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_pool_allocations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIpamPoolAllocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_cidrs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetIpamPoolCidrsOutput, crate::error::GetIpamPoolCidrsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetIpamPoolCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamPoolCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_cidrs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetIpamPoolCidrsOutput, crate::error::GetIpamPoolCidrsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_pool_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_pool_cidrs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIpamPoolCidrsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_resource_cidrs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamResourceCidrsOutput,
    crate::error::GetIpamResourceCidrsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetIpamResourceCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamResourceCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_resource_cidrs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIpamResourceCidrsOutput,
    crate::error::GetIpamResourceCidrsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_resource_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_resource_cidrs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIpamResourceCidrsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_launch_template_data_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLaunchTemplateDataOutput,
    crate::error::GetLaunchTemplateDataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetLaunchTemplateDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetLaunchTemplateDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_launch_template_data_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLaunchTemplateDataOutput,
    crate::error::GetLaunchTemplateDataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_launch_template_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_launch_template_data(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLaunchTemplateDataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedPrefixListAssociationsOutput,
    crate::error::GetManagedPrefixListAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetManagedPrefixListAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetManagedPrefixListAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedPrefixListAssociationsOutput,
    crate::error::GetManagedPrefixListAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_managed_prefix_list_associations_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_managed_prefix_list_associations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetManagedPrefixListAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_entries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedPrefixListEntriesOutput,
    crate::error::GetManagedPrefixListEntriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetManagedPrefixListEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetManagedPrefixListEntriesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_entries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedPrefixListEntriesOutput,
    crate::error::GetManagedPrefixListEntriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_managed_prefix_list_entries_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_managed_prefix_list_entries(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetManagedPrefixListEntriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_analysis_findings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetNetworkInsightsAccessScopeAnalysisFindingsOutput,
    crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_analysis_findings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetNetworkInsightsAccessScopeAnalysisFindingsOutput,
    crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_network_insights_access_scope_analysis_findings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_network_insights_access_scope_analysis_findings(response.body().as_ref(), output).map_err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetNetworkInsightsAccessScopeContentOutput,
    crate::error::GetNetworkInsightsAccessScopeContentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetNetworkInsightsAccessScopeContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetNetworkInsightsAccessScopeContentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetNetworkInsightsAccessScopeContentOutput,
    crate::error::GetNetworkInsightsAccessScopeContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_network_insights_access_scope_content_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_network_insights_access_scope_content(response.body().as_ref(), output).map_err(crate::error::GetNetworkInsightsAccessScopeContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_password_data_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPasswordDataOutput, crate::error::GetPasswordDataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPasswordDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetPasswordDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_password_data_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPasswordDataOutput, crate::error::GetPasswordDataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_password_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_password_data(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPasswordDataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_instances_exchange_quote_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReservedInstancesExchangeQuoteOutput,
    crate::error::GetReservedInstancesExchangeQuoteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetReservedInstancesExchangeQuoteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetReservedInstancesExchangeQuoteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_instances_exchange_quote_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReservedInstancesExchangeQuoteOutput,
    crate::error::GetReservedInstancesExchangeQuoteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_reserved_instances_exchange_quote_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_reserved_instances_exchange_quote(response.body().as_ref(), output).map_err(crate::error::GetReservedInstancesExchangeQuoteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_serial_console_access_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSerialConsoleAccessStatusOutput,
    crate::error::GetSerialConsoleAccessStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSerialConsoleAccessStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSerialConsoleAccessStatusError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_serial_console_access_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSerialConsoleAccessStatusOutput,
    crate::error::GetSerialConsoleAccessStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_serial_console_access_status_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_serial_console_access_status(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetSerialConsoleAccessStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_spot_placement_scores_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSpotPlacementScoresOutput,
    crate::error::GetSpotPlacementScoresError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSpotPlacementScoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSpotPlacementScoresError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_spot_placement_scores_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSpotPlacementScoresOutput,
    crate::error::GetSpotPlacementScoresError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_spot_placement_scores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_spot_placement_scores(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSpotPlacementScoresError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subnet_cidr_reservations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubnetCidrReservationsOutput,
    crate::error::GetSubnetCidrReservationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSubnetCidrReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSubnetCidrReservationsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subnet_cidr_reservations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSubnetCidrReservationsOutput,
    crate::error::GetSubnetCidrReservationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_subnet_cidr_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_subnet_cidr_reservations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSubnetCidrReservationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_attachment_propagations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayAttachmentPropagationsOutput,
    crate::error::GetTransitGatewayAttachmentPropagationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayAttachmentPropagationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayAttachmentPropagationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_attachment_propagations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayAttachmentPropagationsOutput,
    crate::error::GetTransitGatewayAttachmentPropagationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_attachment_propagations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_attachment_propagations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayAttachmentPropagationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_multicast_domain_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::GetTransitGatewayMulticastDomainAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_multicast_domain_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::GetTransitGatewayMulticastDomainAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPolicyTableAssociationsOutput,
    crate::error::GetTransitGatewayPolicyTableAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayPolicyTableAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPolicyTableAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPolicyTableAssociationsOutput,
    crate::error::GetTransitGatewayPolicyTableAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_policy_table_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_policy_table_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPolicyTableAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_entries_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPolicyTableEntriesOutput,
    crate::error::GetTransitGatewayPolicyTableEntriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayPolicyTableEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPolicyTableEntriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_entries_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPolicyTableEntriesOutput,
    crate::error::GetTransitGatewayPolicyTableEntriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_policy_table_entries_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_policy_table_entries(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPolicyTableEntriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_prefix_list_references_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPrefixListReferencesOutput,
    crate::error::GetTransitGatewayPrefixListReferencesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayPrefixListReferencesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPrefixListReferencesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_prefix_list_references_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayPrefixListReferencesOutput,
    crate::error::GetTransitGatewayPrefixListReferencesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_prefix_list_references_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_prefix_list_references(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPrefixListReferencesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayRouteTableAssociationsOutput,
    crate::error::GetTransitGatewayRouteTableAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayRouteTableAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayRouteTableAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayRouteTableAssociationsOutput,
    crate::error::GetTransitGatewayRouteTableAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_route_table_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_route_table_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayRouteTableAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_propagations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayRouteTablePropagationsOutput,
    crate::error::GetTransitGatewayRouteTablePropagationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTransitGatewayRouteTablePropagationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayRouteTablePropagationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_propagations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTransitGatewayRouteTablePropagationsOutput,
    crate::error::GetTransitGatewayRouteTablePropagationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_transit_gateway_route_table_propagations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_route_table_propagations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayRouteTablePropagationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_endpoint_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVerifiedAccessEndpointPolicyOutput,
    crate::error::GetVerifiedAccessEndpointPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetVerifiedAccessEndpointPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVerifiedAccessEndpointPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_endpoint_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVerifiedAccessEndpointPolicyOutput,
    crate::error::GetVerifiedAccessEndpointPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_verified_access_endpoint_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_verified_access_endpoint_policy(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetVerifiedAccessEndpointPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVerifiedAccessGroupPolicyOutput,
    crate::error::GetVerifiedAccessGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetVerifiedAccessGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVerifiedAccessGroupPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVerifiedAccessGroupPolicyOutput,
    crate::error::GetVerifiedAccessGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_verified_access_group_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_verified_access_group_policy(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetVerifiedAccessGroupPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_sample_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpnConnectionDeviceSampleConfigurationOutput,
    crate::error::GetVpnConnectionDeviceSampleConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_sample_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpnConnectionDeviceSampleConfigurationOutput,
    crate::error::GetVpnConnectionDeviceSampleConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_vpn_connection_device_sample_configuration_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_vpn_connection_device_sample_configuration(response.body().as_ref(), output).map_err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_types_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpnConnectionDeviceTypesOutput,
    crate::error::GetVpnConnectionDeviceTypesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetVpnConnectionDeviceTypesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVpnConnectionDeviceTypesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_types_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpnConnectionDeviceTypesOutput,
    crate::error::GetVpnConnectionDeviceTypesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpn_connection_device_types_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_vpn_connection_device_types(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetVpnConnectionDeviceTypesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_client_vpn_client_certificate_revocation_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportClientVpnClientCertificateRevocationListOutput,
    crate::error::ImportClientVpnClientCertificateRevocationListError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportClientVpnClientCertificateRevocationListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportClientVpnClientCertificateRevocationListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_client_vpn_client_certificate_revocation_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportClientVpnClientCertificateRevocationListOutput,
    crate::error::ImportClientVpnClientCertificateRevocationListError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_client_vpn_client_certificate_revocation_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_client_vpn_client_certificate_revocation_list(response.body().as_ref(), output).map_err(crate::error::ImportClientVpnClientCertificateRevocationListError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportImageOutput, crate::error::ImportImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportImageOutput, crate::error::ImportImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportInstanceOutput, crate::error::ImportInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportInstanceOutput, crate::error::ImportInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_key_pair_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportKeyPairOutput, crate::error::ImportKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_key_pair_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportKeyPairOutput, crate::error::ImportKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_key_pair_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_key_pair(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportKeyPairError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportSnapshotOutput, crate::error::ImportSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportSnapshotOutput, crate::error::ImportSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportSnapshotError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportVolumeOutput, crate::error::ImportVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportVolumeOutput, crate::error::ImportVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_volume(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportVolumeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_in_recycle_bin_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListImagesInRecycleBinOutput,
    crate::error::ListImagesInRecycleBinError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListImagesInRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListImagesInRecycleBinError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_in_recycle_bin_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListImagesInRecycleBinOutput,
    crate::error::ListImagesInRecycleBinError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_images_in_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_images_in_recycle_bin(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListImagesInRecycleBinError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_snapshots_in_recycle_bin_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSnapshotsInRecycleBinOutput,
    crate::error::ListSnapshotsInRecycleBinError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListSnapshotsInRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListSnapshotsInRecycleBinError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_snapshots_in_recycle_bin_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSnapshotsInRecycleBinOutput,
    crate::error::ListSnapshotsInRecycleBinError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_snapshots_in_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_snapshots_in_recycle_bin(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSnapshotsInRecycleBinError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_address_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAddressAttributeOutput,
    crate::error::ModifyAddressAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyAddressAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyAddressAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_address_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAddressAttributeOutput,
    crate::error::ModifyAddressAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_address_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_address_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyAddressAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_availability_zone_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAvailabilityZoneGroupOutput,
    crate::error::ModifyAvailabilityZoneGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyAvailabilityZoneGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyAvailabilityZoneGroupError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_availability_zone_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAvailabilityZoneGroupOutput,
    crate::error::ModifyAvailabilityZoneGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_availability_zone_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_availability_zone_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyAvailabilityZoneGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCapacityReservationOutput,
    crate::error::ModifyCapacityReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyCapacityReservationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCapacityReservationOutput,
    crate::error::ModifyCapacityReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_capacity_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyCapacityReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCapacityReservationFleetOutput,
    crate::error::ModifyCapacityReservationFleetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyCapacityReservationFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyCapacityReservationFleetError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyCapacityReservationFleetOutput,
    crate::error::ModifyCapacityReservationFleetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_capacity_reservation_fleet_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_capacity_reservation_fleet(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyCapacityReservationFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_client_vpn_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClientVpnEndpointOutput,
    crate::error::ModifyClientVpnEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_client_vpn_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClientVpnEndpointOutput,
    crate::error::ModifyClientVpnEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_client_vpn_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClientVpnEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_default_credit_specification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDefaultCreditSpecificationOutput,
    crate::error::ModifyDefaultCreditSpecificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyDefaultCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyDefaultCreditSpecificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_default_credit_specification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyDefaultCreditSpecificationOutput,
    crate::error::ModifyDefaultCreditSpecificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_default_credit_specification_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_default_credit_specification(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyDefaultCreditSpecificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ebs_default_kms_key_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEbsDefaultKmsKeyIdOutput,
    crate::error::ModifyEbsDefaultKmsKeyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyEbsDefaultKmsKeyIdError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ebs_default_kms_key_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEbsDefaultKmsKeyIdOutput,
    crate::error::ModifyEbsDefaultKmsKeyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ebs_default_kms_key_id(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyFleetOutput, crate::error::ModifyFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyFleetOutput, crate::error::ModifyFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_fleet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fpga_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyFpgaImageAttributeOutput,
    crate::error::ModifyFpgaImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyFpgaImageAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fpga_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyFpgaImageAttributeOutput,
    crate::error::ModifyFpgaImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_fpga_image_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyFpgaImageAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_hosts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyHostsOutput, crate::error::ModifyHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_hosts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyHostsOutput, crate::error::ModifyHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_hosts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyHostsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_identity_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyIdentityIdFormatOutput,
    crate::error::ModifyIdentityIdFormatError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIdentityIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIdentityIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_identity_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyIdentityIdFormatOutput,
    crate::error::ModifyIdentityIdFormatError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_identity_id_format_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_id_format_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIdFormatOutput, crate::error::ModifyIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_id_format_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIdFormatOutput, crate::error::ModifyIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_id_format_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyImageAttributeOutput,
    crate::error::ModifyImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyImageAttributeOutput,
    crate::error::ModifyImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_image_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceAttributeOutput,
    crate::error::ModifyInstanceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceAttributeOutput,
    crate::error::ModifyInstanceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_capacity_reservation_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceCapacityReservationAttributesOutput,
    crate::error::ModifyInstanceCapacityReservationAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceCapacityReservationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceCapacityReservationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_capacity_reservation_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceCapacityReservationAttributesOutput,
    crate::error::ModifyInstanceCapacityReservationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_instance_capacity_reservation_attributes_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_capacity_reservation_attributes(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceCapacityReservationAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_credit_specification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceCreditSpecificationOutput,
    crate::error::ModifyInstanceCreditSpecificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceCreditSpecificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_credit_specification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceCreditSpecificationOutput,
    crate::error::ModifyInstanceCreditSpecificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_instance_credit_specification_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_instance_credit_specification(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyInstanceCreditSpecificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_start_time_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceEventStartTimeOutput,
    crate::error::ModifyInstanceEventStartTimeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceEventStartTimeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceEventStartTimeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_start_time_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceEventStartTimeOutput,
    crate::error::ModifyInstanceEventStartTimeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_event_start_time_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_instance_event_start_time(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyInstanceEventStartTimeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_window_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceEventWindowOutput,
    crate::error::ModifyInstanceEventWindowError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceEventWindowError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_window_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceEventWindowOutput,
    crate::error::ModifyInstanceEventWindowError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_event_window(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyInstanceEventWindowError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_maintenance_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceMaintenanceOptionsOutput,
    crate::error::ModifyInstanceMaintenanceOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceMaintenanceOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceMaintenanceOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_maintenance_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceMaintenanceOptionsOutput,
    crate::error::ModifyInstanceMaintenanceOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_instance_maintenance_options_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_instance_maintenance_options(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyInstanceMaintenanceOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_metadata_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceMetadataOptionsOutput,
    crate::error::ModifyInstanceMetadataOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstanceMetadataOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceMetadataOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_metadata_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceMetadataOptionsOutput,
    crate::error::ModifyInstanceMetadataOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_metadata_options_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_instance_metadata_options(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyInstanceMetadataOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_placement_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstancePlacementOutput,
    crate::error::ModifyInstancePlacementError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyInstancePlacementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstancePlacementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_placement_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstancePlacementOutput,
    crate::error::ModifyInstancePlacementError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_placement_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_placement(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyInstancePlacementError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamOutput, crate::error::ModifyIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamOutput, crate::error::ModifyIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyIpamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamPoolOutput, crate::error::ModifyIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamPoolOutput, crate::error::ModifyIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyIpamPoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_resource_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyIpamResourceCidrOutput,
    crate::error::ModifyIpamResourceCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIpamResourceCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamResourceCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_resource_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyIpamResourceCidrOutput,
    crate::error::ModifyIpamResourceCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_resource_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_resource_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyIpamResourceCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_scope_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamScopeOutput, crate::error::ModifyIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_scope_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyIpamScopeOutput, crate::error::ModifyIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_scope(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyIpamScopeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_launch_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyLaunchTemplateOutput,
    crate::error::ModifyLaunchTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_launch_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyLaunchTemplateOutput,
    crate::error::ModifyLaunchTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_launch_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyLaunchTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_local_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyLocalGatewayRouteOutput,
    crate::error::ModifyLocalGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_local_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyLocalGatewayRouteOutput,
    crate::error::ModifyLocalGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_local_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyLocalGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_managed_prefix_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyManagedPrefixListOutput,
    crate::error::ModifyManagedPrefixListError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_managed_prefix_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyManagedPrefixListOutput,
    crate::error::ModifyManagedPrefixListError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_managed_prefix_list(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyManagedPrefixListError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_network_interface_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyNetworkInterfaceAttributeOutput,
    crate::error::ModifyNetworkInterfaceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyNetworkInterfaceAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_network_interface_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyNetworkInterfaceAttributeOutput,
    crate::error::ModifyNetworkInterfaceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_network_interface_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_private_dns_name_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyPrivateDnsNameOptionsOutput,
    crate::error::ModifyPrivateDnsNameOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyPrivateDnsNameOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyPrivateDnsNameOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_private_dns_name_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyPrivateDnsNameOptionsOutput,
    crate::error::ModifyPrivateDnsNameOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_private_dns_name_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_private_dns_name_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyPrivateDnsNameOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_reserved_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyReservedInstancesOutput,
    crate::error::ModifyReservedInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyReservedInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_reserved_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyReservedInstancesOutput,
    crate::error::ModifyReservedInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_reserved_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_reserved_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyReservedInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_security_group_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySecurityGroupRulesOutput,
    crate::error::ModifySecurityGroupRulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifySecurityGroupRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySecurityGroupRulesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_security_group_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySecurityGroupRulesOutput,
    crate::error::ModifySecurityGroupRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_security_group_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_security_group_rules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifySecurityGroupRulesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotAttributeOutput,
    crate::error::ModifySnapshotAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifySnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySnapshotAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotAttributeOutput,
    crate::error::ModifySnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_snapshot_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_tier_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotTierOutput,
    crate::error::ModifySnapshotTierError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifySnapshotTierError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySnapshotTierError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_tier_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotTierOutput,
    crate::error::ModifySnapshotTierError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_snapshot_tier_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_snapshot_tier(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifySnapshotTierError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_spot_fleet_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySpotFleetRequestOutput,
    crate::error::ModifySpotFleetRequestError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifySpotFleetRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySpotFleetRequestError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_spot_fleet_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySpotFleetRequestOutput,
    crate::error::ModifySpotFleetRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_spot_fleet_request_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_spot_fleet_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifySpotFleetRequestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_subnet_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySubnetAttributeOutput,
    crate::error::ModifySubnetAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifySubnetAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySubnetAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_subnet_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySubnetAttributeOutput,
    crate::error::ModifySubnetAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_subnet_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_network_services_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorFilterNetworkServicesOutput,
    crate::error::ModifyTrafficMirrorFilterNetworkServicesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_network_services_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorFilterNetworkServicesOutput,
    crate::error::ModifyTrafficMirrorFilterNetworkServicesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_traffic_mirror_filter_network_services_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_filter_network_services(response.body().as_ref(), output).map_err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorFilterRuleOutput,
    crate::error::ModifyTrafficMirrorFilterRuleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorFilterRuleError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorFilterRuleOutput,
    crate::error::ModifyTrafficMirrorFilterRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_filter_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorSessionOutput,
    crate::error::ModifyTrafficMirrorSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorSessionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTrafficMirrorSessionOutput,
    crate::error::ModifyTrafficMirrorSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayOutput,
    crate::error::ModifyTransitGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayOutput,
    crate::error::ModifyTransitGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyTransitGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_prefix_list_reference_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayPrefixListReferenceOutput,
    crate::error::ModifyTransitGatewayPrefixListReferenceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_prefix_list_reference_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayPrefixListReferenceOutput,
    crate::error::ModifyTransitGatewayPrefixListReferenceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::ModifyTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_vpc_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayVpcAttachmentOutput,
    crate::error::ModifyTransitGatewayVpcAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_vpc_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyTransitGatewayVpcAttachmentOutput,
    crate::error::ModifyTransitGatewayVpcAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::ModifyTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessEndpointOutput,
    crate::error::ModifyVerifiedAccessEndpointError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessEndpointError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessEndpointOutput,
    crate::error::ModifyVerifiedAccessEndpointError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessEndpointPolicyOutput,
    crate::error::ModifyVerifiedAccessEndpointPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessEndpointPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessEndpointPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessEndpointPolicyOutput,
    crate::error::ModifyVerifiedAccessEndpointPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_verified_access_endpoint_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_endpoint_policy(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessEndpointPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessGroupOutput,
    crate::error::ModifyVerifiedAccessGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessGroupError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessGroupOutput,
    crate::error::ModifyVerifiedAccessGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessGroupPolicyOutput,
    crate::error::ModifyVerifiedAccessGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessGroupPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessGroupPolicyOutput,
    crate::error::ModifyVerifiedAccessGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_verified_access_group_policy_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_modify_verified_access_group_policy(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ModifyVerifiedAccessGroupPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessInstanceOutput,
    crate::error::ModifyVerifiedAccessInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessInstanceError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessInstanceOutput,
    crate::error::ModifyVerifiedAccessInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_logging_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessInstanceLoggingConfigurationOutput,
    crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_logging_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessInstanceLoggingConfigurationOutput,
    crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_instance_logging_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_instance_logging_configuration(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_trust_provider_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessTrustProviderOutput,
    crate::error::ModifyVerifiedAccessTrustProviderError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_trust_provider_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVerifiedAccessTrustProviderOutput,
    crate::error::ModifyVerifiedAccessTrustProviderError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVolumeOutput, crate::error::ModifyVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVolumeOutput, crate::error::ModifyVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_volume(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVolumeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVolumeAttributeOutput,
    crate::error::ModifyVolumeAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVolumeAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVolumeAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVolumeAttributeOutput,
    crate::error::ModifyVolumeAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_volume_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcAttributeOutput,
    crate::error::ModifyVpcAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcAttributeOutput,
    crate::error::ModifyVpcAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVpcEndpointOutput, crate::error::ModifyVpcEndpointError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVpcEndpointOutput, crate::error::ModifyVpcEndpointError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpcEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_connection_notification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointConnectionNotificationOutput,
    crate::error::ModifyVpcEndpointConnectionNotificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcEndpointConnectionNotificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointConnectionNotificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_connection_notification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointConnectionNotificationOutput,
    crate::error::ModifyVpcEndpointConnectionNotificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_vpc_endpoint_connection_notification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_connection_notification(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointConnectionNotificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServiceConfigurationOutput,
    crate::error::ModifyVpcEndpointServiceConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcEndpointServiceConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServiceConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServiceConfigurationOutput,
    crate::error::ModifyVpcEndpointServiceConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_vpc_endpoint_service_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_configuration(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServiceConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_payer_responsibility_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServicePayerResponsibilityOutput,
    crate::error::ModifyVpcEndpointServicePayerResponsibilityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_payer_responsibility_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServicePayerResponsibilityOutput,
    crate::error::ModifyVpcEndpointServicePayerResponsibilityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_service_payer_responsibility_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_payer_responsibility(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_permissions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServicePermissionsOutput,
    crate::error::ModifyVpcEndpointServicePermissionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcEndpointServicePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServicePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_permissions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcEndpointServicePermissionsOutput,
    crate::error::ModifyVpcEndpointServicePermissionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_vpc_endpoint_service_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_permissions(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServicePermissionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_peering_connection_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcPeeringConnectionOptionsOutput,
    crate::error::ModifyVpcPeeringConnectionOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcPeeringConnectionOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcPeeringConnectionOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_peering_connection_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpcPeeringConnectionOptionsOutput,
    crate::error::ModifyVpcPeeringConnectionOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_vpc_peering_connection_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_peering_connection_options(response.body().as_ref(), output).map_err(crate::error::ModifyVpcPeeringConnectionOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_tenancy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVpcTenancyOutput, crate::error::ModifyVpcTenancyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpcTenancyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcTenancyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_tenancy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyVpcTenancyOutput, crate::error::ModifyVpcTenancyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_tenancy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_tenancy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpcTenancyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnConnectionOutput,
    crate::error::ModifyVpnConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnConnectionOutput,
    crate::error::ModifyVpnConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpnConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnConnectionOptionsOutput,
    crate::error::ModifyVpnConnectionOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpnConnectionOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnConnectionOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnConnectionOptionsOutput,
    crate::error::ModifyVpnConnectionOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_connection_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_connection_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpnConnectionOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnTunnelCertificateOutput,
    crate::error::ModifyVpnTunnelCertificateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpnTunnelCertificateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnTunnelCertificateError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnTunnelCertificateOutput,
    crate::error::ModifyVpnTunnelCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_tunnel_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_tunnel_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpnTunnelCertificateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnTunnelOptionsOutput,
    crate::error::ModifyVpnTunnelOptionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ModifyVpnTunnelOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnTunnelOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyVpnTunnelOptionsOutput,
    crate::error::ModifyVpnTunnelOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_tunnel_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_tunnel_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyVpnTunnelOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_monitor_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MonitorInstancesOutput, crate::error::MonitorInstancesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MonitorInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MonitorInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_monitor_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MonitorInstancesOutput, crate::error::MonitorInstancesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::monitor_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_monitor_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MonitorInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_address_to_vpc_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MoveAddressToVpcOutput, crate::error::MoveAddressToVpcError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MoveAddressToVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MoveAddressToVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_address_to_vpc_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MoveAddressToVpcOutput, crate::error::MoveAddressToVpcError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::move_address_to_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_move_address_to_vpc(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MoveAddressToVpcError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_byoip_cidr_to_ipam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MoveByoipCidrToIpamOutput,
    crate::error::MoveByoipCidrToIpamError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MoveByoipCidrToIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MoveByoipCidrToIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_byoip_cidr_to_ipam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MoveByoipCidrToIpamOutput,
    crate::error::MoveByoipCidrToIpamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::move_byoip_cidr_to_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_move_byoip_cidr_to_ipam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MoveByoipCidrToIpamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_byoip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionByoipCidrOutput,
    crate::error::ProvisionByoipCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ProvisionByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_byoip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionByoipCidrOutput,
    crate::error::ProvisionByoipCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_byoip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ProvisionByoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_ipam_pool_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionIpamPoolCidrOutput,
    crate::error::ProvisionIpamPoolCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ProvisionIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_ipam_pool_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionIpamPoolCidrOutput,
    crate::error::ProvisionIpamPoolCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_ipam_pool_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ProvisionIpamPoolCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_public_ipv4_pool_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionPublicIpv4PoolCidrOutput,
    crate::error::ProvisionPublicIpv4PoolCidrError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ProvisionPublicIpv4PoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionPublicIpv4PoolCidrError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_public_ipv4_pool_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ProvisionPublicIpv4PoolCidrOutput,
    crate::error::ProvisionPublicIpv4PoolCidrError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_public_ipv4_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_public_ipv4_pool_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ProvisionPublicIpv4PoolCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_host_reservation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseHostReservationOutput,
    crate::error::PurchaseHostReservationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PurchaseHostReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseHostReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_host_reservation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseHostReservationOutput,
    crate::error::PurchaseHostReservationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_host_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_host_reservation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PurchaseHostReservationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_instances_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedInstancesOfferingOutput,
    crate::error::PurchaseReservedInstancesOfferingError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PurchaseReservedInstancesOfferingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseReservedInstancesOfferingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_instances_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedInstancesOfferingOutput,
    crate::error::PurchaseReservedInstancesOfferingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::purchase_reserved_instances_offering_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_purchase_reserved_instances_offering(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::PurchaseReservedInstancesOfferingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_scheduled_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseScheduledInstancesOutput,
    crate::error::PurchaseScheduledInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PurchaseScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseScheduledInstancesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_scheduled_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseScheduledInstancesOutput,
    crate::error::PurchaseScheduledInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_scheduled_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PurchaseScheduledInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootInstancesOutput, crate::error::RebootInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RebootInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RebootInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootInstancesOutput, crate::error::RebootInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_instances_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterImageOutput, crate::error::RegisterImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterImageOutput, crate::error::RegisterImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RegisterImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_event_notification_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterInstanceEventNotificationAttributesOutput,
    crate::error::RegisterInstanceEventNotificationAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_event_notification_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterInstanceEventNotificationAttributesOutput,
    crate::error::RegisterInstanceEventNotificationAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::register_instance_event_notification_attributes_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::RegisterInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_members_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTransitGatewayMulticastGroupMembersOutput,
    crate::error::RegisterTransitGatewayMulticastGroupMembersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_members_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTransitGatewayMulticastGroupMembersOutput,
    crate::error::RegisterTransitGatewayMulticastGroupMembersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_transit_gateway_multicast_group_members_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_transit_gateway_multicast_group_members(response.body().as_ref(), output).map_err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_sources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTransitGatewayMulticastGroupSourcesOutput,
    crate::error::RegisterTransitGatewayMulticastGroupSourcesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_sources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RegisterTransitGatewayMulticastGroupSourcesOutput,
    crate::error::RegisterTransitGatewayMulticastGroupSourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_transit_gateway_multicast_group_sources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_transit_gateway_multicast_group_sources(response.body().as_ref(), output).map_err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_multicast_domain_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::RejectTransitGatewayMulticastDomainAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_multicast_domain_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayMulticastDomainAssociationsOutput,
    crate::error::RejectTransitGatewayMulticastDomainAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_peering_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayPeeringAttachmentOutput,
    crate::error::RejectTransitGatewayPeeringAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RejectTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_peering_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayPeeringAttachmentOutput,
    crate::error::RejectTransitGatewayPeeringAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::reject_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_vpc_attachment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayVpcAttachmentOutput,
    crate::error::RejectTransitGatewayVpcAttachmentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RejectTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_vpc_attachment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectTransitGatewayVpcAttachmentOutput,
    crate::error::RejectTransitGatewayVpcAttachmentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::reject_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_endpoint_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectVpcEndpointConnectionsOutput,
    crate::error::RejectVpcEndpointConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RejectVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectVpcEndpointConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_endpoint_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectVpcEndpointConnectionsOutput,
    crate::error::RejectVpcEndpointConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_vpc_endpoint_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RejectVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_peering_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectVpcPeeringConnectionOutput,
    crate::error::RejectVpcPeeringConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RejectVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectVpcPeeringConnectionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_peering_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RejectVpcPeeringConnectionOutput,
    crate::error::RejectVpcPeeringConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_vpc_peering_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RejectVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_address_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReleaseAddressOutput, crate::error::ReleaseAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReleaseAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_address_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReleaseAddressOutput, crate::error::ReleaseAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_address_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_hosts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReleaseHostsOutput, crate::error::ReleaseHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReleaseHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_hosts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReleaseHostsOutput, crate::error::ReleaseHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_release_hosts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReleaseHostsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_ipam_pool_allocation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReleaseIpamPoolAllocationOutput,
    crate::error::ReleaseIpamPoolAllocationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReleaseIpamPoolAllocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseIpamPoolAllocationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_ipam_pool_allocation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReleaseIpamPoolAllocationOutput,
    crate::error::ReleaseIpamPoolAllocationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_ipam_pool_allocation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_release_ipam_pool_allocation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReleaseIpamPoolAllocationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_iam_instance_profile_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceIamInstanceProfileAssociationOutput,
    crate::error::ReplaceIamInstanceProfileAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceIamInstanceProfileAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceIamInstanceProfileAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_iam_instance_profile_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceIamInstanceProfileAssociationOutput,
    crate::error::ReplaceIamInstanceProfileAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::replace_iam_instance_profile_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_iam_instance_profile_association(response.body().as_ref(), output).map_err(crate::error::ReplaceIamInstanceProfileAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceNetworkAclAssociationOutput,
    crate::error::ReplaceNetworkAclAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceNetworkAclAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceNetworkAclAssociationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceNetworkAclAssociationOutput,
    crate::error::ReplaceNetworkAclAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_network_acl_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_network_acl_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReplaceNetworkAclAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_entry_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceNetworkAclEntryOutput,
    crate::error::ReplaceNetworkAclEntryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_entry_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceNetworkAclEntryOutput,
    crate::error::ReplaceNetworkAclEntryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReplaceRouteOutput, crate::error::ReplaceRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReplaceRouteOutput, crate::error::ReplaceRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_route_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_table_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceRouteTableAssociationOutput,
    crate::error::ReplaceRouteTableAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceRouteTableAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceRouteTableAssociationError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_table_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceRouteTableAssociationOutput,
    crate::error::ReplaceRouteTableAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_route_table_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_route_table_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReplaceRouteTableAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_transit_gateway_route_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceTransitGatewayRouteOutput,
    crate::error::ReplaceTransitGatewayRouteError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReplaceTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceTransitGatewayRouteError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_transit_gateway_route_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReplaceTransitGatewayRouteOutput,
    crate::error::ReplaceTransitGatewayRouteError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_transit_gateway_route(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReplaceTransitGatewayRouteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_instance_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReportInstanceStatusOutput,
    crate::error::ReportInstanceStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ReportInstanceStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReportInstanceStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_instance_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ReportInstanceStatusOutput,
    crate::error::ReportInstanceStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::report_instance_status_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RequestSpotFleetOutput, crate::error::RequestSpotFleetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RequestSpotFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RequestSpotFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RequestSpotFleetOutput, crate::error::RequestSpotFleetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::request_spot_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_request_spot_fleet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RequestSpotFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RequestSpotInstancesOutput,
    crate::error::RequestSpotInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RequestSpotInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RequestSpotInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RequestSpotInstancesOutput,
    crate::error::RequestSpotInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::request_spot_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_request_spot_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RequestSpotInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_address_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetAddressAttributeOutput,
    crate::error::ResetAddressAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetAddressAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetAddressAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_address_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetAddressAttributeOutput,
    crate::error::ResetAddressAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_address_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_address_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetAddressAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_ebs_default_kms_key_id_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetEbsDefaultKmsKeyIdOutput,
    crate::error::ResetEbsDefaultKmsKeyIdError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetEbsDefaultKmsKeyIdError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_ebs_default_kms_key_id_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetEbsDefaultKmsKeyIdOutput,
    crate::error::ResetEbsDefaultKmsKeyIdError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_ebs_default_kms_key_id(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_fpga_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetFpgaImageAttributeOutput,
    crate::error::ResetFpgaImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetFpgaImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_fpga_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetFpgaImageAttributeOutput,
    crate::error::ResetFpgaImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_fpga_image_attribute(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetFpgaImageAttributeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_image_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetImageAttributeOutput,
    crate::error::ResetImageAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_image_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetImageAttributeOutput,
    crate::error::ResetImageAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_image_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_instance_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetInstanceAttributeOutput,
    crate::error::ResetInstanceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetInstanceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_instance_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetInstanceAttributeOutput,
    crate::error::ResetInstanceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_instance_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_network_interface_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetNetworkInterfaceAttributeOutput,
    crate::error::ResetNetworkInterfaceAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetNetworkInterfaceAttributeError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_network_interface_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetNetworkInterfaceAttributeOutput,
    crate::error::ResetNetworkInterfaceAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::reset_network_interface_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_snapshot_attribute_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetSnapshotAttributeOutput,
    crate::error::ResetSnapshotAttributeError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ResetSnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetSnapshotAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_snapshot_attribute_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetSnapshotAttributeOutput,
    crate::error::ResetSnapshotAttributeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_snapshot_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_address_to_classic_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreAddressToClassicOutput,
    crate::error::RestoreAddressToClassicError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RestoreAddressToClassicError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreAddressToClassicError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_address_to_classic_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreAddressToClassicOutput,
    crate::error::RestoreAddressToClassicError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_address_to_classic_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_address_to_classic(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreAddressToClassicError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_image_from_recycle_bin_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreImageFromRecycleBinOutput,
    crate::error::RestoreImageFromRecycleBinError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RestoreImageFromRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreImageFromRecycleBinError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_image_from_recycle_bin_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreImageFromRecycleBinOutput,
    crate::error::RestoreImageFromRecycleBinError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_image_from_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_image_from_recycle_bin(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreImageFromRecycleBinError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_managed_prefix_list_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreManagedPrefixListVersionOutput,
    crate::error::RestoreManagedPrefixListVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RestoreManagedPrefixListVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreManagedPrefixListVersionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_managed_prefix_list_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreManagedPrefixListVersionOutput,
    crate::error::RestoreManagedPrefixListVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_managed_prefix_list_version_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_managed_prefix_list_version(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreManagedPrefixListVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_from_recycle_bin_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreSnapshotFromRecycleBinOutput,
    crate::error::RestoreSnapshotFromRecycleBinError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RestoreSnapshotFromRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreSnapshotFromRecycleBinError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_from_recycle_bin_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreSnapshotFromRecycleBinOutput,
    crate::error::RestoreSnapshotFromRecycleBinError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_snapshot_from_recycle_bin_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_snapshot_from_recycle_bin(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreSnapshotFromRecycleBinError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_tier_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreSnapshotTierOutput,
    crate::error::RestoreSnapshotTierError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RestoreSnapshotTierError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreSnapshotTierError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_tier_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreSnapshotTierOutput,
    crate::error::RestoreSnapshotTierError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_snapshot_tier_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_snapshot_tier(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreSnapshotTierError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_client_vpn_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeClientVpnIngressOutput,
    crate::error::RevokeClientVpnIngressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RevokeClientVpnIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeClientVpnIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_client_vpn_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeClientVpnIngressOutput,
    crate::error::RevokeClientVpnIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_client_vpn_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_client_vpn_ingress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeClientVpnIngressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_egress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSecurityGroupEgressOutput,
    crate::error::RevokeSecurityGroupEgressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RevokeSecurityGroupEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeSecurityGroupEgressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_egress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSecurityGroupEgressOutput,
    crate::error::RevokeSecurityGroupEgressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_security_group_egress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_security_group_egress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeSecurityGroupEgressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSecurityGroupIngressOutput,
    crate::error::RevokeSecurityGroupIngressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RevokeSecurityGroupIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeSecurityGroupIngressError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSecurityGroupIngressOutput,
    crate::error::RevokeSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_security_group_ingress(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeSecurityGroupIngressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RunInstancesOutput, crate::error::RunInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RunInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RunInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RunInstancesOutput, crate::error::RunInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_run_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RunInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_scheduled_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RunScheduledInstancesOutput,
    crate::error::RunScheduledInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RunScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RunScheduledInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_scheduled_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RunScheduledInstancesOutput,
    crate::error::RunScheduledInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_run_scheduled_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RunScheduledInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_local_gateway_routes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchLocalGatewayRoutesOutput,
    crate::error::SearchLocalGatewayRoutesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SearchLocalGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchLocalGatewayRoutesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_local_gateway_routes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchLocalGatewayRoutesOutput,
    crate::error::SearchLocalGatewayRoutesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_local_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_local_gateway_routes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SearchLocalGatewayRoutesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_multicast_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchTransitGatewayMulticastGroupsOutput,
    crate::error::SearchTransitGatewayMulticastGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SearchTransitGatewayMulticastGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchTransitGatewayMulticastGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_multicast_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchTransitGatewayMulticastGroupsOutput,
    crate::error::SearchTransitGatewayMulticastGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::search_transit_gateway_multicast_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_transit_gateway_multicast_groups(response.body().as_ref(), output).map_err(crate::error::SearchTransitGatewayMulticastGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_routes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchTransitGatewayRoutesOutput,
    crate::error::SearchTransitGatewayRoutesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SearchTransitGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchTransitGatewayRoutesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_routes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SearchTransitGatewayRoutesOutput,
    crate::error::SearchTransitGatewayRoutesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_transit_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_transit_gateway_routes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SearchTransitGatewayRoutesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_diagnostic_interrupt_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendDiagnosticInterruptOutput,
    crate::error::SendDiagnosticInterruptError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SendDiagnosticInterruptError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SendDiagnosticInterruptError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_diagnostic_interrupt_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendDiagnosticInterruptOutput,
    crate::error::SendDiagnosticInterruptError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_diagnostic_interrupt_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartInstancesOutput, crate::error::StartInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StartInstancesOutput, crate::error::StartInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_access_scope_analysis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNetworkInsightsAccessScopeAnalysisOutput,
    crate::error::StartNetworkInsightsAccessScopeAnalysisError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_access_scope_analysis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNetworkInsightsAccessScopeAnalysisOutput,
    crate::error::StartNetworkInsightsAccessScopeAnalysisError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::start_network_insights_access_scope_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_network_insights_access_scope_analysis(response.body().as_ref(), output).map_err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_analysis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNetworkInsightsAnalysisOutput,
    crate::error::StartNetworkInsightsAnalysisError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartNetworkInsightsAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartNetworkInsightsAnalysisError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_analysis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNetworkInsightsAnalysisOutput,
    crate::error::StartNetworkInsightsAnalysisError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_network_insights_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_network_insights_analysis(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartNetworkInsightsAnalysisError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_vpc_endpoint_service_private_dns_verification_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartVpcEndpointServicePrivateDnsVerificationOutput,
    crate::error::StartVpcEndpointServicePrivateDnsVerificationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_vpc_endpoint_service_private_dns_verification_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartVpcEndpointServicePrivateDnsVerificationOutput,
    crate::error::StartVpcEndpointServicePrivateDnsVerificationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_vpc_endpoint_service_private_dns_verification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_vpc_endpoint_service_private_dns_verification(response.body().as_ref(), output).map_err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopInstancesOutput, crate::error::StopInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StopInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopInstancesOutput, crate::error::StopInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_client_vpn_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TerminateClientVpnConnectionsOutput,
    crate::error::TerminateClientVpnConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TerminateClientVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::TerminateClientVpnConnectionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_client_vpn_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TerminateClientVpnConnectionsOutput,
    crate::error::TerminateClientVpnConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_client_vpn_connections_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_terminate_client_vpn_connections(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::TerminateClientVpnConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TerminateInstancesOutput,
    crate::error::TerminateInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TerminateInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::TerminateInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TerminateInstancesOutput,
    crate::error::TerminateInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_terminate_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TerminateInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_ipv6_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnassignIpv6AddressesOutput,
    crate::error::UnassignIpv6AddressesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UnassignIpv6AddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnassignIpv6AddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_ipv6_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnassignIpv6AddressesOutput,
    crate::error::UnassignIpv6AddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_ipv6_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_unassign_ipv6_addresses(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UnassignIpv6AddressesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_private_ip_addresses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnassignPrivateIpAddressesOutput,
    crate::error::UnassignPrivateIpAddressesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UnassignPrivateIpAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnassignPrivateIpAddressesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_private_ip_addresses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnassignPrivateIpAddressesOutput,
    crate::error::UnassignPrivateIpAddressesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_private_ip_addresses_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmonitor_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnmonitorInstancesOutput,
    crate::error::UnmonitorInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UnmonitorInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnmonitorInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmonitor_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UnmonitorInstancesOutput,
    crate::error::UnmonitorInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unmonitor_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_unmonitor_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UnmonitorInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_egress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSecurityGroupRuleDescriptionsEgressOutput,
    crate::error::UpdateSecurityGroupRuleDescriptionsEgressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_egress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSecurityGroupRuleDescriptionsEgressOutput,
    crate::error::UpdateSecurityGroupRuleDescriptionsEgressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_security_group_rule_descriptions_egress_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_security_group_rule_descriptions_egress(response.body().as_ref(), output).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSecurityGroupRuleDescriptionsIngressOutput,
    crate::error::UpdateSecurityGroupRuleDescriptionsIngressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateSecurityGroupRuleDescriptionsIngressOutput,
    crate::error::UpdateSecurityGroupRuleDescriptionsIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_security_group_rule_descriptions_ingress_output::Builder::default(
            );
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_security_group_rule_descriptions_ingress(response.body().as_ref(), output).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_withdraw_byoip_cidr_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WithdrawByoipCidrOutput, crate::error::WithdrawByoipCidrError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::WithdrawByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::WithdrawByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_withdraw_byoip_cidr_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WithdrawByoipCidrOutput, crate::error::WithdrawByoipCidrError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::withdraw_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_withdraw_byoip_cidr(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::WithdrawByoipCidrError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
