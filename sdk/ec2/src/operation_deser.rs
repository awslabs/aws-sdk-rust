// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_address_transfer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptAddressTransferOutput, crate::error::AcceptAddressTransferError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_address_transfer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptAddressTransferOutput, crate::error::AcceptAddressTransferError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_address_transfer(response.body().as_ref(), output).map_err(crate::error::AcceptAddressTransferError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_instances_exchange_quote_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptReservedInstancesExchangeQuoteOutput, crate::error::AcceptReservedInstancesExchangeQuoteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptReservedInstancesExchangeQuoteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptReservedInstancesExchangeQuoteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_instances_exchange_quote_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptReservedInstancesExchangeQuoteOutput, crate::error::AcceptReservedInstancesExchangeQuoteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_reserved_instances_exchange_quote_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_reserved_instances_exchange_quote(response.body().as_ref(), output).map_err(crate::error::AcceptReservedInstancesExchangeQuoteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_multicast_domain_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayMulticastDomainAssociationsOutput, crate::error::AcceptTransitGatewayMulticastDomainAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_multicast_domain_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayMulticastDomainAssociationsOutput, crate::error::AcceptTransitGatewayMulticastDomainAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_peering_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayPeeringAttachmentOutput, crate::error::AcceptTransitGatewayPeeringAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_peering_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayPeeringAttachmentOutput, crate::error::AcceptTransitGatewayPeeringAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_vpc_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayVpcAttachmentOutput, crate::error::AcceptTransitGatewayVpcAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_transit_gateway_vpc_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptTransitGatewayVpcAttachmentOutput, crate::error::AcceptTransitGatewayVpcAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::AcceptTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_endpoint_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptVpcEndpointConnectionsOutput, crate::error::AcceptVpcEndpointConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptVpcEndpointConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_endpoint_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptVpcEndpointConnectionsOutput, crate::error::AcceptVpcEndpointConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_vpc_endpoint_connections(response.body().as_ref(), output).map_err(crate::error::AcceptVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptVpcPeeringConnectionOutput, crate::error::AcceptVpcPeeringConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AcceptVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AcceptVpcPeeringConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AcceptVpcPeeringConnectionOutput, crate::error::AcceptVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_vpc_peering_connection(response.body().as_ref(), output).map_err(crate::error::AcceptVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_advertise_byoip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AdvertiseByoipCidrOutput, crate::error::AdvertiseByoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AdvertiseByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AdvertiseByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_advertise_byoip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AdvertiseByoipCidrOutput, crate::error::AdvertiseByoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::advertise_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_advertise_byoip_cidr(response.body().as_ref(), output).map_err(crate::error::AdvertiseByoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_address_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateAddressOutput, crate::error::AllocateAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AllocateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_address_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateAddressOutput, crate::error::AllocateAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_address_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_address(response.body().as_ref(), output).map_err(crate::error::AllocateAddressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateHostsOutput, crate::error::AllocateHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AllocateHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateHostsOutput, crate::error::AllocateHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_hosts(response.body().as_ref(), output).map_err(crate::error::AllocateHostsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_ipam_pool_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateIpamPoolCidrOutput, crate::error::AllocateIpamPoolCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AllocateIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AllocateIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_ipam_pool_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AllocateIpamPoolCidrOutput, crate::error::AllocateIpamPoolCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_allocate_ipam_pool_cidr(response.body().as_ref(), output).map_err(crate::error::AllocateIpamPoolCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_security_groups_to_client_vpn_target_network_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ApplySecurityGroupsToClientVpnTargetNetworkOutput, crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_apply_security_groups_to_client_vpn_target_network_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ApplySecurityGroupsToClientVpnTargetNetworkOutput, crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::apply_security_groups_to_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_apply_security_groups_to_client_vpn_target_network(response.body().as_ref(), output).map_err(crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_ipv6_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignIpv6AddressesOutput, crate::error::AssignIpv6AddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssignIpv6AddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssignIpv6AddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_ipv6_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignIpv6AddressesOutput, crate::error::AssignIpv6AddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_ipv6_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_assign_ipv6_addresses(response.body().as_ref(), output).map_err(crate::error::AssignIpv6AddressesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_private_ip_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignPrivateIpAddressesOutput, crate::error::AssignPrivateIpAddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssignPrivateIpAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssignPrivateIpAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_private_ip_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignPrivateIpAddressesOutput, crate::error::AssignPrivateIpAddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_private_ip_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_assign_private_ip_addresses(response.body().as_ref(), output).map_err(crate::error::AssignPrivateIpAddressesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_address_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateAddressOutput, crate::error::AssociateAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_address_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateAddressOutput, crate::error::AssociateAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_address_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_address(response.body().as_ref(), output).map_err(crate::error::AssociateAddressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_client_vpn_target_network_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateClientVpnTargetNetworkOutput, crate::error::AssociateClientVpnTargetNetworkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateClientVpnTargetNetworkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_client_vpn_target_network_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateClientVpnTargetNetworkOutput, crate::error::AssociateClientVpnTargetNetworkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_client_vpn_target_network(response.body().as_ref(), output).map_err(crate::error::AssociateClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_dhcp_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateDhcpOptionsOutput, crate::error::AssociateDhcpOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_dhcp_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateDhcpOptionsOutput, crate::error::AssociateDhcpOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_dhcp_options_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_enclave_certificate_iam_role_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateEnclaveCertificateIamRoleOutput, crate::error::AssociateEnclaveCertificateIamRoleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateEnclaveCertificateIamRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateEnclaveCertificateIamRoleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_enclave_certificate_iam_role_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateEnclaveCertificateIamRoleOutput, crate::error::AssociateEnclaveCertificateIamRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_enclave_certificate_iam_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_enclave_certificate_iam_role(response.body().as_ref(), output).map_err(crate::error::AssociateEnclaveCertificateIamRoleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_iam_instance_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateIamInstanceProfileOutput, crate::error::AssociateIamInstanceProfileError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateIamInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateIamInstanceProfileError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_iam_instance_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateIamInstanceProfileOutput, crate::error::AssociateIamInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_iam_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_iam_instance_profile(response.body().as_ref(), output).map_err(crate::error::AssociateIamInstanceProfileError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_instance_event_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateInstanceEventWindowOutput, crate::error::AssociateInstanceEventWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateInstanceEventWindowError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_instance_event_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateInstanceEventWindowOutput, crate::error::AssociateInstanceEventWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_instance_event_window(response.body().as_ref(), output).map_err(crate::error::AssociateInstanceEventWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateRouteTableOutput, crate::error::AssociateRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateRouteTableOutput, crate::error::AssociateRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_route_table(response.body().as_ref(), output).map_err(crate::error::AssociateRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_subnet_cidr_block_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateSubnetCidrBlockOutput, crate::error::AssociateSubnetCidrBlockError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateSubnetCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateSubnetCidrBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_subnet_cidr_block_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateSubnetCidrBlockOutput, crate::error::AssociateSubnetCidrBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_subnet_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_subnet_cidr_block(response.body().as_ref(), output).map_err(crate::error::AssociateSubnetCidrBlockError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_multicast_domain_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayMulticastDomainOutput, crate::error::AssociateTransitGatewayMulticastDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_multicast_domain_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayMulticastDomainOutput, crate::error::AssociateTransitGatewayMulticastDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_policy_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayPolicyTableOutput, crate::error::AssociateTransitGatewayPolicyTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_policy_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayPolicyTableOutput, crate::error::AssociateTransitGatewayPolicyTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayRouteTableOutput, crate::error::AssociateTransitGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_transit_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTransitGatewayRouteTableOutput, crate::error::AssociateTransitGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::AssociateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trunk_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTrunkInterfaceOutput, crate::error::AssociateTrunkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateTrunkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateTrunkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trunk_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateTrunkInterfaceOutput, crate::error::AssociateTrunkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_trunk_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_trunk_interface(response.body().as_ref(), output).map_err(crate::error::AssociateTrunkInterfaceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_cidr_block_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateVpcCidrBlockOutput, crate::error::AssociateVpcCidrBlockError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AssociateVpcCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AssociateVpcCidrBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_vpc_cidr_block_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateVpcCidrBlockOutput, crate::error::AssociateVpcCidrBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_vpc_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_vpc_cidr_block(response.body().as_ref(), output).map_err(crate::error::AssociateVpcCidrBlockError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_classic_link_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachClassicLinkVpcOutput, crate::error::AttachClassicLinkVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachClassicLinkVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachClassicLinkVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_classic_link_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachClassicLinkVpcOutput, crate::error::AttachClassicLinkVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_classic_link_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_classic_link_vpc(response.body().as_ref(), output).map_err(crate::error::AttachClassicLinkVpcError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachInternetGatewayOutput, crate::error::AttachInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachInternetGatewayOutput, crate::error::AttachInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_network_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachNetworkInterfaceOutput, crate::error::AttachNetworkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_network_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachNetworkInterfaceOutput, crate::error::AttachNetworkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_network_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_network_interface(response.body().as_ref(), output).map_err(crate::error::AttachNetworkInterfaceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_verified_access_trust_provider_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVerifiedAccessTrustProviderOutput, crate::error::AttachVerifiedAccessTrustProviderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_verified_access_trust_provider_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVerifiedAccessTrustProviderOutput, crate::error::AttachVerifiedAccessTrustProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::AttachVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVolumeOutput, crate::error::AttachVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVolumeOutput, crate::error::AttachVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_volume(response.body().as_ref(), output).map_err(crate::error::AttachVolumeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_vpn_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVpnGatewayOutput, crate::error::AttachVpnGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AttachVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AttachVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_vpn_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachVpnGatewayOutput, crate::error::AttachVpnGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_vpn_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_attach_vpn_gateway(response.body().as_ref(), output).map_err(crate::error::AttachVpnGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_client_vpn_ingress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeClientVpnIngressOutput, crate::error::AuthorizeClientVpnIngressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AuthorizeClientVpnIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeClientVpnIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_client_vpn_ingress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeClientVpnIngressOutput, crate::error::AuthorizeClientVpnIngressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_client_vpn_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_client_vpn_ingress(response.body().as_ref(), output).map_err(crate::error::AuthorizeClientVpnIngressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_egress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeSecurityGroupEgressOutput, crate::error::AuthorizeSecurityGroupEgressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AuthorizeSecurityGroupEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeSecurityGroupEgressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_egress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeSecurityGroupEgressOutput, crate::error::AuthorizeSecurityGroupEgressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_security_group_egress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_security_group_egress(response.body().as_ref(), output).map_err(crate::error::AuthorizeSecurityGroupEgressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_ingress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeSecurityGroupIngressOutput, crate::error::AuthorizeSecurityGroupIngressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::AuthorizeSecurityGroupIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AuthorizeSecurityGroupIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_security_group_ingress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AuthorizeSecurityGroupIngressOutput, crate::error::AuthorizeSecurityGroupIngressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_security_group_ingress(response.body().as_ref(), output).map_err(crate::error::AuthorizeSecurityGroupIngressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_bundle_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BundleInstanceOutput, crate::error::BundleInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::BundleInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::BundleInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_bundle_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BundleInstanceOutput, crate::error::BundleInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::bundle_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_bundle_instance(response.body().as_ref(), output).map_err(crate::error::BundleInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_bundle_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelBundleTaskOutput, crate::error::CancelBundleTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelBundleTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelBundleTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_bundle_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelBundleTaskOutput, crate::error::CancelBundleTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_bundle_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_bundle_task(response.body().as_ref(), output).map_err(crate::error::CancelBundleTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCapacityReservationOutput, crate::error::CancelCapacityReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelCapacityReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCapacityReservationOutput, crate::error::CancelCapacityReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_capacity_reservation(response.body().as_ref(), output).map_err(crate::error::CancelCapacityReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCapacityReservationFleetsOutput, crate::error::CancelCapacityReservationFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelCapacityReservationFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelCapacityReservationFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_capacity_reservation_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelCapacityReservationFleetsOutput, crate::error::CancelCapacityReservationFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_capacity_reservation_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_capacity_reservation_fleets(response.body().as_ref(), output).map_err(crate::error::CancelCapacityReservationFleetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_conversion_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelConversionTaskOutput, crate::error::CancelConversionTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelConversionTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelConversionTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_conversion_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelConversionTaskOutput, crate::error::CancelConversionTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_conversion_task_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelExportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelExportTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_export_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelExportTaskOutput, crate::error::CancelExportTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_export_task_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_image_launch_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelImageLaunchPermissionOutput, crate::error::CancelImageLaunchPermissionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelImageLaunchPermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelImageLaunchPermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_image_launch_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelImageLaunchPermissionOutput, crate::error::CancelImageLaunchPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_image_launch_permission_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_image_launch_permission(response.body().as_ref(), output).map_err(crate::error::CancelImageLaunchPermissionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_import_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelImportTaskOutput, crate::error::CancelImportTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelImportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelImportTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_import_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelImportTaskOutput, crate::error::CancelImportTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_import_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_import_task(response.body().as_ref(), output).map_err(crate::error::CancelImportTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_reserved_instances_listing_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelReservedInstancesListingOutput, crate::error::CancelReservedInstancesListingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelReservedInstancesListingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelReservedInstancesListingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_reserved_instances_listing_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelReservedInstancesListingOutput, crate::error::CancelReservedInstancesListingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_reserved_instances_listing_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_reserved_instances_listing(response.body().as_ref(), output).map_err(crate::error::CancelReservedInstancesListingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_fleet_requests_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelSpotFleetRequestsOutput, crate::error::CancelSpotFleetRequestsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelSpotFleetRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelSpotFleetRequestsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_fleet_requests_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelSpotFleetRequestsOutput, crate::error::CancelSpotFleetRequestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_spot_fleet_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_spot_fleet_requests(response.body().as_ref(), output).map_err(crate::error::CancelSpotFleetRequestsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_instance_requests_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelSpotInstanceRequestsOutput, crate::error::CancelSpotInstanceRequestsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CancelSpotInstanceRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CancelSpotInstanceRequestsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_spot_instance_requests_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelSpotInstanceRequestsOutput, crate::error::CancelSpotInstanceRequestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_spot_instance_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_spot_instance_requests(response.body().as_ref(), output).map_err(crate::error::CancelSpotInstanceRequestsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_product_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ConfirmProductInstanceOutput, crate::error::ConfirmProductInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ConfirmProductInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ConfirmProductInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_product_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ConfirmProductInstanceOutput, crate::error::ConfirmProductInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_product_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_confirm_product_instance(response.body().as_ref(), output).map_err(crate::error::ConfirmProductInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_fpga_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopyFpgaImageOutput, crate::error::CopyFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CopyFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopyFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_fpga_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopyFpgaImageOutput, crate::error::CopyFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_fpga_image(response.body().as_ref(), output).map_err(crate::error::CopyFpgaImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopyImageOutput, crate::error::CopyImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CopyImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopyImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopyImageOutput, crate::error::CopyImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_image(response.body().as_ref(), output).map_err(crate::error::CopyImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_snapshot_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopySnapshotOutput, crate::error::CopySnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CopySnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CopySnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_snapshot_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CopySnapshotOutput, crate::error::CopySnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_snapshot(response.body().as_ref(), output).map_err(crate::error::CopySnapshotError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCapacityReservationOutput, crate::error::CreateCapacityReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCapacityReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCapacityReservationOutput, crate::error::CreateCapacityReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_capacity_reservation(response.body().as_ref(), output).map_err(crate::error::CreateCapacityReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCapacityReservationFleetOutput, crate::error::CreateCapacityReservationFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCapacityReservationFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCapacityReservationFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_capacity_reservation_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCapacityReservationFleetOutput, crate::error::CreateCapacityReservationFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_capacity_reservation_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_capacity_reservation_fleet(response.body().as_ref(), output).map_err(crate::error::CreateCapacityReservationFleetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_carrier_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCarrierGatewayOutput, crate::error::CreateCarrierGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCarrierGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCarrierGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_carrier_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCarrierGatewayOutput, crate::error::CreateCarrierGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_carrier_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_carrier_gateway(response.body().as_ref(), output).map_err(crate::error::CreateCarrierGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateClientVpnEndpointOutput, crate::error::CreateClientVpnEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateClientVpnEndpointOutput, crate::error::CreateClientVpnEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_client_vpn_endpoint(response.body().as_ref(), output).map_err(crate::error::CreateClientVpnEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateClientVpnRouteOutput, crate::error::CreateClientVpnRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateClientVpnRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateClientVpnRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_client_vpn_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateClientVpnRouteOutput, crate::error::CreateClientVpnRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_client_vpn_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_client_vpn_route(response.body().as_ref(), output).map_err(crate::error::CreateClientVpnRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCoipCidrOutput, crate::error::CreateCoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCoipCidrOutput, crate::error::CreateCoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_coip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_coip_cidr(response.body().as_ref(), output).map_err(crate::error::CreateCoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCoipPoolOutput, crate::error::CreateCoipPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCoipPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCoipPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_coip_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCoipPoolOutput, crate::error::CreateCoipPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_coip_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_coip_pool(response.body().as_ref(), output).map_err(crate::error::CreateCoipPoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_customer_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCustomerGatewayOutput, crate::error::CreateCustomerGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateCustomerGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCustomerGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_customer_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCustomerGatewayOutput, crate::error::CreateCustomerGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_customer_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_customer_gateway(response.body().as_ref(), output).map_err(crate::error::CreateCustomerGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_subnet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDefaultSubnetOutput, crate::error::CreateDefaultSubnetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateDefaultSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDefaultSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_subnet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDefaultSubnetOutput, crate::error::CreateDefaultSubnetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_default_subnet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_default_subnet(response.body().as_ref(), output).map_err(crate::error::CreateDefaultSubnetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDefaultVpcOutput, crate::error::CreateDefaultVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateDefaultVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDefaultVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_default_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDefaultVpcOutput, crate::error::CreateDefaultVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_default_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_default_vpc(response.body().as_ref(), output).map_err(crate::error::CreateDefaultVpcError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dhcp_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDhcpOptionsOutput, crate::error::CreateDhcpOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dhcp_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDhcpOptionsOutput, crate::error::CreateDhcpOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_dhcp_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_dhcp_options(response.body().as_ref(), output).map_err(crate::error::CreateDhcpOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_egress_only_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateEgressOnlyInternetGatewayOutput, crate::error::CreateEgressOnlyInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateEgressOnlyInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateEgressOnlyInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_egress_only_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateEgressOnlyInternetGatewayOutput, crate::error::CreateEgressOnlyInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_egress_only_internet_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_egress_only_internet_gateway(response.body().as_ref(), output).map_err(crate::error::CreateEgressOnlyInternetGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFleetOutput, crate::error::CreateFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_fleet(response.body().as_ref(), output).map_err(crate::error::CreateFleetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_logs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFlowLogsOutput, crate::error::CreateFlowLogsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_logs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFlowLogsOutput, crate::error::CreateFlowLogsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_flow_logs(response.body().as_ref(), output).map_err(crate::error::CreateFlowLogsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fpga_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFpgaImageOutput, crate::error::CreateFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_fpga_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateFpgaImageOutput, crate::error::CreateFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_fpga_image(response.body().as_ref(), output).map_err(crate::error::CreateFpgaImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_image(response.body().as_ref(), output).map_err(crate::error::CreateImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_event_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceEventWindowOutput, crate::error::CreateInstanceEventWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInstanceEventWindowError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_event_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceEventWindowOutput, crate::error::CreateInstanceEventWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_instance_event_window(response.body().as_ref(), output).map_err(crate::error::CreateInstanceEventWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_export_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceExportTaskOutput, crate::error::CreateInstanceExportTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateInstanceExportTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInstanceExportTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_export_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceExportTaskOutput, crate::error::CreateInstanceExportTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_export_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_instance_export_task(response.body().as_ref(), output).map_err(crate::error::CreateInstanceExportTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInternetGatewayOutput, crate::error::CreateInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInternetGatewayOutput, crate::error::CreateInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_internet_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_internet_gateway(response.body().as_ref(), output).map_err(crate::error::CreateInternetGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamOutput, crate::error::CreateIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamOutput, crate::error::CreateIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam(response.body().as_ref(), output).map_err(crate::error::CreateIpamError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamPoolOutput, crate::error::CreateIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamPoolOutput, crate::error::CreateIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam_pool(response.body().as_ref(), output).map_err(crate::error::CreateIpamPoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_scope_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamScopeOutput, crate::error::CreateIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_ipam_scope_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateIpamScopeOutput, crate::error::CreateIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_ipam_scope(response.body().as_ref(), output).map_err(crate::error::CreateIpamScopeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_pair_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateKeyPairOutput, crate::error::CreateKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_key_pair_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateKeyPairOutput, crate::error::CreateKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_key_pair_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_key_pair(response.body().as_ref(), output).map_err(crate::error::CreateKeyPairError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLaunchTemplateOutput, crate::error::CreateLaunchTemplateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLaunchTemplateOutput, crate::error::CreateLaunchTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_launch_template(response.body().as_ref(), output).map_err(crate::error::CreateLaunchTemplateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_version_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLaunchTemplateVersionOutput, crate::error::CreateLaunchTemplateVersionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLaunchTemplateVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLaunchTemplateVersionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_launch_template_version_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLaunchTemplateVersionOutput, crate::error::CreateLaunchTemplateVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_launch_template_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_launch_template_version(response.body().as_ref(), output).map_err(crate::error::CreateLaunchTemplateVersionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteOutput, crate::error::CreateLocalGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteOutput, crate::error::CreateLocalGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableOutput, crate::error::CreateLocalGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLocalGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableOutput, crate::error::CreateLocalGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_virtual_interface_group_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_virtual_interface_group_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_virtual_interface_group_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table_virtual_interface_group_association(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_vpc_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableVpcAssociationOutput, crate::error::CreateLocalGatewayRouteTableVpcAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_local_gateway_route_table_vpc_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLocalGatewayRouteTableVpcAssociationOutput, crate::error::CreateLocalGatewayRouteTableVpcAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_local_gateway_route_table_vpc_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_local_gateway_route_table_vpc_association(response.body().as_ref(), output).map_err(crate::error::CreateLocalGatewayRouteTableVpcAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_managed_prefix_list_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateManagedPrefixListOutput, crate::error::CreateManagedPrefixListError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_managed_prefix_list_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateManagedPrefixListOutput, crate::error::CreateManagedPrefixListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_managed_prefix_list(response.body().as_ref(), output).map_err(crate::error::CreateManagedPrefixListError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_nat_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNatGatewayOutput, crate::error::CreateNatGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNatGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNatGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_nat_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNatGatewayOutput, crate::error::CreateNatGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_nat_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_nat_gateway(response.body().as_ref(), output).map_err(crate::error::CreateNatGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkAclOutput, crate::error::CreateNetworkAclError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkAclError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkAclOutput, crate::error::CreateNetworkAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_acl_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_acl(response.body().as_ref(), output).map_err(crate::error::CreateNetworkAclError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_entry_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkAclEntryOutput, crate::error::CreateNetworkAclEntryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_acl_entry_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkAclEntryOutput, crate::error::CreateNetworkAclEntryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_access_scope_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInsightsAccessScopeOutput, crate::error::CreateNetworkInsightsAccessScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkInsightsAccessScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInsightsAccessScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_access_scope_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInsightsAccessScopeOutput, crate::error::CreateNetworkInsightsAccessScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_insights_access_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_insights_access_scope(response.body().as_ref(), output).map_err(crate::error::CreateNetworkInsightsAccessScopeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_path_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInsightsPathOutput, crate::error::CreateNetworkInsightsPathError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkInsightsPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInsightsPathError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_insights_path_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInsightsPathOutput, crate::error::CreateNetworkInsightsPathError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_insights_path_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_insights_path(response.body().as_ref(), output).map_err(crate::error::CreateNetworkInsightsPathError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInterfaceOutput, crate::error::CreateNetworkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInterfaceOutput, crate::error::CreateNetworkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_interface(response.body().as_ref(), output).map_err(crate::error::CreateNetworkInterfaceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInterfacePermissionOutput, crate::error::CreateNetworkInterfacePermissionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateNetworkInterfacePermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateNetworkInterfacePermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_interface_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateNetworkInterfacePermissionOutput, crate::error::CreateNetworkInterfacePermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_interface_permission_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_network_interface_permission(response.body().as_ref(), output).map_err(crate::error::CreateNetworkInterfacePermissionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_placement_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlacementGroupOutput, crate::error::CreatePlacementGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreatePlacementGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreatePlacementGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_placement_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePlacementGroupOutput, crate::error::CreatePlacementGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_placement_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_placement_group(response.body().as_ref(), output).map_err(crate::error::CreatePlacementGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_ipv4_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePublicIpv4PoolOutput, crate::error::CreatePublicIpv4PoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreatePublicIpv4PoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreatePublicIpv4PoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_ipv4_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePublicIpv4PoolOutput, crate::error::CreatePublicIpv4PoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_public_ipv4_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_public_ipv4_pool(response.body().as_ref(), output).map_err(crate::error::CreatePublicIpv4PoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_replace_root_volume_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReplaceRootVolumeTaskOutput, crate::error::CreateReplaceRootVolumeTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateReplaceRootVolumeTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateReplaceRootVolumeTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_replace_root_volume_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReplaceRootVolumeTaskOutput, crate::error::CreateReplaceRootVolumeTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_replace_root_volume_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_replace_root_volume_task(response.body().as_ref(), output).map_err(crate::error::CreateReplaceRootVolumeTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reserved_instances_listing_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReservedInstancesListingOutput, crate::error::CreateReservedInstancesListingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateReservedInstancesListingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateReservedInstancesListingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_reserved_instances_listing_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateReservedInstancesListingOutput, crate::error::CreateReservedInstancesListingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_reserved_instances_listing_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_reserved_instances_listing(response.body().as_ref(), output).map_err(crate::error::CreateReservedInstancesListingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_restore_image_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRestoreImageTaskOutput, crate::error::CreateRestoreImageTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateRestoreImageTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRestoreImageTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_restore_image_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRestoreImageTaskOutput, crate::error::CreateRestoreImageTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_restore_image_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_restore_image_task(response.body().as_ref(), output).map_err(crate::error::CreateRestoreImageTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRouteOutput, crate::error::CreateRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRouteOutput, crate::error::CreateRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_route(response.body().as_ref(), output).map_err(crate::error::CreateRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRouteTableOutput, crate::error::CreateRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRouteTableOutput, crate::error::CreateRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_route_table(response.body().as_ref(), output).map_err(crate::error::CreateRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSecurityGroupOutput, crate::error::CreateSecurityGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSecurityGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSecurityGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSecurityGroupOutput, crate::error::CreateSecurityGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_security_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_security_group(response.body().as_ref(), output).map_err(crate::error::CreateSecurityGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSnapshotOutput, crate::error::CreateSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSnapshotOutput, crate::error::CreateSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshot(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshots_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSnapshotsOutput, crate::error::CreateSnapshotsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSnapshotsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSnapshotsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshots_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSnapshotsOutput, crate::error::CreateSnapshotsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshots(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_spot_datafeed_subscription_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSpotDatafeedSubscriptionOutput, crate::error::CreateSpotDatafeedSubscriptionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSpotDatafeedSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_spot_datafeed_subscription_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSpotDatafeedSubscriptionOutput, crate::error::CreateSpotDatafeedSubscriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_spot_datafeed_subscription(response.body().as_ref(), output).map_err(crate::error::CreateSpotDatafeedSubscriptionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_store_image_task_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStoreImageTaskOutput, crate::error::CreateStoreImageTaskError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateStoreImageTaskError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateStoreImageTaskError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_store_image_task_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStoreImageTaskOutput, crate::error::CreateStoreImageTaskError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_store_image_task_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_store_image_task(response.body().as_ref(), output).map_err(crate::error::CreateStoreImageTaskError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSubnetOutput, crate::error::CreateSubnetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSubnetOutput, crate::error::CreateSubnetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_subnet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_subnet(response.body().as_ref(), output).map_err(crate::error::CreateSubnetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_cidr_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSubnetCidrReservationOutput, crate::error::CreateSubnetCidrReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateSubnetCidrReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateSubnetCidrReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_subnet_cidr_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSubnetCidrReservationOutput, crate::error::CreateSubnetCidrReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_subnet_cidr_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_subnet_cidr_reservation(response.body().as_ref(), output).map_err(crate::error::CreateSubnetCidrReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_tags_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorFilterOutput, crate::error::CreateTrafficMirrorFilterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTrafficMirrorFilterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorFilterError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorFilterOutput, crate::error::CreateTrafficMirrorFilterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_filter_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_filter(response.body().as_ref(), output).map_err(crate::error::CreateTrafficMirrorFilterError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorFilterRuleOutput, crate::error::CreateTrafficMirrorFilterRuleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorFilterRuleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_filter_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorFilterRuleOutput, crate::error::CreateTrafficMirrorFilterRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_filter_rule(response.body().as_ref(), output).map_err(crate::error::CreateTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorSessionOutput, crate::error::CreateTrafficMirrorSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorSessionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorSessionOutput, crate::error::CreateTrafficMirrorSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_session(response.body().as_ref(), output).map_err(crate::error::CreateTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_target_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorTargetOutput, crate::error::CreateTrafficMirrorTargetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTrafficMirrorTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTrafficMirrorTargetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_traffic_mirror_target_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTrafficMirrorTargetOutput, crate::error::CreateTrafficMirrorTargetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_traffic_mirror_target_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_traffic_mirror_target(response.body().as_ref(), output).map_err(crate::error::CreateTrafficMirrorTargetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayOutput, crate::error::CreateTransitGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayOutput, crate::error::CreateTransitGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayConnectOutput, crate::error::CreateTransitGatewayConnectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayConnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayConnectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayConnectOutput, crate::error::CreateTransitGatewayConnectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_connect_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_connect(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayConnectError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_peer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayConnectPeerOutput, crate::error::CreateTransitGatewayConnectPeerError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayConnectPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayConnectPeerError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_connect_peer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayConnectPeerOutput, crate::error::CreateTransitGatewayConnectPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_connect_peer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_connect_peer(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayConnectPeerError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_multicast_domain_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayMulticastDomainOutput, crate::error::CreateTransitGatewayMulticastDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_multicast_domain_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayMulticastDomainOutput, crate::error::CreateTransitGatewayMulticastDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_peering_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPeeringAttachmentOutput, crate::error::CreateTransitGatewayPeeringAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_peering_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPeeringAttachmentOutput, crate::error::CreateTransitGatewayPeeringAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_policy_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPolicyTableOutput, crate::error::CreateTransitGatewayPolicyTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_policy_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPolicyTableOutput, crate::error::CreateTransitGatewayPolicyTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_prefix_list_reference_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPrefixListReferenceOutput, crate::error::CreateTransitGatewayPrefixListReferenceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_prefix_list_reference_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayPrefixListReferenceOutput, crate::error::CreateTransitGatewayPrefixListReferenceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteOutput, crate::error::CreateTransitGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteOutput, crate::error::CreateTransitGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteTableOutput, crate::error::CreateTransitGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteTableOutput, crate::error::CreateTransitGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_announcement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteTableAnnouncementOutput, crate::error::CreateTransitGatewayRouteTableAnnouncementError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_route_table_announcement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayRouteTableAnnouncementOutput, crate::error::CreateTransitGatewayRouteTableAnnouncementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_route_table_announcement_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_route_table_announcement(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayRouteTableAnnouncementError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_vpc_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayVpcAttachmentOutput, crate::error::CreateTransitGatewayVpcAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_gateway_vpc_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateTransitGatewayVpcAttachmentOutput, crate::error::CreateTransitGatewayVpcAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::CreateTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessEndpointOutput, crate::error::CreateVerifiedAccessEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessEndpointOutput, crate::error::CreateVerifiedAccessEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_endpoint(response.body().as_ref(), output).map_err(crate::error::CreateVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessGroupOutput, crate::error::CreateVerifiedAccessGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessGroupOutput, crate::error::CreateVerifiedAccessGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_group(response.body().as_ref(), output).map_err(crate::error::CreateVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessInstanceOutput, crate::error::CreateVerifiedAccessInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessInstanceOutput, crate::error::CreateVerifiedAccessInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_instance(response.body().as_ref(), output).map_err(crate::error::CreateVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_trust_provider_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessTrustProviderOutput, crate::error::CreateVerifiedAccessTrustProviderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_verified_access_trust_provider_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVerifiedAccessTrustProviderOutput, crate::error::CreateVerifiedAccessTrustProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::CreateVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVolumeOutput, crate::error::CreateVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVolumeOutput, crate::error::CreateVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_volume(response.body().as_ref(), output).map_err(crate::error::CreateVolumeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcOutput, crate::error::CreateVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcOutput, crate::error::CreateVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc(response.body().as_ref(), output).map_err(crate::error::CreateVpcError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointOutput, crate::error::CreateVpcEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpcEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointOutput, crate::error::CreateVpcEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint(response.body().as_ref(), output).map_err(crate::error::CreateVpcEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_connection_notification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointConnectionNotificationOutput, crate::error::CreateVpcEndpointConnectionNotificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpcEndpointConnectionNotificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointConnectionNotificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_connection_notification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointConnectionNotificationOutput, crate::error::CreateVpcEndpointConnectionNotificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_endpoint_connection_notification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint_connection_notification(response.body().as_ref(), output).map_err(crate::error::CreateVpcEndpointConnectionNotificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_service_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointServiceConfigurationOutput, crate::error::CreateVpcEndpointServiceConfigurationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpcEndpointServiceConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcEndpointServiceConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_endpoint_service_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcEndpointServiceConfigurationOutput, crate::error::CreateVpcEndpointServiceConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_endpoint_service_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_endpoint_service_configuration(response.body().as_ref(), output).map_err(crate::error::CreateVpcEndpointServiceConfigurationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringConnectionOutput, crate::error::CreateVpcPeeringConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpcPeeringConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpcPeeringConnectionOutput, crate::error::CreateVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpc_peering_connection(response.body().as_ref(), output).map_err(crate::error::CreateVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnConnectionOutput, crate::error::CreateVpnConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnConnectionOutput, crate::error::CreateVpnConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpn_connection(response.body().as_ref(), output).map_err(crate::error::CreateVpnConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnConnectionRouteOutput, crate::error::CreateVpnConnectionRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpnConnectionRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnConnectionRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_connection_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnConnectionRouteOutput, crate::error::CreateVpnConnectionRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_connection_route_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnGatewayOutput, crate::error::CreateVpnGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::CreateVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpn_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateVpnGatewayOutput, crate::error::CreateVpnGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpn_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_vpn_gateway(response.body().as_ref(), output).map_err(crate::error::CreateVpnGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_carrier_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCarrierGatewayOutput, crate::error::DeleteCarrierGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteCarrierGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCarrierGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_carrier_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCarrierGatewayOutput, crate::error::DeleteCarrierGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_carrier_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_carrier_gateway(response.body().as_ref(), output).map_err(crate::error::DeleteCarrierGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteClientVpnEndpointOutput, crate::error::DeleteClientVpnEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteClientVpnEndpointOutput, crate::error::DeleteClientVpnEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_client_vpn_endpoint(response.body().as_ref(), output).map_err(crate::error::DeleteClientVpnEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteClientVpnRouteOutput, crate::error::DeleteClientVpnRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteClientVpnRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteClientVpnRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_vpn_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteClientVpnRouteOutput, crate::error::DeleteClientVpnRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_client_vpn_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_client_vpn_route(response.body().as_ref(), output).map_err(crate::error::DeleteClientVpnRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCoipCidrOutput, crate::error::DeleteCoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteCoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCoipCidrOutput, crate::error::DeleteCoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_coip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_coip_cidr(response.body().as_ref(), output).map_err(crate::error::DeleteCoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCoipPoolOutput, crate::error::DeleteCoipPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteCoipPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCoipPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_coip_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCoipPoolOutput, crate::error::DeleteCoipPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_coip_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_coip_pool(response.body().as_ref(), output).map_err(crate::error::DeleteCoipPoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_customer_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCustomerGatewayOutput, crate::error::DeleteCustomerGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteCustomerGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCustomerGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_customer_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCustomerGatewayOutput, crate::error::DeleteCustomerGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_customer_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dhcp_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteDhcpOptionsOutput, crate::error::DeleteDhcpOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dhcp_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteDhcpOptionsOutput, crate::error::DeleteDhcpOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_dhcp_options_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_egress_only_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteEgressOnlyInternetGatewayOutput, crate::error::DeleteEgressOnlyInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteEgressOnlyInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteEgressOnlyInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_egress_only_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteEgressOnlyInternetGatewayOutput, crate::error::DeleteEgressOnlyInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_egress_only_internet_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_egress_only_internet_gateway(response.body().as_ref(), output).map_err(crate::error::DeleteEgressOnlyInternetGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetsOutput, crate::error::DeleteFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFleetsOutput, crate::error::DeleteFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_fleets(response.body().as_ref(), output).map_err(crate::error::DeleteFleetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_logs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFlowLogsOutput, crate::error::DeleteFlowLogsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_logs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFlowLogsOutput, crate::error::DeleteFlowLogsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_flow_logs(response.body().as_ref(), output).map_err(crate::error::DeleteFlowLogsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fpga_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFpgaImageOutput, crate::error::DeleteFpgaImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteFpgaImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteFpgaImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_fpga_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFpgaImageOutput, crate::error::DeleteFpgaImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_fpga_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_fpga_image(response.body().as_ref(), output).map_err(crate::error::DeleteFpgaImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_event_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInstanceEventWindowOutput, crate::error::DeleteInstanceEventWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteInstanceEventWindowError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_event_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInstanceEventWindowOutput, crate::error::DeleteInstanceEventWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_instance_event_window(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceEventWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInternetGatewayOutput, crate::error::DeleteInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInternetGatewayOutput, crate::error::DeleteInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamOutput, crate::error::DeleteIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamOutput, crate::error::DeleteIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam(response.body().as_ref(), output).map_err(crate::error::DeleteIpamError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamPoolOutput, crate::error::DeleteIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamPoolOutput, crate::error::DeleteIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam_pool(response.body().as_ref(), output).map_err(crate::error::DeleteIpamPoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_scope_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamScopeOutput, crate::error::DeleteIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_ipam_scope_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteIpamScopeOutput, crate::error::DeleteIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_ipam_scope(response.body().as_ref(), output).map_err(crate::error::DeleteIpamScopeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_pair_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteKeyPairOutput, crate::error::DeleteKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_key_pair_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteKeyPairOutput, crate::error::DeleteKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_key_pair_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLaunchTemplateOutput, crate::error::DeleteLaunchTemplateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLaunchTemplateOutput, crate::error::DeleteLaunchTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_launch_template(response.body().as_ref(), output).map_err(crate::error::DeleteLaunchTemplateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_versions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLaunchTemplateVersionsOutput, crate::error::DeleteLaunchTemplateVersionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLaunchTemplateVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLaunchTemplateVersionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_launch_template_versions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLaunchTemplateVersionsOutput, crate::error::DeleteLaunchTemplateVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_launch_template_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_launch_template_versions(response.body().as_ref(), output).map_err(crate::error::DeleteLaunchTemplateVersionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteOutput, crate::error::DeleteLocalGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteOutput, crate::error::DeleteLocalGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableOutput, crate::error::DeleteLocalGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLocalGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableOutput, crate::error::DeleteLocalGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_virtual_interface_group_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_virtual_interface_group_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationOutput, crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_virtual_interface_group_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table_virtual_interface_group_association(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_vpc_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableVpcAssociationOutput, crate::error::DeleteLocalGatewayRouteTableVpcAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_local_gateway_route_table_vpc_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLocalGatewayRouteTableVpcAssociationOutput, crate::error::DeleteLocalGatewayRouteTableVpcAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_local_gateway_route_table_vpc_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_local_gateway_route_table_vpc_association(response.body().as_ref(), output).map_err(crate::error::DeleteLocalGatewayRouteTableVpcAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_managed_prefix_list_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteManagedPrefixListOutput, crate::error::DeleteManagedPrefixListError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_managed_prefix_list_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteManagedPrefixListOutput, crate::error::DeleteManagedPrefixListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_managed_prefix_list(response.body().as_ref(), output).map_err(crate::error::DeleteManagedPrefixListError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_nat_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNatGatewayOutput, crate::error::DeleteNatGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNatGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNatGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_nat_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNatGatewayOutput, crate::error::DeleteNatGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_nat_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_nat_gateway(response.body().as_ref(), output).map_err(crate::error::DeleteNatGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkAclOutput, crate::error::DeleteNetworkAclError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkAclError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkAclError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkAclOutput, crate::error::DeleteNetworkAclError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_acl_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_entry_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkAclEntryOutput, crate::error::DeleteNetworkAclEntryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_acl_entry_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkAclEntryOutput, crate::error::DeleteNetworkAclEntryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAccessScopeOutput, crate::error::DeleteNetworkInsightsAccessScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInsightsAccessScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAccessScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAccessScopeOutput, crate::error::DeleteNetworkInsightsAccessScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_access_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_access_scope(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInsightsAccessScopeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_analysis_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAccessScopeAnalysisOutput, crate::error::DeleteNetworkInsightsAccessScopeAnalysisError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_access_scope_analysis_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAccessScopeAnalysisOutput, crate::error::DeleteNetworkInsightsAccessScopeAnalysisError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_access_scope_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_access_scope_analysis(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInsightsAccessScopeAnalysisError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_analysis_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAnalysisOutput, crate::error::DeleteNetworkInsightsAnalysisError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInsightsAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_analysis_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsAnalysisOutput, crate::error::DeleteNetworkInsightsAnalysisError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_analysis(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInsightsAnalysisError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_path_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsPathOutput, crate::error::DeleteNetworkInsightsPathError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInsightsPathError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInsightsPathError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_insights_path_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInsightsPathOutput, crate::error::DeleteNetworkInsightsPathError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_insights_path_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_insights_path(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInsightsPathError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInterfaceOutput, crate::error::DeleteNetworkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInterfaceOutput, crate::error::DeleteNetworkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_interface_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInterfacePermissionOutput, crate::error::DeleteNetworkInterfacePermissionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteNetworkInterfacePermissionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNetworkInterfacePermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_interface_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteNetworkInterfacePermissionOutput, crate::error::DeleteNetworkInterfacePermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_interface_permission_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_network_interface_permission(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkInterfacePermissionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_placement_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePlacementGroupOutput, crate::error::DeletePlacementGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeletePlacementGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeletePlacementGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_placement_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePlacementGroupOutput, crate::error::DeletePlacementGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_placement_group_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_ipv4_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePublicIpv4PoolOutput, crate::error::DeletePublicIpv4PoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeletePublicIpv4PoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeletePublicIpv4PoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_public_ipv4_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePublicIpv4PoolOutput, crate::error::DeletePublicIpv4PoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_public_ipv4_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_public_ipv4_pool(response.body().as_ref(), output).map_err(crate::error::DeletePublicIpv4PoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queued_reserved_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteQueuedReservedInstancesOutput, crate::error::DeleteQueuedReservedInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteQueuedReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteQueuedReservedInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queued_reserved_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteQueuedReservedInstancesOutput, crate::error::DeleteQueuedReservedInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_queued_reserved_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_queued_reserved_instances(response.body().as_ref(), output).map_err(crate::error::DeleteQueuedReservedInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRouteOutput, crate::error::DeleteRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRouteOutput, crate::error::DeleteRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_route_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRouteTableOutput, crate::error::DeleteRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRouteTableOutput, crate::error::DeleteRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_route_table_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSecurityGroupOutput, crate::error::DeleteSecurityGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteSecurityGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSecurityGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSecurityGroupOutput, crate::error::DeleteSecurityGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_security_group_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSnapshotOutput, crate::error::DeleteSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSnapshotOutput, crate::error::DeleteSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_snapshot_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_spot_datafeed_subscription_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSpotDatafeedSubscriptionOutput, crate::error::DeleteSpotDatafeedSubscriptionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSpotDatafeedSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_spot_datafeed_subscription_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSpotDatafeedSubscriptionOutput, crate::error::DeleteSpotDatafeedSubscriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSubnetOutput, crate::error::DeleteSubnetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteSubnetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSubnetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSubnetOutput, crate::error::DeleteSubnetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_subnet_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_cidr_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSubnetCidrReservationOutput, crate::error::DeleteSubnetCidrReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteSubnetCidrReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteSubnetCidrReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_subnet_cidr_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSubnetCidrReservationOutput, crate::error::DeleteSubnetCidrReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_subnet_cidr_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_subnet_cidr_reservation(response.body().as_ref(), output).map_err(crate::error::DeleteSubnetCidrReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_tags_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorFilterOutput, crate::error::DeleteTrafficMirrorFilterError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTrafficMirrorFilterError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorFilterError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorFilterOutput, crate::error::DeleteTrafficMirrorFilterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_filter_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_filter(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficMirrorFilterError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorFilterRuleOutput, crate::error::DeleteTrafficMirrorFilterRuleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorFilterRuleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_filter_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorFilterRuleOutput, crate::error::DeleteTrafficMirrorFilterRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_filter_rule(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorSessionOutput, crate::error::DeleteTrafficMirrorSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorSessionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorSessionOutput, crate::error::DeleteTrafficMirrorSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_session(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_target_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorTargetOutput, crate::error::DeleteTrafficMirrorTargetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTrafficMirrorTargetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTrafficMirrorTargetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_traffic_mirror_target_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTrafficMirrorTargetOutput, crate::error::DeleteTrafficMirrorTargetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_traffic_mirror_target_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_traffic_mirror_target(response.body().as_ref(), output).map_err(crate::error::DeleteTrafficMirrorTargetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayOutput, crate::error::DeleteTransitGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayOutput, crate::error::DeleteTransitGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayConnectOutput, crate::error::DeleteTransitGatewayConnectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayConnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayConnectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayConnectOutput, crate::error::DeleteTransitGatewayConnectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_connect_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_connect(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayConnectError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_peer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayConnectPeerOutput, crate::error::DeleteTransitGatewayConnectPeerError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayConnectPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayConnectPeerError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_connect_peer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayConnectPeerOutput, crate::error::DeleteTransitGatewayConnectPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_connect_peer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_connect_peer(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayConnectPeerError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_multicast_domain_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayMulticastDomainOutput, crate::error::DeleteTransitGatewayMulticastDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_multicast_domain_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayMulticastDomainOutput, crate::error::DeleteTransitGatewayMulticastDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_peering_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPeeringAttachmentOutput, crate::error::DeleteTransitGatewayPeeringAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_peering_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPeeringAttachmentOutput, crate::error::DeleteTransitGatewayPeeringAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_policy_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPolicyTableOutput, crate::error::DeleteTransitGatewayPolicyTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_policy_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPolicyTableOutput, crate::error::DeleteTransitGatewayPolicyTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_prefix_list_reference_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPrefixListReferenceOutput, crate::error::DeleteTransitGatewayPrefixListReferenceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_prefix_list_reference_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayPrefixListReferenceOutput, crate::error::DeleteTransitGatewayPrefixListReferenceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteOutput, crate::error::DeleteTransitGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteOutput, crate::error::DeleteTransitGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteTableOutput, crate::error::DeleteTransitGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteTableOutput, crate::error::DeleteTransitGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_announcement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteTableAnnouncementOutput, crate::error::DeleteTransitGatewayRouteTableAnnouncementError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_route_table_announcement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayRouteTableAnnouncementOutput, crate::error::DeleteTransitGatewayRouteTableAnnouncementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_route_table_announcement_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_route_table_announcement(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayRouteTableAnnouncementError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_vpc_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayVpcAttachmentOutput, crate::error::DeleteTransitGatewayVpcAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_transit_gateway_vpc_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteTransitGatewayVpcAttachmentOutput, crate::error::DeleteTransitGatewayVpcAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::DeleteTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessEndpointOutput, crate::error::DeleteVerifiedAccessEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessEndpointOutput, crate::error::DeleteVerifiedAccessEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_endpoint(response.body().as_ref(), output).map_err(crate::error::DeleteVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessGroupOutput, crate::error::DeleteVerifiedAccessGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessGroupOutput, crate::error::DeleteVerifiedAccessGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_group(response.body().as_ref(), output).map_err(crate::error::DeleteVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessInstanceOutput, crate::error::DeleteVerifiedAccessInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessInstanceOutput, crate::error::DeleteVerifiedAccessInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_instance(response.body().as_ref(), output).map_err(crate::error::DeleteVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_trust_provider_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessTrustProviderOutput, crate::error::DeleteVerifiedAccessTrustProviderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_verified_access_trust_provider_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVerifiedAccessTrustProviderOutput, crate::error::DeleteVerifiedAccessTrustProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::DeleteVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_volume_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcOutput, crate::error::DeleteVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcOutput, crate::error::DeleteVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_connection_notifications_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointConnectionNotificationsOutput, crate::error::DeleteVpcEndpointConnectionNotificationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpcEndpointConnectionNotificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointConnectionNotificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_connection_notifications_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointConnectionNotificationsOutput, crate::error::DeleteVpcEndpointConnectionNotificationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_endpoint_connection_notifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoint_connection_notifications(response.body().as_ref(), output).map_err(crate::error::DeleteVpcEndpointConnectionNotificationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoints_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointsOutput, crate::error::DeleteVpcEndpointsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpcEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoints_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointsOutput, crate::error::DeleteVpcEndpointsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoints(response.body().as_ref(), output).map_err(crate::error::DeleteVpcEndpointsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_service_configurations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointServiceConfigurationsOutput, crate::error::DeleteVpcEndpointServiceConfigurationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpcEndpointServiceConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcEndpointServiceConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_endpoint_service_configurations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcEndpointServiceConfigurationsOutput, crate::error::DeleteVpcEndpointServiceConfigurationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_endpoint_service_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_endpoint_service_configurations(response.body().as_ref(), output).map_err(crate::error::DeleteVpcEndpointServiceConfigurationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringConnectionOutput, crate::error::DeleteVpcPeeringConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpcPeeringConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpcPeeringConnectionOutput, crate::error::DeleteVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_vpc_peering_connection(response.body().as_ref(), output).map_err(crate::error::DeleteVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnConnectionOutput, crate::error::DeleteVpnConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnConnectionOutput, crate::error::DeleteVpnConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_connection_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnConnectionRouteOutput, crate::error::DeleteVpnConnectionRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpnConnectionRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnConnectionRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_connection_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnConnectionRouteOutput, crate::error::DeleteVpnConnectionRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_connection_route_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnGatewayOutput, crate::error::DeleteVpnGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeleteVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpn_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteVpnGatewayOutput, crate::error::DeleteVpnGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpn_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_byoip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionByoipCidrOutput, crate::error::DeprovisionByoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeprovisionByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_byoip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionByoipCidrOutput, crate::error::DeprovisionByoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deprovision_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deprovision_byoip_cidr(response.body().as_ref(), output).map_err(crate::error::DeprovisionByoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_ipam_pool_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionIpamPoolCidrOutput, crate::error::DeprovisionIpamPoolCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeprovisionIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_ipam_pool_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionIpamPoolCidrOutput, crate::error::DeprovisionIpamPoolCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deprovision_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deprovision_ipam_pool_cidr(response.body().as_ref(), output).map_err(crate::error::DeprovisionIpamPoolCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_public_ipv4_pool_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionPublicIpv4PoolCidrOutput, crate::error::DeprovisionPublicIpv4PoolCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeprovisionPublicIpv4PoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeprovisionPublicIpv4PoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deprovision_public_ipv4_pool_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeprovisionPublicIpv4PoolCidrOutput, crate::error::DeprovisionPublicIpv4PoolCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deprovision_public_ipv4_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deprovision_public_ipv4_pool_cidr(response.body().as_ref(), output).map_err(crate::error::DeprovisionPublicIpv4PoolCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterImageOutput, crate::error::DeregisterImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterImageOutput, crate::error::DeregisterImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_image_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_event_notification_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterInstanceEventNotificationAttributesOutput, crate::error::DeregisterInstanceEventNotificationAttributesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_event_notification_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterInstanceEventNotificationAttributesOutput, crate::error::DeregisterInstanceEventNotificationAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_instance_event_notification_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::DeregisterInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_members_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTransitGatewayMulticastGroupMembersOutput, crate::error::DeregisterTransitGatewayMulticastGroupMembersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_members_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTransitGatewayMulticastGroupMembersOutput, crate::error::DeregisterTransitGatewayMulticastGroupMembersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_transit_gateway_multicast_group_members_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_transit_gateway_multicast_group_members(response.body().as_ref(), output).map_err(crate::error::DeregisterTransitGatewayMulticastGroupMembersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_sources_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTransitGatewayMulticastGroupSourcesOutput, crate::error::DeregisterTransitGatewayMulticastGroupSourcesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_transit_gateway_multicast_group_sources_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterTransitGatewayMulticastGroupSourcesOutput, crate::error::DeregisterTransitGatewayMulticastGroupSourcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_transit_gateway_multicast_group_sources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deregister_transit_gateway_multicast_group_sources(response.body().as_ref(), output).map_err(crate::error::DeregisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAccountAttributesOutput, crate::error::DescribeAccountAttributesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAccountAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAccountAttributesOutput, crate::error::DescribeAccountAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_account_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressesOutput, crate::error::DescribeAddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressesOutput, crate::error::DescribeAddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_addresses(response.body().as_ref(), output).map_err(crate::error::DescribeAddressesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressesAttributeOutput, crate::error::DescribeAddressesAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAddressesAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressesAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_addresses_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressesAttributeOutput, crate::error::DescribeAddressesAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_addresses_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_addresses_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeAddressesAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_address_transfers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressTransfersOutput, crate::error::DescribeAddressTransfersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAddressTransfersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAddressTransfersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_address_transfers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAddressTransfersOutput, crate::error::DescribeAddressTransfersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_address_transfers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_address_transfers(response.body().as_ref(), output).map_err(crate::error::DescribeAddressTransfersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAggregateIdFormatOutput, crate::error::DescribeAggregateIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAggregateIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAggregateIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aggregate_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAggregateIdFormatOutput, crate::error::DescribeAggregateIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_aggregate_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_aggregate_id_format(response.body().as_ref(), output).map_err(crate::error::DescribeAggregateIdFormatError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_availability_zones_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAvailabilityZonesOutput, crate::error::DescribeAvailabilityZonesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAvailabilityZonesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAvailabilityZonesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_availability_zones_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAvailabilityZonesOutput, crate::error::DescribeAvailabilityZonesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_availability_zones_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_availability_zones(response.body().as_ref(), output).map_err(crate::error::DescribeAvailabilityZonesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aws_network_performance_metric_subscriptions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput, crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_aws_network_performance_metric_subscriptions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAwsNetworkPerformanceMetricSubscriptionsOutput, crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_aws_network_performance_metric_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_aws_network_performance_metric_subscriptions(response.body().as_ref(), output).map_err(crate::error::DescribeAwsNetworkPerformanceMetricSubscriptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_bundle_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeBundleTasksOutput, crate::error::DescribeBundleTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeBundleTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeBundleTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_bundle_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeBundleTasksOutput, crate::error::DescribeBundleTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_bundle_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_bundle_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeBundleTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_byoip_cidrs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeByoipCidrsOutput, crate::error::DescribeByoipCidrsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeByoipCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeByoipCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_byoip_cidrs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeByoipCidrsOutput, crate::error::DescribeByoipCidrsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_byoip_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_byoip_cidrs(response.body().as_ref(), output).map_err(crate::error::DescribeByoipCidrsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservation_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCapacityReservationFleetsOutput, crate::error::DescribeCapacityReservationFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeCapacityReservationFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCapacityReservationFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservation_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCapacityReservationFleetsOutput, crate::error::DescribeCapacityReservationFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_capacity_reservation_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_capacity_reservation_fleets(response.body().as_ref(), output).map_err(crate::error::DescribeCapacityReservationFleetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCapacityReservationsOutput, crate::error::DescribeCapacityReservationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeCapacityReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCapacityReservationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_capacity_reservations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCapacityReservationsOutput, crate::error::DescribeCapacityReservationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_capacity_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_capacity_reservations(response.body().as_ref(), output).map_err(crate::error::DescribeCapacityReservationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_carrier_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCarrierGatewaysOutput, crate::error::DescribeCarrierGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeCarrierGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCarrierGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_carrier_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCarrierGatewaysOutput, crate::error::DescribeCarrierGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_carrier_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_carrier_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeCarrierGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_classic_link_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClassicLinkInstancesOutput, crate::error::DescribeClassicLinkInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClassicLinkInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClassicLinkInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_classic_link_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClassicLinkInstancesOutput, crate::error::DescribeClassicLinkInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_classic_link_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_classic_link_instances(response.body().as_ref(), output).map_err(crate::error::DescribeClassicLinkInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_authorization_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnAuthorizationRulesOutput, crate::error::DescribeClientVpnAuthorizationRulesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClientVpnAuthorizationRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnAuthorizationRulesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_authorization_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnAuthorizationRulesOutput, crate::error::DescribeClientVpnAuthorizationRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_authorization_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_authorization_rules(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnAuthorizationRulesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnConnectionsOutput, crate::error::DescribeClientVpnConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClientVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnConnectionsOutput, crate::error::DescribeClientVpnConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_connections(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_endpoints_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnEndpointsOutput, crate::error::DescribeClientVpnEndpointsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClientVpnEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_endpoints_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnEndpointsOutput, crate::error::DescribeClientVpnEndpointsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_endpoints(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnEndpointsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_routes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnRoutesOutput, crate::error::DescribeClientVpnRoutesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClientVpnRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnRoutesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_routes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnRoutesOutput, crate::error::DescribeClientVpnRoutesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_routes(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnRoutesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_target_networks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnTargetNetworksOutput, crate::error::DescribeClientVpnTargetNetworksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeClientVpnTargetNetworksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeClientVpnTargetNetworksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_client_vpn_target_networks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClientVpnTargetNetworksOutput, crate::error::DescribeClientVpnTargetNetworksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_client_vpn_target_networks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_client_vpn_target_networks(response.body().as_ref(), output).map_err(crate::error::DescribeClientVpnTargetNetworksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_coip_pools_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCoipPoolsOutput, crate::error::DescribeCoipPoolsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeCoipPoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCoipPoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_coip_pools_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCoipPoolsOutput, crate::error::DescribeCoipPoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_coip_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_coip_pools(response.body().as_ref(), output).map_err(crate::error::DescribeCoipPoolsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conversion_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeConversionTasksOutput, crate::error::DescribeConversionTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeConversionTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeConversionTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_conversion_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeConversionTasksOutput, crate::error::DescribeConversionTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_conversion_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_conversion_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeConversionTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCustomerGatewaysOutput, crate::error::DescribeCustomerGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeCustomerGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCustomerGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCustomerGatewaysOutput, crate::error::DescribeCustomerGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_customer_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_customer_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeCustomerGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_dhcp_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDhcpOptionsOutput, crate::error::DescribeDhcpOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeDhcpOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeDhcpOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_dhcp_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDhcpOptionsOutput, crate::error::DescribeDhcpOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_dhcp_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_dhcp_options(response.body().as_ref(), output).map_err(crate::error::DescribeDhcpOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_egress_only_internet_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEgressOnlyInternetGatewaysOutput, crate::error::DescribeEgressOnlyInternetGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeEgressOnlyInternetGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeEgressOnlyInternetGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_egress_only_internet_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEgressOnlyInternetGatewaysOutput, crate::error::DescribeEgressOnlyInternetGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_egress_only_internet_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_egress_only_internet_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeEgressOnlyInternetGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_gpus_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticGpusOutput, crate::error::DescribeElasticGpusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeElasticGpusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeElasticGpusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_gpus_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticGpusOutput, crate::error::DescribeElasticGpusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_elastic_gpus_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_elastic_gpus(response.body().as_ref(), output).map_err(crate::error::DescribeElasticGpusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_image_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeExportImageTasksOutput, crate::error::DescribeExportImageTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeExportImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeExportImageTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_image_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeExportImageTasksOutput, crate::error::DescribeExportImageTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_export_image_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeExportImageTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeExportTasksOutput, crate::error::DescribeExportTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeExportTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeExportTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_export_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeExportTasksOutput, crate::error::DescribeExportTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_export_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_export_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeExportTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_launch_images_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFastLaunchImagesOutput, crate::error::DescribeFastLaunchImagesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFastLaunchImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFastLaunchImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_launch_images_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFastLaunchImagesOutput, crate::error::DescribeFastLaunchImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fast_launch_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fast_launch_images(response.body().as_ref(), output).map_err(crate::error::DescribeFastLaunchImagesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_snapshot_restores_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFastSnapshotRestoresOutput, crate::error::DescribeFastSnapshotRestoresError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFastSnapshotRestoresError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fast_snapshot_restores_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFastSnapshotRestoresOutput, crate::error::DescribeFastSnapshotRestoresError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fast_snapshot_restores(response.body().as_ref(), output).map_err(crate::error::DescribeFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetHistoryOutput, crate::error::DescribeFleetHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFleetHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetHistoryOutput, crate::error::DescribeFleetHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleet_history(response.body().as_ref(), output).map_err(crate::error::DescribeFleetHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetInstancesOutput, crate::error::DescribeFleetInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFleetInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleet_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetInstancesOutput, crate::error::DescribeFleetInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleet_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleet_instances(response.body().as_ref(), output).map_err(crate::error::DescribeFleetInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetsOutput, crate::error::DescribeFleetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFleetsOutput, crate::error::DescribeFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fleets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fleets(response.body().as_ref(), output).map_err(crate::error::DescribeFleetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_logs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFlowLogsOutput, crate::error::DescribeFlowLogsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFlowLogsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFlowLogsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_logs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFlowLogsOutput, crate::error::DescribeFlowLogsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_flow_logs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_flow_logs(response.body().as_ref(), output).map_err(crate::error::DescribeFlowLogsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFpgaImageAttributeOutput, crate::error::DescribeFpgaImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFpgaImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFpgaImageAttributeOutput, crate::error::DescribeFpgaImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fpga_image_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeFpgaImageAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_images_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFpgaImagesOutput, crate::error::DescribeFpgaImagesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeFpgaImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeFpgaImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_fpga_images_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeFpgaImagesOutput, crate::error::DescribeFpgaImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_fpga_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_fpga_images(response.body().as_ref(), output).map_err(crate::error::DescribeFpgaImagesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservation_offerings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostReservationOfferingsOutput, crate::error::DescribeHostReservationOfferingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeHostReservationOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostReservationOfferingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservation_offerings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostReservationOfferingsOutput, crate::error::DescribeHostReservationOfferingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_host_reservation_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_host_reservation_offerings(response.body().as_ref(), output).map_err(crate::error::DescribeHostReservationOfferingsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostReservationsOutput, crate::error::DescribeHostReservationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeHostReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostReservationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_host_reservations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostReservationsOutput, crate::error::DescribeHostReservationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_host_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_host_reservations(response.body().as_ref(), output).map_err(crate::error::DescribeHostReservationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostsOutput, crate::error::DescribeHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeHostsOutput, crate::error::DescribeHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_hosts(response.body().as_ref(), output).map_err(crate::error::DescribeHostsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_iam_instance_profile_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIamInstanceProfileAssociationsOutput, crate::error::DescribeIamInstanceProfileAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIamInstanceProfileAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIamInstanceProfileAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_iam_instance_profile_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIamInstanceProfileAssociationsOutput, crate::error::DescribeIamInstanceProfileAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_iam_instance_profile_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_iam_instance_profile_associations(response.body().as_ref(), output).map_err(crate::error::DescribeIamInstanceProfileAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_identity_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIdentityIdFormatOutput, crate::error::DescribeIdentityIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIdentityIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIdentityIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_identity_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIdentityIdFormatOutput, crate::error::DescribeIdentityIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_identity_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_identity_id_format(response.body().as_ref(), output).map_err(crate::error::DescribeIdentityIdFormatError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIdFormatOutput, crate::error::DescribeIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIdFormatOutput, crate::error::DescribeIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_id_format(response.body().as_ref(), output).map_err(crate::error::DescribeIdFormatError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImageAttributeOutput, crate::error::DescribeImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImageAttributeOutput, crate::error::DescribeImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_image_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeImageAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_images_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_images_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_images_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_images(response.body().as_ref(), output).map_err(crate::error::DescribeImagesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_image_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImportImageTasksOutput, crate::error::DescribeImportImageTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeImportImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImportImageTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_image_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImportImageTasksOutput, crate::error::DescribeImportImageTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_import_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_import_image_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeImportImageTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_snapshot_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImportSnapshotTasksOutput, crate::error::DescribeImportSnapshotTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeImportSnapshotTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeImportSnapshotTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_import_snapshot_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeImportSnapshotTasksOutput, crate::error::DescribeImportSnapshotTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_import_snapshot_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_import_snapshot_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeImportSnapshotTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceAttributeOutput, crate::error::DescribeInstanceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceAttributeOutput, crate::error::DescribeInstanceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_credit_specifications_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceCreditSpecificationsOutput, crate::error::DescribeInstanceCreditSpecificationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceCreditSpecificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceCreditSpecificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_credit_specifications_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceCreditSpecificationsOutput, crate::error::DescribeInstanceCreditSpecificationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_credit_specifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_credit_specifications(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceCreditSpecificationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_notification_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceEventNotificationAttributesOutput, crate::error::DescribeInstanceEventNotificationAttributesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_notification_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceEventNotificationAttributesOutput, crate::error::DescribeInstanceEventNotificationAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_event_notification_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_windows_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceEventWindowsOutput, crate::error::DescribeInstanceEventWindowsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceEventWindowsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceEventWindowsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_event_windows_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceEventWindowsOutput, crate::error::DescribeInstanceEventWindowsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_event_windows_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_event_windows(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceEventWindowsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instances(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceStatusOutput, crate::error::DescribeInstanceStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceStatusOutput, crate::error::DescribeInstanceStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_status(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_type_offerings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceTypeOfferingsOutput, crate::error::DescribeInstanceTypeOfferingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceTypeOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceTypeOfferingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_type_offerings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceTypeOfferingsOutput, crate::error::DescribeInstanceTypeOfferingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_type_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_type_offerings(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceTypeOfferingsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_types_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceTypesOutput, crate::error::DescribeInstanceTypesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInstanceTypesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInstanceTypesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instance_types_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstanceTypesOutput, crate::error::DescribeInstanceTypesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instance_types_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_instance_types(response.body().as_ref(), output).map_err(crate::error::DescribeInstanceTypesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_internet_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInternetGatewaysOutput, crate::error::DescribeInternetGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeInternetGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeInternetGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_internet_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInternetGatewaysOutput, crate::error::DescribeInternetGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_internet_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_internet_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeInternetGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_pools_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamPoolsOutput, crate::error::DescribeIpamPoolsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIpamPoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamPoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_pools_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamPoolsOutput, crate::error::DescribeIpamPoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipam_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipam_pools(response.body().as_ref(), output).map_err(crate::error::DescribeIpamPoolsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipams_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamsOutput, crate::error::DescribeIpamsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIpamsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipams_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamsOutput, crate::error::DescribeIpamsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipams_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipams(response.body().as_ref(), output).map_err(crate::error::DescribeIpamsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_scopes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamScopesOutput, crate::error::DescribeIpamScopesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIpamScopesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpamScopesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipam_scopes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpamScopesOutput, crate::error::DescribeIpamScopesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipam_scopes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipam_scopes(response.body().as_ref(), output).map_err(crate::error::DescribeIpamScopesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipv6_pools_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpv6PoolsOutput, crate::error::DescribeIpv6PoolsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeIpv6PoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeIpv6PoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ipv6_pools_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeIpv6PoolsOutput, crate::error::DescribeIpv6PoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ipv6_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_ipv6_pools(response.body().as_ref(), output).map_err(crate::error::DescribeIpv6PoolsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_key_pairs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeKeyPairsOutput, crate::error::DescribeKeyPairsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeKeyPairsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeKeyPairsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_key_pairs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeKeyPairsOutput, crate::error::DescribeKeyPairsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_key_pairs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_key_pairs(response.body().as_ref(), output).map_err(crate::error::DescribeKeyPairsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_templates_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLaunchTemplatesOutput, crate::error::DescribeLaunchTemplatesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLaunchTemplatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLaunchTemplatesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_templates_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLaunchTemplatesOutput, crate::error::DescribeLaunchTemplatesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_launch_templates_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_launch_templates(response.body().as_ref(), output).map_err(crate::error::DescribeLaunchTemplatesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_template_versions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLaunchTemplateVersionsOutput, crate::error::DescribeLaunchTemplateVersionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLaunchTemplateVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLaunchTemplateVersionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_launch_template_versions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLaunchTemplateVersionsOutput, crate::error::DescribeLaunchTemplateVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_launch_template_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_launch_template_versions(response.body().as_ref(), output).map_err(crate::error::DescribeLaunchTemplateVersionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_tables_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTablesOutput, crate::error::DescribeLocalGatewayRouteTablesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayRouteTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_tables_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTablesOutput, crate::error::DescribeLocalGatewayRouteTablesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_route_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_tables(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayRouteTablesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_virtual_interface_group_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_virtual_interface_group_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_route_table_virtual_interface_group_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_table_virtual_interface_group_associations(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_vpc_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTableVpcAssociationsOutput, crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_route_table_vpc_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayRouteTableVpcAssociationsOutput, crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_route_table_vpc_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_route_table_vpc_associations(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewaysOutput, crate::error::DescribeLocalGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewaysOutput, crate::error::DescribeLocalGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interface_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayVirtualInterfaceGroupsOutput, crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interface_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayVirtualInterfaceGroupsOutput, crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_virtual_interface_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_virtual_interface_groups(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interfaces_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayVirtualInterfacesOutput, crate::error::DescribeLocalGatewayVirtualInterfacesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeLocalGatewayVirtualInterfacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeLocalGatewayVirtualInterfacesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_local_gateway_virtual_interfaces_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLocalGatewayVirtualInterfacesOutput, crate::error::DescribeLocalGatewayVirtualInterfacesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_local_gateway_virtual_interfaces_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_local_gateway_virtual_interfaces(response.body().as_ref(), output).map_err(crate::error::DescribeLocalGatewayVirtualInterfacesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_managed_prefix_lists_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeManagedPrefixListsOutput, crate::error::DescribeManagedPrefixListsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeManagedPrefixListsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeManagedPrefixListsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_managed_prefix_lists_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeManagedPrefixListsOutput, crate::error::DescribeManagedPrefixListsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_managed_prefix_lists_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_managed_prefix_lists(response.body().as_ref(), output).map_err(crate::error::DescribeManagedPrefixListsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_moving_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMovingAddressesOutput, crate::error::DescribeMovingAddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeMovingAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeMovingAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_moving_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMovingAddressesOutput, crate::error::DescribeMovingAddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_moving_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_moving_addresses(response.body().as_ref(), output).map_err(crate::error::DescribeMovingAddressesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_nat_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNatGatewaysOutput, crate::error::DescribeNatGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNatGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNatGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_nat_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNatGatewaysOutput, crate::error::DescribeNatGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_nat_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_nat_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeNatGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_acls_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkAclsOutput, crate::error::DescribeNetworkAclsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkAclsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkAclsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_acls_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkAclsOutput, crate::error::DescribeNetworkAclsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_acls_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_acls(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkAclsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scope_analyses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAccessScopeAnalysesOutput, crate::error::DescribeNetworkInsightsAccessScopeAnalysesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scope_analyses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAccessScopeAnalysesOutput, crate::error::DescribeNetworkInsightsAccessScopeAnalysesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_insights_access_scope_analyses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_access_scope_analyses(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsAccessScopeAnalysesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scopes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAccessScopesOutput, crate::error::DescribeNetworkInsightsAccessScopesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInsightsAccessScopesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAccessScopesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_access_scopes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAccessScopesOutput, crate::error::DescribeNetworkInsightsAccessScopesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_insights_access_scopes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_access_scopes(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsAccessScopesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_analyses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAnalysesOutput, crate::error::DescribeNetworkInsightsAnalysesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInsightsAnalysesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsAnalysesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_analyses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsAnalysesOutput, crate::error::DescribeNetworkInsightsAnalysesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_insights_analyses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_analyses(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsAnalysesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_paths_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsPathsOutput, crate::error::DescribeNetworkInsightsPathsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInsightsPathsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInsightsPathsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_insights_paths_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInsightsPathsOutput, crate::error::DescribeNetworkInsightsPathsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_insights_paths_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_insights_paths(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInsightsPathsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfaceAttributeOutput, crate::error::DescribeNetworkInterfaceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfaceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfaceAttributeOutput, crate::error::DescribeNetworkInterfaceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_interface_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_interface_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInterfaceAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_permissions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfacePermissionsOutput, crate::error::DescribeNetworkInterfacePermissionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInterfacePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfacePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interface_permissions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfacePermissionsOutput, crate::error::DescribeNetworkInterfacePermissionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_interface_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_interface_permissions(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInterfacePermissionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interfaces_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfacesOutput, crate::error::DescribeNetworkInterfacesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeNetworkInterfacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNetworkInterfacesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_network_interfaces_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNetworkInterfacesOutput, crate::error::DescribeNetworkInterfacesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_network_interfaces_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_network_interfaces(response.body().as_ref(), output).map_err(crate::error::DescribeNetworkInterfacesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_placement_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePlacementGroupsOutput, crate::error::DescribePlacementGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePlacementGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePlacementGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_placement_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePlacementGroupsOutput, crate::error::DescribePlacementGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_placement_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_placement_groups(response.body().as_ref(), output).map_err(crate::error::DescribePlacementGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_prefix_lists_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePrefixListsOutput, crate::error::DescribePrefixListsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePrefixListsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePrefixListsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_prefix_lists_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePrefixListsOutput, crate::error::DescribePrefixListsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_prefix_lists_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_prefix_lists(response.body().as_ref(), output).map_err(crate::error::DescribePrefixListsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_principal_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePrincipalIdFormatOutput, crate::error::DescribePrincipalIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePrincipalIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePrincipalIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_principal_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePrincipalIdFormatOutput, crate::error::DescribePrincipalIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_principal_id_format_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_principal_id_format(response.body().as_ref(), output).map_err(crate::error::DescribePrincipalIdFormatError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_public_ipv4_pools_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePublicIpv4PoolsOutput, crate::error::DescribePublicIpv4PoolsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribePublicIpv4PoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribePublicIpv4PoolsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_public_ipv4_pools_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePublicIpv4PoolsOutput, crate::error::DescribePublicIpv4PoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_public_ipv4_pools_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_public_ipv4_pools(response.body().as_ref(), output).map_err(crate::error::DescribePublicIpv4PoolsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_regions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRegionsOutput, crate::error::DescribeRegionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeRegionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeRegionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_regions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRegionsOutput, crate::error::DescribeRegionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_regions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_regions(response.body().as_ref(), output).map_err(crate::error::DescribeRegionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_replace_root_volume_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReplaceRootVolumeTasksOutput, crate::error::DescribeReplaceRootVolumeTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeReplaceRootVolumeTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReplaceRootVolumeTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_replace_root_volume_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReplaceRootVolumeTasksOutput, crate::error::DescribeReplaceRootVolumeTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_replace_root_volume_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_replace_root_volume_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeReplaceRootVolumeTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesOutput, crate::error::DescribeReservedInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesOutput, crate::error::DescribeReservedInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_listings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesListingsOutput, crate::error::DescribeReservedInstancesListingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeReservedInstancesListingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesListingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_listings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesListingsOutput, crate::error::DescribeReservedInstancesListingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_instances_listings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_listings(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesListingsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_modifications_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesModificationsOutput, crate::error::DescribeReservedInstancesModificationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeReservedInstancesModificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesModificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_modifications_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesModificationsOutput, crate::error::DescribeReservedInstancesModificationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_instances_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_modifications(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesModificationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_offerings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesOfferingsOutput, crate::error::DescribeReservedInstancesOfferingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeReservedInstancesOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeReservedInstancesOfferingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_instances_offerings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReservedInstancesOfferingsOutput, crate::error::DescribeReservedInstancesOfferingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_instances_offerings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_instances_offerings(response.body().as_ref(), output).map_err(crate::error::DescribeReservedInstancesOfferingsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_route_tables_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRouteTablesOutput, crate::error::DescribeRouteTablesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeRouteTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_route_tables_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRouteTablesOutput, crate::error::DescribeRouteTablesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_route_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_route_tables(response.body().as_ref(), output).map_err(crate::error::DescribeRouteTablesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instance_availability_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScheduledInstanceAvailabilityOutput, crate::error::DescribeScheduledInstanceAvailabilityError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeScheduledInstanceAvailabilityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeScheduledInstanceAvailabilityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instance_availability_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScheduledInstanceAvailabilityOutput, crate::error::DescribeScheduledInstanceAvailabilityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_scheduled_instance_availability_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_scheduled_instance_availability(response.body().as_ref(), output).map_err(crate::error::DescribeScheduledInstanceAvailabilityError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScheduledInstancesOutput, crate::error::DescribeScheduledInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeScheduledInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeScheduledInstancesOutput, crate::error::DescribeScheduledInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_scheduled_instances(response.body().as_ref(), output).map_err(crate::error::DescribeScheduledInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_references_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupReferencesOutput, crate::error::DescribeSecurityGroupReferencesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSecurityGroupReferencesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupReferencesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_references_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupReferencesOutput, crate::error::DescribeSecurityGroupReferencesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_group_references_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_security_group_references(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityGroupReferencesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupRulesOutput, crate::error::DescribeSecurityGroupRulesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSecurityGroupRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupRulesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_group_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupRulesOutput, crate::error::DescribeSecurityGroupRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_group_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_security_group_rules(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityGroupRulesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupsOutput, crate::error::DescribeSecurityGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSecurityGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSecurityGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityGroupsOutput, crate::error::DescribeSecurityGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_security_groups(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotAttributeOutput, crate::error::DescribeSnapshotAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotAttributeOutput, crate::error::DescribeSnapshotAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeSnapshotAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshots_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotsOutput, crate::error::DescribeSnapshotsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSnapshotsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshots_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotsOutput, crate::error::DescribeSnapshotsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshots(response.body().as_ref(), output).map_err(crate::error::DescribeSnapshotsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_tier_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotTierStatusOutput, crate::error::DescribeSnapshotTierStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSnapshotTierStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSnapshotTierStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_tier_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSnapshotTierStatusOutput, crate::error::DescribeSnapshotTierStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_tier_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_tier_status(response.body().as_ref(), output).map_err(crate::error::DescribeSnapshotTierStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_datafeed_subscription_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotDatafeedSubscriptionOutput, crate::error::DescribeSpotDatafeedSubscriptionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotDatafeedSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotDatafeedSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_datafeed_subscription_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotDatafeedSubscriptionOutput, crate::error::DescribeSpotDatafeedSubscriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_datafeed_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_datafeed_subscription(response.body().as_ref(), output).map_err(crate::error::DescribeSpotDatafeedSubscriptionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetInstancesOutput, crate::error::DescribeSpotFleetInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotFleetInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetInstancesOutput, crate::error::DescribeSpotFleetInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_fleet_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_instances(response.body().as_ref(), output).map_err(crate::error::DescribeSpotFleetInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_request_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetRequestHistoryOutput, crate::error::DescribeSpotFleetRequestHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotFleetRequestHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetRequestHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_request_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetRequestHistoryOutput, crate::error::DescribeSpotFleetRequestHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_fleet_request_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_request_history(response.body().as_ref(), output).map_err(crate::error::DescribeSpotFleetRequestHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_requests_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetRequestsOutput, crate::error::DescribeSpotFleetRequestsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotFleetRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotFleetRequestsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_fleet_requests_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotFleetRequestsOutput, crate::error::DescribeSpotFleetRequestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_fleet_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_fleet_requests(response.body().as_ref(), output).map_err(crate::error::DescribeSpotFleetRequestsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_instance_requests_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotInstanceRequestsOutput, crate::error::DescribeSpotInstanceRequestsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotInstanceRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotInstanceRequestsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_instance_requests_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotInstanceRequestsOutput, crate::error::DescribeSpotInstanceRequestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_instance_requests_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_instance_requests(response.body().as_ref(), output).map_err(crate::error::DescribeSpotInstanceRequestsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_price_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotPriceHistoryOutput, crate::error::DescribeSpotPriceHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSpotPriceHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSpotPriceHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_spot_price_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSpotPriceHistoryOutput, crate::error::DescribeSpotPriceHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_spot_price_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_spot_price_history(response.body().as_ref(), output).map_err(crate::error::DescribeSpotPriceHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stale_security_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStaleSecurityGroupsOutput, crate::error::DescribeStaleSecurityGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeStaleSecurityGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStaleSecurityGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stale_security_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStaleSecurityGroupsOutput, crate::error::DescribeStaleSecurityGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stale_security_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stale_security_groups(response.body().as_ref(), output).map_err(crate::error::DescribeStaleSecurityGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_store_image_tasks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStoreImageTasksOutput, crate::error::DescribeStoreImageTasksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeStoreImageTasksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStoreImageTasksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_store_image_tasks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStoreImageTasksOutput, crate::error::DescribeStoreImageTasksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_store_image_tasks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_store_image_tasks(response.body().as_ref(), output).map_err(crate::error::DescribeStoreImageTasksError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subnets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSubnetsOutput, crate::error::DescribeSubnetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeSubnetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSubnetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subnets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSubnetsOutput, crate::error::DescribeSubnetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_subnets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_subnets(response.body().as_ref(), output).map_err(crate::error::DescribeSubnetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_tags(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_filters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorFiltersOutput, crate::error::DescribeTrafficMirrorFiltersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTrafficMirrorFiltersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorFiltersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_filters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorFiltersOutput, crate::error::DescribeTrafficMirrorFiltersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_filters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_filters(response.body().as_ref(), output).map_err(crate::error::DescribeTrafficMirrorFiltersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_sessions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorSessionsOutput, crate::error::DescribeTrafficMirrorSessionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTrafficMirrorSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorSessionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_sessions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorSessionsOutput, crate::error::DescribeTrafficMirrorSessionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_sessions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_sessions(response.body().as_ref(), output).map_err(crate::error::DescribeTrafficMirrorSessionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_targets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorTargetsOutput, crate::error::DescribeTrafficMirrorTargetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTrafficMirrorTargetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrafficMirrorTargetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_traffic_mirror_targets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrafficMirrorTargetsOutput, crate::error::DescribeTrafficMirrorTargetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_traffic_mirror_targets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_traffic_mirror_targets(response.body().as_ref(), output).map_err(crate::error::DescribeTrafficMirrorTargetsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_attachments_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayAttachmentsOutput, crate::error::DescribeTransitGatewayAttachmentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_attachments_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayAttachmentsOutput, crate::error::DescribeTransitGatewayAttachmentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_attachments_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayAttachmentsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connect_peers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayConnectPeersOutput, crate::error::DescribeTransitGatewayConnectPeersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayConnectPeersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayConnectPeersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connect_peers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayConnectPeersOutput, crate::error::DescribeTransitGatewayConnectPeersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_connect_peers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_connect_peers(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayConnectPeersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connects_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayConnectsOutput, crate::error::DescribeTransitGatewayConnectsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayConnectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayConnectsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_connects_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayConnectsOutput, crate::error::DescribeTransitGatewayConnectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_connects_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_connects(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayConnectsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_multicast_domains_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayMulticastDomainsOutput, crate::error::DescribeTransitGatewayMulticastDomainsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayMulticastDomainsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayMulticastDomainsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_multicast_domains_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayMulticastDomainsOutput, crate::error::DescribeTransitGatewayMulticastDomainsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_multicast_domains_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_multicast_domains(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayMulticastDomainsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_peering_attachments_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayPeeringAttachmentsOutput, crate::error::DescribeTransitGatewayPeeringAttachmentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_peering_attachments_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayPeeringAttachmentsOutput, crate::error::DescribeTransitGatewayPeeringAttachmentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_peering_attachments_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_peering_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayPeeringAttachmentsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_policy_tables_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayPolicyTablesOutput, crate::error::DescribeTransitGatewayPolicyTablesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayPolicyTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayPolicyTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_policy_tables_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayPolicyTablesOutput, crate::error::DescribeTransitGatewayPolicyTablesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_policy_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_policy_tables(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayPolicyTablesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_table_announcements_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayRouteTableAnnouncementsOutput, crate::error::DescribeTransitGatewayRouteTableAnnouncementsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_table_announcements_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayRouteTableAnnouncementsOutput, crate::error::DescribeTransitGatewayRouteTableAnnouncementsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_route_table_announcements_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_route_table_announcements(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayRouteTableAnnouncementsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_tables_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayRouteTablesOutput, crate::error::DescribeTransitGatewayRouteTablesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayRouteTablesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayRouteTablesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_route_tables_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayRouteTablesOutput, crate::error::DescribeTransitGatewayRouteTablesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_route_tables_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_route_tables(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayRouteTablesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewaysOutput, crate::error::DescribeTransitGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewaysOutput, crate::error::DescribeTransitGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_vpc_attachments_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayVpcAttachmentsOutput, crate::error::DescribeTransitGatewayVpcAttachmentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTransitGatewayVpcAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTransitGatewayVpcAttachmentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transit_gateway_vpc_attachments_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTransitGatewayVpcAttachmentsOutput, crate::error::DescribeTransitGatewayVpcAttachmentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transit_gateway_vpc_attachments_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_transit_gateway_vpc_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeTransitGatewayVpcAttachmentsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trunk_interface_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrunkInterfaceAssociationsOutput, crate::error::DescribeTrunkInterfaceAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeTrunkInterfaceAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeTrunkInterfaceAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trunk_interface_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTrunkInterfaceAssociationsOutput, crate::error::DescribeTrunkInterfaceAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_trunk_interface_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_trunk_interface_associations(response.body().as_ref(), output).map_err(crate::error::DescribeTrunkInterfaceAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_endpoints_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessEndpointsOutput, crate::error::DescribeVerifiedAccessEndpointsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVerifiedAccessEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_endpoints_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessEndpointsOutput, crate::error::DescribeVerifiedAccessEndpointsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_endpoints(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessEndpointsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessGroupsOutput, crate::error::DescribeVerifiedAccessGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVerifiedAccessGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessGroupsOutput, crate::error::DescribeVerifiedAccessGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_groups(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instance_logging_configurations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput, crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instance_logging_configurations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessInstanceLoggingConfigurationsOutput, crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_instance_logging_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_instance_logging_configurations(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessInstanceLoggingConfigurationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessInstancesOutput, crate::error::DescribeVerifiedAccessInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVerifiedAccessInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessInstancesOutput, crate::error::DescribeVerifiedAccessInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_instances(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_trust_providers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessTrustProvidersOutput, crate::error::DescribeVerifiedAccessTrustProvidersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVerifiedAccessTrustProvidersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVerifiedAccessTrustProvidersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_verified_access_trust_providers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVerifiedAccessTrustProvidersOutput, crate::error::DescribeVerifiedAccessTrustProvidersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_verified_access_trust_providers_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_verified_access_trust_providers(response.body().as_ref(), output).map_err(crate::error::DescribeVerifiedAccessTrustProvidersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumeAttributeOutput, crate::error::DescribeVolumeAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVolumeAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumeAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumeAttributeOutput, crate::error::DescribeVolumeAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volume_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volume_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeVolumeAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVolumesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volumes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volumes(response.body().as_ref(), output).map_err(crate::error::DescribeVolumesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_modifications_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesModificationsOutput, crate::error::DescribeVolumesModificationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVolumesModificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumesModificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_modifications_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesModificationsOutput, crate::error::DescribeVolumesModificationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volumes_modifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volumes_modifications(response.body().as_ref(), output).map_err(crate::error::DescribeVolumesModificationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumeStatusOutput, crate::error::DescribeVolumeStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVolumeStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVolumeStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volume_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumeStatusOutput, crate::error::DescribeVolumeStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volume_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_volume_status(response.body().as_ref(), output).map_err(crate::error::DescribeVolumeStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcAttributeOutput, crate::error::DescribeVpcAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcAttributeOutput, crate::error::DescribeVpcAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_attribute(response.body().as_ref(), output).map_err(crate::error::DescribeVpcAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcClassicLinkOutput, crate::error::DescribeVpcClassicLinkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcClassicLinkOutput, crate::error::DescribeVpcClassicLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_classic_link(response.body().as_ref(), output).map_err(crate::error::DescribeVpcClassicLinkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_dns_support_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcClassicLinkDnsSupportOutput, crate::error::DescribeVpcClassicLinkDnsSupportError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcClassicLinkDnsSupportError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_classic_link_dns_support_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcClassicLinkDnsSupportOutput, crate::error::DescribeVpcClassicLinkDnsSupportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_classic_link_dns_support(response.body().as_ref(), output).map_err(crate::error::DescribeVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connection_notifications_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointConnectionNotificationsOutput, crate::error::DescribeVpcEndpointConnectionNotificationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointConnectionNotificationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointConnectionNotificationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connection_notifications_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointConnectionNotificationsOutput, crate::error::DescribeVpcEndpointConnectionNotificationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_connection_notifications_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_connection_notifications(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointConnectionNotificationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointConnectionsOutput, crate::error::DescribeVpcEndpointConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointConnectionsOutput, crate::error::DescribeVpcEndpointConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_connections(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoints_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointsOutput, crate::error::DescribeVpcEndpointsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoints_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointsOutput, crate::error::DescribeVpcEndpointsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoints_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoints(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_configurations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServiceConfigurationsOutput, crate::error::DescribeVpcEndpointServiceConfigurationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointServiceConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServiceConfigurationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_configurations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServiceConfigurationsOutput, crate::error::DescribeVpcEndpointServiceConfigurationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_service_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_service_configurations(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointServiceConfigurationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_permissions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServicePermissionsOutput, crate::error::DescribeVpcEndpointServicePermissionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointServicePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServicePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_service_permissions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServicePermissionsOutput, crate::error::DescribeVpcEndpointServicePermissionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_service_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_service_permissions(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointServicePermissionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_services_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServicesOutput, crate::error::DescribeVpcEndpointServicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcEndpointServicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcEndpointServicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_endpoint_services_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcEndpointServicesOutput, crate::error::DescribeVpcEndpointServicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_endpoint_services_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_endpoint_services(response.body().as_ref(), output).map_err(crate::error::DescribeVpcEndpointServicesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringConnectionsOutput, crate::error::DescribeVpcPeeringConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcPeeringConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpc_peering_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcPeeringConnectionsOutput, crate::error::DescribeVpcPeeringConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpc_peering_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpc_peering_connections(response.body().as_ref(), output).map_err(crate::error::DescribeVpcPeeringConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpcs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcsOutput, crate::error::DescribeVpcsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpcsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpcsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpcs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpcsOutput, crate::error::DescribeVpcsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpcs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpcs(response.body().as_ref(), output).map_err(crate::error::DescribeVpcsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpnConnectionsOutput, crate::error::DescribeVpnConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpnConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpnConnectionsOutput, crate::error::DescribeVpnConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpn_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpn_connections(response.body().as_ref(), output).map_err(crate::error::DescribeVpnConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_gateways_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpnGatewaysOutput, crate::error::DescribeVpnGatewaysError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DescribeVpnGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeVpnGatewaysError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_vpn_gateways_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVpnGatewaysOutput, crate::error::DescribeVpnGatewaysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_vpn_gateways_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_vpn_gateways(response.body().as_ref(), output).map_err(crate::error::DescribeVpnGatewaysError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_classic_link_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachClassicLinkVpcOutput, crate::error::DetachClassicLinkVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachClassicLinkVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachClassicLinkVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_classic_link_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachClassicLinkVpcOutput, crate::error::DetachClassicLinkVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_classic_link_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_classic_link_vpc(response.body().as_ref(), output).map_err(crate::error::DetachClassicLinkVpcError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_internet_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachInternetGatewayOutput, crate::error::DetachInternetGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachInternetGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachInternetGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_internet_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachInternetGatewayOutput, crate::error::DetachInternetGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_internet_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_network_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachNetworkInterfaceOutput, crate::error::DetachNetworkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachNetworkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachNetworkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_network_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachNetworkInterfaceOutput, crate::error::DetachNetworkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_network_interface_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_verified_access_trust_provider_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVerifiedAccessTrustProviderOutput, crate::error::DetachVerifiedAccessTrustProviderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_verified_access_trust_provider_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVerifiedAccessTrustProviderOutput, crate::error::DetachVerifiedAccessTrustProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::DetachVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVolumeOutput, crate::error::DetachVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVolumeOutput, crate::error::DetachVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detach_volume(response.body().as_ref(), output).map_err(crate::error::DetachVolumeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_vpn_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVpnGatewayOutput, crate::error::DetachVpnGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DetachVpnGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetachVpnGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_vpn_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachVpnGatewayOutput, crate::error::DetachVpnGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_vpn_gateway_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_address_transfer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableAddressTransferOutput, crate::error::DisableAddressTransferError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_address_transfer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableAddressTransferOutput, crate::error::DisableAddressTransferError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_address_transfer(response.body().as_ref(), output).map_err(crate::error::DisableAddressTransferError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_aws_network_performance_metric_subscription_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableAwsNetworkPerformanceMetricSubscriptionOutput, crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_aws_network_performance_metric_subscription_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableAwsNetworkPerformanceMetricSubscriptionOutput, crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_aws_network_performance_metric_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_aws_network_performance_metric_subscription(response.body().as_ref(), output).map_err(crate::error::DisableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ebs_encryption_by_default_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableEbsEncryptionByDefaultOutput, crate::error::DisableEbsEncryptionByDefaultError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableEbsEncryptionByDefaultError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ebs_encryption_by_default_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableEbsEncryptionByDefaultOutput, crate::error::DisableEbsEncryptionByDefaultError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_ebs_encryption_by_default(response.body().as_ref(), output).map_err(crate::error::DisableEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_launch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableFastLaunchOutput, crate::error::DisableFastLaunchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableFastLaunchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableFastLaunchError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_launch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableFastLaunchOutput, crate::error::DisableFastLaunchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_fast_launch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_fast_launch(response.body().as_ref(), output).map_err(crate::error::DisableFastLaunchError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_snapshot_restores_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableFastSnapshotRestoresOutput, crate::error::DisableFastSnapshotRestoresError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableFastSnapshotRestoresError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_fast_snapshot_restores_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableFastSnapshotRestoresOutput, crate::error::DisableFastSnapshotRestoresError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_fast_snapshot_restores(response.body().as_ref(), output).map_err(crate::error::DisableFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_image_deprecation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableImageDeprecationOutput, crate::error::DisableImageDeprecationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableImageDeprecationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableImageDeprecationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_image_deprecation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableImageDeprecationOutput, crate::error::DisableImageDeprecationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_image_deprecation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_image_deprecation(response.body().as_ref(), output).map_err(crate::error::DisableImageDeprecationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ipam_organization_admin_account_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableIpamOrganizationAdminAccountOutput, crate::error::DisableIpamOrganizationAdminAccountError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableIpamOrganizationAdminAccountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableIpamOrganizationAdminAccountError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_ipam_organization_admin_account_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableIpamOrganizationAdminAccountOutput, crate::error::DisableIpamOrganizationAdminAccountError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_ipam_organization_admin_account_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_ipam_organization_admin_account(response.body().as_ref(), output).map_err(crate::error::DisableIpamOrganizationAdminAccountError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_serial_console_access_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableSerialConsoleAccessOutput, crate::error::DisableSerialConsoleAccessError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableSerialConsoleAccessError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableSerialConsoleAccessError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_serial_console_access_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableSerialConsoleAccessOutput, crate::error::DisableSerialConsoleAccessError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_serial_console_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_serial_console_access(response.body().as_ref(), output).map_err(crate::error::DisableSerialConsoleAccessError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_transit_gateway_route_table_propagation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableTransitGatewayRouteTablePropagationOutput, crate::error::DisableTransitGatewayRouteTablePropagationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableTransitGatewayRouteTablePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableTransitGatewayRouteTablePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_transit_gateway_route_table_propagation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableTransitGatewayRouteTablePropagationOutput, crate::error::DisableTransitGatewayRouteTablePropagationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_transit_gateway_route_table_propagation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_transit_gateway_route_table_propagation(response.body().as_ref(), output).map_err(crate::error::DisableTransitGatewayRouteTablePropagationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vgw_route_propagation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVgwRoutePropagationOutput, crate::error::DisableVgwRoutePropagationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableVgwRoutePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVgwRoutePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vgw_route_propagation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVgwRoutePropagationOutput, crate::error::DisableVgwRoutePropagationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_vgw_route_propagation_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVpcClassicLinkOutput, crate::error::DisableVpcClassicLinkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVpcClassicLinkOutput, crate::error::DisableVpcClassicLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_vpc_classic_link(response.body().as_ref(), output).map_err(crate::error::DisableVpcClassicLinkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_dns_support_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVpcClassicLinkDnsSupportOutput, crate::error::DisableVpcClassicLinkDnsSupportError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisableVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableVpcClassicLinkDnsSupportError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_vpc_classic_link_dns_support_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisableVpcClassicLinkDnsSupportOutput, crate::error::DisableVpcClassicLinkDnsSupportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_vpc_classic_link_dns_support(response.body().as_ref(), output).map_err(crate::error::DisableVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_address_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateAddressOutput, crate::error::DisassociateAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_address_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateAddressOutput, crate::error::DisassociateAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_address_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_client_vpn_target_network_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateClientVpnTargetNetworkOutput, crate::error::DisassociateClientVpnTargetNetworkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateClientVpnTargetNetworkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateClientVpnTargetNetworkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_client_vpn_target_network_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateClientVpnTargetNetworkOutput, crate::error::DisassociateClientVpnTargetNetworkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_client_vpn_target_network_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_client_vpn_target_network(response.body().as_ref(), output).map_err(crate::error::DisassociateClientVpnTargetNetworkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_enclave_certificate_iam_role_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateEnclaveCertificateIamRoleOutput, crate::error::DisassociateEnclaveCertificateIamRoleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateEnclaveCertificateIamRoleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateEnclaveCertificateIamRoleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_enclave_certificate_iam_role_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateEnclaveCertificateIamRoleOutput, crate::error::DisassociateEnclaveCertificateIamRoleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_enclave_certificate_iam_role_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_enclave_certificate_iam_role(response.body().as_ref(), output).map_err(crate::error::DisassociateEnclaveCertificateIamRoleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_iam_instance_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateIamInstanceProfileOutput, crate::error::DisassociateIamInstanceProfileError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateIamInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateIamInstanceProfileError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_iam_instance_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateIamInstanceProfileOutput, crate::error::DisassociateIamInstanceProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_iam_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_iam_instance_profile(response.body().as_ref(), output).map_err(crate::error::DisassociateIamInstanceProfileError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_instance_event_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateInstanceEventWindowOutput, crate::error::DisassociateInstanceEventWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateInstanceEventWindowError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_instance_event_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateInstanceEventWindowOutput, crate::error::DisassociateInstanceEventWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_instance_event_window(response.body().as_ref(), output).map_err(crate::error::DisassociateInstanceEventWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateRouteTableOutput, crate::error::DisassociateRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateRouteTableOutput, crate::error::DisassociateRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_route_table_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_subnet_cidr_block_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateSubnetCidrBlockOutput, crate::error::DisassociateSubnetCidrBlockError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateSubnetCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateSubnetCidrBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_subnet_cidr_block_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateSubnetCidrBlockOutput, crate::error::DisassociateSubnetCidrBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_subnet_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_subnet_cidr_block(response.body().as_ref(), output).map_err(crate::error::DisassociateSubnetCidrBlockError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_multicast_domain_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayMulticastDomainOutput, crate::error::DisassociateTransitGatewayMulticastDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateTransitGatewayMulticastDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayMulticastDomainError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_multicast_domain_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayMulticastDomainOutput, crate::error::DisassociateTransitGatewayMulticastDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_transit_gateway_multicast_domain_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_multicast_domain(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayMulticastDomainError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_policy_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayPolicyTableOutput, crate::error::DisassociateTransitGatewayPolicyTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateTransitGatewayPolicyTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayPolicyTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_policy_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayPolicyTableOutput, crate::error::DisassociateTransitGatewayPolicyTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_transit_gateway_policy_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_policy_table(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayPolicyTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_route_table_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayRouteTableOutput, crate::error::DisassociateTransitGatewayRouteTableError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateTransitGatewayRouteTableError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTransitGatewayRouteTableError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_transit_gateway_route_table_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTransitGatewayRouteTableOutput, crate::error::DisassociateTransitGatewayRouteTableError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_transit_gateway_route_table_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_transit_gateway_route_table(response.body().as_ref(), output).map_err(crate::error::DisassociateTransitGatewayRouteTableError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trunk_interface_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTrunkInterfaceOutput, crate::error::DisassociateTrunkInterfaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateTrunkInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateTrunkInterfaceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trunk_interface_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateTrunkInterfaceOutput, crate::error::DisassociateTrunkInterfaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_trunk_interface_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_trunk_interface(response.body().as_ref(), output).map_err(crate::error::DisassociateTrunkInterfaceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_cidr_block_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateVpcCidrBlockOutput, crate::error::DisassociateVpcCidrBlockError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::DisassociateVpcCidrBlockError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisassociateVpcCidrBlockError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_vpc_cidr_block_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateVpcCidrBlockOutput, crate::error::DisassociateVpcCidrBlockError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_vpc_cidr_block_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disassociate_vpc_cidr_block(response.body().as_ref(), output).map_err(crate::error::DisassociateVpcCidrBlockError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_address_transfer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableAddressTransferOutput, crate::error::EnableAddressTransferError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableAddressTransferError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableAddressTransferError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_address_transfer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableAddressTransferOutput, crate::error::EnableAddressTransferError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_address_transfer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_address_transfer(response.body().as_ref(), output).map_err(crate::error::EnableAddressTransferError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_aws_network_performance_metric_subscription_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableAwsNetworkPerformanceMetricSubscriptionOutput, crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_aws_network_performance_metric_subscription_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableAwsNetworkPerformanceMetricSubscriptionOutput, crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_aws_network_performance_metric_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_aws_network_performance_metric_subscription(response.body().as_ref(), output).map_err(crate::error::EnableAwsNetworkPerformanceMetricSubscriptionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ebs_encryption_by_default_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableEbsEncryptionByDefaultOutput, crate::error::EnableEbsEncryptionByDefaultError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableEbsEncryptionByDefaultError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ebs_encryption_by_default_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableEbsEncryptionByDefaultOutput, crate::error::EnableEbsEncryptionByDefaultError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_ebs_encryption_by_default(response.body().as_ref(), output).map_err(crate::error::EnableEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_launch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableFastLaunchOutput, crate::error::EnableFastLaunchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableFastLaunchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableFastLaunchError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_launch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableFastLaunchOutput, crate::error::EnableFastLaunchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_fast_launch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_fast_launch(response.body().as_ref(), output).map_err(crate::error::EnableFastLaunchError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_snapshot_restores_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableFastSnapshotRestoresOutput, crate::error::EnableFastSnapshotRestoresError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableFastSnapshotRestoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableFastSnapshotRestoresError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_fast_snapshot_restores_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableFastSnapshotRestoresOutput, crate::error::EnableFastSnapshotRestoresError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_fast_snapshot_restores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_fast_snapshot_restores(response.body().as_ref(), output).map_err(crate::error::EnableFastSnapshotRestoresError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_image_deprecation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableImageDeprecationOutput, crate::error::EnableImageDeprecationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableImageDeprecationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableImageDeprecationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_image_deprecation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableImageDeprecationOutput, crate::error::EnableImageDeprecationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_image_deprecation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_image_deprecation(response.body().as_ref(), output).map_err(crate::error::EnableImageDeprecationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ipam_organization_admin_account_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableIpamOrganizationAdminAccountOutput, crate::error::EnableIpamOrganizationAdminAccountError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableIpamOrganizationAdminAccountError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableIpamOrganizationAdminAccountError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_ipam_organization_admin_account_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableIpamOrganizationAdminAccountOutput, crate::error::EnableIpamOrganizationAdminAccountError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_ipam_organization_admin_account_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_ipam_organization_admin_account(response.body().as_ref(), output).map_err(crate::error::EnableIpamOrganizationAdminAccountError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_reachability_analyzer_organization_sharing_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableReachabilityAnalyzerOrganizationSharingOutput, crate::error::EnableReachabilityAnalyzerOrganizationSharingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_reachability_analyzer_organization_sharing_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableReachabilityAnalyzerOrganizationSharingOutput, crate::error::EnableReachabilityAnalyzerOrganizationSharingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_reachability_analyzer_organization_sharing_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_reachability_analyzer_organization_sharing(response.body().as_ref(), output).map_err(crate::error::EnableReachabilityAnalyzerOrganizationSharingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_serial_console_access_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableSerialConsoleAccessOutput, crate::error::EnableSerialConsoleAccessError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableSerialConsoleAccessError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableSerialConsoleAccessError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_serial_console_access_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableSerialConsoleAccessOutput, crate::error::EnableSerialConsoleAccessError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_serial_console_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_serial_console_access(response.body().as_ref(), output).map_err(crate::error::EnableSerialConsoleAccessError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_transit_gateway_route_table_propagation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableTransitGatewayRouteTablePropagationOutput, crate::error::EnableTransitGatewayRouteTablePropagationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableTransitGatewayRouteTablePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableTransitGatewayRouteTablePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_transit_gateway_route_table_propagation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableTransitGatewayRouteTablePropagationOutput, crate::error::EnableTransitGatewayRouteTablePropagationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_transit_gateway_route_table_propagation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_transit_gateway_route_table_propagation(response.body().as_ref(), output).map_err(crate::error::EnableTransitGatewayRouteTablePropagationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vgw_route_propagation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVgwRoutePropagationOutput, crate::error::EnableVgwRoutePropagationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableVgwRoutePropagationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVgwRoutePropagationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vgw_route_propagation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVgwRoutePropagationOutput, crate::error::EnableVgwRoutePropagationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_vgw_route_propagation_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_volume_io_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVolumeIoOutput, crate::error::EnableVolumeIOError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableVolumeIOError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVolumeIOError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_volume_io_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVolumeIoOutput, crate::error::EnableVolumeIOError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_volume_io_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVpcClassicLinkOutput, crate::error::EnableVpcClassicLinkError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableVpcClassicLinkError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVpcClassicLinkError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVpcClassicLinkOutput, crate::error::EnableVpcClassicLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_vpc_classic_link_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_vpc_classic_link(response.body().as_ref(), output).map_err(crate::error::EnableVpcClassicLinkError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_dns_support_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVpcClassicLinkDnsSupportOutput, crate::error::EnableVpcClassicLinkDnsSupportError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::EnableVpcClassicLinkDnsSupportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableVpcClassicLinkDnsSupportError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_vpc_classic_link_dns_support_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EnableVpcClassicLinkDnsSupportOutput, crate::error::EnableVpcClassicLinkDnsSupportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_vpc_classic_link_dns_support_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_vpc_classic_link_dns_support(response.body().as_ref(), output).map_err(crate::error::EnableVpcClassicLinkDnsSupportError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_certificate_revocation_list_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportClientVpnClientCertificateRevocationListOutput, crate::error::ExportClientVpnClientCertificateRevocationListError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ExportClientVpnClientCertificateRevocationListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportClientVpnClientCertificateRevocationListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_certificate_revocation_list_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportClientVpnClientCertificateRevocationListOutput, crate::error::ExportClientVpnClientCertificateRevocationListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_client_vpn_client_certificate_revocation_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_client_vpn_client_certificate_revocation_list(response.body().as_ref(), output).map_err(crate::error::ExportClientVpnClientCertificateRevocationListError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportClientVpnClientConfigurationOutput, crate::error::ExportClientVpnClientConfigurationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ExportClientVpnClientConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportClientVpnClientConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_client_vpn_client_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportClientVpnClientConfigurationOutput, crate::error::ExportClientVpnClientConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_client_vpn_client_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_client_vpn_client_configuration(response.body().as_ref(), output).map_err(crate::error::ExportClientVpnClientConfigurationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportImageOutput, crate::error::ExportImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ExportImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportImageOutput, crate::error::ExportImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_image(response.body().as_ref(), output).map_err(crate::error::ExportImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_transit_gateway_routes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportTransitGatewayRoutesOutput, crate::error::ExportTransitGatewayRoutesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ExportTransitGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ExportTransitGatewayRoutesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_transit_gateway_routes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ExportTransitGatewayRoutesOutput, crate::error::ExportTransitGatewayRoutesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::export_transit_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_export_transit_gateway_routes(response.body().as_ref(), output).map_err(crate::error::ExportTransitGatewayRoutesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_enclave_certificate_iam_roles_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAssociatedEnclaveCertificateIamRolesOutput, crate::error::GetAssociatedEnclaveCertificateIamRolesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_enclave_certificate_iam_roles_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAssociatedEnclaveCertificateIamRolesOutput, crate::error::GetAssociatedEnclaveCertificateIamRolesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_associated_enclave_certificate_iam_roles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_associated_enclave_certificate_iam_roles(response.body().as_ref(), output).map_err(crate::error::GetAssociatedEnclaveCertificateIamRolesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_ipv6_pool_cidrs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAssociatedIpv6PoolCidrsOutput, crate::error::GetAssociatedIpv6PoolCidrsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetAssociatedIpv6PoolCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAssociatedIpv6PoolCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_associated_ipv6_pool_cidrs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAssociatedIpv6PoolCidrsOutput, crate::error::GetAssociatedIpv6PoolCidrsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_associated_ipv6_pool_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_associated_ipv6_pool_cidrs(response.body().as_ref(), output).map_err(crate::error::GetAssociatedIpv6PoolCidrsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aws_network_performance_data_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAwsNetworkPerformanceDataOutput, crate::error::GetAwsNetworkPerformanceDataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetAwsNetworkPerformanceDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetAwsNetworkPerformanceDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_aws_network_performance_data_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAwsNetworkPerformanceDataOutput, crate::error::GetAwsNetworkPerformanceDataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_aws_network_performance_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_aws_network_performance_data(response.body().as_ref(), output).map_err(crate::error::GetAwsNetworkPerformanceDataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_capacity_reservation_usage_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCapacityReservationUsageOutput, crate::error::GetCapacityReservationUsageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetCapacityReservationUsageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetCapacityReservationUsageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_capacity_reservation_usage_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCapacityReservationUsageOutput, crate::error::GetCapacityReservationUsageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_capacity_reservation_usage_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_capacity_reservation_usage(response.body().as_ref(), output).map_err(crate::error::GetCapacityReservationUsageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_coip_pool_usage_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCoipPoolUsageOutput, crate::error::GetCoipPoolUsageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetCoipPoolUsageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetCoipPoolUsageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_coip_pool_usage_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCoipPoolUsageOutput, crate::error::GetCoipPoolUsageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_coip_pool_usage_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_coip_pool_usage(response.body().as_ref(), output).map_err(crate::error::GetCoipPoolUsageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_output_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConsoleOutputOutput, crate::error::GetConsoleOutputError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetConsoleOutputError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetConsoleOutputError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_output_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConsoleOutputOutput, crate::error::GetConsoleOutputError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_console_output_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_console_output(response.body().as_ref(), output).map_err(crate::error::GetConsoleOutputError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_screenshot_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConsoleScreenshotOutput, crate::error::GetConsoleScreenshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetConsoleScreenshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetConsoleScreenshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_console_screenshot_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetConsoleScreenshotOutput, crate::error::GetConsoleScreenshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_console_screenshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_console_screenshot(response.body().as_ref(), output).map_err(crate::error::GetConsoleScreenshotError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_credit_specification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDefaultCreditSpecificationOutput, crate::error::GetDefaultCreditSpecificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetDefaultCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetDefaultCreditSpecificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_default_credit_specification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDefaultCreditSpecificationOutput, crate::error::GetDefaultCreditSpecificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_default_credit_specification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_default_credit_specification(response.body().as_ref(), output).map_err(crate::error::GetDefaultCreditSpecificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_default_kms_key_id_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEbsDefaultKmsKeyIdOutput, crate::error::GetEbsDefaultKmsKeyIdError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetEbsDefaultKmsKeyIdError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_default_kms_key_id_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEbsDefaultKmsKeyIdOutput, crate::error::GetEbsDefaultKmsKeyIdError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ebs_default_kms_key_id(response.body().as_ref(), output).map_err(crate::error::GetEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_encryption_by_default_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEbsEncryptionByDefaultOutput, crate::error::GetEbsEncryptionByDefaultError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetEbsEncryptionByDefaultError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetEbsEncryptionByDefaultError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ebs_encryption_by_default_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEbsEncryptionByDefaultOutput, crate::error::GetEbsEncryptionByDefaultError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ebs_encryption_by_default_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ebs_encryption_by_default(response.body().as_ref(), output).map_err(crate::error::GetEbsEncryptionByDefaultError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_flow_logs_integration_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFlowLogsIntegrationTemplateOutput, crate::error::GetFlowLogsIntegrationTemplateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetFlowLogsIntegrationTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetFlowLogsIntegrationTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_flow_logs_integration_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFlowLogsIntegrationTemplateOutput, crate::error::GetFlowLogsIntegrationTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_flow_logs_integration_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_flow_logs_integration_template(response.body().as_ref(), output).map_err(crate::error::GetFlowLogsIntegrationTemplateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_for_capacity_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupsForCapacityReservationOutput, crate::error::GetGroupsForCapacityReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetGroupsForCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetGroupsForCapacityReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_for_capacity_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupsForCapacityReservationOutput, crate::error::GetGroupsForCapacityReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_groups_for_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_groups_for_capacity_reservation(response.body().as_ref(), output).map_err(crate::error::GetGroupsForCapacityReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_host_reservation_purchase_preview_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetHostReservationPurchasePreviewOutput, crate::error::GetHostReservationPurchasePreviewError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetHostReservationPurchasePreviewError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetHostReservationPurchasePreviewError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_host_reservation_purchase_preview_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetHostReservationPurchasePreviewOutput, crate::error::GetHostReservationPurchasePreviewError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_host_reservation_purchase_preview_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_host_reservation_purchase_preview(response.body().as_ref(), output).map_err(crate::error::GetHostReservationPurchasePreviewError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_types_from_instance_requirements_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceTypesFromInstanceRequirementsOutput, crate::error::GetInstanceTypesFromInstanceRequirementsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetInstanceTypesFromInstanceRequirementsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetInstanceTypesFromInstanceRequirementsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_types_from_instance_requirements_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceTypesFromInstanceRequirementsOutput, crate::error::GetInstanceTypesFromInstanceRequirementsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_types_from_instance_requirements_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_instance_types_from_instance_requirements(response.body().as_ref(), output).map_err(crate::error::GetInstanceTypesFromInstanceRequirementsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_uefi_data_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceUefiDataOutput, crate::error::GetInstanceUefiDataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetInstanceUefiDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetInstanceUefiDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_uefi_data_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInstanceUefiDataOutput, crate::error::GetInstanceUefiDataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_uefi_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_instance_uefi_data(response.body().as_ref(), output).map_err(crate::error::GetInstanceUefiDataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_address_history_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamAddressHistoryOutput, crate::error::GetIpamAddressHistoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetIpamAddressHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamAddressHistoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_address_history_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamAddressHistoryOutput, crate::error::GetIpamAddressHistoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_address_history_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_address_history(response.body().as_ref(), output).map_err(crate::error::GetIpamAddressHistoryError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_allocations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamPoolAllocationsOutput, crate::error::GetIpamPoolAllocationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetIpamPoolAllocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamPoolAllocationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_allocations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamPoolAllocationsOutput, crate::error::GetIpamPoolAllocationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_pool_allocations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_pool_allocations(response.body().as_ref(), output).map_err(crate::error::GetIpamPoolAllocationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_cidrs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamPoolCidrsOutput, crate::error::GetIpamPoolCidrsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetIpamPoolCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamPoolCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_pool_cidrs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamPoolCidrsOutput, crate::error::GetIpamPoolCidrsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_pool_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_pool_cidrs(response.body().as_ref(), output).map_err(crate::error::GetIpamPoolCidrsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_resource_cidrs_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamResourceCidrsOutput, crate::error::GetIpamResourceCidrsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetIpamResourceCidrsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetIpamResourceCidrsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ipam_resource_cidrs_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetIpamResourceCidrsOutput, crate::error::GetIpamResourceCidrsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_ipam_resource_cidrs_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_ipam_resource_cidrs(response.body().as_ref(), output).map_err(crate::error::GetIpamResourceCidrsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_launch_template_data_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetLaunchTemplateDataOutput, crate::error::GetLaunchTemplateDataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetLaunchTemplateDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetLaunchTemplateDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_launch_template_data_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetLaunchTemplateDataOutput, crate::error::GetLaunchTemplateDataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_launch_template_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_launch_template_data(response.body().as_ref(), output).map_err(crate::error::GetLaunchTemplateDataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedPrefixListAssociationsOutput, crate::error::GetManagedPrefixListAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetManagedPrefixListAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetManagedPrefixListAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedPrefixListAssociationsOutput, crate::error::GetManagedPrefixListAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_managed_prefix_list_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_managed_prefix_list_associations(response.body().as_ref(), output).map_err(crate::error::GetManagedPrefixListAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_entries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedPrefixListEntriesOutput, crate::error::GetManagedPrefixListEntriesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetManagedPrefixListEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetManagedPrefixListEntriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_prefix_list_entries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedPrefixListEntriesOutput, crate::error::GetManagedPrefixListEntriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_managed_prefix_list_entries_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_managed_prefix_list_entries(response.body().as_ref(), output).map_err(crate::error::GetManagedPrefixListEntriesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_analysis_findings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetNetworkInsightsAccessScopeAnalysisFindingsOutput, crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_analysis_findings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetNetworkInsightsAccessScopeAnalysisFindingsOutput, crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_network_insights_access_scope_analysis_findings_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_network_insights_access_scope_analysis_findings(response.body().as_ref(), output).map_err(crate::error::GetNetworkInsightsAccessScopeAnalysisFindingsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_content_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetNetworkInsightsAccessScopeContentOutput, crate::error::GetNetworkInsightsAccessScopeContentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetNetworkInsightsAccessScopeContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetNetworkInsightsAccessScopeContentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_insights_access_scope_content_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetNetworkInsightsAccessScopeContentOutput, crate::error::GetNetworkInsightsAccessScopeContentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_network_insights_access_scope_content_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_network_insights_access_scope_content(response.body().as_ref(), output).map_err(crate::error::GetNetworkInsightsAccessScopeContentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_password_data_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPasswordDataOutput, crate::error::GetPasswordDataError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetPasswordDataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetPasswordDataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_password_data_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPasswordDataOutput, crate::error::GetPasswordDataError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_password_data_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_password_data(response.body().as_ref(), output).map_err(crate::error::GetPasswordDataError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_instances_exchange_quote_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetReservedInstancesExchangeQuoteOutput, crate::error::GetReservedInstancesExchangeQuoteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetReservedInstancesExchangeQuoteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetReservedInstancesExchangeQuoteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_instances_exchange_quote_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetReservedInstancesExchangeQuoteOutput, crate::error::GetReservedInstancesExchangeQuoteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_reserved_instances_exchange_quote_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_reserved_instances_exchange_quote(response.body().as_ref(), output).map_err(crate::error::GetReservedInstancesExchangeQuoteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_serial_console_access_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSerialConsoleAccessStatusOutput, crate::error::GetSerialConsoleAccessStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetSerialConsoleAccessStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSerialConsoleAccessStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_serial_console_access_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSerialConsoleAccessStatusOutput, crate::error::GetSerialConsoleAccessStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_serial_console_access_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_serial_console_access_status(response.body().as_ref(), output).map_err(crate::error::GetSerialConsoleAccessStatusError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_spot_placement_scores_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSpotPlacementScoresOutput, crate::error::GetSpotPlacementScoresError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetSpotPlacementScoresError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSpotPlacementScoresError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_spot_placement_scores_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSpotPlacementScoresOutput, crate::error::GetSpotPlacementScoresError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_spot_placement_scores_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_spot_placement_scores(response.body().as_ref(), output).map_err(crate::error::GetSpotPlacementScoresError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subnet_cidr_reservations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSubnetCidrReservationsOutput, crate::error::GetSubnetCidrReservationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetSubnetCidrReservationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSubnetCidrReservationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_subnet_cidr_reservations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSubnetCidrReservationsOutput, crate::error::GetSubnetCidrReservationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_subnet_cidr_reservations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_subnet_cidr_reservations(response.body().as_ref(), output).map_err(crate::error::GetSubnetCidrReservationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_attachment_propagations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayAttachmentPropagationsOutput, crate::error::GetTransitGatewayAttachmentPropagationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayAttachmentPropagationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayAttachmentPropagationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_attachment_propagations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayAttachmentPropagationsOutput, crate::error::GetTransitGatewayAttachmentPropagationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_attachment_propagations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_attachment_propagations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayAttachmentPropagationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_multicast_domain_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayMulticastDomainAssociationsOutput, crate::error::GetTransitGatewayMulticastDomainAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_multicast_domain_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayMulticastDomainAssociationsOutput, crate::error::GetTransitGatewayMulticastDomainAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPolicyTableAssociationsOutput, crate::error::GetTransitGatewayPolicyTableAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayPolicyTableAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPolicyTableAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPolicyTableAssociationsOutput, crate::error::GetTransitGatewayPolicyTableAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_policy_table_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_policy_table_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPolicyTableAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_entries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPolicyTableEntriesOutput, crate::error::GetTransitGatewayPolicyTableEntriesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayPolicyTableEntriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPolicyTableEntriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_policy_table_entries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPolicyTableEntriesOutput, crate::error::GetTransitGatewayPolicyTableEntriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_policy_table_entries_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_policy_table_entries(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPolicyTableEntriesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_prefix_list_references_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPrefixListReferencesOutput, crate::error::GetTransitGatewayPrefixListReferencesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayPrefixListReferencesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayPrefixListReferencesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_prefix_list_references_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayPrefixListReferencesOutput, crate::error::GetTransitGatewayPrefixListReferencesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_prefix_list_references_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_prefix_list_references(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayPrefixListReferencesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayRouteTableAssociationsOutput, crate::error::GetTransitGatewayRouteTableAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayRouteTableAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayRouteTableAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayRouteTableAssociationsOutput, crate::error::GetTransitGatewayRouteTableAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_route_table_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_route_table_associations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayRouteTableAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_propagations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayRouteTablePropagationsOutput, crate::error::GetTransitGatewayRouteTablePropagationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetTransitGatewayRouteTablePropagationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetTransitGatewayRouteTablePropagationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_transit_gateway_route_table_propagations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTransitGatewayRouteTablePropagationsOutput, crate::error::GetTransitGatewayRouteTablePropagationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_transit_gateway_route_table_propagations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_transit_gateway_route_table_propagations(response.body().as_ref(), output).map_err(crate::error::GetTransitGatewayRouteTablePropagationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_endpoint_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVerifiedAccessEndpointPolicyOutput, crate::error::GetVerifiedAccessEndpointPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetVerifiedAccessEndpointPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVerifiedAccessEndpointPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_endpoint_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVerifiedAccessEndpointPolicyOutput, crate::error::GetVerifiedAccessEndpointPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_verified_access_endpoint_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_verified_access_endpoint_policy(response.body().as_ref(), output).map_err(crate::error::GetVerifiedAccessEndpointPolicyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_group_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVerifiedAccessGroupPolicyOutput, crate::error::GetVerifiedAccessGroupPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetVerifiedAccessGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVerifiedAccessGroupPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_verified_access_group_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVerifiedAccessGroupPolicyOutput, crate::error::GetVerifiedAccessGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_verified_access_group_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_verified_access_group_policy(response.body().as_ref(), output).map_err(crate::error::GetVerifiedAccessGroupPolicyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_sample_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVpnConnectionDeviceSampleConfigurationOutput, crate::error::GetVpnConnectionDeviceSampleConfigurationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_sample_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVpnConnectionDeviceSampleConfigurationOutput, crate::error::GetVpnConnectionDeviceSampleConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpn_connection_device_sample_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_vpn_connection_device_sample_configuration(response.body().as_ref(), output).map_err(crate::error::GetVpnConnectionDeviceSampleConfigurationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_types_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVpnConnectionDeviceTypesOutput, crate::error::GetVpnConnectionDeviceTypesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::GetVpnConnectionDeviceTypesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetVpnConnectionDeviceTypesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpn_connection_device_types_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetVpnConnectionDeviceTypesOutput, crate::error::GetVpnConnectionDeviceTypesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpn_connection_device_types_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_vpn_connection_device_types(response.body().as_ref(), output).map_err(crate::error::GetVpnConnectionDeviceTypesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_client_vpn_client_certificate_revocation_list_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportClientVpnClientCertificateRevocationListOutput, crate::error::ImportClientVpnClientCertificateRevocationListError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportClientVpnClientCertificateRevocationListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportClientVpnClientCertificateRevocationListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_client_vpn_client_certificate_revocation_list_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportClientVpnClientCertificateRevocationListOutput, crate::error::ImportClientVpnClientCertificateRevocationListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_client_vpn_client_certificate_revocation_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_client_vpn_client_certificate_revocation_list(response.body().as_ref(), output).map_err(crate::error::ImportClientVpnClientCertificateRevocationListError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportImageOutput, crate::error::ImportImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportImageOutput, crate::error::ImportImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_image(response.body().as_ref(), output).map_err(crate::error::ImportImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportInstanceOutput, crate::error::ImportInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportInstanceOutput, crate::error::ImportInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_instance(response.body().as_ref(), output).map_err(crate::error::ImportInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_key_pair_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportKeyPairOutput, crate::error::ImportKeyPairError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportKeyPairError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportKeyPairError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_key_pair_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportKeyPairOutput, crate::error::ImportKeyPairError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_key_pair_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_key_pair(response.body().as_ref(), output).map_err(crate::error::ImportKeyPairError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_snapshot_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportSnapshotOutput, crate::error::ImportSnapshotError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportSnapshotError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportSnapshotError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_snapshot_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportSnapshotOutput, crate::error::ImportSnapshotError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_snapshot(response.body().as_ref(), output).map_err(crate::error::ImportSnapshotError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportVolumeOutput, crate::error::ImportVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ImportVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ImportVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ImportVolumeOutput, crate::error::ImportVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_volume(response.body().as_ref(), output).map_err(crate::error::ImportVolumeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_in_recycle_bin_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListImagesInRecycleBinOutput, crate::error::ListImagesInRecycleBinError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ListImagesInRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListImagesInRecycleBinError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_in_recycle_bin_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListImagesInRecycleBinOutput, crate::error::ListImagesInRecycleBinError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_images_in_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_images_in_recycle_bin(response.body().as_ref(), output).map_err(crate::error::ListImagesInRecycleBinError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_snapshots_in_recycle_bin_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSnapshotsInRecycleBinOutput, crate::error::ListSnapshotsInRecycleBinError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ListSnapshotsInRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListSnapshotsInRecycleBinError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_snapshots_in_recycle_bin_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSnapshotsInRecycleBinOutput, crate::error::ListSnapshotsInRecycleBinError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_snapshots_in_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_snapshots_in_recycle_bin(response.body().as_ref(), output).map_err(crate::error::ListSnapshotsInRecycleBinError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_address_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyAddressAttributeOutput, crate::error::ModifyAddressAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyAddressAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyAddressAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_address_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyAddressAttributeOutput, crate::error::ModifyAddressAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_address_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_address_attribute(response.body().as_ref(), output).map_err(crate::error::ModifyAddressAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_availability_zone_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyAvailabilityZoneGroupOutput, crate::error::ModifyAvailabilityZoneGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyAvailabilityZoneGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyAvailabilityZoneGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_availability_zone_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyAvailabilityZoneGroupOutput, crate::error::ModifyAvailabilityZoneGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_availability_zone_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_availability_zone_group(response.body().as_ref(), output).map_err(crate::error::ModifyAvailabilityZoneGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyCapacityReservationOutput, crate::error::ModifyCapacityReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyCapacityReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyCapacityReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyCapacityReservationOutput, crate::error::ModifyCapacityReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_capacity_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_capacity_reservation(response.body().as_ref(), output).map_err(crate::error::ModifyCapacityReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyCapacityReservationFleetOutput, crate::error::ModifyCapacityReservationFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyCapacityReservationFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyCapacityReservationFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_capacity_reservation_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyCapacityReservationFleetOutput, crate::error::ModifyCapacityReservationFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_capacity_reservation_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_capacity_reservation_fleet(response.body().as_ref(), output).map_err(crate::error::ModifyCapacityReservationFleetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_client_vpn_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyClientVpnEndpointOutput, crate::error::ModifyClientVpnEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyClientVpnEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyClientVpnEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_client_vpn_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyClientVpnEndpointOutput, crate::error::ModifyClientVpnEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_client_vpn_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_client_vpn_endpoint(response.body().as_ref(), output).map_err(crate::error::ModifyClientVpnEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_default_credit_specification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyDefaultCreditSpecificationOutput, crate::error::ModifyDefaultCreditSpecificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyDefaultCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyDefaultCreditSpecificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_default_credit_specification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyDefaultCreditSpecificationOutput, crate::error::ModifyDefaultCreditSpecificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_default_credit_specification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_default_credit_specification(response.body().as_ref(), output).map_err(crate::error::ModifyDefaultCreditSpecificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ebs_default_kms_key_id_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyEbsDefaultKmsKeyIdOutput, crate::error::ModifyEbsDefaultKmsKeyIdError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyEbsDefaultKmsKeyIdError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ebs_default_kms_key_id_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyEbsDefaultKmsKeyIdOutput, crate::error::ModifyEbsDefaultKmsKeyIdError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ebs_default_kms_key_id(response.body().as_ref(), output).map_err(crate::error::ModifyEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyFleetOutput, crate::error::ModifyFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyFleetOutput, crate::error::ModifyFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_fleet(response.body().as_ref(), output).map_err(crate::error::ModifyFleetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fpga_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyFpgaImageAttributeOutput, crate::error::ModifyFpgaImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyFpgaImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_fpga_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyFpgaImageAttributeOutput, crate::error::ModifyFpgaImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_fpga_image_attribute(response.body().as_ref(), output).map_err(crate::error::ModifyFpgaImageAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_hosts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyHostsOutput, crate::error::ModifyHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_hosts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyHostsOutput, crate::error::ModifyHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_hosts(response.body().as_ref(), output).map_err(crate::error::ModifyHostsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_identity_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIdentityIdFormatOutput, crate::error::ModifyIdentityIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIdentityIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIdentityIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_identity_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIdentityIdFormatOutput, crate::error::ModifyIdentityIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_identity_id_format_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_id_format_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIdFormatOutput, crate::error::ModifyIdFormatError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIdFormatError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIdFormatError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_id_format_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIdFormatOutput, crate::error::ModifyIdFormatError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_id_format_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyImageAttributeOutput, crate::error::ModifyImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyImageAttributeOutput, crate::error::ModifyImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_image_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceAttributeOutput, crate::error::ModifyInstanceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceAttributeOutput, crate::error::ModifyInstanceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_capacity_reservation_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceCapacityReservationAttributesOutput, crate::error::ModifyInstanceCapacityReservationAttributesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceCapacityReservationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceCapacityReservationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_capacity_reservation_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceCapacityReservationAttributesOutput, crate::error::ModifyInstanceCapacityReservationAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_capacity_reservation_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_capacity_reservation_attributes(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceCapacityReservationAttributesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_credit_specification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceCreditSpecificationOutput, crate::error::ModifyInstanceCreditSpecificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceCreditSpecificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceCreditSpecificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_credit_specification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceCreditSpecificationOutput, crate::error::ModifyInstanceCreditSpecificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_credit_specification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_credit_specification(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceCreditSpecificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_start_time_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceEventStartTimeOutput, crate::error::ModifyInstanceEventStartTimeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceEventStartTimeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceEventStartTimeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_start_time_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceEventStartTimeOutput, crate::error::ModifyInstanceEventStartTimeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_event_start_time_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_event_start_time(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceEventStartTimeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_window_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceEventWindowOutput, crate::error::ModifyInstanceEventWindowError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceEventWindowError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceEventWindowError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_event_window_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceEventWindowOutput, crate::error::ModifyInstanceEventWindowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_event_window_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_event_window(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceEventWindowError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_maintenance_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceMaintenanceOptionsOutput, crate::error::ModifyInstanceMaintenanceOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceMaintenanceOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceMaintenanceOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_maintenance_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceMaintenanceOptionsOutput, crate::error::ModifyInstanceMaintenanceOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_maintenance_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_maintenance_options(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceMaintenanceOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_metadata_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceMetadataOptionsOutput, crate::error::ModifyInstanceMetadataOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstanceMetadataOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstanceMetadataOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_metadata_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceMetadataOptionsOutput, crate::error::ModifyInstanceMetadataOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_metadata_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_metadata_options(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceMetadataOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_placement_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstancePlacementOutput, crate::error::ModifyInstancePlacementError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyInstancePlacementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyInstancePlacementError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_placement_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstancePlacementOutput, crate::error::ModifyInstancePlacementError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_placement_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_instance_placement(response.body().as_ref(), output).map_err(crate::error::ModifyInstancePlacementError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamOutput, crate::error::ModifyIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamOutput, crate::error::ModifyIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam(response.body().as_ref(), output).map_err(crate::error::ModifyIpamError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_pool_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamPoolOutput, crate::error::ModifyIpamPoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIpamPoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamPoolError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_pool_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamPoolOutput, crate::error::ModifyIpamPoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_pool_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_pool(response.body().as_ref(), output).map_err(crate::error::ModifyIpamPoolError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_resource_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamResourceCidrOutput, crate::error::ModifyIpamResourceCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIpamResourceCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamResourceCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_resource_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamResourceCidrOutput, crate::error::ModifyIpamResourceCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_resource_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_resource_cidr(response.body().as_ref(), output).map_err(crate::error::ModifyIpamResourceCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_scope_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamScopeOutput, crate::error::ModifyIpamScopeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyIpamScopeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyIpamScopeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_ipam_scope_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyIpamScopeOutput, crate::error::ModifyIpamScopeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_ipam_scope_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_ipam_scope(response.body().as_ref(), output).map_err(crate::error::ModifyIpamScopeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_launch_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyLaunchTemplateOutput, crate::error::ModifyLaunchTemplateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyLaunchTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyLaunchTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_launch_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyLaunchTemplateOutput, crate::error::ModifyLaunchTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_launch_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_launch_template(response.body().as_ref(), output).map_err(crate::error::ModifyLaunchTemplateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_local_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyLocalGatewayRouteOutput, crate::error::ModifyLocalGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyLocalGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyLocalGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_local_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyLocalGatewayRouteOutput, crate::error::ModifyLocalGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_local_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_local_gateway_route(response.body().as_ref(), output).map_err(crate::error::ModifyLocalGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_managed_prefix_list_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyManagedPrefixListOutput, crate::error::ModifyManagedPrefixListError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyManagedPrefixListError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyManagedPrefixListError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_managed_prefix_list_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyManagedPrefixListOutput, crate::error::ModifyManagedPrefixListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_managed_prefix_list_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_managed_prefix_list(response.body().as_ref(), output).map_err(crate::error::ModifyManagedPrefixListError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_network_interface_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyNetworkInterfaceAttributeOutput, crate::error::ModifyNetworkInterfaceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyNetworkInterfaceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_network_interface_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyNetworkInterfaceAttributeOutput, crate::error::ModifyNetworkInterfaceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_network_interface_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_private_dns_name_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyPrivateDnsNameOptionsOutput, crate::error::ModifyPrivateDnsNameOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyPrivateDnsNameOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyPrivateDnsNameOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_private_dns_name_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyPrivateDnsNameOptionsOutput, crate::error::ModifyPrivateDnsNameOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_private_dns_name_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_private_dns_name_options(response.body().as_ref(), output).map_err(crate::error::ModifyPrivateDnsNameOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_reserved_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyReservedInstancesOutput, crate::error::ModifyReservedInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyReservedInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyReservedInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_reserved_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyReservedInstancesOutput, crate::error::ModifyReservedInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_reserved_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_reserved_instances(response.body().as_ref(), output).map_err(crate::error::ModifyReservedInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_security_group_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySecurityGroupRulesOutput, crate::error::ModifySecurityGroupRulesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifySecurityGroupRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySecurityGroupRulesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_security_group_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySecurityGroupRulesOutput, crate::error::ModifySecurityGroupRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_security_group_rules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_security_group_rules(response.body().as_ref(), output).map_err(crate::error::ModifySecurityGroupRulesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySnapshotAttributeOutput, crate::error::ModifySnapshotAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifySnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySnapshotAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySnapshotAttributeOutput, crate::error::ModifySnapshotAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_snapshot_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_tier_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySnapshotTierOutput, crate::error::ModifySnapshotTierError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifySnapshotTierError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySnapshotTierError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_tier_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySnapshotTierOutput, crate::error::ModifySnapshotTierError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_snapshot_tier_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_snapshot_tier(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotTierError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_spot_fleet_request_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySpotFleetRequestOutput, crate::error::ModifySpotFleetRequestError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifySpotFleetRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySpotFleetRequestError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_spot_fleet_request_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySpotFleetRequestOutput, crate::error::ModifySpotFleetRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_spot_fleet_request_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_spot_fleet_request(response.body().as_ref(), output).map_err(crate::error::ModifySpotFleetRequestError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_subnet_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySubnetAttributeOutput, crate::error::ModifySubnetAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifySubnetAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifySubnetAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_subnet_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifySubnetAttributeOutput, crate::error::ModifySubnetAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_subnet_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_network_services_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorFilterNetworkServicesOutput, crate::error::ModifyTrafficMirrorFilterNetworkServicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_network_services_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorFilterNetworkServicesOutput, crate::error::ModifyTrafficMirrorFilterNetworkServicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_traffic_mirror_filter_network_services_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_filter_network_services(response.body().as_ref(), output).map_err(crate::error::ModifyTrafficMirrorFilterNetworkServicesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorFilterRuleOutput, crate::error::ModifyTrafficMirrorFilterRuleError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTrafficMirrorFilterRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorFilterRuleError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_filter_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorFilterRuleOutput, crate::error::ModifyTrafficMirrorFilterRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_traffic_mirror_filter_rule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_filter_rule(response.body().as_ref(), output).map_err(crate::error::ModifyTrafficMirrorFilterRuleError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_session_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorSessionOutput, crate::error::ModifyTrafficMirrorSessionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTrafficMirrorSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTrafficMirrorSessionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_traffic_mirror_session_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTrafficMirrorSessionOutput, crate::error::ModifyTrafficMirrorSessionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_traffic_mirror_session_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_traffic_mirror_session(response.body().as_ref(), output).map_err(crate::error::ModifyTrafficMirrorSessionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayOutput, crate::error::ModifyTransitGatewayError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTransitGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayOutput, crate::error::ModifyTransitGatewayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_transit_gateway_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway(response.body().as_ref(), output).map_err(crate::error::ModifyTransitGatewayError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_prefix_list_reference_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayPrefixListReferenceOutput, crate::error::ModifyTransitGatewayPrefixListReferenceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTransitGatewayPrefixListReferenceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayPrefixListReferenceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_prefix_list_reference_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayPrefixListReferenceOutput, crate::error::ModifyTransitGatewayPrefixListReferenceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_transit_gateway_prefix_list_reference_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway_prefix_list_reference(response.body().as_ref(), output).map_err(crate::error::ModifyTransitGatewayPrefixListReferenceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_vpc_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayVpcAttachmentOutput, crate::error::ModifyTransitGatewayVpcAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_transit_gateway_vpc_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyTransitGatewayVpcAttachmentOutput, crate::error::ModifyTransitGatewayVpcAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::ModifyTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessEndpointOutput, crate::error::ModifyVerifiedAccessEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessEndpointOutput, crate::error::ModifyVerifiedAccessEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_endpoint(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessEndpointPolicyOutput, crate::error::ModifyVerifiedAccessEndpointPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessEndpointPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessEndpointPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_endpoint_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessEndpointPolicyOutput, crate::error::ModifyVerifiedAccessEndpointPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_endpoint_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_endpoint_policy(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessEndpointPolicyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessGroupOutput, crate::error::ModifyVerifiedAccessGroupError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessGroupError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessGroupOutput, crate::error::ModifyVerifiedAccessGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_group(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessGroupError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessGroupPolicyOutput, crate::error::ModifyVerifiedAccessGroupPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessGroupPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_group_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessGroupPolicyOutput, crate::error::ModifyVerifiedAccessGroupPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_group_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_group_policy(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessGroupPolicyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessInstanceOutput, crate::error::ModifyVerifiedAccessInstanceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessInstanceOutput, crate::error::ModifyVerifiedAccessInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_instance(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessInstanceError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_logging_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessInstanceLoggingConfigurationOutput, crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_instance_logging_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessInstanceLoggingConfigurationOutput, crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_instance_logging_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_instance_logging_configuration(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessInstanceLoggingConfigurationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_trust_provider_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessTrustProviderOutput, crate::error::ModifyVerifiedAccessTrustProviderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVerifiedAccessTrustProviderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVerifiedAccessTrustProviderError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_verified_access_trust_provider_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVerifiedAccessTrustProviderOutput, crate::error::ModifyVerifiedAccessTrustProviderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_verified_access_trust_provider_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_verified_access_trust_provider(response.body().as_ref(), output).map_err(crate::error::ModifyVerifiedAccessTrustProviderError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVolumeOutput, crate::error::ModifyVolumeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVolumeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVolumeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVolumeOutput, crate::error::ModifyVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_volume_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_volume(response.body().as_ref(), output).map_err(crate::error::ModifyVolumeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVolumeAttributeOutput, crate::error::ModifyVolumeAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVolumeAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVolumeAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_volume_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVolumeAttributeOutput, crate::error::ModifyVolumeAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_volume_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcAttributeOutput, crate::error::ModifyVpcAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcAttributeOutput, crate::error::ModifyVpcAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointOutput, crate::error::ModifyVpcEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointOutput, crate::error::ModifyVpcEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_connection_notification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointConnectionNotificationOutput, crate::error::ModifyVpcEndpointConnectionNotificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcEndpointConnectionNotificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointConnectionNotificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_connection_notification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointConnectionNotificationOutput, crate::error::ModifyVpcEndpointConnectionNotificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_connection_notification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_connection_notification(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointConnectionNotificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServiceConfigurationOutput, crate::error::ModifyVpcEndpointServiceConfigurationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcEndpointServiceConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServiceConfigurationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServiceConfigurationOutput, crate::error::ModifyVpcEndpointServiceConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_service_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_configuration(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServiceConfigurationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_payer_responsibility_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServicePayerResponsibilityOutput, crate::error::ModifyVpcEndpointServicePayerResponsibilityError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_payer_responsibility_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServicePayerResponsibilityOutput, crate::error::ModifyVpcEndpointServicePayerResponsibilityError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_service_payer_responsibility_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_payer_responsibility(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServicePayerResponsibilityError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_permissions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServicePermissionsOutput, crate::error::ModifyVpcEndpointServicePermissionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcEndpointServicePermissionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcEndpointServicePermissionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_endpoint_service_permissions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcEndpointServicePermissionsOutput, crate::error::ModifyVpcEndpointServicePermissionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_endpoint_service_permissions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_endpoint_service_permissions(response.body().as_ref(), output).map_err(crate::error::ModifyVpcEndpointServicePermissionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_peering_connection_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcPeeringConnectionOptionsOutput, crate::error::ModifyVpcPeeringConnectionOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcPeeringConnectionOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcPeeringConnectionOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_peering_connection_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcPeeringConnectionOptionsOutput, crate::error::ModifyVpcPeeringConnectionOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_peering_connection_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_peering_connection_options(response.body().as_ref(), output).map_err(crate::error::ModifyVpcPeeringConnectionOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_tenancy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcTenancyOutput, crate::error::ModifyVpcTenancyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpcTenancyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpcTenancyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpc_tenancy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpcTenancyOutput, crate::error::ModifyVpcTenancyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpc_tenancy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpc_tenancy(response.body().as_ref(), output).map_err(crate::error::ModifyVpcTenancyError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnConnectionOutput, crate::error::ModifyVpnConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpnConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnConnectionOutput, crate::error::ModifyVpnConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_connection(response.body().as_ref(), output).map_err(crate::error::ModifyVpnConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnConnectionOptionsOutput, crate::error::ModifyVpnConnectionOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpnConnectionOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnConnectionOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_connection_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnConnectionOptionsOutput, crate::error::ModifyVpnConnectionOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_connection_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_connection_options(response.body().as_ref(), output).map_err(crate::error::ModifyVpnConnectionOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_certificate_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnTunnelCertificateOutput, crate::error::ModifyVpnTunnelCertificateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpnTunnelCertificateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnTunnelCertificateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_certificate_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnTunnelCertificateOutput, crate::error::ModifyVpnTunnelCertificateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_tunnel_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_tunnel_certificate(response.body().as_ref(), output).map_err(crate::error::ModifyVpnTunnelCertificateError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnTunnelOptionsOutput, crate::error::ModifyVpnTunnelOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ModifyVpnTunnelOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ModifyVpnTunnelOptionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_vpn_tunnel_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyVpnTunnelOptionsOutput, crate::error::ModifyVpnTunnelOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_vpn_tunnel_options_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_vpn_tunnel_options(response.body().as_ref(), output).map_err(crate::error::ModifyVpnTunnelOptionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_monitor_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MonitorInstancesOutput, crate::error::MonitorInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::MonitorInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MonitorInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_monitor_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MonitorInstancesOutput, crate::error::MonitorInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::monitor_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_monitor_instances(response.body().as_ref(), output).map_err(crate::error::MonitorInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_address_to_vpc_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MoveAddressToVpcOutput, crate::error::MoveAddressToVpcError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::MoveAddressToVpcError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MoveAddressToVpcError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_address_to_vpc_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MoveAddressToVpcOutput, crate::error::MoveAddressToVpcError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::move_address_to_vpc_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_move_address_to_vpc(response.body().as_ref(), output).map_err(crate::error::MoveAddressToVpcError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_byoip_cidr_to_ipam_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MoveByoipCidrToIpamOutput, crate::error::MoveByoipCidrToIpamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::MoveByoipCidrToIpamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::MoveByoipCidrToIpamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_move_byoip_cidr_to_ipam_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MoveByoipCidrToIpamOutput, crate::error::MoveByoipCidrToIpamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::move_byoip_cidr_to_ipam_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_move_byoip_cidr_to_ipam(response.body().as_ref(), output).map_err(crate::error::MoveByoipCidrToIpamError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_byoip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionByoipCidrOutput, crate::error::ProvisionByoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ProvisionByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_byoip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionByoipCidrOutput, crate::error::ProvisionByoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_byoip_cidr(response.body().as_ref(), output).map_err(crate::error::ProvisionByoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_ipam_pool_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionIpamPoolCidrOutput, crate::error::ProvisionIpamPoolCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ProvisionIpamPoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionIpamPoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_ipam_pool_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionIpamPoolCidrOutput, crate::error::ProvisionIpamPoolCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_ipam_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_ipam_pool_cidr(response.body().as_ref(), output).map_err(crate::error::ProvisionIpamPoolCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_public_ipv4_pool_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionPublicIpv4PoolCidrOutput, crate::error::ProvisionPublicIpv4PoolCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ProvisionPublicIpv4PoolCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ProvisionPublicIpv4PoolCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_provision_public_ipv4_pool_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ProvisionPublicIpv4PoolCidrOutput, crate::error::ProvisionPublicIpv4PoolCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::provision_public_ipv4_pool_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_provision_public_ipv4_pool_cidr(response.body().as_ref(), output).map_err(crate::error::ProvisionPublicIpv4PoolCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_host_reservation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseHostReservationOutput, crate::error::PurchaseHostReservationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::PurchaseHostReservationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseHostReservationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_host_reservation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseHostReservationOutput, crate::error::PurchaseHostReservationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_host_reservation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_host_reservation(response.body().as_ref(), output).map_err(crate::error::PurchaseHostReservationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_instances_offering_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseReservedInstancesOfferingOutput, crate::error::PurchaseReservedInstancesOfferingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::PurchaseReservedInstancesOfferingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseReservedInstancesOfferingError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_instances_offering_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseReservedInstancesOfferingOutput, crate::error::PurchaseReservedInstancesOfferingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_reserved_instances_offering_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_reserved_instances_offering(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedInstancesOfferingError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_scheduled_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseScheduledInstancesOutput, crate::error::PurchaseScheduledInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::PurchaseScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PurchaseScheduledInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_scheduled_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PurchaseScheduledInstancesOutput, crate::error::PurchaseScheduledInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_scheduled_instances(response.body().as_ref(), output).map_err(crate::error::PurchaseScheduledInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RebootInstancesOutput, crate::error::RebootInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RebootInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RebootInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RebootInstancesOutput, crate::error::RebootInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_instances_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_image_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterImageOutput, crate::error::RegisterImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterImageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_image_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterImageOutput, crate::error::RegisterImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_image_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_image(response.body().as_ref(), output).map_err(crate::error::RegisterImageError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_event_notification_attributes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterInstanceEventNotificationAttributesOutput, crate::error::RegisterInstanceEventNotificationAttributesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterInstanceEventNotificationAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterInstanceEventNotificationAttributesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_event_notification_attributes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterInstanceEventNotificationAttributesOutput, crate::error::RegisterInstanceEventNotificationAttributesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_instance_event_notification_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_instance_event_notification_attributes(response.body().as_ref(), output).map_err(crate::error::RegisterInstanceEventNotificationAttributesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_members_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTransitGatewayMulticastGroupMembersOutput, crate::error::RegisterTransitGatewayMulticastGroupMembersError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_members_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTransitGatewayMulticastGroupMembersOutput, crate::error::RegisterTransitGatewayMulticastGroupMembersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_transit_gateway_multicast_group_members_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_transit_gateway_multicast_group_members(response.body().as_ref(), output).map_err(crate::error::RegisterTransitGatewayMulticastGroupMembersError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_sources_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTransitGatewayMulticastGroupSourcesOutput, crate::error::RegisterTransitGatewayMulticastGroupSourcesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_transit_gateway_multicast_group_sources_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterTransitGatewayMulticastGroupSourcesOutput, crate::error::RegisterTransitGatewayMulticastGroupSourcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_transit_gateway_multicast_group_sources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_transit_gateway_multicast_group_sources(response.body().as_ref(), output).map_err(crate::error::RegisterTransitGatewayMulticastGroupSourcesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_multicast_domain_associations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayMulticastDomainAssociationsOutput, crate::error::RejectTransitGatewayMulticastDomainAssociationsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_multicast_domain_associations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayMulticastDomainAssociationsOutput, crate::error::RejectTransitGatewayMulticastDomainAssociationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_transit_gateway_multicast_domain_associations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_multicast_domain_associations(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayMulticastDomainAssociationsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_peering_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayPeeringAttachmentOutput, crate::error::RejectTransitGatewayPeeringAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RejectTransitGatewayPeeringAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayPeeringAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_peering_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayPeeringAttachmentOutput, crate::error::RejectTransitGatewayPeeringAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_transit_gateway_peering_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_peering_attachment(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayPeeringAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_vpc_attachment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayVpcAttachmentOutput, crate::error::RejectTransitGatewayVpcAttachmentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RejectTransitGatewayVpcAttachmentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectTransitGatewayVpcAttachmentError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_transit_gateway_vpc_attachment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectTransitGatewayVpcAttachmentOutput, crate::error::RejectTransitGatewayVpcAttachmentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_transit_gateway_vpc_attachment_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_transit_gateway_vpc_attachment(response.body().as_ref(), output).map_err(crate::error::RejectTransitGatewayVpcAttachmentError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_endpoint_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectVpcEndpointConnectionsOutput, crate::error::RejectVpcEndpointConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RejectVpcEndpointConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectVpcEndpointConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_endpoint_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectVpcEndpointConnectionsOutput, crate::error::RejectVpcEndpointConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_vpc_endpoint_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_vpc_endpoint_connections(response.body().as_ref(), output).map_err(crate::error::RejectVpcEndpointConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_peering_connection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectVpcPeeringConnectionOutput, crate::error::RejectVpcPeeringConnectionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RejectVpcPeeringConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RejectVpcPeeringConnectionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_vpc_peering_connection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RejectVpcPeeringConnectionOutput, crate::error::RejectVpcPeeringConnectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_vpc_peering_connection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_vpc_peering_connection(response.body().as_ref(), output).map_err(crate::error::RejectVpcPeeringConnectionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_address_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseAddressOutput, crate::error::ReleaseAddressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReleaseAddressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseAddressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_address_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseAddressOutput, crate::error::ReleaseAddressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_address_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_hosts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseHostsOutput, crate::error::ReleaseHostsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReleaseHostsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseHostsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_hosts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseHostsOutput, crate::error::ReleaseHostsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_hosts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_release_hosts(response.body().as_ref(), output).map_err(crate::error::ReleaseHostsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_ipam_pool_allocation_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseIpamPoolAllocationOutput, crate::error::ReleaseIpamPoolAllocationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReleaseIpamPoolAllocationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReleaseIpamPoolAllocationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_release_ipam_pool_allocation_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReleaseIpamPoolAllocationOutput, crate::error::ReleaseIpamPoolAllocationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::release_ipam_pool_allocation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_release_ipam_pool_allocation(response.body().as_ref(), output).map_err(crate::error::ReleaseIpamPoolAllocationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_iam_instance_profile_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceIamInstanceProfileAssociationOutput, crate::error::ReplaceIamInstanceProfileAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceIamInstanceProfileAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceIamInstanceProfileAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_iam_instance_profile_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceIamInstanceProfileAssociationOutput, crate::error::ReplaceIamInstanceProfileAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_iam_instance_profile_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_iam_instance_profile_association(response.body().as_ref(), output).map_err(crate::error::ReplaceIamInstanceProfileAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceNetworkAclAssociationOutput, crate::error::ReplaceNetworkAclAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceNetworkAclAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceNetworkAclAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceNetworkAclAssociationOutput, crate::error::ReplaceNetworkAclAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_network_acl_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_network_acl_association(response.body().as_ref(), output).map_err(crate::error::ReplaceNetworkAclAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_entry_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceNetworkAclEntryOutput, crate::error::ReplaceNetworkAclEntryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceNetworkAclEntryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceNetworkAclEntryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_network_acl_entry_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceNetworkAclEntryOutput, crate::error::ReplaceNetworkAclEntryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_network_acl_entry_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceRouteOutput, crate::error::ReplaceRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceRouteOutput, crate::error::ReplaceRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_route_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_table_association_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceRouteTableAssociationOutput, crate::error::ReplaceRouteTableAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceRouteTableAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceRouteTableAssociationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_route_table_association_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceRouteTableAssociationOutput, crate::error::ReplaceRouteTableAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_route_table_association_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_route_table_association(response.body().as_ref(), output).map_err(crate::error::ReplaceRouteTableAssociationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_transit_gateway_route_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceTransitGatewayRouteOutput, crate::error::ReplaceTransitGatewayRouteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReplaceTransitGatewayRouteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReplaceTransitGatewayRouteError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_replace_transit_gateway_route_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReplaceTransitGatewayRouteOutput, crate::error::ReplaceTransitGatewayRouteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::replace_transit_gateway_route_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_replace_transit_gateway_route(response.body().as_ref(), output).map_err(crate::error::ReplaceTransitGatewayRouteError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_instance_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReportInstanceStatusOutput, crate::error::ReportInstanceStatusError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ReportInstanceStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ReportInstanceStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_instance_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ReportInstanceStatusOutput, crate::error::ReportInstanceStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::report_instance_status_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestSpotFleetOutput, crate::error::RequestSpotFleetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RequestSpotFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RequestSpotFleetError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestSpotFleetOutput, crate::error::RequestSpotFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::request_spot_fleet_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_request_spot_fleet(response.body().as_ref(), output).map_err(crate::error::RequestSpotFleetError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestSpotInstancesOutput, crate::error::RequestSpotInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RequestSpotInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RequestSpotInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_request_spot_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RequestSpotInstancesOutput, crate::error::RequestSpotInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::request_spot_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_request_spot_instances(response.body().as_ref(), output).map_err(crate::error::RequestSpotInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_address_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetAddressAttributeOutput, crate::error::ResetAddressAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetAddressAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetAddressAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_address_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetAddressAttributeOutput, crate::error::ResetAddressAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_address_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_address_attribute(response.body().as_ref(), output).map_err(crate::error::ResetAddressAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_ebs_default_kms_key_id_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetEbsDefaultKmsKeyIdOutput, crate::error::ResetEbsDefaultKmsKeyIdError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetEbsDefaultKmsKeyIdError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetEbsDefaultKmsKeyIdError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_ebs_default_kms_key_id_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetEbsDefaultKmsKeyIdOutput, crate::error::ResetEbsDefaultKmsKeyIdError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_ebs_default_kms_key_id_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_ebs_default_kms_key_id(response.body().as_ref(), output).map_err(crate::error::ResetEbsDefaultKmsKeyIdError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_fpga_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetFpgaImageAttributeOutput, crate::error::ResetFpgaImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetFpgaImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetFpgaImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_fpga_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetFpgaImageAttributeOutput, crate::error::ResetFpgaImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_fpga_image_attribute_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_fpga_image_attribute(response.body().as_ref(), output).map_err(crate::error::ResetFpgaImageAttributeError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_image_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetImageAttributeOutput, crate::error::ResetImageAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetImageAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetImageAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_image_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetImageAttributeOutput, crate::error::ResetImageAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_image_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_instance_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetInstanceAttributeOutput, crate::error::ResetInstanceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetInstanceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetInstanceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_instance_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetInstanceAttributeOutput, crate::error::ResetInstanceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_instance_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_network_interface_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetNetworkInterfaceAttributeOutput, crate::error::ResetNetworkInterfaceAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetNetworkInterfaceAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetNetworkInterfaceAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_network_interface_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetNetworkInterfaceAttributeOutput, crate::error::ResetNetworkInterfaceAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_network_interface_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_snapshot_attribute_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetSnapshotAttributeOutput, crate::error::ResetSnapshotAttributeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::ResetSnapshotAttributeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ResetSnapshotAttributeError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_snapshot_attribute_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ResetSnapshotAttributeOutput, crate::error::ResetSnapshotAttributeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_snapshot_attribute_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_address_to_classic_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreAddressToClassicOutput, crate::error::RestoreAddressToClassicError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RestoreAddressToClassicError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreAddressToClassicError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_address_to_classic_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreAddressToClassicOutput, crate::error::RestoreAddressToClassicError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_address_to_classic_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_address_to_classic(response.body().as_ref(), output).map_err(crate::error::RestoreAddressToClassicError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_image_from_recycle_bin_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreImageFromRecycleBinOutput, crate::error::RestoreImageFromRecycleBinError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RestoreImageFromRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreImageFromRecycleBinError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_image_from_recycle_bin_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreImageFromRecycleBinOutput, crate::error::RestoreImageFromRecycleBinError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_image_from_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_image_from_recycle_bin(response.body().as_ref(), output).map_err(crate::error::RestoreImageFromRecycleBinError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_managed_prefix_list_version_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreManagedPrefixListVersionOutput, crate::error::RestoreManagedPrefixListVersionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RestoreManagedPrefixListVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreManagedPrefixListVersionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_managed_prefix_list_version_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreManagedPrefixListVersionOutput, crate::error::RestoreManagedPrefixListVersionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_managed_prefix_list_version_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_managed_prefix_list_version(response.body().as_ref(), output).map_err(crate::error::RestoreManagedPrefixListVersionError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_from_recycle_bin_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreSnapshotFromRecycleBinOutput, crate::error::RestoreSnapshotFromRecycleBinError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RestoreSnapshotFromRecycleBinError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreSnapshotFromRecycleBinError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_from_recycle_bin_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreSnapshotFromRecycleBinOutput, crate::error::RestoreSnapshotFromRecycleBinError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_snapshot_from_recycle_bin_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_snapshot_from_recycle_bin(response.body().as_ref(), output).map_err(crate::error::RestoreSnapshotFromRecycleBinError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_tier_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreSnapshotTierOutput, crate::error::RestoreSnapshotTierError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RestoreSnapshotTierError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RestoreSnapshotTierError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_snapshot_tier_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RestoreSnapshotTierOutput, crate::error::RestoreSnapshotTierError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_snapshot_tier_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_snapshot_tier(response.body().as_ref(), output).map_err(crate::error::RestoreSnapshotTierError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_client_vpn_ingress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeClientVpnIngressOutput, crate::error::RevokeClientVpnIngressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RevokeClientVpnIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeClientVpnIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_client_vpn_ingress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeClientVpnIngressOutput, crate::error::RevokeClientVpnIngressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_client_vpn_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_client_vpn_ingress(response.body().as_ref(), output).map_err(crate::error::RevokeClientVpnIngressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_egress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeSecurityGroupEgressOutput, crate::error::RevokeSecurityGroupEgressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RevokeSecurityGroupEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeSecurityGroupEgressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_egress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeSecurityGroupEgressOutput, crate::error::RevokeSecurityGroupEgressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_security_group_egress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_security_group_egress(response.body().as_ref(), output).map_err(crate::error::RevokeSecurityGroupEgressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_ingress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeSecurityGroupIngressOutput, crate::error::RevokeSecurityGroupIngressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RevokeSecurityGroupIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RevokeSecurityGroupIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_security_group_ingress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RevokeSecurityGroupIngressOutput, crate::error::RevokeSecurityGroupIngressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_security_group_ingress(response.body().as_ref(), output).map_err(crate::error::RevokeSecurityGroupIngressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunInstancesOutput, crate::error::RunInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RunInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RunInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunInstancesOutput, crate::error::RunInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_run_instances(response.body().as_ref(), output).map_err(crate::error::RunInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_scheduled_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunScheduledInstancesOutput, crate::error::RunScheduledInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::RunScheduledInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::RunScheduledInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_scheduled_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunScheduledInstancesOutput, crate::error::RunScheduledInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_scheduled_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_run_scheduled_instances(response.body().as_ref(), output).map_err(crate::error::RunScheduledInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_local_gateway_routes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchLocalGatewayRoutesOutput, crate::error::SearchLocalGatewayRoutesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::SearchLocalGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchLocalGatewayRoutesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_local_gateway_routes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchLocalGatewayRoutesOutput, crate::error::SearchLocalGatewayRoutesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_local_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_local_gateway_routes(response.body().as_ref(), output).map_err(crate::error::SearchLocalGatewayRoutesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_multicast_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchTransitGatewayMulticastGroupsOutput, crate::error::SearchTransitGatewayMulticastGroupsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::SearchTransitGatewayMulticastGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchTransitGatewayMulticastGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_multicast_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchTransitGatewayMulticastGroupsOutput, crate::error::SearchTransitGatewayMulticastGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_transit_gateway_multicast_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_transit_gateway_multicast_groups(response.body().as_ref(), output).map_err(crate::error::SearchTransitGatewayMulticastGroupsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_routes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchTransitGatewayRoutesOutput, crate::error::SearchTransitGatewayRoutesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::SearchTransitGatewayRoutesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchTransitGatewayRoutesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_transit_gateway_routes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SearchTransitGatewayRoutesOutput, crate::error::SearchTransitGatewayRoutesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_transit_gateway_routes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_search_transit_gateway_routes(response.body().as_ref(), output).map_err(crate::error::SearchTransitGatewayRoutesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_diagnostic_interrupt_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendDiagnosticInterruptOutput, crate::error::SendDiagnosticInterruptError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::SendDiagnosticInterruptError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SendDiagnosticInterruptError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_diagnostic_interrupt_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SendDiagnosticInterruptOutput, crate::error::SendDiagnosticInterruptError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_diagnostic_interrupt_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartInstancesOutput, crate::error::StartInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::StartInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartInstancesOutput, crate::error::StartInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_instances(response.body().as_ref(), output).map_err(crate::error::StartInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_access_scope_analysis_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNetworkInsightsAccessScopeAnalysisOutput, crate::error::StartNetworkInsightsAccessScopeAnalysisError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_access_scope_analysis_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNetworkInsightsAccessScopeAnalysisOutput, crate::error::StartNetworkInsightsAccessScopeAnalysisError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_network_insights_access_scope_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_network_insights_access_scope_analysis(response.body().as_ref(), output).map_err(crate::error::StartNetworkInsightsAccessScopeAnalysisError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_analysis_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNetworkInsightsAnalysisOutput, crate::error::StartNetworkInsightsAnalysisError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::StartNetworkInsightsAnalysisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartNetworkInsightsAnalysisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_network_insights_analysis_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNetworkInsightsAnalysisOutput, crate::error::StartNetworkInsightsAnalysisError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_network_insights_analysis_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_network_insights_analysis(response.body().as_ref(), output).map_err(crate::error::StartNetworkInsightsAnalysisError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_vpc_endpoint_service_private_dns_verification_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartVpcEndpointServicePrivateDnsVerificationOutput, crate::error::StartVpcEndpointServicePrivateDnsVerificationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_vpc_endpoint_service_private_dns_verification_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartVpcEndpointServicePrivateDnsVerificationOutput, crate::error::StartVpcEndpointServicePrivateDnsVerificationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_vpc_endpoint_service_private_dns_verification_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_start_vpc_endpoint_service_private_dns_verification(response.body().as_ref(), output).map_err(crate::error::StartVpcEndpointServicePrivateDnsVerificationError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopInstancesOutput, crate::error::StopInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::StopInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StopInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopInstancesOutput, crate::error::StopInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_stop_instances(response.body().as_ref(), output).map_err(crate::error::StopInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_client_vpn_connections_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateClientVpnConnectionsOutput, crate::error::TerminateClientVpnConnectionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::TerminateClientVpnConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::TerminateClientVpnConnectionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_client_vpn_connections_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateClientVpnConnectionsOutput, crate::error::TerminateClientVpnConnectionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_client_vpn_connections_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_terminate_client_vpn_connections(response.body().as_ref(), output).map_err(crate::error::TerminateClientVpnConnectionsError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateInstancesOutput, crate::error::TerminateInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::TerminateInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::TerminateInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateInstancesOutput, crate::error::TerminateInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_terminate_instances(response.body().as_ref(), output).map_err(crate::error::TerminateInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_ipv6_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignIpv6AddressesOutput, crate::error::UnassignIpv6AddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::UnassignIpv6AddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnassignIpv6AddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_ipv6_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignIpv6AddressesOutput, crate::error::UnassignIpv6AddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_ipv6_addresses_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_unassign_ipv6_addresses(response.body().as_ref(), output).map_err(crate::error::UnassignIpv6AddressesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_private_ip_addresses_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignPrivateIpAddressesOutput, crate::error::UnassignPrivateIpAddressesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::UnassignPrivateIpAddressesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnassignPrivateIpAddressesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_private_ip_addresses_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignPrivateIpAddressesOutput, crate::error::UnassignPrivateIpAddressesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_private_ip_addresses_output::Builder::default();
        let _ = response;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmonitor_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnmonitorInstancesOutput, crate::error::UnmonitorInstancesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::UnmonitorInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UnmonitorInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmonitor_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnmonitorInstancesOutput, crate::error::UnmonitorInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unmonitor_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_unmonitor_instances(response.body().as_ref(), output).map_err(crate::error::UnmonitorInstancesError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_egress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSecurityGroupRuleDescriptionsEgressOutput, crate::error::UpdateSecurityGroupRuleDescriptionsEgressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_egress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSecurityGroupRuleDescriptionsEgressOutput, crate::error::UpdateSecurityGroupRuleDescriptionsEgressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_security_group_rule_descriptions_egress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_security_group_rule_descriptions_egress(response.body().as_ref(), output).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsEgressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_ingress_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSecurityGroupRuleDescriptionsIngressOutput, crate::error::UpdateSecurityGroupRuleDescriptionsIngressError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_security_group_rule_descriptions_ingress_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSecurityGroupRuleDescriptionsIngressOutput, crate::error::UpdateSecurityGroupRuleDescriptionsIngressError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_security_group_rule_descriptions_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_security_group_rule_descriptions_ingress(response.body().as_ref(), output).map_err(crate::error::UpdateSecurityGroupRuleDescriptionsIngressError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_withdraw_byoip_cidr_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::WithdrawByoipCidrOutput, crate::error::WithdrawByoipCidrError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response).map_err(crate::error::WithdrawByoipCidrError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::WithdrawByoipCidrError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_withdraw_byoip_cidr_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::WithdrawByoipCidrOutput, crate::error::WithdrawByoipCidrError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::withdraw_byoip_cidr_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_withdraw_byoip_cidr(response.body().as_ref(), output).map_err(crate::error::WithdrawByoipCidrError::unhandled)?;
        output._set_request_id(aws_http::request_id::RequestId::request_id(response).map(str::to_string));
        output.build()
    })
}

