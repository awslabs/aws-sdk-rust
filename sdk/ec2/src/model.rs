// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Information about an address range that is provisioned for use with your Amazon Web Services resources
/// through bring your own IP addresses (BYOIP).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ByoipCidr {
    /// <p>The address range, in CIDR notation.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The description of the address range.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Upon success, contains the ID of the address pool. Otherwise, contains an error message.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The state of the address pool.</p>
    pub state: std::option::Option<crate::model::ByoipCidrState>,
}
impl std::fmt::Debug for ByoipCidr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ByoipCidr");
        formatter.field("cidr", &self.cidr);
        formatter.field("description", &self.description);
        formatter.field("status_message", &self.status_message);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`ByoipCidr`](crate::model::ByoipCidr)
pub mod byoip_cidr {
    /// A builder for [`ByoipCidr`](crate::model::ByoipCidr)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ByoipCidrState>,
    }
    impl Builder {
        /// <p>The address range, in CIDR notation.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>The description of the address range.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Upon success, contains the ID of the address pool. Otherwise, contains an error message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The state of the address pool.</p>
        pub fn state(mut self, input: crate::model::ByoipCidrState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ByoipCidrState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ByoipCidr`](crate::model::ByoipCidr)
        pub fn build(self) -> crate::model::ByoipCidr {
            crate::model::ByoipCidr {
                cidr: self.cidr,
                description: self.description,
                status_message: self.status_message,
                state: self.state,
            }
        }
    }
}
impl ByoipCidr {
    /// Creates a new builder-style object to manufacture [`ByoipCidr`](crate::model::ByoipCidr)
    pub fn builder() -> crate::model::byoip_cidr::Builder {
        crate::model::byoip_cidr::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ByoipCidrState {
    Advertised,
    Deprovisioned,
    FailedDeprovision,
    FailedProvision,
    PendingDeprovision,
    PendingProvision,
    Provisioned,
    ProvisionedNotPubliclyAdvertisable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ByoipCidrState {
    fn from(s: &str) -> Self {
        match s {
            "advertised" => ByoipCidrState::Advertised,
            "deprovisioned" => ByoipCidrState::Deprovisioned,
            "failed-deprovision" => ByoipCidrState::FailedDeprovision,
            "failed-provision" => ByoipCidrState::FailedProvision,
            "pending-deprovision" => ByoipCidrState::PendingDeprovision,
            "pending-provision" => ByoipCidrState::PendingProvision,
            "provisioned" => ByoipCidrState::Provisioned,
            "provisioned-not-publicly-advertisable" => {
                ByoipCidrState::ProvisionedNotPubliclyAdvertisable
            }
            other => ByoipCidrState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ByoipCidrState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ByoipCidrState::from(s))
    }
}
impl ByoipCidrState {
    pub fn as_str(&self) -> &str {
        match self {
            ByoipCidrState::Advertised => "advertised",
            ByoipCidrState::Deprovisioned => "deprovisioned",
            ByoipCidrState::FailedDeprovision => "failed-deprovision",
            ByoipCidrState::FailedProvision => "failed-provision",
            ByoipCidrState::PendingDeprovision => "pending-deprovision",
            ByoipCidrState::PendingProvision => "pending-provision",
            ByoipCidrState::Provisioned => "provisioned",
            ByoipCidrState::ProvisionedNotPubliclyAdvertisable => {
                "provisioned-not-publicly-advertisable"
            }
            ByoipCidrState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "advertised",
            "deprovisioned",
            "failed-deprovision",
            "failed-provision",
            "pending-deprovision",
            "pending-provision",
            "provisioned",
            "provisioned-not-publicly-advertisable",
        ]
    }
}
impl AsRef<str> for ByoipCidrState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the description of a security group rule.</p>
/// <p>You can use this when you want to update the security group rule description for either an inbound or outbound rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRuleDescription {
    /// <p>The ID of the security group rule.</p>
    pub security_group_rule_id: std::option::Option<std::string::String>,
    /// <p>The description of the security group rule.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityGroupRuleDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRuleDescription");
        formatter.field("security_group_rule_id", &self.security_group_rule_id);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
pub mod security_group_rule_description {
    /// A builder for [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_rule_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the security group rule.</p>
        pub fn security_group_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_group_rule_id = Some(input.into());
            self
        }
        pub fn set_security_group_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_group_rule_id = input;
            self
        }
        /// <p>The description of the security group rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
        pub fn build(self) -> crate::model::SecurityGroupRuleDescription {
            crate::model::SecurityGroupRuleDescription {
                security_group_rule_id: self.security_group_rule_id,
                description: self.description,
            }
        }
    }
}
impl SecurityGroupRuleDescription {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRuleDescription`](crate::model::SecurityGroupRuleDescription)
    pub fn builder() -> crate::model::security_group_rule_description::Builder {
        crate::model::security_group_rule_description::Builder::default()
    }
}

/// <p>Describes a set of permissions for a security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpPermission {
    /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
    /// A value of <code>-1</code> indicates all ICMP/ICMPv6 types. If you specify all
    /// ICMP/ICMPv6 types, you must specify all codes.</p>
    pub from_port: std::option::Option<i32>,
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>)
    /// or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>).</p>
    /// <p>[VPC only] Use <code>-1</code> to specify all protocols. When authorizing
    /// security group rules, specifying <code>-1</code> or a protocol number other than
    /// <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows
    /// traffic on all ports, regardless of any port range you specify. For <code>tcp</code>,
    /// <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>icmpv6</code>,
    /// the port range is optional; if you omit the port range, traffic for all types and codes is allowed.</p>
    pub ip_protocol: std::option::Option<std::string::String>,
    /// <p>The IPv4 ranges.</p>
    pub ip_ranges: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
    /// <p>[VPC only] The IPv6 ranges.</p>
    pub ipv6_ranges: std::option::Option<std::vec::Vec<crate::model::Ipv6Range>>,
    /// <p>[VPC only] The prefix list IDs.</p>
    pub prefix_list_ids: std::option::Option<std::vec::Vec<crate::model::PrefixListId>>,
    /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value
    /// of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types,
    /// you must specify all codes.</p>
    pub to_port: std::option::Option<i32>,
    /// <p>The security group and Amazon Web Services account ID pairs.</p>
    pub user_id_group_pairs: std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
}
impl std::fmt::Debug for IpPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpPermission");
        formatter.field("from_port", &self.from_port);
        formatter.field("ip_protocol", &self.ip_protocol);
        formatter.field("ip_ranges", &self.ip_ranges);
        formatter.field("ipv6_ranges", &self.ipv6_ranges);
        formatter.field("prefix_list_ids", &self.prefix_list_ids);
        formatter.field("to_port", &self.to_port);
        formatter.field("user_id_group_pairs", &self.user_id_group_pairs);
        formatter.finish()
    }
}
/// See [`IpPermission`](crate::model::IpPermission)
pub mod ip_permission {
    /// A builder for [`IpPermission`](crate::model::IpPermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) ip_protocol: std::option::Option<std::string::String>,
        pub(crate) ip_ranges: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
        pub(crate) ipv6_ranges: std::option::Option<std::vec::Vec<crate::model::Ipv6Range>>,
        pub(crate) prefix_list_ids: std::option::Option<std::vec::Vec<crate::model::PrefixListId>>,
        pub(crate) to_port: std::option::Option<i32>,
        pub(crate) user_id_group_pairs:
            std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
    }
    impl Builder {
        /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.
        /// A value of <code>-1</code> indicates all ICMP/ICMPv6 types. If you specify all
        /// ICMP/ICMPv6 types, you must specify all codes.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>)
        /// or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>).</p>
        /// <p>[VPC only] Use <code>-1</code> to specify all protocols. When authorizing
        /// security group rules, specifying <code>-1</code> or a protocol number other than
        /// <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows
        /// traffic on all ports, regardless of any port range you specify. For <code>tcp</code>,
        /// <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>icmpv6</code>,
        /// the port range is optional; if you omit the port range, traffic for all types and codes is allowed.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_protocol = Some(input.into());
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_protocol = input;
            self
        }
        pub fn ip_ranges(mut self, input: impl Into<crate::model::IpRange>) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input.into());
            self.ip_ranges = Some(v);
            self
        }
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        pub fn ipv6_ranges(mut self, input: impl Into<crate::model::Ipv6Range>) -> Self {
            let mut v = self.ipv6_ranges.unwrap_or_default();
            v.push(input.into());
            self.ipv6_ranges = Some(v);
            self
        }
        pub fn set_ipv6_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6Range>>,
        ) -> Self {
            self.ipv6_ranges = input;
            self
        }
        pub fn prefix_list_ids(mut self, input: impl Into<crate::model::PrefixListId>) -> Self {
            let mut v = self.prefix_list_ids.unwrap_or_default();
            v.push(input.into());
            self.prefix_list_ids = Some(v);
            self
        }
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrefixListId>>,
        ) -> Self {
            self.prefix_list_ids = input;
            self
        }
        /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value
        /// of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types,
        /// you must specify all codes.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        pub fn user_id_group_pairs(
            mut self,
            input: impl Into<crate::model::UserIdGroupPair>,
        ) -> Self {
            let mut v = self.user_id_group_pairs.unwrap_or_default();
            v.push(input.into());
            self.user_id_group_pairs = Some(v);
            self
        }
        pub fn set_user_id_group_pairs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
        ) -> Self {
            self.user_id_group_pairs = input;
            self
        }
        /// Consumes the builder and constructs a [`IpPermission`](crate::model::IpPermission)
        pub fn build(self) -> crate::model::IpPermission {
            crate::model::IpPermission {
                from_port: self.from_port,
                ip_protocol: self.ip_protocol,
                ip_ranges: self.ip_ranges,
                ipv6_ranges: self.ipv6_ranges,
                prefix_list_ids: self.prefix_list_ids,
                to_port: self.to_port,
                user_id_group_pairs: self.user_id_group_pairs,
            }
        }
    }
}
impl IpPermission {
    /// Creates a new builder-style object to manufacture [`IpPermission`](crate::model::IpPermission)
    pub fn builder() -> crate::model::ip_permission::Builder {
        crate::model::ip_permission::Builder::default()
    }
}

/// <p>Describes a security group and Amazon Web Services account ID pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserIdGroupPair {
    /// <p>A description for the security group rule that references this user ID group
    /// pair.</p>
    /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
    /// spaces, and ._-:/()#,@[]+=;{}!$*</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the security group. In a request, use this parameter for a security group
    /// in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the
    /// security group ID. </p>
    /// <p>For a referenced security group in another VPC, this value is not returned if the
    /// referenced security group is deleted.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The status of a VPC peering connection, if applicable.</p>
    pub peering_status: std::option::Option<std::string::String>,
    /// <p>The ID of an Amazon Web Services account.</p>
    /// <p>For a referenced security group in another VPC, the account ID of the referenced
    /// security group is returned in the response. If the referenced security group is deleted,
    /// this value is not returned.</p>
    /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group
    /// in another Amazon Web Services account.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC peering connection, if applicable.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserIdGroupPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserIdGroupPair");
        formatter.field("description", &self.description);
        formatter.field("group_id", &self.group_id);
        formatter.field("group_name", &self.group_name);
        formatter.field("peering_status", &self.peering_status);
        formatter.field("user_id", &self.user_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`UserIdGroupPair`](crate::model::UserIdGroupPair)
pub mod user_id_group_pair {
    /// A builder for [`UserIdGroupPair`](crate::model::UserIdGroupPair)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) peering_status: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description for the security group rule that references this user ID group
        /// pair.</p>
        /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
        /// spaces, and ._-:/()#,@[]+=;{}!$*</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the security group. In a request, use this parameter for a security group
        /// in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the
        /// security group ID. </p>
        /// <p>For a referenced security group in another VPC, this value is not returned if the
        /// referenced security group is deleted.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The status of a VPC peering connection, if applicable.</p>
        pub fn peering_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_status = Some(input.into());
            self
        }
        pub fn set_peering_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.peering_status = input;
            self
        }
        /// <p>The ID of an Amazon Web Services account.</p>
        /// <p>For a referenced security group in another VPC, the account ID of the referenced
        /// security group is returned in the response. If the referenced security group is deleted,
        /// this value is not returned.</p>
        /// <p>[EC2-Classic] Required when adding or removing rules that reference a security group
        /// in another Amazon Web Services account.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The ID of the VPC for the referenced security group, if applicable.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the VPC peering connection, if applicable.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserIdGroupPair`](crate::model::UserIdGroupPair)
        pub fn build(self) -> crate::model::UserIdGroupPair {
            crate::model::UserIdGroupPair {
                description: self.description,
                group_id: self.group_id,
                group_name: self.group_name,
                peering_status: self.peering_status,
                user_id: self.user_id,
                vpc_id: self.vpc_id,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl UserIdGroupPair {
    /// Creates a new builder-style object to manufacture [`UserIdGroupPair`](crate::model::UserIdGroupPair)
    pub fn builder() -> crate::model::user_id_group_pair::Builder {
        crate::model::user_id_group_pair::Builder::default()
    }
}

/// <p>Describes a prefix list ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrefixListId {
    /// <p>A description for the security group rule that references this prefix list ID.</p>
    /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
    /// spaces, and ._-:/()#,@[]+=;{}!$*</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrefixListId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrefixListId");
        formatter.field("description", &self.description);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.finish()
    }
}
/// See [`PrefixListId`](crate::model::PrefixListId)
pub mod prefix_list_id {
    /// A builder for [`PrefixListId`](crate::model::PrefixListId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description for the security group rule that references this prefix list ID.</p>
        /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
        /// spaces, and ._-:/()#,@[]+=;{}!$*</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the prefix.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefixListId`](crate::model::PrefixListId)
        pub fn build(self) -> crate::model::PrefixListId {
            crate::model::PrefixListId {
                description: self.description,
                prefix_list_id: self.prefix_list_id,
            }
        }
    }
}
impl PrefixListId {
    /// Creates a new builder-style object to manufacture [`PrefixListId`](crate::model::PrefixListId)
    pub fn builder() -> crate::model::prefix_list_id::Builder {
        crate::model::prefix_list_id::Builder::default()
    }
}

/// <p>[EC2-VPC only] Describes an IPv6 range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6Range {
    /// <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group,
    /// not both. To specify a single IPv6 address, use the /128 prefix length.</p>
    pub cidr_ipv6: std::option::Option<std::string::String>,
    /// <p>A description for the security group rule that references this IPv6 address range.</p>
    /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
    /// spaces, and ._-:/()#,@[]+=&;{}!$*</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6Range");
        formatter.field("cidr_ipv6", &self.cidr_ipv6);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`Ipv6Range`](crate::model::Ipv6Range)
pub mod ipv6_range {
    /// A builder for [`Ipv6Range`](crate::model::Ipv6Range)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_ipv6: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group,
        /// not both. To specify a single IPv6 address, use the /128 prefix length.</p>
        pub fn cidr_ipv6(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv6 = Some(input.into());
            self
        }
        pub fn set_cidr_ipv6(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv6 = input;
            self
        }
        /// <p>A description for the security group rule that references this IPv6 address range.</p>
        /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
        /// spaces, and ._-:/()#,@[]+=&;{}!$*</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6Range`](crate::model::Ipv6Range)
        pub fn build(self) -> crate::model::Ipv6Range {
            crate::model::Ipv6Range {
                cidr_ipv6: self.cidr_ipv6,
                description: self.description,
            }
        }
    }
}
impl Ipv6Range {
    /// Creates a new builder-style object to manufacture [`Ipv6Range`](crate::model::Ipv6Range)
    pub fn builder() -> crate::model::ipv6_range::Builder {
        crate::model::ipv6_range::Builder::default()
    }
}

/// <p>Describes an IPv4 range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpRange {
    /// <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group,
    /// not both. To specify a single IPv4 address, use the /32 prefix length.</p>
    pub cidr_ip: std::option::Option<std::string::String>,
    /// <p>A description for the security group rule that references this IPv4 address range.</p>
    /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
    /// spaces, and ._-:/()#,@[]+=&;{}!$*</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpRange");
        formatter.field("cidr_ip", &self.cidr_ip);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`IpRange`](crate::model::IpRange)
pub mod ip_range {
    /// A builder for [`IpRange`](crate::model::IpRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_ip: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group,
        /// not both. To specify a single IPv4 address, use the /32 prefix length.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ip = Some(input.into());
            self
        }
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ip = input;
            self
        }
        /// <p>A description for the security group rule that references this IPv4 address range.</p>
        /// <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9,
        /// spaces, and ._-:/()#,@[]+=&;{}!$*</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`IpRange`](crate::model::IpRange)
        pub fn build(self) -> crate::model::IpRange {
            crate::model::IpRange {
                cidr_ip: self.cidr_ip,
                description: self.description,
            }
        }
    }
}
impl IpRange {
    /// Creates a new builder-style object to manufacture [`IpRange`](crate::model::IpRange)
    pub fn builder() -> crate::model::ip_range::Builder {
        crate::model::ip_range::Builder::default()
    }
}

/// <p>Describes the monitoring of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMonitoring {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The monitoring for the instance.</p>
    pub monitoring: std::option::Option<crate::model::Monitoring>,
}
impl std::fmt::Debug for InstanceMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMonitoring");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("monitoring", &self.monitoring);
        formatter.finish()
    }
}
/// See [`InstanceMonitoring`](crate::model::InstanceMonitoring)
pub mod instance_monitoring {
    /// A builder for [`InstanceMonitoring`](crate::model::InstanceMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::Monitoring>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The monitoring for the instance.</p>
        pub fn monitoring(mut self, input: crate::model::Monitoring) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::Monitoring>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMonitoring`](crate::model::InstanceMonitoring)
        pub fn build(self) -> crate::model::InstanceMonitoring {
            crate::model::InstanceMonitoring {
                instance_id: self.instance_id,
                monitoring: self.monitoring,
            }
        }
    }
}
impl InstanceMonitoring {
    /// Creates a new builder-style object to manufacture [`InstanceMonitoring`](crate::model::InstanceMonitoring)
    pub fn builder() -> crate::model::instance_monitoring::Builder {
        crate::model::instance_monitoring::Builder::default()
    }
}

/// <p>Describes the monitoring of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Monitoring {
    /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
    /// enabled.</p>
    pub state: std::option::Option<crate::model::MonitoringState>,
}
impl std::fmt::Debug for Monitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Monitoring");
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`Monitoring`](crate::model::Monitoring)
pub mod monitoring {
    /// A builder for [`Monitoring`](crate::model::Monitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::MonitoringState>,
    }
    impl Builder {
        /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
        /// enabled.</p>
        pub fn state(mut self, input: crate::model::MonitoringState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::MonitoringState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`Monitoring`](crate::model::Monitoring)
        pub fn build(self) -> crate::model::Monitoring {
            crate::model::Monitoring { state: self.state }
        }
    }
}
impl Monitoring {
    /// Creates a new builder-style object to manufacture [`Monitoring`](crate::model::Monitoring)
    pub fn builder() -> crate::model::monitoring::Builder {
        crate::model::monitoring::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringState {
    Disabled,
    Disabling,
    Enabled,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => MonitoringState::Disabled,
            "disabling" => MonitoringState::Disabling,
            "enabled" => MonitoringState::Enabled,
            "pending" => MonitoringState::Pending,
            other => MonitoringState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringState::from(s))
    }
}
impl MonitoringState {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringState::Disabled => "disabled",
            MonitoringState::Disabling => "disabling",
            MonitoringState::Enabled => "enabled",
            MonitoringState::Pending => "pending",
            MonitoringState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "disabling", "enabled", "pending"]
    }
}
impl AsRef<str> for MonitoringState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an instance state change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStateChange {
    /// <p>The current state of the instance.</p>
    pub current_state: std::option::Option<crate::model::InstanceState>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The previous state of the instance.</p>
    pub previous_state: std::option::Option<crate::model::InstanceState>,
}
impl std::fmt::Debug for InstanceStateChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStateChange");
        formatter.field("current_state", &self.current_state);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("previous_state", &self.previous_state);
        formatter.finish()
    }
}
/// See [`InstanceStateChange`](crate::model::InstanceStateChange)
pub mod instance_state_change {
    /// A builder for [`InstanceStateChange`](crate::model::InstanceStateChange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_state: std::option::Option<crate::model::InstanceState>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) previous_state: std::option::Option<crate::model::InstanceState>,
    }
    impl Builder {
        /// <p>The current state of the instance.</p>
        pub fn current_state(mut self, input: crate::model::InstanceState) -> Self {
            self.current_state = Some(input);
            self
        }
        pub fn set_current_state(
            mut self,
            input: std::option::Option<crate::model::InstanceState>,
        ) -> Self {
            self.current_state = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The previous state of the instance.</p>
        pub fn previous_state(mut self, input: crate::model::InstanceState) -> Self {
            self.previous_state = Some(input);
            self
        }
        pub fn set_previous_state(
            mut self,
            input: std::option::Option<crate::model::InstanceState>,
        ) -> Self {
            self.previous_state = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStateChange`](crate::model::InstanceStateChange)
        pub fn build(self) -> crate::model::InstanceStateChange {
            crate::model::InstanceStateChange {
                current_state: self.current_state,
                instance_id: self.instance_id,
                previous_state: self.previous_state,
            }
        }
    }
}
impl InstanceStateChange {
    /// Creates a new builder-style object to manufacture [`InstanceStateChange`](crate::model::InstanceStateChange)
    pub fn builder() -> crate::model::instance_state_change::Builder {
        crate::model::instance_state_change::Builder::default()
    }
}

/// <p>Describes the current state of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceState {
    /// <p>The state of the instance as a 16-bit unsigned integer. </p>
    /// <p>The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values
    /// between 256 and 65,535. These numerical values are used for internal purposes and should
    /// be ignored.</p>
    /// <p>The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values
    /// between 0 and 255. </p>
    /// <p>The valid values for instance-state-code will all be in the range of the low byte and
    /// they are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>0</code> : <code>pending</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>16</code> : <code>running</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>32</code> : <code>shutting-down</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>48</code> : <code>terminated</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>64</code> : <code>stopping</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>80</code> : <code>stopped</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in
    /// decimal.</p>
    pub code: std::option::Option<i32>,
    /// <p>The current state of the instance.</p>
    pub name: std::option::Option<crate::model::InstanceStateName>,
}
impl std::fmt::Debug for InstanceState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceState");
        formatter.field("code", &self.code);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`InstanceState`](crate::model::InstanceState)
pub mod instance_state {
    /// A builder for [`InstanceState`](crate::model::InstanceState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<i32>,
        pub(crate) name: std::option::Option<crate::model::InstanceStateName>,
    }
    impl Builder {
        /// <p>The state of the instance as a 16-bit unsigned integer. </p>
        /// <p>The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values
        /// between 256 and 65,535. These numerical values are used for internal purposes and should
        /// be ignored.</p>
        /// <p>The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values
        /// between 0 and 255. </p>
        /// <p>The valid values for instance-state-code will all be in the range of the low byte and
        /// they are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>0</code> : <code>pending</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>16</code> : <code>running</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>32</code> : <code>shutting-down</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>48</code> : <code>terminated</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>64</code> : <code>stopping</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>80</code> : <code>stopped</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in
        /// decimal.</p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>The current state of the instance.</p>
        pub fn name(mut self, input: crate::model::InstanceStateName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::InstanceStateName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceState`](crate::model::InstanceState)
        pub fn build(self) -> crate::model::InstanceState {
            crate::model::InstanceState {
                code: self.code,
                name: self.name,
            }
        }
    }
}
impl InstanceState {
    /// Creates a new builder-style object to manufacture [`InstanceState`](crate::model::InstanceState)
    pub fn builder() -> crate::model::instance_state::Builder {
        crate::model::instance_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceStateName {
    Pending,
    Running,
    ShuttingDown,
    Stopped,
    Stopping,
    Terminated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceStateName {
    fn from(s: &str) -> Self {
        match s {
            "pending" => InstanceStateName::Pending,
            "running" => InstanceStateName::Running,
            "shutting-down" => InstanceStateName::ShuttingDown,
            "stopped" => InstanceStateName::Stopped,
            "stopping" => InstanceStateName::Stopping,
            "terminated" => InstanceStateName::Terminated,
            other => InstanceStateName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceStateName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceStateName::from(s))
    }
}
impl InstanceStateName {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceStateName::Pending => "pending",
            InstanceStateName::Running => "running",
            InstanceStateName::ShuttingDown => "shutting-down",
            InstanceStateName::Stopped => "stopped",
            InstanceStateName::Stopping => "stopping",
            InstanceStateName::Terminated => "terminated",
            InstanceStateName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "pending",
            "running",
            "shutting-down",
            "stopped",
            "stopping",
            "terminated",
        ]
    }
}
impl AsRef<str> for InstanceStateName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a terminated Client VPN endpoint client connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateConnectionStatus {
    /// <p>The ID of the client connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The state of the client connection.</p>
    pub previous_status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
    /// <p>A message about the status of the client connection, if applicable.</p>
    pub current_status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
}
impl std::fmt::Debug for TerminateConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateConnectionStatus");
        formatter.field("connection_id", &self.connection_id);
        formatter.field("previous_status", &self.previous_status);
        formatter.field("current_status", &self.current_status);
        formatter.finish()
    }
}
/// See [`TerminateConnectionStatus`](crate::model::TerminateConnectionStatus)
pub mod terminate_connection_status {
    /// A builder for [`TerminateConnectionStatus`](crate::model::TerminateConnectionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) previous_status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
        pub(crate) current_status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
    }
    impl Builder {
        /// <p>The ID of the client connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The state of the client connection.</p>
        pub fn previous_status(mut self, input: crate::model::ClientVpnConnectionStatus) -> Self {
            self.previous_status = Some(input);
            self
        }
        pub fn set_previous_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnConnectionStatus>,
        ) -> Self {
            self.previous_status = input;
            self
        }
        /// <p>A message about the status of the client connection, if applicable.</p>
        pub fn current_status(mut self, input: crate::model::ClientVpnConnectionStatus) -> Self {
            self.current_status = Some(input);
            self
        }
        pub fn set_current_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnConnectionStatus>,
        ) -> Self {
            self.current_status = input;
            self
        }
        /// Consumes the builder and constructs a [`TerminateConnectionStatus`](crate::model::TerminateConnectionStatus)
        pub fn build(self) -> crate::model::TerminateConnectionStatus {
            crate::model::TerminateConnectionStatus {
                connection_id: self.connection_id,
                previous_status: self.previous_status,
                current_status: self.current_status,
            }
        }
    }
}
impl TerminateConnectionStatus {
    /// Creates a new builder-style object to manufacture [`TerminateConnectionStatus`](crate::model::TerminateConnectionStatus)
    pub fn builder() -> crate::model::terminate_connection_status::Builder {
        crate::model::terminate_connection_status::Builder::default()
    }
}

/// <p>Describes the status of a client connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnConnectionStatus {
    /// <p>The state of the client connection.</p>
    pub code: std::option::Option<crate::model::ClientVpnConnectionStatusCode>,
    /// <p>A message about the status of the client connection, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnConnectionStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientVpnConnectionStatus`](crate::model::ClientVpnConnectionStatus)
pub mod client_vpn_connection_status {
    /// A builder for [`ClientVpnConnectionStatus`](crate::model::ClientVpnConnectionStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ClientVpnConnectionStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the client connection.</p>
        pub fn code(mut self, input: crate::model::ClientVpnConnectionStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientVpnConnectionStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the client connection, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnConnectionStatus`](crate::model::ClientVpnConnectionStatus)
        pub fn build(self) -> crate::model::ClientVpnConnectionStatus {
            crate::model::ClientVpnConnectionStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientVpnConnectionStatus {
    /// Creates a new builder-style object to manufacture [`ClientVpnConnectionStatus`](crate::model::ClientVpnConnectionStatus)
    pub fn builder() -> crate::model::client_vpn_connection_status::Builder {
        crate::model::client_vpn_connection_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnConnectionStatusCode {
    Active,
    FailedToTerminate,
    Terminated,
    Terminating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnConnectionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => ClientVpnConnectionStatusCode::Active,
            "failed-to-terminate" => ClientVpnConnectionStatusCode::FailedToTerminate,
            "terminated" => ClientVpnConnectionStatusCode::Terminated,
            "terminating" => ClientVpnConnectionStatusCode::Terminating,
            other => ClientVpnConnectionStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnConnectionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnConnectionStatusCode::from(s))
    }
}
impl ClientVpnConnectionStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnConnectionStatusCode::Active => "active",
            ClientVpnConnectionStatusCode::FailedToTerminate => "failed-to-terminate",
            ClientVpnConnectionStatusCode::Terminated => "terminated",
            ClientVpnConnectionStatusCode::Terminating => "terminating",
            ClientVpnConnectionStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "failed-to-terminate", "terminated", "terminating"]
    }
}
impl AsRef<str> for ClientVpnConnectionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network insights analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInsightsAnalysis {
    /// <p>The ID of the network insights analysis.</p>
    pub network_insights_analysis_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the network insights analysis.</p>
    pub network_insights_analysis_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the path.</p>
    pub network_insights_path_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARN) of the Amazon Web Services resources that the path must traverse.</p>
    pub filter_in_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The time the analysis started.</p>
    pub start_date: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the network insights analysis.</p>
    pub status: std::option::Option<crate::model::AnalysisStatus>,
    /// <p>The status message, if the status is <code>failed</code>.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Indicates whether the destination is reachable from the source.</p>
    pub network_path_found: std::option::Option<bool>,
    /// <p>The components in the path from source to destination.</p>
    pub forward_path_components: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
    /// <p>The components in the path from destination to source.</p>
    pub return_path_components: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
    /// <p>The explanations. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html">Reachability Analyzer explanation codes</a>.</p>
    pub explanations: std::option::Option<std::vec::Vec<crate::model::Explanation>>,
    /// <p>Potential intermediate components.</p>
    pub alternate_path_hints: std::option::Option<std::vec::Vec<crate::model::AlternatePathHint>>,
    /// <p>The tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for NetworkInsightsAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInsightsAnalysis");
        formatter.field(
            "network_insights_analysis_id",
            &self.network_insights_analysis_id,
        );
        formatter.field(
            "network_insights_analysis_arn",
            &self.network_insights_analysis_arn,
        );
        formatter.field("network_insights_path_id", &self.network_insights_path_id);
        formatter.field("filter_in_arns", &self.filter_in_arns);
        formatter.field("start_date", &self.start_date);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("network_path_found", &self.network_path_found);
        formatter.field("forward_path_components", &self.forward_path_components);
        formatter.field("return_path_components", &self.return_path_components);
        formatter.field("explanations", &self.explanations);
        formatter.field("alternate_path_hints", &self.alternate_path_hints);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`NetworkInsightsAnalysis`](crate::model::NetworkInsightsAnalysis)
pub mod network_insights_analysis {
    /// A builder for [`NetworkInsightsAnalysis`](crate::model::NetworkInsightsAnalysis)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_insights_analysis_id: std::option::Option<std::string::String>,
        pub(crate) network_insights_analysis_arn: std::option::Option<std::string::String>,
        pub(crate) network_insights_path_id: std::option::Option<std::string::String>,
        pub(crate) filter_in_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::AnalysisStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) network_path_found: std::option::Option<bool>,
        pub(crate) forward_path_components:
            std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
        pub(crate) return_path_components:
            std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
        pub(crate) explanations: std::option::Option<std::vec::Vec<crate::model::Explanation>>,
        pub(crate) alternate_path_hints:
            std::option::Option<std::vec::Vec<crate::model::AlternatePathHint>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the network insights analysis.</p>
        pub fn network_insights_analysis_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_insights_analysis_id = Some(input.into());
            self
        }
        pub fn set_network_insights_analysis_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_insights_analysis_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the network insights analysis.</p>
        pub fn network_insights_analysis_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_insights_analysis_arn = Some(input.into());
            self
        }
        pub fn set_network_insights_analysis_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_insights_analysis_arn = input;
            self
        }
        /// <p>The ID of the path.</p>
        pub fn network_insights_path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_insights_path_id = Some(input.into());
            self
        }
        pub fn set_network_insights_path_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_insights_path_id = input;
            self
        }
        pub fn filter_in_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.filter_in_arns.unwrap_or_default();
            v.push(input.into());
            self.filter_in_arns = Some(v);
            self
        }
        pub fn set_filter_in_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.filter_in_arns = input;
            self
        }
        /// <p>The time the analysis started.</p>
        pub fn start_date(mut self, input: smithy_types::Instant) -> Self {
            self.start_date = Some(input);
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The status of the network insights analysis.</p>
        pub fn status(mut self, input: crate::model::AnalysisStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AnalysisStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message, if the status is <code>failed</code>.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Indicates whether the destination is reachable from the source.</p>
        pub fn network_path_found(mut self, input: bool) -> Self {
            self.network_path_found = Some(input);
            self
        }
        pub fn set_network_path_found(mut self, input: std::option::Option<bool>) -> Self {
            self.network_path_found = input;
            self
        }
        pub fn forward_path_components(
            mut self,
            input: impl Into<crate::model::PathComponent>,
        ) -> Self {
            let mut v = self.forward_path_components.unwrap_or_default();
            v.push(input.into());
            self.forward_path_components = Some(v);
            self
        }
        pub fn set_forward_path_components(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
        ) -> Self {
            self.forward_path_components = input;
            self
        }
        pub fn return_path_components(
            mut self,
            input: impl Into<crate::model::PathComponent>,
        ) -> Self {
            let mut v = self.return_path_components.unwrap_or_default();
            v.push(input.into());
            self.return_path_components = Some(v);
            self
        }
        pub fn set_return_path_components(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
        ) -> Self {
            self.return_path_components = input;
            self
        }
        pub fn explanations(mut self, input: impl Into<crate::model::Explanation>) -> Self {
            let mut v = self.explanations.unwrap_or_default();
            v.push(input.into());
            self.explanations = Some(v);
            self
        }
        pub fn set_explanations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Explanation>>,
        ) -> Self {
            self.explanations = input;
            self
        }
        pub fn alternate_path_hints(
            mut self,
            input: impl Into<crate::model::AlternatePathHint>,
        ) -> Self {
            let mut v = self.alternate_path_hints.unwrap_or_default();
            v.push(input.into());
            self.alternate_path_hints = Some(v);
            self
        }
        pub fn set_alternate_path_hints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlternatePathHint>>,
        ) -> Self {
            self.alternate_path_hints = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInsightsAnalysis`](crate::model::NetworkInsightsAnalysis)
        pub fn build(self) -> crate::model::NetworkInsightsAnalysis {
            crate::model::NetworkInsightsAnalysis {
                network_insights_analysis_id: self.network_insights_analysis_id,
                network_insights_analysis_arn: self.network_insights_analysis_arn,
                network_insights_path_id: self.network_insights_path_id,
                filter_in_arns: self.filter_in_arns,
                start_date: self.start_date,
                status: self.status,
                status_message: self.status_message,
                network_path_found: self.network_path_found,
                forward_path_components: self.forward_path_components,
                return_path_components: self.return_path_components,
                explanations: self.explanations,
                alternate_path_hints: self.alternate_path_hints,
                tags: self.tags,
            }
        }
    }
}
impl NetworkInsightsAnalysis {
    /// Creates a new builder-style object to manufacture [`NetworkInsightsAnalysis`](crate::model::NetworkInsightsAnalysis)
    pub fn builder() -> crate::model::network_insights_analysis::Builder {
        crate::model::network_insights_analysis::Builder::default()
    }
}

/// <p>Describes a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key of the tag.</p>
    /// <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters.
    /// May not begin with <code>aws:</code>.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    /// <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag.</p>
        /// <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters.
        /// May not begin with <code>aws:</code>.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        /// <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Describes an potential intermediate component of a feasible path.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlternatePathHint {
    /// <p>The ID of the component.</p>
    pub component_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    pub component_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlternatePathHint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlternatePathHint");
        formatter.field("component_id", &self.component_id);
        formatter.field("component_arn", &self.component_arn);
        formatter.finish()
    }
}
/// See [`AlternatePathHint`](crate::model::AlternatePathHint)
pub mod alternate_path_hint {
    /// A builder for [`AlternatePathHint`](crate::model::AlternatePathHint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component_id: std::option::Option<std::string::String>,
        pub(crate) component_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the component.</p>
        pub fn component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_id = Some(input.into());
            self
        }
        pub fn set_component_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.component_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the component.</p>
        pub fn component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.component_arn = Some(input.into());
            self
        }
        pub fn set_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.component_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AlternatePathHint`](crate::model::AlternatePathHint)
        pub fn build(self) -> crate::model::AlternatePathHint {
            crate::model::AlternatePathHint {
                component_id: self.component_id,
                component_arn: self.component_arn,
            }
        }
    }
}
impl AlternatePathHint {
    /// Creates a new builder-style object to manufacture [`AlternatePathHint`](crate::model::AlternatePathHint)
    pub fn builder() -> crate::model::alternate_path_hint::Builder {
        crate::model::alternate_path_hint::Builder::default()
    }
}

/// <p>Describes an explanation code for an unreachable path. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html">Reachability Analyzer explanation codes</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Explanation {
    /// <p>The network ACL.</p>
    pub acl: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The network ACL rule.</p>
    pub acl_rule: std::option::Option<crate::model::AnalysisAclRule>,
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    pub addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The resource to which the component is attached.</p>
    pub attached_to: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The Availability Zones.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The CIDR ranges.</p>
    pub cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The component.</p>
    pub component: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The customer gateway.</p>
    pub customer_gateway: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The destination.</p>
    pub destination: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The destination VPC.</p>
    pub destination_vpc: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The direction. The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>egress</p>
    /// </li>
    /// <li>
    /// <p>ingress</p>
    /// </li>
    /// </ul>
    pub direction: std::option::Option<std::string::String>,
    /// <p>The explanation code.</p>
    pub explanation_code: std::option::Option<std::string::String>,
    /// <p>The route table.</p>
    pub ingress_route_table: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The internet gateway.</p>
    pub internet_gateway: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub load_balancer_arn: std::option::Option<std::string::String>,
    /// <p>The listener for a Classic Load Balancer.</p>
    pub classic_load_balancer_listener:
        std::option::Option<crate::model::AnalysisLoadBalancerListener>,
    /// <p>The listener port of the load balancer.</p>
    pub load_balancer_listener_port: std::option::Option<i32>,
    /// <p>The target.</p>
    pub load_balancer_target: std::option::Option<crate::model::AnalysisLoadBalancerTarget>,
    /// <p>The target group.</p>
    pub load_balancer_target_group: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The target groups.</p>
    pub load_balancer_target_groups:
        std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
    /// <p>The target port.</p>
    pub load_balancer_target_port: std::option::Option<i32>,
    /// <p>The load balancer listener.</p>
    pub elastic_load_balancer_listener: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The missing component.</p>
    pub missing_component: std::option::Option<std::string::String>,
    /// <p>The NAT gateway.</p>
    pub nat_gateway: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The network interface.</p>
    pub network_interface: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The packet field.</p>
    pub packet_field: std::option::Option<std::string::String>,
    /// <p>The VPC peering connection.</p>
    pub vpc_peering_connection: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The port.</p>
    pub port: std::option::Option<i32>,
    /// <p>The port ranges.</p>
    pub port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
    /// <p>The prefix list.</p>
    pub prefix_list: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The protocols.</p>
    pub protocols: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The route table route.</p>
    pub route_table_route: std::option::Option<crate::model::AnalysisRouteTableRoute>,
    /// <p>The route table.</p>
    pub route_table: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The security group.</p>
    pub security_group: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The security group rule.</p>
    pub security_group_rule: std::option::Option<crate::model::AnalysisSecurityGroupRule>,
    /// <p>The security groups.</p>
    pub security_groups: std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
    /// <p>The source VPC.</p>
    pub source_vpc: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The state.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The subnet.</p>
    pub subnet: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The route table for the subnet.</p>
    pub subnet_route_table: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The component VPC.</p>
    pub vpc: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The VPC endpoint.</p>
    pub vpc_endpoint: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The VPN connection.</p>
    pub vpn_connection: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The VPN gateway.</p>
    pub vpn_gateway: std::option::Option<crate::model::AnalysisComponent>,
}
impl std::fmt::Debug for Explanation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Explanation");
        formatter.field("acl", &self.acl);
        formatter.field("acl_rule", &self.acl_rule);
        formatter.field("address", &self.address);
        formatter.field("addresses", &self.addresses);
        formatter.field("attached_to", &self.attached_to);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("cidrs", &self.cidrs);
        formatter.field("component", &self.component);
        formatter.field("customer_gateway", &self.customer_gateway);
        formatter.field("destination", &self.destination);
        formatter.field("destination_vpc", &self.destination_vpc);
        formatter.field("direction", &self.direction);
        formatter.field("explanation_code", &self.explanation_code);
        formatter.field("ingress_route_table", &self.ingress_route_table);
        formatter.field("internet_gateway", &self.internet_gateway);
        formatter.field("load_balancer_arn", &self.load_balancer_arn);
        formatter.field(
            "classic_load_balancer_listener",
            &self.classic_load_balancer_listener,
        );
        formatter.field(
            "load_balancer_listener_port",
            &self.load_balancer_listener_port,
        );
        formatter.field("load_balancer_target", &self.load_balancer_target);
        formatter.field(
            "load_balancer_target_group",
            &self.load_balancer_target_group,
        );
        formatter.field(
            "load_balancer_target_groups",
            &self.load_balancer_target_groups,
        );
        formatter.field("load_balancer_target_port", &self.load_balancer_target_port);
        formatter.field(
            "elastic_load_balancer_listener",
            &self.elastic_load_balancer_listener,
        );
        formatter.field("missing_component", &self.missing_component);
        formatter.field("nat_gateway", &self.nat_gateway);
        formatter.field("network_interface", &self.network_interface);
        formatter.field("packet_field", &self.packet_field);
        formatter.field("vpc_peering_connection", &self.vpc_peering_connection);
        formatter.field("port", &self.port);
        formatter.field("port_ranges", &self.port_ranges);
        formatter.field("prefix_list", &self.prefix_list);
        formatter.field("protocols", &self.protocols);
        formatter.field("route_table_route", &self.route_table_route);
        formatter.field("route_table", &self.route_table);
        formatter.field("security_group", &self.security_group);
        formatter.field("security_group_rule", &self.security_group_rule);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("source_vpc", &self.source_vpc);
        formatter.field("state", &self.state);
        formatter.field("subnet", &self.subnet);
        formatter.field("subnet_route_table", &self.subnet_route_table);
        formatter.field("vpc", &self.vpc);
        formatter.field("vpc_endpoint", &self.vpc_endpoint);
        formatter.field("vpn_connection", &self.vpn_connection);
        formatter.field("vpn_gateway", &self.vpn_gateway);
        formatter.finish()
    }
}
/// See [`Explanation`](crate::model::Explanation)
pub mod explanation {
    /// A builder for [`Explanation`](crate::model::Explanation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acl: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) acl_rule: std::option::Option<crate::model::AnalysisAclRule>,
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) attached_to: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) component: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) customer_gateway: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) destination: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) destination_vpc: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) direction: std::option::Option<std::string::String>,
        pub(crate) explanation_code: std::option::Option<std::string::String>,
        pub(crate) ingress_route_table: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) internet_gateway: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) load_balancer_arn: std::option::Option<std::string::String>,
        pub(crate) classic_load_balancer_listener:
            std::option::Option<crate::model::AnalysisLoadBalancerListener>,
        pub(crate) load_balancer_listener_port: std::option::Option<i32>,
        pub(crate) load_balancer_target:
            std::option::Option<crate::model::AnalysisLoadBalancerTarget>,
        pub(crate) load_balancer_target_group: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) load_balancer_target_groups:
            std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
        pub(crate) load_balancer_target_port: std::option::Option<i32>,
        pub(crate) elastic_load_balancer_listener:
            std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) missing_component: std::option::Option<std::string::String>,
        pub(crate) nat_gateway: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) network_interface: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) packet_field: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        pub(crate) prefix_list: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) protocols: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) route_table_route: std::option::Option<crate::model::AnalysisRouteTableRoute>,
        pub(crate) route_table: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) security_group: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) security_group_rule:
            std::option::Option<crate::model::AnalysisSecurityGroupRule>,
        pub(crate) security_groups:
            std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
        pub(crate) source_vpc: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) subnet: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) subnet_route_table: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) vpc: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) vpc_endpoint: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) vpn_connection: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) vpn_gateway: std::option::Option<crate::model::AnalysisComponent>,
    }
    impl Builder {
        /// <p>The network ACL.</p>
        pub fn acl(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.acl = Some(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.acl = input;
            self
        }
        /// <p>The network ACL rule.</p>
        pub fn acl_rule(mut self, input: crate::model::AnalysisAclRule) -> Self {
            self.acl_rule = Some(input);
            self
        }
        pub fn set_acl_rule(
            mut self,
            input: std::option::Option<crate::model::AnalysisAclRule>,
        ) -> Self {
            self.acl_rule = input;
            self
        }
        /// <p>The IPv4 address, in CIDR notation.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        pub fn addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.addresses.unwrap_or_default();
            v.push(input.into());
            self.addresses = Some(v);
            self
        }
        pub fn set_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// <p>The resource to which the component is attached.</p>
        pub fn attached_to(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.attached_to = Some(input);
            self
        }
        pub fn set_attached_to(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.attached_to = input;
            self
        }
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        pub fn cidrs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cidrs.unwrap_or_default();
            v.push(input.into());
            self.cidrs = Some(v);
            self
        }
        pub fn set_cidrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cidrs = input;
            self
        }
        /// <p>The component.</p>
        pub fn component(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.component = Some(input);
            self
        }
        pub fn set_component(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.component = input;
            self
        }
        /// <p>The customer gateway.</p>
        pub fn customer_gateway(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.customer_gateway = Some(input);
            self
        }
        pub fn set_customer_gateway(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.customer_gateway = input;
            self
        }
        /// <p>The destination.</p>
        pub fn destination(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.destination = Some(input);
            self
        }
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>The destination VPC.</p>
        pub fn destination_vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.destination_vpc = Some(input);
            self
        }
        pub fn set_destination_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.destination_vpc = input;
            self
        }
        /// <p>The direction. The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>egress</p>
        /// </li>
        /// <li>
        /// <p>ingress</p>
        /// </li>
        /// </ul>
        pub fn direction(mut self, input: impl Into<std::string::String>) -> Self {
            self.direction = Some(input.into());
            self
        }
        pub fn set_direction(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.direction = input;
            self
        }
        /// <p>The explanation code.</p>
        pub fn explanation_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.explanation_code = Some(input.into());
            self
        }
        pub fn set_explanation_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explanation_code = input;
            self
        }
        /// <p>The route table.</p>
        pub fn ingress_route_table(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.ingress_route_table = Some(input);
            self
        }
        pub fn set_ingress_route_table(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.ingress_route_table = input;
            self
        }
        /// <p>The internet gateway.</p>
        pub fn internet_gateway(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.internet_gateway = Some(input);
            self
        }
        pub fn set_internet_gateway(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.internet_gateway = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_arn = Some(input.into());
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_arn = input;
            self
        }
        /// <p>The listener for a Classic Load Balancer.</p>
        pub fn classic_load_balancer_listener(
            mut self,
            input: crate::model::AnalysisLoadBalancerListener,
        ) -> Self {
            self.classic_load_balancer_listener = Some(input);
            self
        }
        pub fn set_classic_load_balancer_listener(
            mut self,
            input: std::option::Option<crate::model::AnalysisLoadBalancerListener>,
        ) -> Self {
            self.classic_load_balancer_listener = input;
            self
        }
        /// <p>The listener port of the load balancer.</p>
        pub fn load_balancer_listener_port(mut self, input: i32) -> Self {
            self.load_balancer_listener_port = Some(input);
            self
        }
        pub fn set_load_balancer_listener_port(mut self, input: std::option::Option<i32>) -> Self {
            self.load_balancer_listener_port = input;
            self
        }
        /// <p>The target.</p>
        pub fn load_balancer_target(
            mut self,
            input: crate::model::AnalysisLoadBalancerTarget,
        ) -> Self {
            self.load_balancer_target = Some(input);
            self
        }
        pub fn set_load_balancer_target(
            mut self,
            input: std::option::Option<crate::model::AnalysisLoadBalancerTarget>,
        ) -> Self {
            self.load_balancer_target = input;
            self
        }
        /// <p>The target group.</p>
        pub fn load_balancer_target_group(
            mut self,
            input: crate::model::AnalysisComponent,
        ) -> Self {
            self.load_balancer_target_group = Some(input);
            self
        }
        pub fn set_load_balancer_target_group(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.load_balancer_target_group = input;
            self
        }
        pub fn load_balancer_target_groups(
            mut self,
            input: impl Into<crate::model::AnalysisComponent>,
        ) -> Self {
            let mut v = self.load_balancer_target_groups.unwrap_or_default();
            v.push(input.into());
            self.load_balancer_target_groups = Some(v);
            self
        }
        pub fn set_load_balancer_target_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
        ) -> Self {
            self.load_balancer_target_groups = input;
            self
        }
        /// <p>The target port.</p>
        pub fn load_balancer_target_port(mut self, input: i32) -> Self {
            self.load_balancer_target_port = Some(input);
            self
        }
        pub fn set_load_balancer_target_port(mut self, input: std::option::Option<i32>) -> Self {
            self.load_balancer_target_port = input;
            self
        }
        /// <p>The load balancer listener.</p>
        pub fn elastic_load_balancer_listener(
            mut self,
            input: crate::model::AnalysisComponent,
        ) -> Self {
            self.elastic_load_balancer_listener = Some(input);
            self
        }
        pub fn set_elastic_load_balancer_listener(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.elastic_load_balancer_listener = input;
            self
        }
        /// <p>The missing component.</p>
        pub fn missing_component(mut self, input: impl Into<std::string::String>) -> Self {
            self.missing_component = Some(input.into());
            self
        }
        pub fn set_missing_component(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.missing_component = input;
            self
        }
        /// <p>The NAT gateway.</p>
        pub fn nat_gateway(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.nat_gateway = Some(input);
            self
        }
        pub fn set_nat_gateway(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.nat_gateway = input;
            self
        }
        /// <p>The network interface.</p>
        pub fn network_interface(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.network_interface = Some(input);
            self
        }
        pub fn set_network_interface(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.network_interface = input;
            self
        }
        /// <p>The packet field.</p>
        pub fn packet_field(mut self, input: impl Into<std::string::String>) -> Self {
            self.packet_field = Some(input.into());
            self
        }
        pub fn set_packet_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.packet_field = input;
            self
        }
        /// <p>The VPC peering connection.</p>
        pub fn vpc_peering_connection(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpc_peering_connection = Some(input);
            self
        }
        pub fn set_vpc_peering_connection(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpc_peering_connection = input;
            self
        }
        /// <p>The port.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        pub fn port_ranges(mut self, input: impl Into<crate::model::PortRange>) -> Self {
            let mut v = self.port_ranges.unwrap_or_default();
            v.push(input.into());
            self.port_ranges = Some(v);
            self
        }
        pub fn set_port_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        ) -> Self {
            self.port_ranges = input;
            self
        }
        /// <p>The prefix list.</p>
        pub fn prefix_list(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.prefix_list = Some(input);
            self
        }
        pub fn set_prefix_list(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.prefix_list = input;
            self
        }
        pub fn protocols(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input.into());
            self.protocols = Some(v);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// <p>The route table route.</p>
        pub fn route_table_route(mut self, input: crate::model::AnalysisRouteTableRoute) -> Self {
            self.route_table_route = Some(input);
            self
        }
        pub fn set_route_table_route(
            mut self,
            input: std::option::Option<crate::model::AnalysisRouteTableRoute>,
        ) -> Self {
            self.route_table_route = input;
            self
        }
        /// <p>The route table.</p>
        pub fn route_table(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.route_table = Some(input);
            self
        }
        pub fn set_route_table(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.route_table = input;
            self
        }
        /// <p>The security group.</p>
        pub fn security_group(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.security_group = Some(input);
            self
        }
        pub fn set_security_group(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.security_group = input;
            self
        }
        /// <p>The security group rule.</p>
        pub fn security_group_rule(
            mut self,
            input: crate::model::AnalysisSecurityGroupRule,
        ) -> Self {
            self.security_group_rule = Some(input);
            self
        }
        pub fn set_security_group_rule(
            mut self,
            input: std::option::Option<crate::model::AnalysisSecurityGroupRule>,
        ) -> Self {
            self.security_group_rule = input;
            self
        }
        pub fn security_groups(
            mut self,
            input: impl Into<crate::model::AnalysisComponent>,
        ) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AnalysisComponent>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The source VPC.</p>
        pub fn source_vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.source_vpc = Some(input);
            self
        }
        pub fn set_source_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.source_vpc = input;
            self
        }
        /// <p>The state.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The subnet.</p>
        pub fn subnet(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.subnet = Some(input);
            self
        }
        pub fn set_subnet(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.subnet = input;
            self
        }
        /// <p>The route table for the subnet.</p>
        pub fn subnet_route_table(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.subnet_route_table = Some(input);
            self
        }
        pub fn set_subnet_route_table(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.subnet_route_table = input;
            self
        }
        /// <p>The component VPC.</p>
        pub fn vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpc = Some(input);
            self
        }
        pub fn set_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpc = input;
            self
        }
        /// <p>The VPC endpoint.</p>
        pub fn vpc_endpoint(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpc_endpoint = Some(input);
            self
        }
        pub fn set_vpc_endpoint(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpc_endpoint = input;
            self
        }
        /// <p>The VPN connection.</p>
        pub fn vpn_connection(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpn_connection = Some(input);
            self
        }
        pub fn set_vpn_connection(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpn_connection = input;
            self
        }
        /// <p>The VPN gateway.</p>
        pub fn vpn_gateway(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpn_gateway = Some(input);
            self
        }
        pub fn set_vpn_gateway(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpn_gateway = input;
            self
        }
        /// Consumes the builder and constructs a [`Explanation`](crate::model::Explanation)
        pub fn build(self) -> crate::model::Explanation {
            crate::model::Explanation {
                acl: self.acl,
                acl_rule: self.acl_rule,
                address: self.address,
                addresses: self.addresses,
                attached_to: self.attached_to,
                availability_zones: self.availability_zones,
                cidrs: self.cidrs,
                component: self.component,
                customer_gateway: self.customer_gateway,
                destination: self.destination,
                destination_vpc: self.destination_vpc,
                direction: self.direction,
                explanation_code: self.explanation_code,
                ingress_route_table: self.ingress_route_table,
                internet_gateway: self.internet_gateway,
                load_balancer_arn: self.load_balancer_arn,
                classic_load_balancer_listener: self.classic_load_balancer_listener,
                load_balancer_listener_port: self.load_balancer_listener_port,
                load_balancer_target: self.load_balancer_target,
                load_balancer_target_group: self.load_balancer_target_group,
                load_balancer_target_groups: self.load_balancer_target_groups,
                load_balancer_target_port: self.load_balancer_target_port,
                elastic_load_balancer_listener: self.elastic_load_balancer_listener,
                missing_component: self.missing_component,
                nat_gateway: self.nat_gateway,
                network_interface: self.network_interface,
                packet_field: self.packet_field,
                vpc_peering_connection: self.vpc_peering_connection,
                port: self.port,
                port_ranges: self.port_ranges,
                prefix_list: self.prefix_list,
                protocols: self.protocols,
                route_table_route: self.route_table_route,
                route_table: self.route_table,
                security_group: self.security_group,
                security_group_rule: self.security_group_rule,
                security_groups: self.security_groups,
                source_vpc: self.source_vpc,
                state: self.state,
                subnet: self.subnet,
                subnet_route_table: self.subnet_route_table,
                vpc: self.vpc,
                vpc_endpoint: self.vpc_endpoint,
                vpn_connection: self.vpn_connection,
                vpn_gateway: self.vpn_gateway,
            }
        }
    }
}
impl Explanation {
    /// Creates a new builder-style object to manufacture [`Explanation`](crate::model::Explanation)
    pub fn builder() -> crate::model::explanation::Builder {
        crate::model::explanation::Builder::default()
    }
}

/// <p>Describes a path component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisComponent {
    /// <p>The ID of the component.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnalysisComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisComponent");
        formatter.field("id", &self.id);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`AnalysisComponent`](crate::model::AnalysisComponent)
pub mod analysis_component {
    /// A builder for [`AnalysisComponent`](crate::model::AnalysisComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the component.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the component.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisComponent`](crate::model::AnalysisComponent)
        pub fn build(self) -> crate::model::AnalysisComponent {
            crate::model::AnalysisComponent {
                id: self.id,
                arn: self.arn,
            }
        }
    }
}
impl AnalysisComponent {
    /// Creates a new builder-style object to manufacture [`AnalysisComponent`](crate::model::AnalysisComponent)
    pub fn builder() -> crate::model::analysis_component::Builder {
        crate::model::analysis_component::Builder::default()
    }
}

/// <p>Describes a security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisSecurityGroupRule {
    /// <p>The IPv4 address range, in CIDR notation.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The direction. The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>egress</p>
    /// </li>
    /// <li>
    /// <p>ingress</p>
    /// </li>
    /// </ul>
    pub direction: std::option::Option<std::string::String>,
    /// <p>The security group ID.</p>
    pub security_group_id: std::option::Option<std::string::String>,
    /// <p>The port range.</p>
    pub port_range: std::option::Option<crate::model::PortRange>,
    /// <p>The prefix list ID.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The protocol name.</p>
    pub protocol: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnalysisSecurityGroupRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisSecurityGroupRule");
        formatter.field("cidr", &self.cidr);
        formatter.field("direction", &self.direction);
        formatter.field("security_group_id", &self.security_group_id);
        formatter.field("port_range", &self.port_range);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`AnalysisSecurityGroupRule`](crate::model::AnalysisSecurityGroupRule)
pub mod analysis_security_group_rule {
    /// A builder for [`AnalysisSecurityGroupRule`](crate::model::AnalysisSecurityGroupRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) direction: std::option::Option<std::string::String>,
        pub(crate) security_group_id: std::option::Option<std::string::String>,
        pub(crate) port_range: std::option::Option<crate::model::PortRange>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 address range, in CIDR notation.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>The direction. The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>egress</p>
        /// </li>
        /// <li>
        /// <p>ingress</p>
        /// </li>
        /// </ul>
        pub fn direction(mut self, input: impl Into<std::string::String>) -> Self {
            self.direction = Some(input.into());
            self
        }
        pub fn set_direction(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.direction = input;
            self
        }
        /// <p>The security group ID.</p>
        pub fn security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_group_id = Some(input.into());
            self
        }
        pub fn set_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_group_id = input;
            self
        }
        /// <p>The port range.</p>
        pub fn port_range(mut self, input: crate::model::PortRange) -> Self {
            self.port_range = Some(input);
            self
        }
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.port_range = input;
            self
        }
        /// <p>The prefix list ID.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The protocol name.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisSecurityGroupRule`](crate::model::AnalysisSecurityGroupRule)
        pub fn build(self) -> crate::model::AnalysisSecurityGroupRule {
            crate::model::AnalysisSecurityGroupRule {
                cidr: self.cidr,
                direction: self.direction,
                security_group_id: self.security_group_id,
                port_range: self.port_range,
                prefix_list_id: self.prefix_list_id,
                protocol: self.protocol,
            }
        }
    }
}
impl AnalysisSecurityGroupRule {
    /// Creates a new builder-style object to manufacture [`AnalysisSecurityGroupRule`](crate::model::AnalysisSecurityGroupRule)
    pub fn builder() -> crate::model::analysis_security_group_rule::Builder {
        crate::model::analysis_security_group_rule::Builder::default()
    }
}

/// <p>Describes a range of ports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PortRange {
    /// <p>The first port in the range.</p>
    pub from: std::option::Option<i32>,
    /// <p>The last port in the range.</p>
    pub to: std::option::Option<i32>,
}
impl std::fmt::Debug for PortRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PortRange");
        formatter.field("from", &self.from);
        formatter.field("to", &self.to);
        formatter.finish()
    }
}
/// See [`PortRange`](crate::model::PortRange)
pub mod port_range {
    /// A builder for [`PortRange`](crate::model::PortRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<i32>,
        pub(crate) to: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The first port in the range.</p>
        pub fn from(mut self, input: i32) -> Self {
            self.from = Some(input);
            self
        }
        pub fn set_from(mut self, input: std::option::Option<i32>) -> Self {
            self.from = input;
            self
        }
        /// <p>The last port in the range.</p>
        pub fn to(mut self, input: i32) -> Self {
            self.to = Some(input);
            self
        }
        pub fn set_to(mut self, input: std::option::Option<i32>) -> Self {
            self.to = input;
            self
        }
        /// Consumes the builder and constructs a [`PortRange`](crate::model::PortRange)
        pub fn build(self) -> crate::model::PortRange {
            crate::model::PortRange {
                from: self.from,
                to: self.to,
            }
        }
    }
}
impl PortRange {
    /// Creates a new builder-style object to manufacture [`PortRange`](crate::model::PortRange)
    pub fn builder() -> crate::model::port_range::Builder {
        crate::model::port_range::Builder::default()
    }
}

/// <p>Describes a route table route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisRouteTableRoute {
    /// <p>The destination IPv4 address, in CIDR notation.</p>
    pub destination_cidr: std::option::Option<std::string::String>,
    /// <p>The prefix of the Amazon Web Service.</p>
    pub destination_prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The ID of an egress-only internet gateway.</p>
    pub egress_only_internet_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the gateway, such as an internet gateway or virtual private gateway.</p>
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance, such as a NAT instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The ID of a NAT gateway.</p>
    pub nat_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of a network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>Describes how the route was created. The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreateRoute</code> - The route was manually added to the route table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p>
    /// </li>
    /// </ul>
    pub origin: std::option::Option<std::string::String>,
    /// <p>The ID of a transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of a VPC peering connection.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnalysisRouteTableRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisRouteTableRoute");
        formatter.field("destination_cidr", &self.destination_cidr);
        formatter.field(
            "destination_prefix_list_id",
            &self.destination_prefix_list_id,
        );
        formatter.field(
            "egress_only_internet_gateway_id",
            &self.egress_only_internet_gateway_id,
        );
        formatter.field("gateway_id", &self.gateway_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("nat_gateway_id", &self.nat_gateway_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("origin", &self.origin);
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`AnalysisRouteTableRoute`](crate::model::AnalysisRouteTableRoute)
pub mod analysis_route_table_route {
    /// A builder for [`AnalysisRouteTableRoute`](crate::model::AnalysisRouteTableRoute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr: std::option::Option<std::string::String>,
        pub(crate) destination_prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) egress_only_internet_gateway_id: std::option::Option<std::string::String>,
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) nat_gateway_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination IPv4 address, in CIDR notation.</p>
        pub fn destination_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr = Some(input.into());
            self
        }
        pub fn set_destination_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr = input;
            self
        }
        /// <p>The prefix of the Amazon Web Service.</p>
        pub fn destination_prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_prefix_list_id = Some(input.into());
            self
        }
        pub fn set_destination_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_prefix_list_id = input;
            self
        }
        /// <p>The ID of an egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = Some(input.into());
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = input;
            self
        }
        /// <p>The ID of the gateway, such as an internet gateway or virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// <p>The ID of the instance, such as a NAT instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The ID of a NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.nat_gateway_id = Some(input.into());
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nat_gateway_id = input;
            self
        }
        /// <p>The ID of a network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>Describes how the route was created. The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreateRoute</code> - The route was manually added to the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p>
        /// </li>
        /// </ul>
        pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin = Some(input.into());
            self
        }
        pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin = input;
            self
        }
        /// <p>The ID of a transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The ID of a VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisRouteTableRoute`](crate::model::AnalysisRouteTableRoute)
        pub fn build(self) -> crate::model::AnalysisRouteTableRoute {
            crate::model::AnalysisRouteTableRoute {
                destination_cidr: self.destination_cidr,
                destination_prefix_list_id: self.destination_prefix_list_id,
                egress_only_internet_gateway_id: self.egress_only_internet_gateway_id,
                gateway_id: self.gateway_id,
                instance_id: self.instance_id,
                nat_gateway_id: self.nat_gateway_id,
                network_interface_id: self.network_interface_id,
                origin: self.origin,
                transit_gateway_id: self.transit_gateway_id,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl AnalysisRouteTableRoute {
    /// Creates a new builder-style object to manufacture [`AnalysisRouteTableRoute`](crate::model::AnalysisRouteTableRoute)
    pub fn builder() -> crate::model::analysis_route_table_route::Builder {
        crate::model::analysis_route_table_route::Builder::default()
    }
}

/// <p>Describes a load balancer target.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisLoadBalancerTarget {
    /// <p>The IP address.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>Information about the instance.</p>
    pub instance: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The port on which the target is listening.</p>
    pub port: std::option::Option<i32>,
}
impl std::fmt::Debug for AnalysisLoadBalancerTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisLoadBalancerTarget");
        formatter.field("address", &self.address);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("instance", &self.instance);
        formatter.field("port", &self.port);
        formatter.finish()
    }
}
/// See [`AnalysisLoadBalancerTarget`](crate::model::AnalysisLoadBalancerTarget)
pub mod analysis_load_balancer_target {
    /// A builder for [`AnalysisLoadBalancerTarget`](crate::model::AnalysisLoadBalancerTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) instance: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The IP address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>Information about the instance.</p>
        pub fn instance(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.instance = Some(input);
            self
        }
        pub fn set_instance(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.instance = input;
            self
        }
        /// <p>The port on which the target is listening.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisLoadBalancerTarget`](crate::model::AnalysisLoadBalancerTarget)
        pub fn build(self) -> crate::model::AnalysisLoadBalancerTarget {
            crate::model::AnalysisLoadBalancerTarget {
                address: self.address,
                availability_zone: self.availability_zone,
                instance: self.instance,
                port: self.port,
            }
        }
    }
}
impl AnalysisLoadBalancerTarget {
    /// Creates a new builder-style object to manufacture [`AnalysisLoadBalancerTarget`](crate::model::AnalysisLoadBalancerTarget)
    pub fn builder() -> crate::model::analysis_load_balancer_target::Builder {
        crate::model::analysis_load_balancer_target::Builder::default()
    }
}

/// <p>Describes a load balancer listener.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisLoadBalancerListener {
    /// <p>The port on which the load balancer is listening.</p>
    pub load_balancer_port: std::option::Option<i32>,
    /// <p>[Classic Load Balancers] The back-end port for the listener.</p>
    pub instance_port: std::option::Option<i32>,
}
impl std::fmt::Debug for AnalysisLoadBalancerListener {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisLoadBalancerListener");
        formatter.field("load_balancer_port", &self.load_balancer_port);
        formatter.field("instance_port", &self.instance_port);
        formatter.finish()
    }
}
/// See [`AnalysisLoadBalancerListener`](crate::model::AnalysisLoadBalancerListener)
pub mod analysis_load_balancer_listener {
    /// A builder for [`AnalysisLoadBalancerListener`](crate::model::AnalysisLoadBalancerListener)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_port: std::option::Option<i32>,
        pub(crate) instance_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The port on which the load balancer is listening.</p>
        pub fn load_balancer_port(mut self, input: i32) -> Self {
            self.load_balancer_port = Some(input);
            self
        }
        pub fn set_load_balancer_port(mut self, input: std::option::Option<i32>) -> Self {
            self.load_balancer_port = input;
            self
        }
        /// <p>[Classic Load Balancers] The back-end port for the listener.</p>
        pub fn instance_port(mut self, input: i32) -> Self {
            self.instance_port = Some(input);
            self
        }
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_port = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisLoadBalancerListener`](crate::model::AnalysisLoadBalancerListener)
        pub fn build(self) -> crate::model::AnalysisLoadBalancerListener {
            crate::model::AnalysisLoadBalancerListener {
                load_balancer_port: self.load_balancer_port,
                instance_port: self.instance_port,
            }
        }
    }
}
impl AnalysisLoadBalancerListener {
    /// Creates a new builder-style object to manufacture [`AnalysisLoadBalancerListener`](crate::model::AnalysisLoadBalancerListener)
    pub fn builder() -> crate::model::analysis_load_balancer_listener::Builder {
        crate::model::analysis_load_balancer_listener::Builder::default()
    }
}

/// <p>Describes a network access control (ACL) rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisAclRule {
    /// <p>The IPv4 address range, in CIDR notation.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>Indicates whether the rule is an outbound rule.</p>
    pub egress: std::option::Option<bool>,
    /// <p>The range of ports.</p>
    pub port_range: std::option::Option<crate::model::PortRange>,
    /// <p>The protocol.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Indicates whether to allow or deny traffic that matches the rule.</p>
    pub rule_action: std::option::Option<std::string::String>,
    /// <p>The rule number.</p>
    pub rule_number: std::option::Option<i32>,
}
impl std::fmt::Debug for AnalysisAclRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisAclRule");
        formatter.field("cidr", &self.cidr);
        formatter.field("egress", &self.egress);
        formatter.field("port_range", &self.port_range);
        formatter.field("protocol", &self.protocol);
        formatter.field("rule_action", &self.rule_action);
        formatter.field("rule_number", &self.rule_number);
        formatter.finish()
    }
}
/// See [`AnalysisAclRule`](crate::model::AnalysisAclRule)
pub mod analysis_acl_rule {
    /// A builder for [`AnalysisAclRule`](crate::model::AnalysisAclRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) egress: std::option::Option<bool>,
        pub(crate) port_range: std::option::Option<crate::model::PortRange>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) rule_action: std::option::Option<std::string::String>,
        pub(crate) rule_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The IPv4 address range, in CIDR notation.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>Indicates whether the rule is an outbound rule.</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.egress = Some(input);
            self
        }
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.egress = input;
            self
        }
        /// <p>The range of ports.</p>
        pub fn port_range(mut self, input: crate::model::PortRange) -> Self {
            self.port_range = Some(input);
            self
        }
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.port_range = input;
            self
        }
        /// <p>The protocol.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Indicates whether to allow or deny traffic that matches the rule.</p>
        pub fn rule_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_action = Some(input.into());
            self
        }
        pub fn set_rule_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_action = input;
            self
        }
        /// <p>The rule number.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.rule_number = Some(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.rule_number = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisAclRule`](crate::model::AnalysisAclRule)
        pub fn build(self) -> crate::model::AnalysisAclRule {
            crate::model::AnalysisAclRule {
                cidr: self.cidr,
                egress: self.egress,
                port_range: self.port_range,
                protocol: self.protocol,
                rule_action: self.rule_action,
                rule_number: self.rule_number,
            }
        }
    }
}
impl AnalysisAclRule {
    /// Creates a new builder-style object to manufacture [`AnalysisAclRule`](crate::model::AnalysisAclRule)
    pub fn builder() -> crate::model::analysis_acl_rule::Builder {
        crate::model::analysis_acl_rule::Builder::default()
    }
}

/// <p>Describes a path component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PathComponent {
    /// <p>The sequence number.</p>
    pub sequence_number: std::option::Option<i32>,
    /// <p>The network ACL rule.</p>
    pub acl_rule: std::option::Option<crate::model::AnalysisAclRule>,
    /// <p>The component.</p>
    pub component: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The destination VPC.</p>
    pub destination_vpc: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The outbound header.</p>
    pub outbound_header: std::option::Option<crate::model::AnalysisPacketHeader>,
    /// <p>The inbound header.</p>
    pub inbound_header: std::option::Option<crate::model::AnalysisPacketHeader>,
    /// <p>The route table route.</p>
    pub route_table_route: std::option::Option<crate::model::AnalysisRouteTableRoute>,
    /// <p>The security group rule.</p>
    pub security_group_rule: std::option::Option<crate::model::AnalysisSecurityGroupRule>,
    /// <p>The source VPC.</p>
    pub source_vpc: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The subnet.</p>
    pub subnet: std::option::Option<crate::model::AnalysisComponent>,
    /// <p>The component VPC.</p>
    pub vpc: std::option::Option<crate::model::AnalysisComponent>,
}
impl std::fmt::Debug for PathComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PathComponent");
        formatter.field("sequence_number", &self.sequence_number);
        formatter.field("acl_rule", &self.acl_rule);
        formatter.field("component", &self.component);
        formatter.field("destination_vpc", &self.destination_vpc);
        formatter.field("outbound_header", &self.outbound_header);
        formatter.field("inbound_header", &self.inbound_header);
        formatter.field("route_table_route", &self.route_table_route);
        formatter.field("security_group_rule", &self.security_group_rule);
        formatter.field("source_vpc", &self.source_vpc);
        formatter.field("subnet", &self.subnet);
        formatter.field("vpc", &self.vpc);
        formatter.finish()
    }
}
/// See [`PathComponent`](crate::model::PathComponent)
pub mod path_component {
    /// A builder for [`PathComponent`](crate::model::PathComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence_number: std::option::Option<i32>,
        pub(crate) acl_rule: std::option::Option<crate::model::AnalysisAclRule>,
        pub(crate) component: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) destination_vpc: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) outbound_header: std::option::Option<crate::model::AnalysisPacketHeader>,
        pub(crate) inbound_header: std::option::Option<crate::model::AnalysisPacketHeader>,
        pub(crate) route_table_route: std::option::Option<crate::model::AnalysisRouteTableRoute>,
        pub(crate) security_group_rule:
            std::option::Option<crate::model::AnalysisSecurityGroupRule>,
        pub(crate) source_vpc: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) subnet: std::option::Option<crate::model::AnalysisComponent>,
        pub(crate) vpc: std::option::Option<crate::model::AnalysisComponent>,
    }
    impl Builder {
        /// <p>The sequence number.</p>
        pub fn sequence_number(mut self, input: i32) -> Self {
            self.sequence_number = Some(input);
            self
        }
        pub fn set_sequence_number(mut self, input: std::option::Option<i32>) -> Self {
            self.sequence_number = input;
            self
        }
        /// <p>The network ACL rule.</p>
        pub fn acl_rule(mut self, input: crate::model::AnalysisAclRule) -> Self {
            self.acl_rule = Some(input);
            self
        }
        pub fn set_acl_rule(
            mut self,
            input: std::option::Option<crate::model::AnalysisAclRule>,
        ) -> Self {
            self.acl_rule = input;
            self
        }
        /// <p>The component.</p>
        pub fn component(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.component = Some(input);
            self
        }
        pub fn set_component(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.component = input;
            self
        }
        /// <p>The destination VPC.</p>
        pub fn destination_vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.destination_vpc = Some(input);
            self
        }
        pub fn set_destination_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.destination_vpc = input;
            self
        }
        /// <p>The outbound header.</p>
        pub fn outbound_header(mut self, input: crate::model::AnalysisPacketHeader) -> Self {
            self.outbound_header = Some(input);
            self
        }
        pub fn set_outbound_header(
            mut self,
            input: std::option::Option<crate::model::AnalysisPacketHeader>,
        ) -> Self {
            self.outbound_header = input;
            self
        }
        /// <p>The inbound header.</p>
        pub fn inbound_header(mut self, input: crate::model::AnalysisPacketHeader) -> Self {
            self.inbound_header = Some(input);
            self
        }
        pub fn set_inbound_header(
            mut self,
            input: std::option::Option<crate::model::AnalysisPacketHeader>,
        ) -> Self {
            self.inbound_header = input;
            self
        }
        /// <p>The route table route.</p>
        pub fn route_table_route(mut self, input: crate::model::AnalysisRouteTableRoute) -> Self {
            self.route_table_route = Some(input);
            self
        }
        pub fn set_route_table_route(
            mut self,
            input: std::option::Option<crate::model::AnalysisRouteTableRoute>,
        ) -> Self {
            self.route_table_route = input;
            self
        }
        /// <p>The security group rule.</p>
        pub fn security_group_rule(
            mut self,
            input: crate::model::AnalysisSecurityGroupRule,
        ) -> Self {
            self.security_group_rule = Some(input);
            self
        }
        pub fn set_security_group_rule(
            mut self,
            input: std::option::Option<crate::model::AnalysisSecurityGroupRule>,
        ) -> Self {
            self.security_group_rule = input;
            self
        }
        /// <p>The source VPC.</p>
        pub fn source_vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.source_vpc = Some(input);
            self
        }
        pub fn set_source_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.source_vpc = input;
            self
        }
        /// <p>The subnet.</p>
        pub fn subnet(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.subnet = Some(input);
            self
        }
        pub fn set_subnet(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.subnet = input;
            self
        }
        /// <p>The component VPC.</p>
        pub fn vpc(mut self, input: crate::model::AnalysisComponent) -> Self {
            self.vpc = Some(input);
            self
        }
        pub fn set_vpc(
            mut self,
            input: std::option::Option<crate::model::AnalysisComponent>,
        ) -> Self {
            self.vpc = input;
            self
        }
        /// Consumes the builder and constructs a [`PathComponent`](crate::model::PathComponent)
        pub fn build(self) -> crate::model::PathComponent {
            crate::model::PathComponent {
                sequence_number: self.sequence_number,
                acl_rule: self.acl_rule,
                component: self.component,
                destination_vpc: self.destination_vpc,
                outbound_header: self.outbound_header,
                inbound_header: self.inbound_header,
                route_table_route: self.route_table_route,
                security_group_rule: self.security_group_rule,
                source_vpc: self.source_vpc,
                subnet: self.subnet,
                vpc: self.vpc,
            }
        }
    }
}
impl PathComponent {
    /// Creates a new builder-style object to manufacture [`PathComponent`](crate::model::PathComponent)
    pub fn builder() -> crate::model::path_component::Builder {
        crate::model::path_component::Builder::default()
    }
}

/// <p>Describes a header. Reflects any changes made by a component as traffic passes through.
/// The fields of an inbound header are null except for the first component of a path.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnalysisPacketHeader {
    /// <p>The destination addresses.</p>
    pub destination_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The destination port ranges.</p>
    pub destination_port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
    /// <p>The protocol.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The source addresses.</p>
    pub source_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The source port ranges.</p>
    pub source_port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
}
impl std::fmt::Debug for AnalysisPacketHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnalysisPacketHeader");
        formatter.field("destination_addresses", &self.destination_addresses);
        formatter.field("destination_port_ranges", &self.destination_port_ranges);
        formatter.field("protocol", &self.protocol);
        formatter.field("source_addresses", &self.source_addresses);
        formatter.field("source_port_ranges", &self.source_port_ranges);
        formatter.finish()
    }
}
/// See [`AnalysisPacketHeader`](crate::model::AnalysisPacketHeader)
pub mod analysis_packet_header {
    /// A builder for [`AnalysisPacketHeader`](crate::model::AnalysisPacketHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) destination_port_ranges:
            std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) source_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_port_ranges: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
    }
    impl Builder {
        pub fn destination_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.destination_addresses.unwrap_or_default();
            v.push(input.into());
            self.destination_addresses = Some(v);
            self
        }
        pub fn set_destination_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.destination_addresses = input;
            self
        }
        pub fn destination_port_ranges(
            mut self,
            input: impl Into<crate::model::PortRange>,
        ) -> Self {
            let mut v = self.destination_port_ranges.unwrap_or_default();
            v.push(input.into());
            self.destination_port_ranges = Some(v);
            self
        }
        pub fn set_destination_port_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        ) -> Self {
            self.destination_port_ranges = input;
            self
        }
        /// <p>The protocol.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        pub fn source_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_addresses.unwrap_or_default();
            v.push(input.into());
            self.source_addresses = Some(v);
            self
        }
        pub fn set_source_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_addresses = input;
            self
        }
        pub fn source_port_ranges(mut self, input: impl Into<crate::model::PortRange>) -> Self {
            let mut v = self.source_port_ranges.unwrap_or_default();
            v.push(input.into());
            self.source_port_ranges = Some(v);
            self
        }
        pub fn set_source_port_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortRange>>,
        ) -> Self {
            self.source_port_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`AnalysisPacketHeader`](crate::model::AnalysisPacketHeader)
        pub fn build(self) -> crate::model::AnalysisPacketHeader {
            crate::model::AnalysisPacketHeader {
                destination_addresses: self.destination_addresses,
                destination_port_ranges: self.destination_port_ranges,
                protocol: self.protocol,
                source_addresses: self.source_addresses,
                source_port_ranges: self.source_port_ranges,
            }
        }
    }
}
impl AnalysisPacketHeader {
    /// Creates a new builder-style object to manufacture [`AnalysisPacketHeader`](crate::model::AnalysisPacketHeader)
    pub fn builder() -> crate::model::analysis_packet_header::Builder {
        crate::model::analysis_packet_header::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnalysisStatus {
    Failed,
    Running,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AnalysisStatus {
    fn from(s: &str) -> Self {
        match s {
            "failed" => AnalysisStatus::Failed,
            "running" => AnalysisStatus::Running,
            "succeeded" => AnalysisStatus::Succeeded,
            other => AnalysisStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AnalysisStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnalysisStatus::from(s))
    }
}
impl AnalysisStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AnalysisStatus::Failed => "failed",
            AnalysisStatus::Running => "running",
            AnalysisStatus::Succeeded => "succeeded",
            AnalysisStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["failed", "running", "succeeded"]
    }
}
impl AsRef<str> for AnalysisStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The tags to apply to a resource when the resource is being created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagSpecification {
    /// <p>The type of resource to tag on creation. The possible values are:
    /// <code>capacity-reservation</code> | <code>carrier-gateway</code> |
    /// <code>client-vpn-endpoint</code> | <code>customer-gateway</code> |
    /// <code>dedicated-host</code> | <code>dhcp-options</code> |
    /// <code>egress-only-internet-gateway</code> | <code>elastic-gpu</code> |
    /// <code>elastic-ip</code> | <code>export-image-task</code> |
    /// <code>export-instance-task</code> | <code>fleet</code> | <code>fpga-image</code> |
    /// <code>host-reservation</code> | <code>image</code> | <code>import-image-task</code> |
    /// <code>import-snapshot-task</code> | <code>instance</code> | <code>instance-event-window</code> |
    /// <code>internet-gateway</code> | <code>ipv4pool-ec2</code> | <code>ipv6pool-ec2</code> |
    /// <code>key-pair</code> | <code>launch-template</code> | <code>local-gateway-route-table-vpc-association</code> |
    /// <code>natgateway</code> | <code>network-acl</code> | <code>network-insights-analysis</code> |
    /// <code>network-insights-path</code> | <code>network-interface</code> |
    /// <code>placement-group</code> | <code>prefix-list</code> | <code>reserved-instances</code> |
    /// <code>route-table</code> | <code>security-group</code> | <code>security-group-rule</code> |
    /// <code>snapshot</code> | <code>spot-fleet-request</code> | <code>spot-instances-request</code> | <code>subnet</code> |
    /// <code>traffic-mirror-filter</code> | <code>traffic-mirror-session</code> | <code>traffic-mirror-target</code> |
    /// <code>transit-gateway</code> | <code>transit-gateway-attachment</code> |
    /// <code>transit-gateway-multicast-domain</code> | <code>transit-gateway-route-table</code> |
    /// <code>volume</code> | <code>vpc</code> | <code>vpc-endpoint</code> | <code>vpc-endpoint-service</code> |
    /// <code>vpc-flow-log</code> | <code>vpc-peering-connection</code> |
    /// <code>vpn-connection</code> | <code>vpn-gateway</code>.</p>
    /// <p>To tag a resource after it has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The tags to apply to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagSpecification");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TagSpecification`](crate::model::TagSpecification)
pub mod tag_specification {
    /// A builder for [`TagSpecification`](crate::model::TagSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The type of resource to tag on creation. The possible values are:
        /// <code>capacity-reservation</code> | <code>carrier-gateway</code> |
        /// <code>client-vpn-endpoint</code> | <code>customer-gateway</code> |
        /// <code>dedicated-host</code> | <code>dhcp-options</code> |
        /// <code>egress-only-internet-gateway</code> | <code>elastic-gpu</code> |
        /// <code>elastic-ip</code> | <code>export-image-task</code> |
        /// <code>export-instance-task</code> | <code>fleet</code> | <code>fpga-image</code> |
        /// <code>host-reservation</code> | <code>image</code> | <code>import-image-task</code> |
        /// <code>import-snapshot-task</code> | <code>instance</code> | <code>instance-event-window</code> |
        /// <code>internet-gateway</code> | <code>ipv4pool-ec2</code> | <code>ipv6pool-ec2</code> |
        /// <code>key-pair</code> | <code>launch-template</code> | <code>local-gateway-route-table-vpc-association</code> |
        /// <code>natgateway</code> | <code>network-acl</code> | <code>network-insights-analysis</code> |
        /// <code>network-insights-path</code> | <code>network-interface</code> |
        /// <code>placement-group</code> | <code>prefix-list</code> | <code>reserved-instances</code> |
        /// <code>route-table</code> | <code>security-group</code> | <code>security-group-rule</code> |
        /// <code>snapshot</code> | <code>spot-fleet-request</code> | <code>spot-instances-request</code> | <code>subnet</code> |
        /// <code>traffic-mirror-filter</code> | <code>traffic-mirror-session</code> | <code>traffic-mirror-target</code> |
        /// <code>transit-gateway</code> | <code>transit-gateway-attachment</code> |
        /// <code>transit-gateway-multicast-domain</code> | <code>transit-gateway-route-table</code> |
        /// <code>volume</code> | <code>vpc</code> | <code>vpc-endpoint</code> | <code>vpc-endpoint-service</code> |
        /// <code>vpc-flow-log</code> | <code>vpc-peering-connection</code> |
        /// <code>vpn-connection</code> | <code>vpn-gateway</code>.</p>
        /// <p>To tag a resource after it has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagSpecification`](crate::model::TagSpecification)
        pub fn build(self) -> crate::model::TagSpecification {
            crate::model::TagSpecification {
                resource_type: self.resource_type,
                tags: self.tags,
            }
        }
    }
}
impl TagSpecification {
    /// Creates a new builder-style object to manufacture [`TagSpecification`](crate::model::TagSpecification)
    pub fn builder() -> crate::model::tag_specification::Builder {
        crate::model::tag_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    CapacityReservation,
    CarrierGateway,
    ClientVpnEndpoint,
    CustomerGateway,
    DedicatedHost,
    DhcpOptions,
    EgressOnlyInternetGateway,
    ElasticGpu,
    ElasticIp,
    ExportImageTask,
    ExportInstanceTask,
    Fleet,
    FpgaImage,
    HostReservation,
    Image,
    ImportImageTask,
    ImportSnapshotTask,
    Instance,
    InstanceEventWindow,
    InternetGateway,
    Ipv4poolEc2,
    Ipv6poolEc2,
    KeyPair,
    LaunchTemplate,
    LocalGateway,
    LocalGatewayRouteTable,
    LocalGatewayRouteTableVirtualInterfaceGroupAssociation,
    LocalGatewayRouteTableVpcAssociation,
    LocalGatewayVirtualInterface,
    LocalGatewayVirtualInterfaceGroup,
    Natgateway,
    NetworkAcl,
    NetworkInsightsAnalysis,
    NetworkInsightsPath,
    NetworkInterface,
    PlacementGroup,
    PrefixList,
    ReplaceRootVolumeTask,
    ReservedInstances,
    RouteTable,
    SecurityGroup,
    SecurityGroupRule,
    Snapshot,
    SpotFleetRequest,
    SpotInstancesRequest,
    Subnet,
    TrafficMirrorFilter,
    TrafficMirrorSession,
    TrafficMirrorTarget,
    TransitGateway,
    TransitGatewayAttachment,
    TransitGatewayConnectPeer,
    TransitGatewayMulticastDomain,
    TransitGatewayRouteTable,
    Volume,
    Vpc,
    VpcEndpoint,
    VpcEndpointService,
    VpcFlowLog,
    VpcPeeringConnection,
    VpnConnection,
    VpnGateway,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "capacity-reservation" => ResourceType::CapacityReservation,
            "carrier-gateway" => ResourceType::CarrierGateway,
            "client-vpn-endpoint" => ResourceType::ClientVpnEndpoint,
            "customer-gateway" => ResourceType::CustomerGateway,
            "dedicated-host" => ResourceType::DedicatedHost,
            "dhcp-options" => ResourceType::DhcpOptions,
            "egress-only-internet-gateway" => ResourceType::EgressOnlyInternetGateway,
            "elastic-gpu" => ResourceType::ElasticGpu,
            "elastic-ip" => ResourceType::ElasticIp,
            "export-image-task" => ResourceType::ExportImageTask,
            "export-instance-task" => ResourceType::ExportInstanceTask,
            "fleet" => ResourceType::Fleet,
            "fpga-image" => ResourceType::FpgaImage,
            "host-reservation" => ResourceType::HostReservation,
            "image" => ResourceType::Image,
            "import-image-task" => ResourceType::ImportImageTask,
            "import-snapshot-task" => ResourceType::ImportSnapshotTask,
            "instance" => ResourceType::Instance,
            "instance-event-window" => ResourceType::InstanceEventWindow,
            "internet-gateway" => ResourceType::InternetGateway,
            "ipv4pool-ec2" => ResourceType::Ipv4poolEc2,
            "ipv6pool-ec2" => ResourceType::Ipv6poolEc2,
            "key-pair" => ResourceType::KeyPair,
            "launch-template" => ResourceType::LaunchTemplate,
            "local-gateway" => ResourceType::LocalGateway,
            "local-gateway-route-table" => ResourceType::LocalGatewayRouteTable,
            "local-gateway-route-table-virtual-interface-group-association" => {
                ResourceType::LocalGatewayRouteTableVirtualInterfaceGroupAssociation
            }
            "local-gateway-route-table-vpc-association" => {
                ResourceType::LocalGatewayRouteTableVpcAssociation
            }
            "local-gateway-virtual-interface" => ResourceType::LocalGatewayVirtualInterface,
            "local-gateway-virtual-interface-group" => {
                ResourceType::LocalGatewayVirtualInterfaceGroup
            }
            "natgateway" => ResourceType::Natgateway,
            "network-acl" => ResourceType::NetworkAcl,
            "network-insights-analysis" => ResourceType::NetworkInsightsAnalysis,
            "network-insights-path" => ResourceType::NetworkInsightsPath,
            "network-interface" => ResourceType::NetworkInterface,
            "placement-group" => ResourceType::PlacementGroup,
            "prefix-list" => ResourceType::PrefixList,
            "replace-root-volume-task" => ResourceType::ReplaceRootVolumeTask,
            "reserved-instances" => ResourceType::ReservedInstances,
            "route-table" => ResourceType::RouteTable,
            "security-group" => ResourceType::SecurityGroup,
            "security-group-rule" => ResourceType::SecurityGroupRule,
            "snapshot" => ResourceType::Snapshot,
            "spot-fleet-request" => ResourceType::SpotFleetRequest,
            "spot-instances-request" => ResourceType::SpotInstancesRequest,
            "subnet" => ResourceType::Subnet,
            "traffic-mirror-filter" => ResourceType::TrafficMirrorFilter,
            "traffic-mirror-session" => ResourceType::TrafficMirrorSession,
            "traffic-mirror-target" => ResourceType::TrafficMirrorTarget,
            "transit-gateway" => ResourceType::TransitGateway,
            "transit-gateway-attachment" => ResourceType::TransitGatewayAttachment,
            "transit-gateway-connect-peer" => ResourceType::TransitGatewayConnectPeer,
            "transit-gateway-multicast-domain" => ResourceType::TransitGatewayMulticastDomain,
            "transit-gateway-route-table" => ResourceType::TransitGatewayRouteTable,
            "volume" => ResourceType::Volume,
            "vpc" => ResourceType::Vpc,
            "vpc-endpoint" => ResourceType::VpcEndpoint,
            "vpc-endpoint-service" => ResourceType::VpcEndpointService,
            "vpc-flow-log" => ResourceType::VpcFlowLog,
            "vpc-peering-connection" => ResourceType::VpcPeeringConnection,
            "vpn-connection" => ResourceType::VpnConnection,
            "vpn-gateway" => ResourceType::VpnGateway,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::CapacityReservation => "capacity-reservation",
            ResourceType::CarrierGateway => "carrier-gateway",
            ResourceType::ClientVpnEndpoint => "client-vpn-endpoint",
            ResourceType::CustomerGateway => "customer-gateway",
            ResourceType::DedicatedHost => "dedicated-host",
            ResourceType::DhcpOptions => "dhcp-options",
            ResourceType::EgressOnlyInternetGateway => "egress-only-internet-gateway",
            ResourceType::ElasticGpu => "elastic-gpu",
            ResourceType::ElasticIp => "elastic-ip",
            ResourceType::ExportImageTask => "export-image-task",
            ResourceType::ExportInstanceTask => "export-instance-task",
            ResourceType::Fleet => "fleet",
            ResourceType::FpgaImage => "fpga-image",
            ResourceType::HostReservation => "host-reservation",
            ResourceType::Image => "image",
            ResourceType::ImportImageTask => "import-image-task",
            ResourceType::ImportSnapshotTask => "import-snapshot-task",
            ResourceType::Instance => "instance",
            ResourceType::InstanceEventWindow => "instance-event-window",
            ResourceType::InternetGateway => "internet-gateway",
            ResourceType::Ipv4poolEc2 => "ipv4pool-ec2",
            ResourceType::Ipv6poolEc2 => "ipv6pool-ec2",
            ResourceType::KeyPair => "key-pair",
            ResourceType::LaunchTemplate => "launch-template",
            ResourceType::LocalGateway => "local-gateway",
            ResourceType::LocalGatewayRouteTable => "local-gateway-route-table",
            ResourceType::LocalGatewayRouteTableVirtualInterfaceGroupAssociation => {
                "local-gateway-route-table-virtual-interface-group-association"
            }
            ResourceType::LocalGatewayRouteTableVpcAssociation => {
                "local-gateway-route-table-vpc-association"
            }
            ResourceType::LocalGatewayVirtualInterface => "local-gateway-virtual-interface",
            ResourceType::LocalGatewayVirtualInterfaceGroup => {
                "local-gateway-virtual-interface-group"
            }
            ResourceType::Natgateway => "natgateway",
            ResourceType::NetworkAcl => "network-acl",
            ResourceType::NetworkInsightsAnalysis => "network-insights-analysis",
            ResourceType::NetworkInsightsPath => "network-insights-path",
            ResourceType::NetworkInterface => "network-interface",
            ResourceType::PlacementGroup => "placement-group",
            ResourceType::PrefixList => "prefix-list",
            ResourceType::ReplaceRootVolumeTask => "replace-root-volume-task",
            ResourceType::ReservedInstances => "reserved-instances",
            ResourceType::RouteTable => "route-table",
            ResourceType::SecurityGroup => "security-group",
            ResourceType::SecurityGroupRule => "security-group-rule",
            ResourceType::Snapshot => "snapshot",
            ResourceType::SpotFleetRequest => "spot-fleet-request",
            ResourceType::SpotInstancesRequest => "spot-instances-request",
            ResourceType::Subnet => "subnet",
            ResourceType::TrafficMirrorFilter => "traffic-mirror-filter",
            ResourceType::TrafficMirrorSession => "traffic-mirror-session",
            ResourceType::TrafficMirrorTarget => "traffic-mirror-target",
            ResourceType::TransitGateway => "transit-gateway",
            ResourceType::TransitGatewayAttachment => "transit-gateway-attachment",
            ResourceType::TransitGatewayConnectPeer => "transit-gateway-connect-peer",
            ResourceType::TransitGatewayMulticastDomain => "transit-gateway-multicast-domain",
            ResourceType::TransitGatewayRouteTable => "transit-gateway-route-table",
            ResourceType::Volume => "volume",
            ResourceType::Vpc => "vpc",
            ResourceType::VpcEndpoint => "vpc-endpoint",
            ResourceType::VpcEndpointService => "vpc-endpoint-service",
            ResourceType::VpcFlowLog => "vpc-flow-log",
            ResourceType::VpcPeeringConnection => "vpc-peering-connection",
            ResourceType::VpnConnection => "vpn-connection",
            ResourceType::VpnGateway => "vpn-gateway",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "capacity-reservation",
            "carrier-gateway",
            "client-vpn-endpoint",
            "customer-gateway",
            "dedicated-host",
            "dhcp-options",
            "egress-only-internet-gateway",
            "elastic-gpu",
            "elastic-ip",
            "export-image-task",
            "export-instance-task",
            "fleet",
            "fpga-image",
            "host-reservation",
            "image",
            "import-image-task",
            "import-snapshot-task",
            "instance",
            "instance-event-window",
            "internet-gateway",
            "ipv4pool-ec2",
            "ipv6pool-ec2",
            "key-pair",
            "launch-template",
            "local-gateway",
            "local-gateway-route-table",
            "local-gateway-route-table-virtual-interface-group-association",
            "local-gateway-route-table-vpc-association",
            "local-gateway-virtual-interface",
            "local-gateway-virtual-interface-group",
            "natgateway",
            "network-acl",
            "network-insights-analysis",
            "network-insights-path",
            "network-interface",
            "placement-group",
            "prefix-list",
            "replace-root-volume-task",
            "reserved-instances",
            "route-table",
            "security-group",
            "security-group-rule",
            "snapshot",
            "spot-fleet-request",
            "spot-instances-request",
            "subnet",
            "traffic-mirror-filter",
            "traffic-mirror-session",
            "traffic-mirror-target",
            "transit-gateway",
            "transit-gateway-attachment",
            "transit-gateway-connect-peer",
            "transit-gateway-multicast-domain",
            "transit-gateway-route-table",
            "volume",
            "vpc",
            "vpc-endpoint",
            "vpc-endpoint-service",
            "vpc-flow-log",
            "vpc-peering-connection",
            "vpn-connection",
            "vpn-gateway",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a route for a transit gateway route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRoute {
    /// <p>The CIDR block used for destination matches.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list used for destination matches.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The attachments.</p>
    pub transit_gateway_attachments:
        std::option::Option<std::vec::Vec<crate::model::TransitGatewayRouteAttachment>>,
    /// <p>The route type.</p>
    pub r#type: std::option::Option<crate::model::TransitGatewayRouteType>,
    /// <p>The state of the route.</p>
    pub state: std::option::Option<crate::model::TransitGatewayRouteState>,
}
impl std::fmt::Debug for TransitGatewayRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRoute");
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field(
            "transit_gateway_attachments",
            &self.transit_gateway_attachments,
        );
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayRoute`](crate::model::TransitGatewayRoute)
pub mod transit_gateway_route {
    /// A builder for [`TransitGatewayRoute`](crate::model::TransitGatewayRoute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachments:
            std::option::Option<std::vec::Vec<crate::model::TransitGatewayRouteAttachment>>,
        pub(crate) r#type: std::option::Option<crate::model::TransitGatewayRouteType>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayRouteState>,
    }
    impl Builder {
        /// <p>The CIDR block used for destination matches.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>The ID of the prefix list used for destination matches.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        pub fn transit_gateway_attachments(
            mut self,
            input: impl Into<crate::model::TransitGatewayRouteAttachment>,
        ) -> Self {
            let mut v = self.transit_gateway_attachments.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_attachments = Some(v);
            self
        }
        pub fn set_transit_gateway_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransitGatewayRouteAttachment>>,
        ) -> Self {
            self.transit_gateway_attachments = input;
            self
        }
        /// <p>The route type.</p>
        pub fn r#type(mut self, input: crate::model::TransitGatewayRouteType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayRouteType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the route.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayRouteState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayRouteState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRoute`](crate::model::TransitGatewayRoute)
        pub fn build(self) -> crate::model::TransitGatewayRoute {
            crate::model::TransitGatewayRoute {
                destination_cidr_block: self.destination_cidr_block,
                prefix_list_id: self.prefix_list_id,
                transit_gateway_attachments: self.transit_gateway_attachments,
                r#type: self.r#type,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayRoute {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRoute`](crate::model::TransitGatewayRoute)
    pub fn builder() -> crate::model::transit_gateway_route::Builder {
        crate::model::transit_gateway_route::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayRouteState {
    Active,
    Blackhole,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayRouteState {
    fn from(s: &str) -> Self {
        match s {
            "active" => TransitGatewayRouteState::Active,
            "blackhole" => TransitGatewayRouteState::Blackhole,
            "deleted" => TransitGatewayRouteState::Deleted,
            "deleting" => TransitGatewayRouteState::Deleting,
            "pending" => TransitGatewayRouteState::Pending,
            other => TransitGatewayRouteState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayRouteState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayRouteState::from(s))
    }
}
impl TransitGatewayRouteState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayRouteState::Active => "active",
            TransitGatewayRouteState::Blackhole => "blackhole",
            TransitGatewayRouteState::Deleted => "deleted",
            TransitGatewayRouteState::Deleting => "deleting",
            TransitGatewayRouteState::Pending => "pending",
            TransitGatewayRouteState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "blackhole", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for TransitGatewayRouteState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayRouteType {
    Propagated,
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayRouteType {
    fn from(s: &str) -> Self {
        match s {
            "propagated" => TransitGatewayRouteType::Propagated,
            "static" => TransitGatewayRouteType::Static,
            other => TransitGatewayRouteType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayRouteType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayRouteType::from(s))
    }
}
impl TransitGatewayRouteType {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayRouteType::Propagated => "propagated",
            TransitGatewayRouteType::Static => "static",
            TransitGatewayRouteType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["propagated", "static"]
    }
}
impl AsRef<str> for TransitGatewayRouteType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a route attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRouteAttachment {
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated. </p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
}
impl std::fmt::Debug for TransitGatewayRouteAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRouteAttachment");
        formatter.field("resource_id", &self.resource_id);
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
/// See [`TransitGatewayRouteAttachment`](crate::model::TransitGatewayRouteAttachment)
pub mod transit_gateway_route_attachment {
    /// A builder for [`TransitGatewayRouteAttachment`](crate::model::TransitGatewayRouteAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    }
    impl Builder {
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated. </p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRouteAttachment`](crate::model::TransitGatewayRouteAttachment)
        pub fn build(self) -> crate::model::TransitGatewayRouteAttachment {
            crate::model::TransitGatewayRouteAttachment {
                resource_id: self.resource_id,
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl TransitGatewayRouteAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRouteAttachment`](crate::model::TransitGatewayRouteAttachment)
    pub fn builder() -> crate::model::transit_gateway_route_attachment::Builder {
        crate::model::transit_gateway_route_attachment::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayAttachmentResourceType {
    Connect,
    DirectConnectGateway,
    Peering,
    TgwPeering,
    Vpc,
    Vpn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayAttachmentResourceType {
    fn from(s: &str) -> Self {
        match s {
            "connect" => TransitGatewayAttachmentResourceType::Connect,
            "direct-connect-gateway" => TransitGatewayAttachmentResourceType::DirectConnectGateway,
            "peering" => TransitGatewayAttachmentResourceType::Peering,
            "tgw-peering" => TransitGatewayAttachmentResourceType::TgwPeering,
            "vpc" => TransitGatewayAttachmentResourceType::Vpc,
            "vpn" => TransitGatewayAttachmentResourceType::Vpn,
            other => TransitGatewayAttachmentResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayAttachmentResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayAttachmentResourceType::from(s))
    }
}
impl TransitGatewayAttachmentResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayAttachmentResourceType::Connect => "connect",
            TransitGatewayAttachmentResourceType::DirectConnectGateway => "direct-connect-gateway",
            TransitGatewayAttachmentResourceType::Peering => "peering",
            TransitGatewayAttachmentResourceType::TgwPeering => "tgw-peering",
            TransitGatewayAttachmentResourceType::Vpc => "vpc",
            TransitGatewayAttachmentResourceType::Vpn => "vpn",
            TransitGatewayAttachmentResourceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "connect",
            "direct-connect-gateway",
            "peering",
            "tgw-peering",
            "vpc",
            "vpn",
        ]
    }
}
impl AsRef<str> for TransitGatewayAttachmentResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter name and value pair that is used to return a more specific list of results from a describe operation.
/// Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The filter values. Filter values are case-sensitive.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter. Filter names are case-sensitive.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>Describes the  transit gateway multicast group resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastGroup {
    /// <p>The IP address assigned to the  transit gateway multicast group.</p>
    pub group_ip_address: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource, for example a VPC attachment.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain group resource.</p>
    pub resource_owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway attachment.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>Indicates that the resource is a  transit gateway multicast group member.</p>
    pub group_member: std::option::Option<bool>,
    /// <p>Indicates that the resource is a  transit gateway multicast group member.</p>
    pub group_source: std::option::Option<bool>,
    /// <p>The member type (for example, <code>static</code>).</p>
    pub member_type: std::option::Option<crate::model::MembershipType>,
    /// <p>The source type.</p>
    pub source_type: std::option::Option<crate::model::MembershipType>,
}
impl std::fmt::Debug for TransitGatewayMulticastGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastGroup");
        formatter.field("group_ip_address", &self.group_ip_address);
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_owner_id", &self.resource_owner_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("group_member", &self.group_member);
        formatter.field("group_source", &self.group_source);
        formatter.field("member_type", &self.member_type);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastGroup`](crate::model::TransitGatewayMulticastGroup)
pub mod transit_gateway_multicast_group {
    /// A builder for [`TransitGatewayMulticastGroup`](crate::model::TransitGatewayMulticastGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_ip_address: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) resource_owner_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) group_member: std::option::Option<bool>,
        pub(crate) group_source: std::option::Option<bool>,
        pub(crate) member_type: std::option::Option<crate::model::MembershipType>,
        pub(crate) source_type: std::option::Option<crate::model::MembershipType>,
    }
    impl Builder {
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_ip_address = Some(input.into());
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_ip_address = input;
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource, for example a VPC attachment.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain group resource.</p>
        pub fn resource_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner_id = Some(input.into());
            self
        }
        pub fn set_resource_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner_id = input;
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>Indicates that the resource is a  transit gateway multicast group member.</p>
        pub fn group_member(mut self, input: bool) -> Self {
            self.group_member = Some(input);
            self
        }
        pub fn set_group_member(mut self, input: std::option::Option<bool>) -> Self {
            self.group_member = input;
            self
        }
        /// <p>Indicates that the resource is a  transit gateway multicast group member.</p>
        pub fn group_source(mut self, input: bool) -> Self {
            self.group_source = Some(input);
            self
        }
        pub fn set_group_source(mut self, input: std::option::Option<bool>) -> Self {
            self.group_source = input;
            self
        }
        /// <p>The member type (for example, <code>static</code>).</p>
        pub fn member_type(mut self, input: crate::model::MembershipType) -> Self {
            self.member_type = Some(input);
            self
        }
        pub fn set_member_type(
            mut self,
            input: std::option::Option<crate::model::MembershipType>,
        ) -> Self {
            self.member_type = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: crate::model::MembershipType) -> Self {
            self.source_type = Some(input);
            self
        }
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::MembershipType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastGroup`](crate::model::TransitGatewayMulticastGroup)
        pub fn build(self) -> crate::model::TransitGatewayMulticastGroup {
            crate::model::TransitGatewayMulticastGroup {
                group_ip_address: self.group_ip_address,
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                subnet_id: self.subnet_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_owner_id: self.resource_owner_id,
                network_interface_id: self.network_interface_id,
                group_member: self.group_member,
                group_source: self.group_source,
                member_type: self.member_type,
                source_type: self.source_type,
            }
        }
    }
}
impl TransitGatewayMulticastGroup {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastGroup`](crate::model::TransitGatewayMulticastGroup)
    pub fn builder() -> crate::model::transit_gateway_multicast_group::Builder {
        crate::model::transit_gateway_multicast_group::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MembershipType {
    Igmp,
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MembershipType {
    fn from(s: &str) -> Self {
        match s {
            "igmp" => MembershipType::Igmp,
            "static" => MembershipType::Static,
            other => MembershipType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MembershipType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MembershipType::from(s))
    }
}
impl MembershipType {
    pub fn as_str(&self) -> &str {
        match self {
            MembershipType::Igmp => "igmp",
            MembershipType::Static => "static",
            MembershipType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["igmp", "static"]
    }
}
impl AsRef<str> for MembershipType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a route for a local gateway route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayRoute {
    /// <p>The CIDR block used for destination matches.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The ID of the virtual interface group.</p>
    pub local_gateway_virtual_interface_group_id: std::option::Option<std::string::String>,
    /// <p>The route type.</p>
    pub r#type: std::option::Option<crate::model::LocalGatewayRouteType>,
    /// <p>The state of the route.</p>
    pub state: std::option::Option<crate::model::LocalGatewayRouteState>,
    /// <p>The ID of the local gateway route table.</p>
    pub local_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the local gateway route table.</p>
    pub local_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway route.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LocalGatewayRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGatewayRoute");
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field(
            "local_gateway_virtual_interface_group_id",
            &self.local_gateway_virtual_interface_group_id,
        );
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field(
            "local_gateway_route_table_id",
            &self.local_gateway_route_table_id,
        );
        formatter.field(
            "local_gateway_route_table_arn",
            &self.local_gateway_route_table_arn,
        );
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`LocalGatewayRoute`](crate::model::LocalGatewayRoute)
pub mod local_gateway_route {
    /// A builder for [`LocalGatewayRoute`](crate::model::LocalGatewayRoute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) local_gateway_virtual_interface_group_id:
            std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::LocalGatewayRouteType>,
        pub(crate) state: std::option::Option<crate::model::LocalGatewayRouteState>,
        pub(crate) local_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block used for destination matches.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>The ID of the virtual interface group.</p>
        pub fn local_gateway_virtual_interface_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_virtual_interface_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = input;
            self
        }
        /// <p>The route type.</p>
        pub fn r#type(mut self, input: crate::model::LocalGatewayRouteType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LocalGatewayRouteType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the route.</p>
        pub fn state(mut self, input: crate::model::LocalGatewayRouteState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LocalGatewayRouteState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the local gateway route table.</p>
        pub fn local_gateway_route_table_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway route.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayRoute`](crate::model::LocalGatewayRoute)
        pub fn build(self) -> crate::model::LocalGatewayRoute {
            crate::model::LocalGatewayRoute {
                destination_cidr_block: self.destination_cidr_block,
                local_gateway_virtual_interface_group_id: self
                    .local_gateway_virtual_interface_group_id,
                r#type: self.r#type,
                state: self.state,
                local_gateway_route_table_id: self.local_gateway_route_table_id,
                local_gateway_route_table_arn: self.local_gateway_route_table_arn,
                owner_id: self.owner_id,
            }
        }
    }
}
impl LocalGatewayRoute {
    /// Creates a new builder-style object to manufacture [`LocalGatewayRoute`](crate::model::LocalGatewayRoute)
    pub fn builder() -> crate::model::local_gateway_route::Builder {
        crate::model::local_gateway_route::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LocalGatewayRouteState {
    Active,
    Blackhole,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LocalGatewayRouteState {
    fn from(s: &str) -> Self {
        match s {
            "active" => LocalGatewayRouteState::Active,
            "blackhole" => LocalGatewayRouteState::Blackhole,
            "deleted" => LocalGatewayRouteState::Deleted,
            "deleting" => LocalGatewayRouteState::Deleting,
            "pending" => LocalGatewayRouteState::Pending,
            other => LocalGatewayRouteState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LocalGatewayRouteState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LocalGatewayRouteState::from(s))
    }
}
impl LocalGatewayRouteState {
    pub fn as_str(&self) -> &str {
        match self {
            LocalGatewayRouteState::Active => "active",
            LocalGatewayRouteState::Blackhole => "blackhole",
            LocalGatewayRouteState::Deleted => "deleted",
            LocalGatewayRouteState::Deleting => "deleting",
            LocalGatewayRouteState::Pending => "pending",
            LocalGatewayRouteState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "blackhole", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for LocalGatewayRouteState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LocalGatewayRouteType {
    Propagated,
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LocalGatewayRouteType {
    fn from(s: &str) -> Self {
        match s {
            "propagated" => LocalGatewayRouteType::Propagated,
            "static" => LocalGatewayRouteType::Static,
            other => LocalGatewayRouteType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LocalGatewayRouteType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LocalGatewayRouteType::from(s))
    }
}
impl LocalGatewayRouteType {
    pub fn as_str(&self) -> &str {
        match self {
            LocalGatewayRouteType::Propagated => "propagated",
            LocalGatewayRouteType::Static => "static",
            LocalGatewayRouteType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["propagated", "static"]
    }
}
impl AsRef<str> for LocalGatewayRouteType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the launch specification for a Scheduled Instance.</p>
/// <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet.
/// You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesLaunchSpecification {
    /// <p>The block device mapping entries.</p>
    pub block_device_mappings:
        std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesBlockDeviceMapping>>,
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile:
        std::option::Option<crate::model::ScheduledInstancesIamInstanceProfile>,
    /// <p>The ID of the Amazon Machine Image (AMI).</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the kernel.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>Enable or disable monitoring for the instances.</p>
    pub monitoring: std::option::Option<crate::model::ScheduledInstancesMonitoring>,
    /// <p>The network interfaces.</p>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesNetworkInterface>>,
    /// <p>The placement information.</p>
    pub placement: std::option::Option<crate::model::ScheduledInstancesPlacement>,
    /// <p>The ID of the RAM disk.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the security groups.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the subnet in which to launch the instances.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The base64-encoded MIME user data.</p>
    pub user_data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesLaunchSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesLaunchSpecification");
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &self.user_data);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesLaunchSpecification`](crate::model::ScheduledInstancesLaunchSpecification)
pub mod scheduled_instances_launch_specification {
    /// A builder for [`ScheduledInstancesLaunchSpecification`](crate::model::ScheduledInstancesLaunchSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesBlockDeviceMapping>>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::ScheduledInstancesIamInstanceProfile>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::ScheduledInstancesMonitoring>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesNetworkInterface>>,
        pub(crate) placement: std::option::Option<crate::model::ScheduledInstancesPlacement>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::ScheduledInstancesBlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ScheduledInstancesBlockDeviceMapping>,
            >,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::ScheduledInstancesIamInstanceProfile,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstancesIamInstanceProfile>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI).</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the kernel.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>Enable or disable monitoring for the instances.</p>
        pub fn monitoring(mut self, input: crate::model::ScheduledInstancesMonitoring) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstancesMonitoring>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::ScheduledInstancesNetworkInterface>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ScheduledInstancesNetworkInterface>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The placement information.</p>
        pub fn placement(mut self, input: crate::model::ScheduledInstancesPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstancesPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>The ID of the subnet in which to launch the instances.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The base64-encoded MIME user data.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesLaunchSpecification`](crate::model::ScheduledInstancesLaunchSpecification)
        pub fn build(self) -> crate::model::ScheduledInstancesLaunchSpecification {
            crate::model::ScheduledInstancesLaunchSpecification {
                block_device_mappings: self.block_device_mappings,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                image_id: self.image_id,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                monitoring: self.monitoring,
                network_interfaces: self.network_interfaces,
                placement: self.placement,
                ramdisk_id: self.ramdisk_id,
                security_group_ids: self.security_group_ids,
                subnet_id: self.subnet_id,
                user_data: self.user_data,
            }
        }
    }
}
impl ScheduledInstancesLaunchSpecification {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesLaunchSpecification`](crate::model::ScheduledInstancesLaunchSpecification)
    pub fn builder() -> crate::model::scheduled_instances_launch_specification::Builder {
        crate::model::scheduled_instances_launch_specification::Builder::default()
    }
}

/// <p>Describes the placement for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesPlacement {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The name of the placement group.</p>
    pub group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesPlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesPlacement");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("group_name", &self.group_name);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesPlacement`](crate::model::ScheduledInstancesPlacement)
pub mod scheduled_instances_placement {
    /// A builder for [`ScheduledInstancesPlacement`](crate::model::ScheduledInstancesPlacement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The name of the placement group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesPlacement`](crate::model::ScheduledInstancesPlacement)
        pub fn build(self) -> crate::model::ScheduledInstancesPlacement {
            crate::model::ScheduledInstancesPlacement {
                availability_zone: self.availability_zone,
                group_name: self.group_name,
            }
        }
    }
}
impl ScheduledInstancesPlacement {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesPlacement`](crate::model::ScheduledInstancesPlacement)
    pub fn builder() -> crate::model::scheduled_instances_placement::Builder {
        crate::model::scheduled_instances_placement::Builder::default()
    }
}

/// <p>Describes a network interface for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesNetworkInterface {
    /// <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The
    /// public IPv4 address can only be assigned to a network interface for eth0, and can only be
    /// assigned to a new network interface, not an existing one. You cannot specify more than one
    /// network interface in the request. If launching into a default subnet, the default value is
    /// <code>true</code>.</p>
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>Indicates whether to delete the interface when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The index of the device for the network interface attachment.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The IDs of the security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
    pub ipv6_address_count: std::option::Option<i32>,
    /// <p>The specific IPv6 addresses from the subnet range.</p>
    pub ipv6_addresses:
        std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesIpv6Address>>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The private IPv4 addresses.</p>
    pub private_ip_address_configs:
        std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesPrivateIpAddressConfig>>,
    /// <p>The number of secondary private IPv4 addresses.</p>
    pub secondary_private_ip_address_count: std::option::Option<i32>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesNetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesNetworkInterface");
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("description", &self.description);
        formatter.field("device_index", &self.device_index);
        formatter.field("groups", &self.groups);
        formatter.field("ipv6_address_count", &self.ipv6_address_count);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field(
            "private_ip_address_configs",
            &self.private_ip_address_configs,
        );
        formatter.field(
            "secondary_private_ip_address_count",
            &self.secondary_private_ip_address_count,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesNetworkInterface`](crate::model::ScheduledInstancesNetworkInterface)
pub mod scheduled_instances_network_interface {
    /// A builder for [`ScheduledInstancesNetworkInterface`](crate::model::ScheduledInstancesNetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ipv6_address_count: std::option::Option<i32>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesIpv6Address>>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_address_configs: std::option::Option<
            std::vec::Vec<crate::model::ScheduledInstancesPrivateIpAddressConfig>,
        >,
        pub(crate) secondary_private_ip_address_count: std::option::Option<i32>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The
        /// public IPv4 address can only be assigned to a network interface for eth0, and can only be
        /// assigned to a new network interface, not an existing one. You cannot specify more than one
        /// network interface in the request. If launching into a default subnet, the default value is
        /// <code>true</code>.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// <p>Indicates whether to delete the interface when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The index of the device for the network interface attachment.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.ipv6_address_count = Some(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_address_count = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::ScheduledInstancesIpv6Address>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScheduledInstancesIpv6Address>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_address_configs(
            mut self,
            input: impl Into<crate::model::ScheduledInstancesPrivateIpAddressConfig>,
        ) -> Self {
            let mut v = self.private_ip_address_configs.unwrap_or_default();
            v.push(input.into());
            self.private_ip_address_configs = Some(v);
            self
        }
        pub fn set_private_ip_address_configs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ScheduledInstancesPrivateIpAddressConfig>,
            >,
        ) -> Self {
            self.private_ip_address_configs = input;
            self
        }
        /// <p>The number of secondary private IPv4 addresses.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.secondary_private_ip_address_count = Some(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.secondary_private_ip_address_count = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesNetworkInterface`](crate::model::ScheduledInstancesNetworkInterface)
        pub fn build(self) -> crate::model::ScheduledInstancesNetworkInterface {
            crate::model::ScheduledInstancesNetworkInterface {
                associate_public_ip_address: self.associate_public_ip_address,
                delete_on_termination: self.delete_on_termination,
                description: self.description,
                device_index: self.device_index,
                groups: self.groups,
                ipv6_address_count: self.ipv6_address_count,
                ipv6_addresses: self.ipv6_addresses,
                network_interface_id: self.network_interface_id,
                private_ip_address: self.private_ip_address,
                private_ip_address_configs: self.private_ip_address_configs,
                secondary_private_ip_address_count: self.secondary_private_ip_address_count,
                subnet_id: self.subnet_id,
            }
        }
    }
}
impl ScheduledInstancesNetworkInterface {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesNetworkInterface`](crate::model::ScheduledInstancesNetworkInterface)
    pub fn builder() -> crate::model::scheduled_instances_network_interface::Builder {
        crate::model::scheduled_instances_network_interface::Builder::default()
    }
}

/// <p>Describes a private IPv4 address for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesPrivateIpAddressConfig {
    /// <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
    pub primary: std::option::Option<bool>,
    /// <p>The IPv4 address.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesPrivateIpAddressConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesPrivateIpAddressConfig");
        formatter.field("primary", &self.primary);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesPrivateIpAddressConfig`](crate::model::ScheduledInstancesPrivateIpAddressConfig)
pub mod scheduled_instances_private_ip_address_config {
    /// A builder for [`ScheduledInstancesPrivateIpAddressConfig`](crate::model::ScheduledInstancesPrivateIpAddressConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary: std::option::Option<bool>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// <p>The IPv4 address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesPrivateIpAddressConfig`](crate::model::ScheduledInstancesPrivateIpAddressConfig)
        pub fn build(self) -> crate::model::ScheduledInstancesPrivateIpAddressConfig {
            crate::model::ScheduledInstancesPrivateIpAddressConfig {
                primary: self.primary,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl ScheduledInstancesPrivateIpAddressConfig {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesPrivateIpAddressConfig`](crate::model::ScheduledInstancesPrivateIpAddressConfig)
    pub fn builder() -> crate::model::scheduled_instances_private_ip_address_config::Builder {
        crate::model::scheduled_instances_private_ip_address_config::Builder::default()
    }
}

/// <p>Describes an IPv6 address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesIpv6Address {
    /// <p>The IPv6 address.</p>
    pub ipv6_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesIpv6Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesIpv6Address");
        formatter.field("ipv6_address", &self.ipv6_address);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesIpv6Address`](crate::model::ScheduledInstancesIpv6Address)
pub mod scheduled_instances_ipv6_address {
    /// A builder for [`ScheduledInstancesIpv6Address`](crate::model::ScheduledInstancesIpv6Address)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 address.</p>
        pub fn ipv6_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_address = Some(input.into());
            self
        }
        pub fn set_ipv6_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_address = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesIpv6Address`](crate::model::ScheduledInstancesIpv6Address)
        pub fn build(self) -> crate::model::ScheduledInstancesIpv6Address {
            crate::model::ScheduledInstancesIpv6Address {
                ipv6_address: self.ipv6_address,
            }
        }
    }
}
impl ScheduledInstancesIpv6Address {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesIpv6Address`](crate::model::ScheduledInstancesIpv6Address)
    pub fn builder() -> crate::model::scheduled_instances_ipv6_address::Builder {
        crate::model::scheduled_instances_ipv6_address::Builder::default()
    }
}

/// <p>Describes whether monitoring is enabled for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesMonitoring {
    /// <p>Indicates whether monitoring is enabled.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for ScheduledInstancesMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesMonitoring");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesMonitoring`](crate::model::ScheduledInstancesMonitoring)
pub mod scheduled_instances_monitoring {
    /// A builder for [`ScheduledInstancesMonitoring`](crate::model::ScheduledInstancesMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether monitoring is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesMonitoring`](crate::model::ScheduledInstancesMonitoring)
        pub fn build(self) -> crate::model::ScheduledInstancesMonitoring {
            crate::model::ScheduledInstancesMonitoring {
                enabled: self.enabled,
            }
        }
    }
}
impl ScheduledInstancesMonitoring {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesMonitoring`](crate::model::ScheduledInstancesMonitoring)
    pub fn builder() -> crate::model::scheduled_instances_monitoring::Builder {
        crate::model::scheduled_instances_monitoring::Builder::default()
    }
}

/// <p>Describes an IAM instance profile for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesIamInstanceProfile {
    /// <p>The Amazon Resource Name (ARN).</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesIamInstanceProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesIamInstanceProfile");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesIamInstanceProfile`](crate::model::ScheduledInstancesIamInstanceProfile)
pub mod scheduled_instances_iam_instance_profile {
    /// A builder for [`ScheduledInstancesIamInstanceProfile`](crate::model::ScheduledInstancesIamInstanceProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesIamInstanceProfile`](crate::model::ScheduledInstancesIamInstanceProfile)
        pub fn build(self) -> crate::model::ScheduledInstancesIamInstanceProfile {
            crate::model::ScheduledInstancesIamInstanceProfile {
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl ScheduledInstancesIamInstanceProfile {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesIamInstanceProfile`](crate::model::ScheduledInstancesIamInstanceProfile)
    pub fn builder() -> crate::model::scheduled_instances_iam_instance_profile::Builder {
        crate::model::scheduled_instances_iam_instance_profile::Builder::default()
    }
}

/// <p>Describes a block device mapping for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesBlockDeviceMapping {
    /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
    pub ebs: std::option::Option<crate::model::ScheduledInstancesEbs>,
    /// <p>To omit the device from the block device mapping, specify an empty string.</p>
    pub no_device: std::option::Option<std::string::String>,
    /// <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered
    /// starting from 0. An instance type with two available instance store volumes can specify mappings
    /// for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store
    /// volumes depends on the instance type. After you connect to the instance, you must mount the
    /// volume.</p>
    /// <p>Constraints: For M3 instances, you must specify instance store volumes in the block device
    /// mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes
    /// specified in the block device mapping for the AMI.</p>
    pub virtual_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesBlockDeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesBlockDeviceMapping");
        formatter.field("device_name", &self.device_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesBlockDeviceMapping`](crate::model::ScheduledInstancesBlockDeviceMapping)
pub mod scheduled_instances_block_device_mapping {
    /// A builder for [`ScheduledInstancesBlockDeviceMapping`](crate::model::ScheduledInstancesBlockDeviceMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::ScheduledInstancesEbs>,
        pub(crate) no_device: std::option::Option<std::string::String>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
        pub fn ebs(mut self, input: crate::model::ScheduledInstancesEbs) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstancesEbs>,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// <p>To omit the device from the block device mapping, specify an empty string.</p>
        pub fn no_device(mut self, input: impl Into<std::string::String>) -> Self {
            self.no_device = Some(input.into());
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.no_device = input;
            self
        }
        /// <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered
        /// starting from 0. An instance type with two available instance store volumes can specify mappings
        /// for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store
        /// volumes depends on the instance type. After you connect to the instance, you must mount the
        /// volume.</p>
        /// <p>Constraints: For M3 instances, you must specify instance store volumes in the block device
        /// mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes
        /// specified in the block device mapping for the AMI.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesBlockDeviceMapping`](crate::model::ScheduledInstancesBlockDeviceMapping)
        pub fn build(self) -> crate::model::ScheduledInstancesBlockDeviceMapping {
            crate::model::ScheduledInstancesBlockDeviceMapping {
                device_name: self.device_name,
                ebs: self.ebs,
                no_device: self.no_device,
                virtual_name: self.virtual_name,
            }
        }
    }
}
impl ScheduledInstancesBlockDeviceMapping {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesBlockDeviceMapping`](crate::model::ScheduledInstancesBlockDeviceMapping)
    pub fn builder() -> crate::model::scheduled_instances_block_device_mapping::Builder {
        crate::model::scheduled_instances_block_device_mapping::Builder::default()
    }
}

/// <p>Describes an EBS volume for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstancesEbs {
    /// <p>Indicates whether the volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The number of I/O operations per second (IOPS) to provision for an <code>io1</code> or <code>io2</code> volume, with a maximum
    /// ratio of 50 IOPS/GiB for <code>io1</code>, and 500 IOPS/GiB for <code>io2</code>. Range is 100 to 64,000 IOPS for
    /// volumes in most Regions. Maximum IOPS of 64,000 is guaranteed only on
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">instances built on the Nitro System</a>. Other instance families guarantee performance up to
    /// 32,000 IOPS. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
    /// <i>Amazon EC2 User Guide</i>.</p>
    /// <p>This parameter is valid only for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) volumes.</p>
    pub iops: std::option::Option<i32>,
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiB.</p>
    /// <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code> io2</code> for Provisioned IOPS SSD, Throughput Optimized HDD
    /// for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for
    /// Magnetic.</p>
    /// <p>Default: <code>gp2</code>
    /// </p>
    pub volume_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstancesEbs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstancesEbs");
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("iops", &self.iops);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.finish()
    }
}
/// See [`ScheduledInstancesEbs`](crate::model::ScheduledInstancesEbs)
pub mod scheduled_instances_ebs {
    /// A builder for [`ScheduledInstancesEbs`](crate::model::ScheduledInstancesEbs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The number of I/O operations per second (IOPS) to provision for an <code>io1</code> or <code>io2</code> volume, with a maximum
        /// ratio of 50 IOPS/GiB for <code>io1</code>, and 500 IOPS/GiB for <code>io2</code>. Range is 100 to 64,000 IOPS for
        /// volumes in most Regions. Maximum IOPS of 64,000 is guaranteed only on
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">instances built on the Nitro System</a>. Other instance families guarantee performance up to
        /// 32,000 IOPS. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        /// <p>This parameter is valid only for Provisioned IOPS SSD (<code>io1</code> and <code>io2</code>) volumes.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The size of the volume, in GiB.</p>
        /// <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code> io2</code> for Provisioned IOPS SSD, Throughput Optimized HDD
        /// for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for
        /// Magnetic.</p>
        /// <p>Default: <code>gp2</code>
        /// </p>
        pub fn volume_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_type = Some(input.into());
            self
        }
        pub fn set_volume_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstancesEbs`](crate::model::ScheduledInstancesEbs)
        pub fn build(self) -> crate::model::ScheduledInstancesEbs {
            crate::model::ScheduledInstancesEbs {
                delete_on_termination: self.delete_on_termination,
                encrypted: self.encrypted,
                iops: self.iops,
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size,
                volume_type: self.volume_type,
            }
        }
    }
}
impl ScheduledInstancesEbs {
    /// Creates a new builder-style object to manufacture [`ScheduledInstancesEbs`](crate::model::ScheduledInstancesEbs)
    pub fn builder() -> crate::model::scheduled_instances_ebs::Builder {
        crate::model::scheduled_instances_ebs::Builder::default()
    }
}

/// <p>Describes an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Instance {
    /// <p>The AMI launch index, which can be used to find this instance in the launch
    /// group.</p>
    pub ami_launch_index: std::option::Option<i32>,
    /// <p>The ID of the AMI used to launch the instance.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The kernel associated with this instance, if applicable.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair, if this instance was launched with an associated key
    /// pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The time the instance was launched.</p>
    pub launch_time: std::option::Option<smithy_types::Instant>,
    /// <p>The monitoring for the instance.</p>
    pub monitoring: std::option::Option<crate::model::Monitoring>,
    /// <p>The location where the instance launched, if applicable.</p>
    pub placement: std::option::Option<crate::model::Placement>,
    /// <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
    pub platform: std::option::Option<crate::model::PlatformValues>,
    /// <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname
    /// can only be used inside the Amazon EC2 network. This name is not available until the
    /// instance enters the <code>running</code> state. </p>
    /// <p>[EC2-VPC] The Amazon-provided DNS server resolves Amazon-provided private DNS
    /// hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not
    /// using the Amazon-provided DNS server in your VPC, your custom domain name servers must
    /// resolve the hostname as appropriate.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The private IPv4 address assigned to the instance.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The product codes attached to this instance, if applicable.</p>
    pub product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
    /// <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available
    /// until the instance enters the <code>running</code> state. For EC2-VPC, this name is only
    /// available if you've enabled DNS hostnames for your VPC.</p>
    pub public_dns_name: std::option::Option<std::string::String>,
    /// <p>The public IPv4 address, or the Carrier IP address assigned to the instance, if
    /// applicable.</p>
    /// <p>A Carrier IP address only applies to an instance launched in a subnet associated with
    /// a Wavelength Zone.</p>
    pub public_ip_address: std::option::Option<std::string::String>,
    /// <p>The RAM disk associated with this instance, if applicable.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The current state of the instance.</p>
    pub state: std::option::Option<crate::model::InstanceState>,
    /// <p>The reason for the most recent state transition. This might be an empty string.</p>
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The architecture of the image.</p>
    pub architecture: std::option::Option<crate::model::ArchitectureValues>,
    /// <p>Any block device mapping entries for the instance.</p>
    pub block_device_mappings:
        std::option::Option<std::vec::Vec<crate::model::InstanceBlockDeviceMapping>>,
    /// <p>The idempotency token you provided when you launched the instance, if
    /// applicable.</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization
    /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
    /// provide optimal I/O performance. This optimization isn't available with all instance
    /// types. Additional usage charges apply when using an EBS Optimized instance.</p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>Specifies whether enhanced networking with ENA is enabled.</p>
    pub ena_support: std::option::Option<bool>,
    /// <p>The hypervisor type of the instance. The value <code>xen</code> is used for both Xen and
    /// Nitro hypervisors.</p>
    pub hypervisor: std::option::Option<crate::model::HypervisorType>,
    /// <p>The IAM instance profile associated with the instance, if applicable.</p>
    pub iam_instance_profile: std::option::Option<crate::model::IamInstanceProfile>,
    /// <p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>
    pub instance_lifecycle: std::option::Option<crate::model::InstanceLifecycleType>,
    /// <p>The Elastic GPU associated with the instance.</p>
    pub elastic_gpu_associations:
        std::option::Option<std::vec::Vec<crate::model::ElasticGpuAssociation>>,
    /// <p> The elastic inference accelerator associated with the instance.</p>
    pub elastic_inference_accelerator_associations:
        std::option::Option<std::vec::Vec<crate::model::ElasticInferenceAcceleratorAssociation>>,
    /// <p>[EC2-VPC] The network interfaces for the instance.</p>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterface>>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The device name of the root device volume (for example,
    /// <code>/dev/sda1</code>).</p>
    pub root_device_name: std::option::Option<std::string::String>,
    /// <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance
    /// store volume.</p>
    pub root_device_type: std::option::Option<crate::model::DeviceType>,
    /// <p>The security groups for the instance.</p>
    pub security_groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>Indicates whether source/destination checking is enabled.</p>
    pub source_dest_check: std::option::Option<bool>,
    /// <p>If the request is a Spot Instance request, the ID of the request.</p>
    pub spot_instance_request_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface
    /// is enabled.</p>
    pub sriov_net_support: std::option::Option<std::string::String>,
    /// <p>The reason for the most recent state transition.</p>
    pub state_reason: std::option::Option<crate::model::StateReason>,
    /// <p>Any tags assigned to the instance.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The virtualization type of the instance.</p>
    pub virtualization_type: std::option::Option<crate::model::VirtualizationType>,
    /// <p>The CPU options for the instance.</p>
    pub cpu_options: std::option::Option<crate::model::CpuOptions>,
    /// <p>The ID of the Capacity Reservation.</p>
    pub capacity_reservation_id: std::option::Option<std::string::String>,
    /// <p>Information about the Capacity Reservation targeting option.</p>
    pub capacity_reservation_specification:
        std::option::Option<crate::model::CapacityReservationSpecificationResponse>,
    /// <p>Indicates whether the instance is enabled for hibernation.</p>
    pub hibernation_options: std::option::Option<crate::model::HibernationOptions>,
    /// <p>The license configurations.</p>
    pub licenses: std::option::Option<std::vec::Vec<crate::model::LicenseConfiguration>>,
    /// <p>The metadata options for the instance.</p>
    pub metadata_options: std::option::Option<crate::model::InstanceMetadataOptionsResponse>,
    /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
    pub enclave_options: std::option::Option<crate::model::EnclaveOptions>,
    /// <p>The boot mode of the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
    /// <i>Amazon EC2 User Guide</i>.</p>
    pub boot_mode: std::option::Option<crate::model::BootModeValues>,
}
impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Instance");
        formatter.field("ami_launch_index", &self.ami_launch_index);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("launch_time", &self.launch_time);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("placement", &self.placement);
        formatter.field("platform", &self.platform);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("product_codes", &self.product_codes);
        formatter.field("public_dns_name", &self.public_dns_name);
        formatter.field("public_ip_address", &self.public_ip_address);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("architecture", &self.architecture);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("client_token", &self.client_token);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("ena_support", &self.ena_support);
        formatter.field("hypervisor", &self.hypervisor);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("instance_lifecycle", &self.instance_lifecycle);
        formatter.field("elastic_gpu_associations", &self.elastic_gpu_associations);
        formatter.field(
            "elastic_inference_accelerator_associations",
            &self.elastic_inference_accelerator_associations,
        );
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("root_device_name", &self.root_device_name);
        formatter.field("root_device_type", &self.root_device_type);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("source_dest_check", &self.source_dest_check);
        formatter.field("spot_instance_request_id", &self.spot_instance_request_id);
        formatter.field("sriov_net_support", &self.sriov_net_support);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("tags", &self.tags);
        formatter.field("virtualization_type", &self.virtualization_type);
        formatter.field("cpu_options", &self.cpu_options);
        formatter.field("capacity_reservation_id", &self.capacity_reservation_id);
        formatter.field(
            "capacity_reservation_specification",
            &self.capacity_reservation_specification,
        );
        formatter.field("hibernation_options", &self.hibernation_options);
        formatter.field("licenses", &self.licenses);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.field("enclave_options", &self.enclave_options);
        formatter.field("boot_mode", &self.boot_mode);
        formatter.finish()
    }
}
/// See [`Instance`](crate::model::Instance)
pub mod instance {
    /// A builder for [`Instance`](crate::model::Instance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ami_launch_index: std::option::Option<i32>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) launch_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring: std::option::Option<crate::model::Monitoring>,
        pub(crate) placement: std::option::Option<crate::model::Placement>,
        pub(crate) platform: std::option::Option<crate::model::PlatformValues>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        pub(crate) public_dns_name: std::option::Option<std::string::String>,
        pub(crate) public_ip_address: std::option::Option<std::string::String>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::InstanceState>,
        pub(crate) state_transition_reason: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<crate::model::ArchitectureValues>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::InstanceBlockDeviceMapping>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) ena_support: std::option::Option<bool>,
        pub(crate) hypervisor: std::option::Option<crate::model::HypervisorType>,
        pub(crate) iam_instance_profile: std::option::Option<crate::model::IamInstanceProfile>,
        pub(crate) instance_lifecycle: std::option::Option<crate::model::InstanceLifecycleType>,
        pub(crate) elastic_gpu_associations:
            std::option::Option<std::vec::Vec<crate::model::ElasticGpuAssociation>>,
        pub(crate) elastic_inference_accelerator_associations: std::option::Option<
            std::vec::Vec<crate::model::ElasticInferenceAcceleratorAssociation>,
        >,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterface>>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) root_device_name: std::option::Option<std::string::String>,
        pub(crate) root_device_type: std::option::Option<crate::model::DeviceType>,
        pub(crate) security_groups:
            std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) source_dest_check: std::option::Option<bool>,
        pub(crate) spot_instance_request_id: std::option::Option<std::string::String>,
        pub(crate) sriov_net_support: std::option::Option<std::string::String>,
        pub(crate) state_reason: std::option::Option<crate::model::StateReason>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) virtualization_type: std::option::Option<crate::model::VirtualizationType>,
        pub(crate) cpu_options: std::option::Option<crate::model::CpuOptions>,
        pub(crate) capacity_reservation_id: std::option::Option<std::string::String>,
        pub(crate) capacity_reservation_specification:
            std::option::Option<crate::model::CapacityReservationSpecificationResponse>,
        pub(crate) hibernation_options: std::option::Option<crate::model::HibernationOptions>,
        pub(crate) licenses: std::option::Option<std::vec::Vec<crate::model::LicenseConfiguration>>,
        pub(crate) metadata_options:
            std::option::Option<crate::model::InstanceMetadataOptionsResponse>,
        pub(crate) enclave_options: std::option::Option<crate::model::EnclaveOptions>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootModeValues>,
    }
    impl Builder {
        /// <p>The AMI launch index, which can be used to find this instance in the launch
        /// group.</p>
        pub fn ami_launch_index(mut self, input: i32) -> Self {
            self.ami_launch_index = Some(input);
            self
        }
        pub fn set_ami_launch_index(mut self, input: std::option::Option<i32>) -> Self {
            self.ami_launch_index = input;
            self
        }
        /// <p>The ID of the AMI used to launch the instance.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The kernel associated with this instance, if applicable.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair, if this instance was launched with an associated key
        /// pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The time the instance was launched.</p>
        pub fn launch_time(mut self, input: smithy_types::Instant) -> Self {
            self.launch_time = Some(input);
            self
        }
        pub fn set_launch_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.launch_time = input;
            self
        }
        /// <p>The monitoring for the instance.</p>
        pub fn monitoring(mut self, input: crate::model::Monitoring) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::Monitoring>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        /// <p>The location where the instance launched, if applicable.</p>
        pub fn placement(mut self, input: crate::model::Placement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::Placement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname
        /// can only be used inside the Amazon EC2 network. This name is not available until the
        /// instance enters the <code>running</code> state. </p>
        /// <p>[EC2-VPC] The Amazon-provided DNS server resolves Amazon-provided private DNS
        /// hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not
        /// using the Amazon-provided DNS server in your VPC, your custom domain name servers must
        /// resolve the hostname as appropriate.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The private IPv4 address assigned to the instance.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn product_codes(mut self, input: impl Into<crate::model::ProductCode>) -> Self {
            let mut v = self.product_codes.unwrap_or_default();
            v.push(input.into());
            self.product_codes = Some(v);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        ) -> Self {
            self.product_codes = input;
            self
        }
        /// <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available
        /// until the instance enters the <code>running</code> state. For EC2-VPC, this name is only
        /// available if you've enabled DNS hostnames for your VPC.</p>
        pub fn public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_dns_name = Some(input.into());
            self
        }
        pub fn set_public_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_dns_name = input;
            self
        }
        /// <p>The public IPv4 address, or the Carrier IP address assigned to the instance, if
        /// applicable.</p>
        /// <p>A Carrier IP address only applies to an instance launched in a subnet associated with
        /// a Wavelength Zone.</p>
        pub fn public_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip_address = Some(input.into());
            self
        }
        pub fn set_public_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ip_address = input;
            self
        }
        /// <p>The RAM disk associated with this instance, if applicable.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// <p>The current state of the instance.</p>
        pub fn state(mut self, input: crate::model::InstanceState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::InstanceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the most recent state transition. This might be an empty string.</p>
        pub fn state_transition_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_transition_reason = Some(input.into());
            self
        }
        pub fn set_state_transition_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_transition_reason = input;
            self
        }
        /// <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The architecture of the image.</p>
        pub fn architecture(mut self, input: crate::model::ArchitectureValues) -> Self {
            self.architecture = Some(input);
            self
        }
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::ArchitectureValues>,
        ) -> Self {
            self.architecture = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::InstanceBlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceBlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>The idempotency token you provided when you launched the instance, if
        /// applicable.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization
        /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
        /// provide optimal I/O performance. This optimization isn't available with all instance
        /// types. Additional usage charges apply when using an EBS Optimized instance.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>Specifies whether enhanced networking with ENA is enabled.</p>
        pub fn ena_support(mut self, input: bool) -> Self {
            self.ena_support = Some(input);
            self
        }
        pub fn set_ena_support(mut self, input: std::option::Option<bool>) -> Self {
            self.ena_support = input;
            self
        }
        /// <p>The hypervisor type of the instance. The value <code>xen</code> is used for both Xen and
        /// Nitro hypervisors.</p>
        pub fn hypervisor(mut self, input: crate::model::HypervisorType) -> Self {
            self.hypervisor = Some(input);
            self
        }
        pub fn set_hypervisor(
            mut self,
            input: std::option::Option<crate::model::HypervisorType>,
        ) -> Self {
            self.hypervisor = input;
            self
        }
        /// <p>The IAM instance profile associated with the instance, if applicable.</p>
        pub fn iam_instance_profile(mut self, input: crate::model::IamInstanceProfile) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfile>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>
        pub fn instance_lifecycle(mut self, input: crate::model::InstanceLifecycleType) -> Self {
            self.instance_lifecycle = Some(input);
            self
        }
        pub fn set_instance_lifecycle(
            mut self,
            input: std::option::Option<crate::model::InstanceLifecycleType>,
        ) -> Self {
            self.instance_lifecycle = input;
            self
        }
        pub fn elastic_gpu_associations(
            mut self,
            input: impl Into<crate::model::ElasticGpuAssociation>,
        ) -> Self {
            let mut v = self.elastic_gpu_associations.unwrap_or_default();
            v.push(input.into());
            self.elastic_gpu_associations = Some(v);
            self
        }
        pub fn set_elastic_gpu_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ElasticGpuAssociation>>,
        ) -> Self {
            self.elastic_gpu_associations = input;
            self
        }
        pub fn elastic_inference_accelerator_associations(
            mut self,
            input: impl Into<crate::model::ElasticInferenceAcceleratorAssociation>,
        ) -> Self {
            let mut v = self
                .elastic_inference_accelerator_associations
                .unwrap_or_default();
            v.push(input.into());
            self.elastic_inference_accelerator_associations = Some(v);
            self
        }
        pub fn set_elastic_inference_accelerator_associations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ElasticInferenceAcceleratorAssociation>,
            >,
        ) -> Self {
            self.elastic_inference_accelerator_associations = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::InstanceNetworkInterface>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The device name of the root device volume (for example,
        /// <code>/dev/sda1</code>).</p>
        pub fn root_device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.root_device_name = Some(input.into());
            self
        }
        pub fn set_root_device_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.root_device_name = input;
            self
        }
        /// <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance
        /// store volume.</p>
        pub fn root_device_type(mut self, input: crate::model::DeviceType) -> Self {
            self.root_device_type = Some(input);
            self
        }
        pub fn set_root_device_type(
            mut self,
            input: std::option::Option<crate::model::DeviceType>,
        ) -> Self {
            self.root_device_type = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Indicates whether source/destination checking is enabled.</p>
        pub fn source_dest_check(mut self, input: bool) -> Self {
            self.source_dest_check = Some(input);
            self
        }
        pub fn set_source_dest_check(mut self, input: std::option::Option<bool>) -> Self {
            self.source_dest_check = input;
            self
        }
        /// <p>If the request is a Spot Instance request, the ID of the request.</p>
        pub fn spot_instance_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_instance_request_id = Some(input.into());
            self
        }
        pub fn set_spot_instance_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_instance_request_id = input;
            self
        }
        /// <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface
        /// is enabled.</p>
        pub fn sriov_net_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.sriov_net_support = Some(input.into());
            self
        }
        pub fn set_sriov_net_support(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sriov_net_support = input;
            self
        }
        /// <p>The reason for the most recent state transition.</p>
        pub fn state_reason(mut self, input: crate::model::StateReason) -> Self {
            self.state_reason = Some(input);
            self
        }
        pub fn set_state_reason(
            mut self,
            input: std::option::Option<crate::model::StateReason>,
        ) -> Self {
            self.state_reason = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The virtualization type of the instance.</p>
        pub fn virtualization_type(mut self, input: crate::model::VirtualizationType) -> Self {
            self.virtualization_type = Some(input);
            self
        }
        pub fn set_virtualization_type(
            mut self,
            input: std::option::Option<crate::model::VirtualizationType>,
        ) -> Self {
            self.virtualization_type = input;
            self
        }
        /// <p>The CPU options for the instance.</p>
        pub fn cpu_options(mut self, input: crate::model::CpuOptions) -> Self {
            self.cpu_options = Some(input);
            self
        }
        pub fn set_cpu_options(
            mut self,
            input: std::option::Option<crate::model::CpuOptions>,
        ) -> Self {
            self.cpu_options = input;
            self
        }
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_reservation_id = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_id = input;
            self
        }
        /// <p>Information about the Capacity Reservation targeting option.</p>
        pub fn capacity_reservation_specification(
            mut self,
            input: crate::model::CapacityReservationSpecificationResponse,
        ) -> Self {
            self.capacity_reservation_specification = Some(input);
            self
        }
        pub fn set_capacity_reservation_specification(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationSpecificationResponse>,
        ) -> Self {
            self.capacity_reservation_specification = input;
            self
        }
        /// <p>Indicates whether the instance is enabled for hibernation.</p>
        pub fn hibernation_options(mut self, input: crate::model::HibernationOptions) -> Self {
            self.hibernation_options = Some(input);
            self
        }
        pub fn set_hibernation_options(
            mut self,
            input: std::option::Option<crate::model::HibernationOptions>,
        ) -> Self {
            self.hibernation_options = input;
            self
        }
        pub fn licenses(mut self, input: impl Into<crate::model::LicenseConfiguration>) -> Self {
            let mut v = self.licenses.unwrap_or_default();
            v.push(input.into());
            self.licenses = Some(v);
            self
        }
        pub fn set_licenses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LicenseConfiguration>>,
        ) -> Self {
            self.licenses = input;
            self
        }
        /// <p>The metadata options for the instance.</p>
        pub fn metadata_options(
            mut self,
            input: crate::model::InstanceMetadataOptionsResponse,
        ) -> Self {
            self.metadata_options = Some(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataOptionsResponse>,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
        pub fn enclave_options(mut self, input: crate::model::EnclaveOptions) -> Self {
            self.enclave_options = Some(input);
            self
        }
        pub fn set_enclave_options(
            mut self,
            input: std::option::Option<crate::model::EnclaveOptions>,
        ) -> Self {
            self.enclave_options = input;
            self
        }
        /// <p>The boot mode of the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        pub fn boot_mode(mut self, input: crate::model::BootModeValues) -> Self {
            self.boot_mode = Some(input);
            self
        }
        pub fn set_boot_mode(
            mut self,
            input: std::option::Option<crate::model::BootModeValues>,
        ) -> Self {
            self.boot_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`Instance`](crate::model::Instance)
        pub fn build(self) -> crate::model::Instance {
            crate::model::Instance {
                ami_launch_index: self.ami_launch_index,
                image_id: self.image_id,
                instance_id: self.instance_id,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                launch_time: self.launch_time,
                monitoring: self.monitoring,
                placement: self.placement,
                platform: self.platform,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
                product_codes: self.product_codes,
                public_dns_name: self.public_dns_name,
                public_ip_address: self.public_ip_address,
                ramdisk_id: self.ramdisk_id,
                state: self.state,
                state_transition_reason: self.state_transition_reason,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                architecture: self.architecture,
                block_device_mappings: self.block_device_mappings,
                client_token: self.client_token,
                ebs_optimized: self.ebs_optimized,
                ena_support: self.ena_support,
                hypervisor: self.hypervisor,
                iam_instance_profile: self.iam_instance_profile,
                instance_lifecycle: self.instance_lifecycle,
                elastic_gpu_associations: self.elastic_gpu_associations,
                elastic_inference_accelerator_associations: self
                    .elastic_inference_accelerator_associations,
                network_interfaces: self.network_interfaces,
                outpost_arn: self.outpost_arn,
                root_device_name: self.root_device_name,
                root_device_type: self.root_device_type,
                security_groups: self.security_groups,
                source_dest_check: self.source_dest_check,
                spot_instance_request_id: self.spot_instance_request_id,
                sriov_net_support: self.sriov_net_support,
                state_reason: self.state_reason,
                tags: self.tags,
                virtualization_type: self.virtualization_type,
                cpu_options: self.cpu_options,
                capacity_reservation_id: self.capacity_reservation_id,
                capacity_reservation_specification: self.capacity_reservation_specification,
                hibernation_options: self.hibernation_options,
                licenses: self.licenses,
                metadata_options: self.metadata_options,
                enclave_options: self.enclave_options,
                boot_mode: self.boot_mode,
            }
        }
    }
}
impl Instance {
    /// Creates a new builder-style object to manufacture [`Instance`](crate::model::Instance)
    pub fn builder() -> crate::model::instance::Builder {
        crate::model::instance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BootModeValues {
    LegacyBios,
    Uefi,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BootModeValues {
    fn from(s: &str) -> Self {
        match s {
            "legacy-bios" => BootModeValues::LegacyBios,
            "uefi" => BootModeValues::Uefi,
            other => BootModeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BootModeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BootModeValues::from(s))
    }
}
impl BootModeValues {
    pub fn as_str(&self) -> &str {
        match self {
            BootModeValues::LegacyBios => "legacy-bios",
            BootModeValues::Uefi => "uefi",
            BootModeValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["legacy-bios", "uefi"]
    }
}
impl AsRef<str> for BootModeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnclaveOptions {
    /// <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves;
    /// otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for EnclaveOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnclaveOptions");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`EnclaveOptions`](crate::model::EnclaveOptions)
pub mod enclave_options {
    /// A builder for [`EnclaveOptions`](crate::model::EnclaveOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves;
        /// otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`EnclaveOptions`](crate::model::EnclaveOptions)
        pub fn build(self) -> crate::model::EnclaveOptions {
            crate::model::EnclaveOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl EnclaveOptions {
    /// Creates a new builder-style object to manufacture [`EnclaveOptions`](crate::model::EnclaveOptions)
    pub fn builder() -> crate::model::enclave_options::Builder {
        crate::model::enclave_options::Builder::default()
    }
}

/// <p>The metadata options for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMetadataOptionsResponse {
    /// <p>The state of the metadata option changes.</p>
    /// <p>
    /// <code>pending</code> - The metadata options are being updated and the instance is not
    /// ready to process metadata traffic with the new selection.</p>
    /// <p>
    /// <code>applied</code> - The metadata options have been successfully applied on the
    /// instance.</p>
    pub state: std::option::Option<crate::model::InstanceMetadataOptionsState>,
    /// <p>The state of token usage for your instance metadata requests. If the parameter is not
    /// specified in the request, the default state is <code>optional</code>.</p>
    /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
    /// with or without a signed token header on your request. If you retrieve the IAM role
    /// credentials without a token, the version 1.0 role credentials are returned. If you
    /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
    /// credentials are returned.</p>
    /// <p>If the state is <code>required</code>, you must send a signed token header with any
    /// instance metadata retrieval requests. In this state, retrieving the IAM role credential
    /// always returns the version 2.0 credentials; the version 1.0 credentials are not
    /// available.</p>
    pub http_tokens: std::option::Option<crate::model::HttpTokensState>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
    /// number, the further instance metadata requests can travel.</p>
    /// <p>Default: 1</p>
    /// <p>Possible values: Integers from 1 to 64</p>
    pub http_put_response_hop_limit: std::option::Option<i32>,
    /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
    /// the parameter is not specified, the default state is <code>enabled</code>.</p>
    /// <note>
    /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your
    /// instance metadata.</p>
    /// </note>
    pub http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
    /// <p>Whether or not the IPv6 endpoint for the instance metadata service is enabled or disabled.</p>
    pub http_protocol_ipv6: std::option::Option<crate::model::InstanceMetadataProtocolState>,
}
impl std::fmt::Debug for InstanceMetadataOptionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMetadataOptionsResponse");
        formatter.field("state", &self.state);
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field("http_protocol_ipv6", &self.http_protocol_ipv6);
        formatter.finish()
    }
}
/// See [`InstanceMetadataOptionsResponse`](crate::model::InstanceMetadataOptionsResponse)
pub mod instance_metadata_options_response {
    /// A builder for [`InstanceMetadataOptionsResponse`](crate::model::InstanceMetadataOptionsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::InstanceMetadataOptionsState>,
        pub(crate) http_tokens: std::option::Option<crate::model::HttpTokensState>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        pub(crate) http_protocol_ipv6:
            std::option::Option<crate::model::InstanceMetadataProtocolState>,
    }
    impl Builder {
        /// <p>The state of the metadata option changes.</p>
        /// <p>
        /// <code>pending</code> - The metadata options are being updated and the instance is not
        /// ready to process metadata traffic with the new selection.</p>
        /// <p>
        /// <code>applied</code> - The metadata options have been successfully applied on the
        /// instance.</p>
        pub fn state(mut self, input: crate::model::InstanceMetadataOptionsState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataOptionsState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not
        /// specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
        /// with or without a signed token header on your request. If you retrieve the IAM role
        /// credentials without a token, the version 1.0 role credentials are returned. If you
        /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
        /// credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any
        /// instance metadata retrieval requests. In this state, retrieving the IAM role credential
        /// always returns the version 2.0 credentials; the version 1.0 credentials are not
        /// available.</p>
        pub fn http_tokens(mut self, input: crate::model::HttpTokensState) -> Self {
            self.http_tokens = Some(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::HttpTokensState>,
        ) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
        /// number, the further instance metadata requests can travel.</p>
        /// <p>Default: 1</p>
        /// <p>Possible values: Integers from 1 to 64</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
        /// the parameter is not specified, the default state is <code>enabled</code>.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your
        /// instance metadata.</p>
        /// </note>
        pub fn http_endpoint(mut self, input: crate::model::InstanceMetadataEndpointState) -> Self {
            self.http_endpoint = Some(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>Whether or not the IPv6 endpoint for the instance metadata service is enabled or disabled.</p>
        pub fn http_protocol_ipv6(
            mut self,
            input: crate::model::InstanceMetadataProtocolState,
        ) -> Self {
            self.http_protocol_ipv6 = Some(input);
            self
        }
        pub fn set_http_protocol_ipv6(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataProtocolState>,
        ) -> Self {
            self.http_protocol_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMetadataOptionsResponse`](crate::model::InstanceMetadataOptionsResponse)
        pub fn build(self) -> crate::model::InstanceMetadataOptionsResponse {
            crate::model::InstanceMetadataOptionsResponse {
                state: self.state,
                http_tokens: self.http_tokens,
                http_put_response_hop_limit: self.http_put_response_hop_limit,
                http_endpoint: self.http_endpoint,
                http_protocol_ipv6: self.http_protocol_ipv6,
            }
        }
    }
}
impl InstanceMetadataOptionsResponse {
    /// Creates a new builder-style object to manufacture [`InstanceMetadataOptionsResponse`](crate::model::InstanceMetadataOptionsResponse)
    pub fn builder() -> crate::model::instance_metadata_options_response::Builder {
        crate::model::instance_metadata_options_response::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMetadataProtocolState {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMetadataProtocolState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => InstanceMetadataProtocolState::Disabled,
            "enabled" => InstanceMetadataProtocolState::Enabled,
            other => InstanceMetadataProtocolState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMetadataProtocolState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMetadataProtocolState::from(s))
    }
}
impl InstanceMetadataProtocolState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMetadataProtocolState::Disabled => "disabled",
            InstanceMetadataProtocolState::Enabled => "enabled",
            InstanceMetadataProtocolState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for InstanceMetadataProtocolState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMetadataEndpointState {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMetadataEndpointState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => InstanceMetadataEndpointState::Disabled,
            "enabled" => InstanceMetadataEndpointState::Enabled,
            other => InstanceMetadataEndpointState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMetadataEndpointState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMetadataEndpointState::from(s))
    }
}
impl InstanceMetadataEndpointState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMetadataEndpointState::Disabled => "disabled",
            InstanceMetadataEndpointState::Enabled => "enabled",
            InstanceMetadataEndpointState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for InstanceMetadataEndpointState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HttpTokensState {
    Optional,
    Required,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HttpTokensState {
    fn from(s: &str) -> Self {
        match s {
            "optional" => HttpTokensState::Optional,
            "required" => HttpTokensState::Required,
            other => HttpTokensState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HttpTokensState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HttpTokensState::from(s))
    }
}
impl HttpTokensState {
    pub fn as_str(&self) -> &str {
        match self {
            HttpTokensState::Optional => "optional",
            HttpTokensState::Required => "required",
            HttpTokensState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["optional", "required"]
    }
}
impl AsRef<str> for HttpTokensState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMetadataOptionsState {
    Applied,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMetadataOptionsState {
    fn from(s: &str) -> Self {
        match s {
            "applied" => InstanceMetadataOptionsState::Applied,
            "pending" => InstanceMetadataOptionsState::Pending,
            other => InstanceMetadataOptionsState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMetadataOptionsState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMetadataOptionsState::from(s))
    }
}
impl InstanceMetadataOptionsState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMetadataOptionsState::Applied => "applied",
            InstanceMetadataOptionsState::Pending => "pending",
            InstanceMetadataOptionsState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["applied", "pending"]
    }
}
impl AsRef<str> for InstanceMetadataOptionsState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a license configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LicenseConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseConfiguration");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`LicenseConfiguration`](crate::model::LicenseConfiguration)
pub mod license_configuration {
    /// A builder for [`LicenseConfiguration`](crate::model::LicenseConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseConfiguration`](crate::model::LicenseConfiguration)
        pub fn build(self) -> crate::model::LicenseConfiguration {
            crate::model::LicenseConfiguration {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl LicenseConfiguration {
    /// Creates a new builder-style object to manufacture [`LicenseConfiguration`](crate::model::LicenseConfiguration)
    pub fn builder() -> crate::model::license_configuration::Builder {
        crate::model::license_configuration::Builder::default()
    }
}

/// <p>Indicates whether your instance is configured for hibernation. This parameter is valid
/// only if the instance meets the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites">hibernation
/// prerequisites</a>. For
/// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate your instance</a> in the
/// <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HibernationOptions {
    /// <p>If this parameter is set to <code>true</code>, your instance is enabled for
    /// hibernation; otherwise, it is not enabled for hibernation.</p>
    pub configured: std::option::Option<bool>,
}
impl std::fmt::Debug for HibernationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HibernationOptions");
        formatter.field("configured", &self.configured);
        formatter.finish()
    }
}
/// See [`HibernationOptions`](crate::model::HibernationOptions)
pub mod hibernation_options {
    /// A builder for [`HibernationOptions`](crate::model::HibernationOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If this parameter is set to <code>true</code>, your instance is enabled for
        /// hibernation; otherwise, it is not enabled for hibernation.</p>
        pub fn configured(mut self, input: bool) -> Self {
            self.configured = Some(input);
            self
        }
        pub fn set_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.configured = input;
            self
        }
        /// Consumes the builder and constructs a [`HibernationOptions`](crate::model::HibernationOptions)
        pub fn build(self) -> crate::model::HibernationOptions {
            crate::model::HibernationOptions {
                configured: self.configured,
            }
        }
    }
}
impl HibernationOptions {
    /// Creates a new builder-style object to manufacture [`HibernationOptions`](crate::model::HibernationOptions)
    pub fn builder() -> crate::model::hibernation_options::Builder {
        crate::model::hibernation_options::Builder::default()
    }
}

/// <p>Describes the instance's Capacity Reservation targeting preferences. The action returns the
/// <code>capacityReservationPreference</code> response element if the instance is
/// configured to run in On-Demand capacity, or if it is configured in run in any
/// <code>open</code> Capacity Reservation that has matching attributes (instance type, platform,
/// Availability Zone). The action returns the <code>capacityReservationTarget</code>
/// response element if the instance explicily targets a specific Capacity Reservation or Capacity Reservation group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationSpecificationResponse {
    /// <p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that
    /// has matching attributes (instance type, platform, Availability Zone).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is
    /// available. The instance runs in On-Demand capacity.</p>
    /// </li>
    /// </ul>
    pub capacity_reservation_preference:
        std::option::Option<crate::model::CapacityReservationPreference>,
    /// <p>Information about the targeted Capacity Reservation or Capacity Reservation group.</p>
    pub capacity_reservation_target:
        std::option::Option<crate::model::CapacityReservationTargetResponse>,
}
impl std::fmt::Debug for CapacityReservationSpecificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationSpecificationResponse");
        formatter.field(
            "capacity_reservation_preference",
            &self.capacity_reservation_preference,
        );
        formatter.field(
            "capacity_reservation_target",
            &self.capacity_reservation_target,
        );
        formatter.finish()
    }
}
/// See [`CapacityReservationSpecificationResponse`](crate::model::CapacityReservationSpecificationResponse)
pub mod capacity_reservation_specification_response {
    /// A builder for [`CapacityReservationSpecificationResponse`](crate::model::CapacityReservationSpecificationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_preference:
            std::option::Option<crate::model::CapacityReservationPreference>,
        pub(crate) capacity_reservation_target:
            std::option::Option<crate::model::CapacityReservationTargetResponse>,
    }
    impl Builder {
        /// <p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that
        /// has matching attributes (instance type, platform, Availability Zone).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is
        /// available. The instance runs in On-Demand capacity.</p>
        /// </li>
        /// </ul>
        pub fn capacity_reservation_preference(
            mut self,
            input: crate::model::CapacityReservationPreference,
        ) -> Self {
            self.capacity_reservation_preference = Some(input);
            self
        }
        pub fn set_capacity_reservation_preference(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationPreference>,
        ) -> Self {
            self.capacity_reservation_preference = input;
            self
        }
        /// <p>Information about the targeted Capacity Reservation or Capacity Reservation group.</p>
        pub fn capacity_reservation_target(
            mut self,
            input: crate::model::CapacityReservationTargetResponse,
        ) -> Self {
            self.capacity_reservation_target = Some(input);
            self
        }
        pub fn set_capacity_reservation_target(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTargetResponse>,
        ) -> Self {
            self.capacity_reservation_target = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationSpecificationResponse`](crate::model::CapacityReservationSpecificationResponse)
        pub fn build(self) -> crate::model::CapacityReservationSpecificationResponse {
            crate::model::CapacityReservationSpecificationResponse {
                capacity_reservation_preference: self.capacity_reservation_preference,
                capacity_reservation_target: self.capacity_reservation_target,
            }
        }
    }
}
impl CapacityReservationSpecificationResponse {
    /// Creates a new builder-style object to manufacture [`CapacityReservationSpecificationResponse`](crate::model::CapacityReservationSpecificationResponse)
    pub fn builder() -> crate::model::capacity_reservation_specification_response::Builder {
        crate::model::capacity_reservation_specification_response::Builder::default()
    }
}

/// <p>Describes a target Capacity Reservation or Capacity Reservation group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationTargetResponse {
    /// <p>The ID of the targeted Capacity Reservation.</p>
    pub capacity_reservation_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the targeted Capacity Reservation group.</p>
    pub capacity_reservation_resource_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CapacityReservationTargetResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationTargetResponse");
        formatter.field("capacity_reservation_id", &self.capacity_reservation_id);
        formatter.field(
            "capacity_reservation_resource_group_arn",
            &self.capacity_reservation_resource_group_arn,
        );
        formatter.finish()
    }
}
/// See [`CapacityReservationTargetResponse`](crate::model::CapacityReservationTargetResponse)
pub mod capacity_reservation_target_response {
    /// A builder for [`CapacityReservationTargetResponse`](crate::model::CapacityReservationTargetResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_id: std::option::Option<std::string::String>,
        pub(crate) capacity_reservation_resource_group_arn:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the targeted Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_reservation_id = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_id = input;
            self
        }
        /// <p>The ARN of the targeted Capacity Reservation group.</p>
        pub fn capacity_reservation_resource_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.capacity_reservation_resource_group_arn = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_resource_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationTargetResponse`](crate::model::CapacityReservationTargetResponse)
        pub fn build(self) -> crate::model::CapacityReservationTargetResponse {
            crate::model::CapacityReservationTargetResponse {
                capacity_reservation_id: self.capacity_reservation_id,
                capacity_reservation_resource_group_arn: self
                    .capacity_reservation_resource_group_arn,
            }
        }
    }
}
impl CapacityReservationTargetResponse {
    /// Creates a new builder-style object to manufacture [`CapacityReservationTargetResponse`](crate::model::CapacityReservationTargetResponse)
    pub fn builder() -> crate::model::capacity_reservation_target_response::Builder {
        crate::model::capacity_reservation_target_response::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacityReservationPreference {
    None,
    Open,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacityReservationPreference {
    fn from(s: &str) -> Self {
        match s {
            "none" => CapacityReservationPreference::None,
            "open" => CapacityReservationPreference::Open,
            other => CapacityReservationPreference::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacityReservationPreference {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacityReservationPreference::from(s))
    }
}
impl CapacityReservationPreference {
    pub fn as_str(&self) -> &str {
        match self {
            CapacityReservationPreference::None => "none",
            CapacityReservationPreference::Open => "open",
            CapacityReservationPreference::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["none", "open"]
    }
}
impl AsRef<str> for CapacityReservationPreference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The CPU options for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CpuOptions {
    /// <p>The number of CPU cores for the instance.</p>
    pub core_count: std::option::Option<i32>,
    /// <p>The number of threads per CPU core.</p>
    pub threads_per_core: std::option::Option<i32>,
}
impl std::fmt::Debug for CpuOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CpuOptions");
        formatter.field("core_count", &self.core_count);
        formatter.field("threads_per_core", &self.threads_per_core);
        formatter.finish()
    }
}
/// See [`CpuOptions`](crate::model::CpuOptions)
pub mod cpu_options {
    /// A builder for [`CpuOptions`](crate::model::CpuOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_count: std::option::Option<i32>,
        pub(crate) threads_per_core: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of CPU cores for the instance.</p>
        pub fn core_count(mut self, input: i32) -> Self {
            self.core_count = Some(input);
            self
        }
        pub fn set_core_count(mut self, input: std::option::Option<i32>) -> Self {
            self.core_count = input;
            self
        }
        /// <p>The number of threads per CPU core.</p>
        pub fn threads_per_core(mut self, input: i32) -> Self {
            self.threads_per_core = Some(input);
            self
        }
        pub fn set_threads_per_core(mut self, input: std::option::Option<i32>) -> Self {
            self.threads_per_core = input;
            self
        }
        /// Consumes the builder and constructs a [`CpuOptions`](crate::model::CpuOptions)
        pub fn build(self) -> crate::model::CpuOptions {
            crate::model::CpuOptions {
                core_count: self.core_count,
                threads_per_core: self.threads_per_core,
            }
        }
    }
}
impl CpuOptions {
    /// Creates a new builder-style object to manufacture [`CpuOptions`](crate::model::CpuOptions)
    pub fn builder() -> crate::model::cpu_options::Builder {
        crate::model::cpu_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VirtualizationType {
    Hvm,
    Paravirtual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VirtualizationType {
    fn from(s: &str) -> Self {
        match s {
            "hvm" => VirtualizationType::Hvm,
            "paravirtual" => VirtualizationType::Paravirtual,
            other => VirtualizationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VirtualizationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VirtualizationType::from(s))
    }
}
impl VirtualizationType {
    pub fn as_str(&self) -> &str {
        match self {
            VirtualizationType::Hvm => "hvm",
            VirtualizationType::Paravirtual => "paravirtual",
            VirtualizationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["hvm", "paravirtual"]
    }
}
impl AsRef<str> for VirtualizationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a state change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StateReason {
    /// <p>The reason code for the state change.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The message for the state change.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Server.InsufficientInstanceCapacity</code>: There was insufficient
    /// capacity available to satisfy the launch request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Server.InternalError</code>: An internal error caused the instance to
    /// terminate during launch.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled
    /// retirement.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the
    /// number of Spot requests with a maximum price equal to or higher than the Spot
    /// price exceeded available capacity or because of an increase in the Spot
    /// price.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Server.SpotInstanceTermination</code>: The instance was terminated
    /// because the number of Spot requests with a maximum price equal to or higher than
    /// the Spot price exceeded available capacity or because of an increase in the Spot
    /// price.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down
    /// using the <code>shutdown -h</code> command from the instance.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.InstanceTerminated</code>: The instance was terminated or
    /// rebooted during AMI creation.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.InternalError</code>: A client error caused the instance to
    /// terminate during launch.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not
    /// found.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiatedHibernate</code>: Hibernation was initiated on the
    /// instance.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiatedShutdown</code>: The instance was shut down using
    /// the Amazon EC2 API.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS
    /// volumes or total storage was exceeded. Decrease usage or request an increase in
    /// your account limits.</p>
    /// </li>
    /// </ul>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StateReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StateReason");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`StateReason`](crate::model::StateReason)
pub mod state_reason {
    /// A builder for [`StateReason`](crate::model::StateReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The reason code for the state change.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The message for the state change.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Server.InsufficientInstanceCapacity</code>: There was insufficient
        /// capacity available to satisfy the launch request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Server.InternalError</code>: An internal error caused the instance to
        /// terminate during launch.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled
        /// retirement.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the
        /// number of Spot requests with a maximum price equal to or higher than the Spot
        /// price exceeded available capacity or because of an increase in the Spot
        /// price.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Server.SpotInstanceTermination</code>: The instance was terminated
        /// because the number of Spot requests with a maximum price equal to or higher than
        /// the Spot price exceeded available capacity or because of an increase in the Spot
        /// price.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down
        /// using the <code>shutdown -h</code> command from the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.InstanceTerminated</code>: The instance was terminated or
        /// rebooted during AMI creation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.InternalError</code>: A client error caused the instance to
        /// terminate during launch.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not
        /// found.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiatedHibernate</code>: Hibernation was initiated on the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiatedShutdown</code>: The instance was shut down using
        /// the Amazon EC2 API.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS
        /// volumes or total storage was exceeded. Decrease usage or request an increase in
        /// your account limits.</p>
        /// </li>
        /// </ul>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StateReason`](crate::model::StateReason)
        pub fn build(self) -> crate::model::StateReason {
            crate::model::StateReason {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl StateReason {
    /// Creates a new builder-style object to manufacture [`StateReason`](crate::model::StateReason)
    pub fn builder() -> crate::model::state_reason::Builder {
        crate::model::state_reason::Builder::default()
    }
}

/// <p>Describes a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GroupIdentifier {
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GroupIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GroupIdentifier");
        formatter.field("group_name", &self.group_name);
        formatter.field("group_id", &self.group_id);
        formatter.finish()
    }
}
/// See [`GroupIdentifier`](crate::model::GroupIdentifier)
pub mod group_identifier {
    /// A builder for [`GroupIdentifier`](crate::model::GroupIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupIdentifier`](crate::model::GroupIdentifier)
        pub fn build(self) -> crate::model::GroupIdentifier {
            crate::model::GroupIdentifier {
                group_name: self.group_name,
                group_id: self.group_id,
            }
        }
    }
}
impl GroupIdentifier {
    /// Creates a new builder-style object to manufacture [`GroupIdentifier`](crate::model::GroupIdentifier)
    pub fn builder() -> crate::model::group_identifier::Builder {
        crate::model::group_identifier::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeviceType {
    Ebs,
    InstanceStore,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeviceType {
    fn from(s: &str) -> Self {
        match s {
            "ebs" => DeviceType::Ebs,
            "instance-store" => DeviceType::InstanceStore,
            other => DeviceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeviceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeviceType::from(s))
    }
}
impl DeviceType {
    pub fn as_str(&self) -> &str {
        match self {
            DeviceType::Ebs => "ebs",
            DeviceType::InstanceStore => "instance-store",
            DeviceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ebs", "instance-store"]
    }
}
impl AsRef<str> for DeviceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceNetworkInterface {
    /// <p>The association information for an Elastic IPv4 associated with the network
    /// interface.</p>
    pub association: std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
    /// <p>The network interface attachment.</p>
    pub attachment: std::option::Option<crate::model::InstanceNetworkInterfaceAttachment>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>One or more security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>One or more IPv6 addresses associated with the network interface.</p>
    pub ipv6_addresses: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
    /// <p>The MAC address.</p>
    pub mac_address: std::option::Option<std::string::String>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that created the network interface.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The private DNS name.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>One or more private IPv4 addresses associated with the network interface.</p>
    pub private_ip_addresses:
        std::option::Option<std::vec::Vec<crate::model::InstancePrivateIpAddress>>,
    /// <p>Indicates whether source/destination checking is enabled.</p>
    pub source_dest_check: std::option::Option<bool>,
    /// <p>The status of the network interface.</p>
    pub status: std::option::Option<crate::model::NetworkInterfaceStatus>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Describes the type of network interface.</p>
    /// <p>Valid values: <code>interface</code> | <code>efa</code> | <code>trunk</code>
    /// </p>
    pub interface_type: std::option::Option<std::string::String>,
    /// <p>The IPv4 delegated prefixes that are assigned to the network interface.</p>
    pub ipv4_prefixes: std::option::Option<std::vec::Vec<crate::model::InstanceIpv4Prefix>>,
    /// <p>The IPv6 delegated prefixes that are assigned to the network interface.</p>
    pub ipv6_prefixes: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Prefix>>,
}
impl std::fmt::Debug for InstanceNetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceNetworkInterface");
        formatter.field("association", &self.association);
        formatter.field("attachment", &self.attachment);
        formatter.field("description", &self.description);
        formatter.field("groups", &self.groups);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("mac_address", &self.mac_address);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field("source_dest_check", &self.source_dest_check);
        formatter.field("status", &self.status);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("interface_type", &self.interface_type);
        formatter.field("ipv4_prefixes", &self.ipv4_prefixes);
        formatter.field("ipv6_prefixes", &self.ipv6_prefixes);
        formatter.finish()
    }
}
/// See [`InstanceNetworkInterface`](crate::model::InstanceNetworkInterface)
pub mod instance_network_interface {
    /// A builder for [`InstanceNetworkInterface`](crate::model::InstanceNetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association:
            std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
        pub(crate) attachment:
            std::option::Option<crate::model::InstanceNetworkInterfaceAttachment>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        pub(crate) mac_address: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::InstancePrivateIpAddress>>,
        pub(crate) source_dest_check: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::NetworkInterfaceStatus>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) interface_type: std::option::Option<std::string::String>,
        pub(crate) ipv4_prefixes:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv4Prefix>>,
        pub(crate) ipv6_prefixes:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Prefix>>,
    }
    impl Builder {
        /// <p>The association information for an Elastic IPv4 associated with the network
        /// interface.</p>
        pub fn association(
            mut self,
            input: crate::model::InstanceNetworkInterfaceAssociation,
        ) -> Self {
            self.association = Some(input);
            self
        }
        pub fn set_association(
            mut self,
            input: std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
        ) -> Self {
            self.association = input;
            self
        }
        /// <p>The network interface attachment.</p>
        pub fn attachment(
            mut self,
            input: crate::model::InstanceNetworkInterfaceAttachment,
        ) -> Self {
            self.attachment = Some(input);
            self
        }
        pub fn set_attachment(
            mut self,
            input: std::option::Option<crate::model::InstanceNetworkInterfaceAttachment>,
        ) -> Self {
            self.attachment = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.groups = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::InstanceIpv6Address>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The MAC address.</p>
        pub fn mac_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_address = Some(input.into());
            self
        }
        pub fn set_mac_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_address = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that created the network interface.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The private DNS name.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_addresses(
            mut self,
            input: impl Into<crate::model::InstancePrivateIpAddress>,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.private_ip_addresses = Some(v);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstancePrivateIpAddress>>,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>Indicates whether source/destination checking is enabled.</p>
        pub fn source_dest_check(mut self, input: bool) -> Self {
            self.source_dest_check = Some(input);
            self
        }
        pub fn set_source_dest_check(mut self, input: std::option::Option<bool>) -> Self {
            self.source_dest_check = input;
            self
        }
        /// <p>The status of the network interface.</p>
        pub fn status(mut self, input: crate::model::NetworkInterfaceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>Describes the type of network interface.</p>
        /// <p>Valid values: <code>interface</code> | <code>efa</code> | <code>trunk</code>
        /// </p>
        pub fn interface_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_type = Some(input.into());
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interface_type = input;
            self
        }
        pub fn ipv4_prefixes(mut self, input: impl Into<crate::model::InstanceIpv4Prefix>) -> Self {
            let mut v = self.ipv4_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv4_prefixes = Some(v);
            self
        }
        pub fn set_ipv4_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv4Prefix>>,
        ) -> Self {
            self.ipv4_prefixes = input;
            self
        }
        pub fn ipv6_prefixes(mut self, input: impl Into<crate::model::InstanceIpv6Prefix>) -> Self {
            let mut v = self.ipv6_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv6_prefixes = Some(v);
            self
        }
        pub fn set_ipv6_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Prefix>>,
        ) -> Self {
            self.ipv6_prefixes = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNetworkInterface`](crate::model::InstanceNetworkInterface)
        pub fn build(self) -> crate::model::InstanceNetworkInterface {
            crate::model::InstanceNetworkInterface {
                association: self.association,
                attachment: self.attachment,
                description: self.description,
                groups: self.groups,
                ipv6_addresses: self.ipv6_addresses,
                mac_address: self.mac_address,
                network_interface_id: self.network_interface_id,
                owner_id: self.owner_id,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                source_dest_check: self.source_dest_check,
                status: self.status,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                interface_type: self.interface_type,
                ipv4_prefixes: self.ipv4_prefixes,
                ipv6_prefixes: self.ipv6_prefixes,
            }
        }
    }
}
impl InstanceNetworkInterface {
    /// Creates a new builder-style object to manufacture [`InstanceNetworkInterface`](crate::model::InstanceNetworkInterface)
    pub fn builder() -> crate::model::instance_network_interface::Builder {
        crate::model::instance_network_interface::Builder::default()
    }
}

/// <p>Information about an IPv6 prefix.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceIpv6Prefix {
    /// <p>One or more IPv6 prefixes assigned to the network interface.</p>
    pub ipv6_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceIpv6Prefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceIpv6Prefix");
        formatter.field("ipv6_prefix", &self.ipv6_prefix);
        formatter.finish()
    }
}
/// See [`InstanceIpv6Prefix`](crate::model::InstanceIpv6Prefix)
pub mod instance_ipv6_prefix {
    /// A builder for [`InstanceIpv6Prefix`](crate::model::InstanceIpv6Prefix)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One or more IPv6 prefixes assigned to the network interface.</p>
        pub fn ipv6_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_prefix = Some(input.into());
            self
        }
        pub fn set_ipv6_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIpv6Prefix`](crate::model::InstanceIpv6Prefix)
        pub fn build(self) -> crate::model::InstanceIpv6Prefix {
            crate::model::InstanceIpv6Prefix {
                ipv6_prefix: self.ipv6_prefix,
            }
        }
    }
}
impl InstanceIpv6Prefix {
    /// Creates a new builder-style object to manufacture [`InstanceIpv6Prefix`](crate::model::InstanceIpv6Prefix)
    pub fn builder() -> crate::model::instance_ipv6_prefix::Builder {
        crate::model::instance_ipv6_prefix::Builder::default()
    }
}

/// <p>Information about an IPv4 prefix.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceIpv4Prefix {
    /// <p>One or more IPv4 prefixes assigned to the network interface.</p>
    pub ipv4_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceIpv4Prefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceIpv4Prefix");
        formatter.field("ipv4_prefix", &self.ipv4_prefix);
        formatter.finish()
    }
}
/// See [`InstanceIpv4Prefix`](crate::model::InstanceIpv4Prefix)
pub mod instance_ipv4_prefix {
    /// A builder for [`InstanceIpv4Prefix`](crate::model::InstanceIpv4Prefix)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv4_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One or more IPv4 prefixes assigned to the network interface.</p>
        pub fn ipv4_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_prefix = Some(input.into());
            self
        }
        pub fn set_ipv4_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIpv4Prefix`](crate::model::InstanceIpv4Prefix)
        pub fn build(self) -> crate::model::InstanceIpv4Prefix {
            crate::model::InstanceIpv4Prefix {
                ipv4_prefix: self.ipv4_prefix,
            }
        }
    }
}
impl InstanceIpv4Prefix {
    /// Creates a new builder-style object to manufacture [`InstanceIpv4Prefix`](crate::model::InstanceIpv4Prefix)
    pub fn builder() -> crate::model::instance_ipv4_prefix::Builder {
        crate::model::instance_ipv4_prefix::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceStatus {
    Associated,
    Attaching,
    Available,
    Detaching,
    InUse,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkInterfaceStatus {
    fn from(s: &str) -> Self {
        match s {
            "associated" => NetworkInterfaceStatus::Associated,
            "attaching" => NetworkInterfaceStatus::Attaching,
            "available" => NetworkInterfaceStatus::Available,
            "detaching" => NetworkInterfaceStatus::Detaching,
            "in-use" => NetworkInterfaceStatus::InUse,
            other => NetworkInterfaceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkInterfaceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceStatus::from(s))
    }
}
impl NetworkInterfaceStatus {
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceStatus::Associated => "associated",
            NetworkInterfaceStatus::Attaching => "attaching",
            NetworkInterfaceStatus::Available => "available",
            NetworkInterfaceStatus::Detaching => "detaching",
            NetworkInterfaceStatus::InUse => "in-use",
            NetworkInterfaceStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "attaching",
            "available",
            "detaching",
            "in-use",
        ]
    }
}
impl AsRef<str> for NetworkInterfaceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a private IPv4 address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstancePrivateIpAddress {
    /// <p>The association information for an Elastic IP address for the network interface.</p>
    pub association: std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
    /// <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
    pub primary: std::option::Option<bool>,
    /// <p>The private IPv4 DNS name.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The private IPv4 address of the network interface.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstancePrivateIpAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancePrivateIpAddress");
        formatter.field("association", &self.association);
        formatter.field("primary", &self.primary);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`InstancePrivateIpAddress`](crate::model::InstancePrivateIpAddress)
pub mod instance_private_ip_address {
    /// A builder for [`InstancePrivateIpAddress`](crate::model::InstancePrivateIpAddress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association:
            std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
        pub(crate) primary: std::option::Option<bool>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association information for an Elastic IP address for the network interface.</p>
        pub fn association(
            mut self,
            input: crate::model::InstanceNetworkInterfaceAssociation,
        ) -> Self {
            self.association = Some(input);
            self
        }
        pub fn set_association(
            mut self,
            input: std::option::Option<crate::model::InstanceNetworkInterfaceAssociation>,
        ) -> Self {
            self.association = input;
            self
        }
        /// <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// <p>The private IPv4 DNS name.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The private IPv4 address of the network interface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`InstancePrivateIpAddress`](crate::model::InstancePrivateIpAddress)
        pub fn build(self) -> crate::model::InstancePrivateIpAddress {
            crate::model::InstancePrivateIpAddress {
                association: self.association,
                primary: self.primary,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl InstancePrivateIpAddress {
    /// Creates a new builder-style object to manufacture [`InstancePrivateIpAddress`](crate::model::InstancePrivateIpAddress)
    pub fn builder() -> crate::model::instance_private_ip_address::Builder {
        crate::model::instance_private_ip_address::Builder::default()
    }
}

/// <p>Describes association information for an Elastic IP address (IPv4).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceNetworkInterfaceAssociation {
    /// <p>The carrier IP address associated with the network interface.</p>
    pub carrier_ip: std::option::Option<std::string::String>,
    /// <p>The ID of the owner of the Elastic IP address.</p>
    pub ip_owner_id: std::option::Option<std::string::String>,
    /// <p>The public DNS name.</p>
    pub public_dns_name: std::option::Option<std::string::String>,
    /// <p>The public IP address or Elastic IP address bound to the network interface.</p>
    pub public_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceNetworkInterfaceAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceNetworkInterfaceAssociation");
        formatter.field("carrier_ip", &self.carrier_ip);
        formatter.field("ip_owner_id", &self.ip_owner_id);
        formatter.field("public_dns_name", &self.public_dns_name);
        formatter.field("public_ip", &self.public_ip);
        formatter.finish()
    }
}
/// See [`InstanceNetworkInterfaceAssociation`](crate::model::InstanceNetworkInterfaceAssociation)
pub mod instance_network_interface_association {
    /// A builder for [`InstanceNetworkInterfaceAssociation`](crate::model::InstanceNetworkInterfaceAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) carrier_ip: std::option::Option<std::string::String>,
        pub(crate) ip_owner_id: std::option::Option<std::string::String>,
        pub(crate) public_dns_name: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The carrier IP address associated with the network interface.</p>
        pub fn carrier_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier_ip = Some(input.into());
            self
        }
        pub fn set_carrier_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.carrier_ip = input;
            self
        }
        /// <p>The ID of the owner of the Elastic IP address.</p>
        pub fn ip_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_owner_id = Some(input.into());
            self
        }
        pub fn set_ip_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_owner_id = input;
            self
        }
        /// <p>The public DNS name.</p>
        pub fn public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_dns_name = Some(input.into());
            self
        }
        pub fn set_public_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_dns_name = input;
            self
        }
        /// <p>The public IP address or Elastic IP address bound to the network interface.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNetworkInterfaceAssociation`](crate::model::InstanceNetworkInterfaceAssociation)
        pub fn build(self) -> crate::model::InstanceNetworkInterfaceAssociation {
            crate::model::InstanceNetworkInterfaceAssociation {
                carrier_ip: self.carrier_ip,
                ip_owner_id: self.ip_owner_id,
                public_dns_name: self.public_dns_name,
                public_ip: self.public_ip,
            }
        }
    }
}
impl InstanceNetworkInterfaceAssociation {
    /// Creates a new builder-style object to manufacture [`InstanceNetworkInterfaceAssociation`](crate::model::InstanceNetworkInterfaceAssociation)
    pub fn builder() -> crate::model::instance_network_interface_association::Builder {
        crate::model::instance_network_interface_association::Builder::default()
    }
}

/// <p>Describes an IPv6 address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceIpv6Address {
    /// <p>The IPv6 address.</p>
    pub ipv6_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceIpv6Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceIpv6Address");
        formatter.field("ipv6_address", &self.ipv6_address);
        formatter.finish()
    }
}
/// See [`InstanceIpv6Address`](crate::model::InstanceIpv6Address)
pub mod instance_ipv6_address {
    /// A builder for [`InstanceIpv6Address`](crate::model::InstanceIpv6Address)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 address.</p>
        pub fn ipv6_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_address = Some(input.into());
            self
        }
        pub fn set_ipv6_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_address = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIpv6Address`](crate::model::InstanceIpv6Address)
        pub fn build(self) -> crate::model::InstanceIpv6Address {
            crate::model::InstanceIpv6Address {
                ipv6_address: self.ipv6_address,
            }
        }
    }
}
impl InstanceIpv6Address {
    /// Creates a new builder-style object to manufacture [`InstanceIpv6Address`](crate::model::InstanceIpv6Address)
    pub fn builder() -> crate::model::instance_ipv6_address::Builder {
        crate::model::instance_ipv6_address::Builder::default()
    }
}

/// <p>Describes a network interface attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceNetworkInterfaceAttachment {
    /// <p>The time stamp when the attachment initiated.</p>
    pub attach_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the network interface attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The index of the device on the instance for the network interface attachment.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The attachment state.</p>
    pub status: std::option::Option<crate::model::AttachmentStatus>,
    /// <p>The index of the network card.</p>
    pub network_card_index: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceNetworkInterfaceAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceNetworkInterfaceAttachment");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("attachment_id", &self.attachment_id);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("device_index", &self.device_index);
        formatter.field("status", &self.status);
        formatter.field("network_card_index", &self.network_card_index);
        formatter.finish()
    }
}
/// See [`InstanceNetworkInterfaceAttachment`](crate::model::InstanceNetworkInterfaceAttachment)
pub mod instance_network_interface_attachment {
    /// A builder for [`InstanceNetworkInterfaceAttachment`](crate::model::InstanceNetworkInterfaceAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<smithy_types::Instant>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) status: std::option::Option<crate::model::AttachmentStatus>,
        pub(crate) network_card_index: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The time stamp when the attachment initiated.</p>
        pub fn attach_time(mut self, input: smithy_types::Instant) -> Self {
            self.attach_time = Some(input);
            self
        }
        pub fn set_attach_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>The ID of the network interface attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The index of the device on the instance for the network interface attachment.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        /// <p>The attachment state.</p>
        pub fn status(mut self, input: crate::model::AttachmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AttachmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The index of the network card.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNetworkInterfaceAttachment`](crate::model::InstanceNetworkInterfaceAttachment)
        pub fn build(self) -> crate::model::InstanceNetworkInterfaceAttachment {
            crate::model::InstanceNetworkInterfaceAttachment {
                attach_time: self.attach_time,
                attachment_id: self.attachment_id,
                delete_on_termination: self.delete_on_termination,
                device_index: self.device_index,
                status: self.status,
                network_card_index: self.network_card_index,
            }
        }
    }
}
impl InstanceNetworkInterfaceAttachment {
    /// Creates a new builder-style object to manufacture [`InstanceNetworkInterfaceAttachment`](crate::model::InstanceNetworkInterfaceAttachment)
    pub fn builder() -> crate::model::instance_network_interface_attachment::Builder {
        crate::model::instance_network_interface_attachment::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttachmentStatus {
    Attached,
    Attaching,
    Detached,
    Detaching,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AttachmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "attached" => AttachmentStatus::Attached,
            "attaching" => AttachmentStatus::Attaching,
            "detached" => AttachmentStatus::Detached,
            "detaching" => AttachmentStatus::Detaching,
            other => AttachmentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AttachmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AttachmentStatus::from(s))
    }
}
impl AttachmentStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AttachmentStatus::Attached => "attached",
            AttachmentStatus::Attaching => "attaching",
            AttachmentStatus::Detached => "detached",
            AttachmentStatus::Detaching => "detaching",
            AttachmentStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["attached", "attaching", "detached", "detaching"]
    }
}
impl AsRef<str> for AttachmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>
/// Describes the association between an instance and an elastic inference accelerator.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticInferenceAcceleratorAssociation {
    /// <p>
    /// The Amazon Resource Name (ARN) of the elastic inference accelerator.
    /// </p>
    pub elastic_inference_accelerator_arn: std::option::Option<std::string::String>,
    /// <p>
    /// The ID of the association.
    /// </p>
    pub elastic_inference_accelerator_association_id: std::option::Option<std::string::String>,
    /// <p>
    /// The state of the elastic inference accelerator.
    /// </p>
    pub elastic_inference_accelerator_association_state: std::option::Option<std::string::String>,
    /// <p>
    /// The time at which the elastic inference accelerator is associated with an instance.
    /// </p>
    pub elastic_inference_accelerator_association_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ElasticInferenceAcceleratorAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticInferenceAcceleratorAssociation");
        formatter.field(
            "elastic_inference_accelerator_arn",
            &self.elastic_inference_accelerator_arn,
        );
        formatter.field(
            "elastic_inference_accelerator_association_id",
            &self.elastic_inference_accelerator_association_id,
        );
        formatter.field(
            "elastic_inference_accelerator_association_state",
            &self.elastic_inference_accelerator_association_state,
        );
        formatter.field(
            "elastic_inference_accelerator_association_time",
            &self.elastic_inference_accelerator_association_time,
        );
        formatter.finish()
    }
}
/// See [`ElasticInferenceAcceleratorAssociation`](crate::model::ElasticInferenceAcceleratorAssociation)
pub mod elastic_inference_accelerator_association {
    /// A builder for [`ElasticInferenceAcceleratorAssociation`](crate::model::ElasticInferenceAcceleratorAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elastic_inference_accelerator_arn: std::option::Option<std::string::String>,
        pub(crate) elastic_inference_accelerator_association_id:
            std::option::Option<std::string::String>,
        pub(crate) elastic_inference_accelerator_association_state:
            std::option::Option<std::string::String>,
        pub(crate) elastic_inference_accelerator_association_time:
            std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>
        /// The Amazon Resource Name (ARN) of the elastic inference accelerator.
        /// </p>
        pub fn elastic_inference_accelerator_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_arn = Some(input.into());
            self
        }
        pub fn set_elastic_inference_accelerator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_arn = input;
            self
        }
        /// <p>
        /// The ID of the association.
        /// </p>
        pub fn elastic_inference_accelerator_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_association_id = Some(input.into());
            self
        }
        pub fn set_elastic_inference_accelerator_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_association_id = input;
            self
        }
        /// <p>
        /// The state of the elastic inference accelerator.
        /// </p>
        pub fn elastic_inference_accelerator_association_state(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_association_state = Some(input.into());
            self
        }
        pub fn set_elastic_inference_accelerator_association_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_inference_accelerator_association_state = input;
            self
        }
        /// <p>
        /// The time at which the elastic inference accelerator is associated with an instance.
        /// </p>
        pub fn elastic_inference_accelerator_association_time(
            mut self,
            input: smithy_types::Instant,
        ) -> Self {
            self.elastic_inference_accelerator_association_time = Some(input);
            self
        }
        pub fn set_elastic_inference_accelerator_association_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.elastic_inference_accelerator_association_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticInferenceAcceleratorAssociation`](crate::model::ElasticInferenceAcceleratorAssociation)
        pub fn build(self) -> crate::model::ElasticInferenceAcceleratorAssociation {
            crate::model::ElasticInferenceAcceleratorAssociation {
                elastic_inference_accelerator_arn: self.elastic_inference_accelerator_arn,
                elastic_inference_accelerator_association_id: self
                    .elastic_inference_accelerator_association_id,
                elastic_inference_accelerator_association_state: self
                    .elastic_inference_accelerator_association_state,
                elastic_inference_accelerator_association_time: self
                    .elastic_inference_accelerator_association_time,
            }
        }
    }
}
impl ElasticInferenceAcceleratorAssociation {
    /// Creates a new builder-style object to manufacture [`ElasticInferenceAcceleratorAssociation`](crate::model::ElasticInferenceAcceleratorAssociation)
    pub fn builder() -> crate::model::elastic_inference_accelerator_association::Builder {
        crate::model::elastic_inference_accelerator_association::Builder::default()
    }
}

/// <p>Describes the association between an instance and an Elastic Graphics accelerator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticGpuAssociation {
    /// <p>The ID of the Elastic Graphics accelerator.</p>
    pub elastic_gpu_id: std::option::Option<std::string::String>,
    /// <p>The ID of the association.</p>
    pub elastic_gpu_association_id: std::option::Option<std::string::String>,
    /// <p>The state of the association between the instance and the
    /// Elastic Graphics accelerator.</p>
    pub elastic_gpu_association_state: std::option::Option<std::string::String>,
    /// <p>The time the Elastic Graphics accelerator was associated with the instance.</p>
    pub elastic_gpu_association_time: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ElasticGpuAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticGpuAssociation");
        formatter.field("elastic_gpu_id", &self.elastic_gpu_id);
        formatter.field(
            "elastic_gpu_association_id",
            &self.elastic_gpu_association_id,
        );
        formatter.field(
            "elastic_gpu_association_state",
            &self.elastic_gpu_association_state,
        );
        formatter.field(
            "elastic_gpu_association_time",
            &self.elastic_gpu_association_time,
        );
        formatter.finish()
    }
}
/// See [`ElasticGpuAssociation`](crate::model::ElasticGpuAssociation)
pub mod elastic_gpu_association {
    /// A builder for [`ElasticGpuAssociation`](crate::model::ElasticGpuAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elastic_gpu_id: std::option::Option<std::string::String>,
        pub(crate) elastic_gpu_association_id: std::option::Option<std::string::String>,
        pub(crate) elastic_gpu_association_state: std::option::Option<std::string::String>,
        pub(crate) elastic_gpu_association_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_gpu_id = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_id = input;
            self
        }
        /// <p>The ID of the association.</p>
        pub fn elastic_gpu_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_gpu_association_id = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_association_id = input;
            self
        }
        /// <p>The state of the association between the instance and the
        /// Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_association_state(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_gpu_association_state = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_association_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_association_state = input;
            self
        }
        /// <p>The time the Elastic Graphics accelerator was associated with the instance.</p>
        pub fn elastic_gpu_association_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_gpu_association_time = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_association_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_association_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticGpuAssociation`](crate::model::ElasticGpuAssociation)
        pub fn build(self) -> crate::model::ElasticGpuAssociation {
            crate::model::ElasticGpuAssociation {
                elastic_gpu_id: self.elastic_gpu_id,
                elastic_gpu_association_id: self.elastic_gpu_association_id,
                elastic_gpu_association_state: self.elastic_gpu_association_state,
                elastic_gpu_association_time: self.elastic_gpu_association_time,
            }
        }
    }
}
impl ElasticGpuAssociation {
    /// Creates a new builder-style object to manufacture [`ElasticGpuAssociation`](crate::model::ElasticGpuAssociation)
    pub fn builder() -> crate::model::elastic_gpu_association::Builder {
        crate::model::elastic_gpu_association::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceLifecycleType {
    Scheduled,
    Spot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceLifecycleType {
    fn from(s: &str) -> Self {
        match s {
            "scheduled" => InstanceLifecycleType::Scheduled,
            "spot" => InstanceLifecycleType::Spot,
            other => InstanceLifecycleType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceLifecycleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceLifecycleType::from(s))
    }
}
impl InstanceLifecycleType {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceLifecycleType::Scheduled => "scheduled",
            InstanceLifecycleType::Spot => "spot",
            InstanceLifecycleType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["scheduled", "spot"]
    }
}
impl AsRef<str> for InstanceLifecycleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IAM instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamInstanceProfile {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the instance profile.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamInstanceProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamInstanceProfile");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`IamInstanceProfile`](crate::model::IamInstanceProfile)
pub mod iam_instance_profile {
    /// A builder for [`IamInstanceProfile`](crate::model::IamInstanceProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the instance profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`IamInstanceProfile`](crate::model::IamInstanceProfile)
        pub fn build(self) -> crate::model::IamInstanceProfile {
            crate::model::IamInstanceProfile {
                arn: self.arn,
                id: self.id,
            }
        }
    }
}
impl IamInstanceProfile {
    /// Creates a new builder-style object to manufacture [`IamInstanceProfile`](crate::model::IamInstanceProfile)
    pub fn builder() -> crate::model::iam_instance_profile::Builder {
        crate::model::iam_instance_profile::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HypervisorType {
    Ovm,
    Xen,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HypervisorType {
    fn from(s: &str) -> Self {
        match s {
            "ovm" => HypervisorType::Ovm,
            "xen" => HypervisorType::Xen,
            other => HypervisorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HypervisorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HypervisorType::from(s))
    }
}
impl HypervisorType {
    pub fn as_str(&self) -> &str {
        match self {
            HypervisorType::Ovm => "ovm",
            HypervisorType::Xen => "xen",
            HypervisorType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ovm", "xen"]
    }
}
impl AsRef<str> for HypervisorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a block device mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceBlockDeviceMapping {
    /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to automatically set up EBS volumes when the instance is
    /// launched.</p>
    pub ebs: std::option::Option<crate::model::EbsInstanceBlockDevice>,
}
impl std::fmt::Debug for InstanceBlockDeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceBlockDeviceMapping");
        formatter.field("device_name", &self.device_name);
        formatter.field("ebs", &self.ebs);
        formatter.finish()
    }
}
/// See [`InstanceBlockDeviceMapping`](crate::model::InstanceBlockDeviceMapping)
pub mod instance_block_device_mapping {
    /// A builder for [`InstanceBlockDeviceMapping`](crate::model::InstanceBlockDeviceMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::EbsInstanceBlockDevice>,
    }
    impl Builder {
        /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Parameters used to automatically set up EBS volumes when the instance is
        /// launched.</p>
        pub fn ebs(mut self, input: crate::model::EbsInstanceBlockDevice) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(
            mut self,
            input: std::option::Option<crate::model::EbsInstanceBlockDevice>,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceBlockDeviceMapping`](crate::model::InstanceBlockDeviceMapping)
        pub fn build(self) -> crate::model::InstanceBlockDeviceMapping {
            crate::model::InstanceBlockDeviceMapping {
                device_name: self.device_name,
                ebs: self.ebs,
            }
        }
    }
}
impl InstanceBlockDeviceMapping {
    /// Creates a new builder-style object to manufacture [`InstanceBlockDeviceMapping`](crate::model::InstanceBlockDeviceMapping)
    pub fn builder() -> crate::model::instance_block_device_mapping::Builder {
        crate::model::instance_block_device_mapping::Builder::default()
    }
}

/// <p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsInstanceBlockDevice {
    /// <p>The time stamp when the attachment initiated.</p>
    pub attach_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates whether the volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The attachment state.</p>
    pub status: std::option::Option<crate::model::AttachmentStatus>,
    /// <p>The ID of the EBS volume.</p>
    pub volume_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EbsInstanceBlockDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsInstanceBlockDevice");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("status", &self.status);
        formatter.field("volume_id", &self.volume_id);
        formatter.finish()
    }
}
/// See [`EbsInstanceBlockDevice`](crate::model::EbsInstanceBlockDevice)
pub mod ebs_instance_block_device {
    /// A builder for [`EbsInstanceBlockDevice`](crate::model::EbsInstanceBlockDevice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<smithy_types::Instant>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::AttachmentStatus>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time stamp when the attachment initiated.</p>
        pub fn attach_time(mut self, input: smithy_types::Instant) -> Self {
            self.attach_time = Some(input);
            self
        }
        pub fn set_attach_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>Indicates whether the volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The attachment state.</p>
        pub fn status(mut self, input: crate::model::AttachmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AttachmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the EBS volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsInstanceBlockDevice`](crate::model::EbsInstanceBlockDevice)
        pub fn build(self) -> crate::model::EbsInstanceBlockDevice {
            crate::model::EbsInstanceBlockDevice {
                attach_time: self.attach_time,
                delete_on_termination: self.delete_on_termination,
                status: self.status,
                volume_id: self.volume_id,
            }
        }
    }
}
impl EbsInstanceBlockDevice {
    /// Creates a new builder-style object to manufacture [`EbsInstanceBlockDevice`](crate::model::EbsInstanceBlockDevice)
    pub fn builder() -> crate::model::ebs_instance_block_device::Builder {
        crate::model::ebs_instance_block_device::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArchitectureValues {
    Arm64,
    I386,
    X8664,
    X8664Mac,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArchitectureValues {
    fn from(s: &str) -> Self {
        match s {
            "arm64" => ArchitectureValues::Arm64,
            "i386" => ArchitectureValues::I386,
            "x86_64" => ArchitectureValues::X8664,
            "x86_64_mac" => ArchitectureValues::X8664Mac,
            other => ArchitectureValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArchitectureValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArchitectureValues::from(s))
    }
}
impl ArchitectureValues {
    pub fn as_str(&self) -> &str {
        match self {
            ArchitectureValues::Arm64 => "arm64",
            ArchitectureValues::I386 => "i386",
            ArchitectureValues::X8664 => "x86_64",
            ArchitectureValues::X8664Mac => "x86_64_mac",
            ArchitectureValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["arm64", "i386", "x86_64", "x86_64_mac"]
    }
}
impl AsRef<str> for ArchitectureValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a product code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductCode {
    /// <p>The product code.</p>
    pub product_code_id: std::option::Option<std::string::String>,
    /// <p>The type of product code.</p>
    pub product_code_type: std::option::Option<crate::model::ProductCodeValues>,
}
impl std::fmt::Debug for ProductCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductCode");
        formatter.field("product_code_id", &self.product_code_id);
        formatter.field("product_code_type", &self.product_code_type);
        formatter.finish()
    }
}
/// See [`ProductCode`](crate::model::ProductCode)
pub mod product_code {
    /// A builder for [`ProductCode`](crate::model::ProductCode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_code_id: std::option::Option<std::string::String>,
        pub(crate) product_code_type: std::option::Option<crate::model::ProductCodeValues>,
    }
    impl Builder {
        /// <p>The product code.</p>
        pub fn product_code_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_code_id = Some(input.into());
            self
        }
        pub fn set_product_code_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.product_code_id = input;
            self
        }
        /// <p>The type of product code.</p>
        pub fn product_code_type(mut self, input: crate::model::ProductCodeValues) -> Self {
            self.product_code_type = Some(input);
            self
        }
        pub fn set_product_code_type(
            mut self,
            input: std::option::Option<crate::model::ProductCodeValues>,
        ) -> Self {
            self.product_code_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductCode`](crate::model::ProductCode)
        pub fn build(self) -> crate::model::ProductCode {
            crate::model::ProductCode {
                product_code_id: self.product_code_id,
                product_code_type: self.product_code_type,
            }
        }
    }
}
impl ProductCode {
    /// Creates a new builder-style object to manufacture [`ProductCode`](crate::model::ProductCode)
    pub fn builder() -> crate::model::product_code::Builder {
        crate::model::product_code::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductCodeValues {
    Devpay,
    Marketplace,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProductCodeValues {
    fn from(s: &str) -> Self {
        match s {
            "devpay" => ProductCodeValues::Devpay,
            "marketplace" => ProductCodeValues::Marketplace,
            other => ProductCodeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProductCodeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductCodeValues::from(s))
    }
}
impl ProductCodeValues {
    pub fn as_str(&self) -> &str {
        match self {
            ProductCodeValues::Devpay => "devpay",
            ProductCodeValues::Marketplace => "marketplace",
            ProductCodeValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["devpay", "marketplace"]
    }
}
impl AsRef<str> for ProductCodeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlatformValues {
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlatformValues {
    fn from(s: &str) -> Self {
        match s {
            "Windows" => PlatformValues::Windows,
            other => PlatformValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlatformValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlatformValues::from(s))
    }
}
impl PlatformValues {
    pub fn as_str(&self) -> &str {
        match self {
            PlatformValues::Windows => "Windows",
            PlatformValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Windows"]
    }
}
impl AsRef<str> for PlatformValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the placement of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Placement {
    /// <p>The Availability Zone of the instance.</p>
    /// <p>If not specified, an Availability Zone will be automatically chosen for you based on
    /// the load balancing criteria for the Region.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The affinity setting for the instance on the Dedicated Host. This parameter is not
    /// supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub affinity: std::option::Option<std::string::String>,
    /// <p>The name of the placement group the instance is in.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The number of the partition the instance is in. Valid only if the placement group
    /// strategy is set to <code>partition</code>.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub partition_number: std::option::Option<i32>,
    /// <p>The ID of the Dedicated Host on which the instance resides. This parameter is not
    /// supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub host_id: std::option::Option<std::string::String>,
    /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a
    /// tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code>
    /// tenancy is not supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    /// <p>T3 instances that use the <code>unlimited</code> CPU credit option do not support <code>host</code> tenancy.</p>
    pub tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>Reserved for future use.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub spread_domain: std::option::Option<std::string::String>,
    /// <p>The ARN of the host resource group in which to launch the instances. If you specify
    /// a host resource group ARN, omit the <b>Tenancy</b>
    /// parameter or set it to <code>host</code>.</p>
    /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
    pub host_resource_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Placement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Placement");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("affinity", &self.affinity);
        formatter.field("group_name", &self.group_name);
        formatter.field("partition_number", &self.partition_number);
        formatter.field("host_id", &self.host_id);
        formatter.field("tenancy", &self.tenancy);
        formatter.field("spread_domain", &self.spread_domain);
        formatter.field("host_resource_group_arn", &self.host_resource_group_arn);
        formatter.finish()
    }
}
/// See [`Placement`](crate::model::Placement)
pub mod placement {
    /// A builder for [`Placement`](crate::model::Placement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) affinity: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) partition_number: std::option::Option<i32>,
        pub(crate) host_id: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) spread_domain: std::option::Option<std::string::String>,
        pub(crate) host_resource_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Availability Zone of the instance.</p>
        /// <p>If not specified, an Availability Zone will be automatically chosen for you based on
        /// the load balancing criteria for the Region.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The affinity setting for the instance on the Dedicated Host. This parameter is not
        /// supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn affinity(mut self, input: impl Into<std::string::String>) -> Self {
            self.affinity = Some(input.into());
            self
        }
        pub fn set_affinity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.affinity = input;
            self
        }
        /// <p>The name of the placement group the instance is in.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The number of the partition the instance is in. Valid only if the placement group
        /// strategy is set to <code>partition</code>.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn partition_number(mut self, input: i32) -> Self {
            self.partition_number = Some(input);
            self
        }
        pub fn set_partition_number(mut self, input: std::option::Option<i32>) -> Self {
            self.partition_number = input;
            self
        }
        /// <p>The ID of the Dedicated Host on which the instance resides. This parameter is not
        /// supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_id = Some(input.into());
            self
        }
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_id = input;
            self
        }
        /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a
        /// tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code>
        /// tenancy is not supported for the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html">ImportInstance</a> command.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        /// <p>T3 instances that use the <code>unlimited</code> CPU credit option do not support <code>host</code> tenancy.</p>
        pub fn tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        pub fn set_tenancy(mut self, input: std::option::Option<crate::model::Tenancy>) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>Reserved for future use.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn spread_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.spread_domain = Some(input.into());
            self
        }
        pub fn set_spread_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spread_domain = input;
            self
        }
        /// <p>The ARN of the host resource group in which to launch the instances. If you specify
        /// a host resource group ARN, omit the <b>Tenancy</b>
        /// parameter or set it to <code>host</code>.</p>
        /// <p>This parameter is not supported by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet">CreateFleet</a>.</p>
        pub fn host_resource_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_resource_group_arn = Some(input.into());
            self
        }
        pub fn set_host_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_resource_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Placement`](crate::model::Placement)
        pub fn build(self) -> crate::model::Placement {
            crate::model::Placement {
                availability_zone: self.availability_zone,
                affinity: self.affinity,
                group_name: self.group_name,
                partition_number: self.partition_number,
                host_id: self.host_id,
                tenancy: self.tenancy,
                spread_domain: self.spread_domain,
                host_resource_group_arn: self.host_resource_group_arn,
            }
        }
    }
}
impl Placement {
    /// Creates a new builder-style object to manufacture [`Placement`](crate::model::Placement)
    pub fn builder() -> crate::model::placement::Builder {
        crate::model::placement::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Tenancy {
    Dedicated,
    Default,
    Host,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Tenancy {
    fn from(s: &str) -> Self {
        match s {
            "dedicated" => Tenancy::Dedicated,
            "default" => Tenancy::Default,
            "host" => Tenancy::Host,
            other => Tenancy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Tenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Tenancy::from(s))
    }
}
impl Tenancy {
    pub fn as_str(&self) -> &str {
        match self {
            Tenancy::Dedicated => "dedicated",
            Tenancy::Default => "default",
            Tenancy::Host => "host",
            Tenancy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["dedicated", "default", "host"]
    }
}
impl AsRef<str> for Tenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceType {
    A12xlarge,
    A14xlarge,
    A1Large,
    A1Medium,
    A1Metal,
    A1Xlarge,
    C1Medium,
    C1Xlarge,
    C32xlarge,
    C34xlarge,
    C38xlarge,
    C3Large,
    C3Xlarge,
    C42xlarge,
    C44xlarge,
    C48xlarge,
    C4Large,
    C4Xlarge,
    C512xlarge,
    C518xlarge,
    C524xlarge,
    C52xlarge,
    C54xlarge,
    C59xlarge,
    C5Large,
    C5Metal,
    C5Xlarge,
    C5a12xlarge,
    C5a16xlarge,
    C5a24xlarge,
    C5a2xlarge,
    C5a4xlarge,
    C5a8xlarge,
    C5aLarge,
    C5aXlarge,
    C5ad12xlarge,
    C5ad16xlarge,
    C5ad24xlarge,
    C5ad2xlarge,
    C5ad4xlarge,
    C5ad8xlarge,
    C5adLarge,
    C5adXlarge,
    C5d12xlarge,
    C5d18xlarge,
    C5d24xlarge,
    C5d2xlarge,
    C5d4xlarge,
    C5d9xlarge,
    C5dLarge,
    C5dMetal,
    C5dXlarge,
    C5n18xlarge,
    C5n2xlarge,
    C5n4xlarge,
    C5n9xlarge,
    C5nLarge,
    C5nMetal,
    C5nXlarge,
    C6g12xlarge,
    C6g16xlarge,
    C6g2xlarge,
    C6g4xlarge,
    C6g8xlarge,
    C6gLarge,
    C6gMedium,
    C6gMetal,
    C6gXlarge,
    C6gd12xlarge,
    C6gd16xlarge,
    C6gd2xlarge,
    C6gd4xlarge,
    C6gd8xlarge,
    C6gdLarge,
    C6gdMedium,
    C6gdMetal,
    C6gdXlarge,
    C6gn12xlarge,
    C6gn16xlarge,
    C6gn2xlarge,
    C6gn4xlarge,
    C6gn8xlarge,
    C6gnLarge,
    C6gnMedium,
    C6gnXlarge,
    Cc14xlarge,
    Cc28xlarge,
    Cg14xlarge,
    Cr18xlarge,
    D22xlarge,
    D24xlarge,
    D28xlarge,
    D2Xlarge,
    D32xlarge,
    D34xlarge,
    D38xlarge,
    D3Xlarge,
    D3en12xlarge,
    D3en2xlarge,
    D3en4xlarge,
    D3en6xlarge,
    D3en8xlarge,
    D3enXlarge,
    F116xlarge,
    F12xlarge,
    F14xlarge,
    G22xlarge,
    G28xlarge,
    G316xlarge,
    G34xlarge,
    G38xlarge,
    G3sXlarge,
    G4ad16xlarge,
    G4ad2xlarge,
    G4ad4xlarge,
    G4ad8xlarge,
    G4adXlarge,
    G4dn12xlarge,
    G4dn16xlarge,
    G4dn2xlarge,
    G4dn4xlarge,
    G4dn8xlarge,
    G4dnMetal,
    G4dnXlarge,
    H116xlarge,
    H12xlarge,
    H14xlarge,
    H18xlarge,
    Hi14xlarge,
    Hs18xlarge,
    I22xlarge,
    I24xlarge,
    I28xlarge,
    I2Xlarge,
    I316xlarge,
    I32xlarge,
    I34xlarge,
    I38xlarge,
    I3Large,
    I3Metal,
    I3Xlarge,
    I3en12xlarge,
    I3en24xlarge,
    I3en2xlarge,
    I3en3xlarge,
    I3en6xlarge,
    I3enLarge,
    I3enMetal,
    I3enXlarge,
    Inf124xlarge,
    Inf12xlarge,
    Inf16xlarge,
    Inf1Xlarge,
    M1Large,
    M1Medium,
    M1Small,
    M1Xlarge,
    M22xlarge,
    M24xlarge,
    M2Xlarge,
    M32xlarge,
    M3Large,
    M3Medium,
    M3Xlarge,
    M410xlarge,
    M416xlarge,
    M42xlarge,
    M44xlarge,
    M4Large,
    M4Xlarge,
    M512xlarge,
    M516xlarge,
    M524xlarge,
    M52xlarge,
    M54xlarge,
    M58xlarge,
    M5Large,
    M5Metal,
    M5Xlarge,
    M5a12xlarge,
    M5a16xlarge,
    M5a24xlarge,
    M5a2xlarge,
    M5a4xlarge,
    M5a8xlarge,
    M5aLarge,
    M5aXlarge,
    M5ad12xlarge,
    M5ad16xlarge,
    M5ad24xlarge,
    M5ad2xlarge,
    M5ad4xlarge,
    M5ad8xlarge,
    M5adLarge,
    M5adXlarge,
    M5d12xlarge,
    M5d16xlarge,
    M5d24xlarge,
    M5d2xlarge,
    M5d4xlarge,
    M5d8xlarge,
    M5dLarge,
    M5dMetal,
    M5dXlarge,
    M5dn12xlarge,
    M5dn16xlarge,
    M5dn24xlarge,
    M5dn2xlarge,
    M5dn4xlarge,
    M5dn8xlarge,
    M5dnLarge,
    M5dnMetal,
    M5dnXlarge,
    M5n12xlarge,
    M5n16xlarge,
    M5n24xlarge,
    M5n2xlarge,
    M5n4xlarge,
    M5n8xlarge,
    M5nLarge,
    M5nMetal,
    M5nXlarge,
    M5zn12xlarge,
    M5zn2xlarge,
    M5zn3xlarge,
    M5zn6xlarge,
    M5znLarge,
    M5znMetal,
    M5znXlarge,
    M6g12xlarge,
    M6g16xlarge,
    M6g2xlarge,
    M6g4xlarge,
    M6g8xlarge,
    M6gLarge,
    M6gMedium,
    M6gMetal,
    M6gXlarge,
    M6gd12xlarge,
    M6gd16xlarge,
    M6gd2xlarge,
    M6gd4xlarge,
    M6gd8xlarge,
    M6gdLarge,
    M6gdMedium,
    M6gdMetal,
    M6gdXlarge,
    M6i12xlarge,
    M6i16xlarge,
    M6i24xlarge,
    M6i2xlarge,
    M6i32xlarge,
    M6i4xlarge,
    M6i8xlarge,
    M6iLarge,
    M6iXlarge,
    Mac1Metal,
    P216xlarge,
    P28xlarge,
    P2Xlarge,
    P316xlarge,
    P32xlarge,
    P38xlarge,
    P3dn24xlarge,
    P4d24xlarge,
    R32xlarge,
    R34xlarge,
    R38xlarge,
    R3Large,
    R3Xlarge,
    R416xlarge,
    R42xlarge,
    R44xlarge,
    R48xlarge,
    R4Large,
    R4Xlarge,
    R512xlarge,
    R516xlarge,
    R524xlarge,
    R52xlarge,
    R54xlarge,
    R58xlarge,
    R5Large,
    R5Metal,
    R5Xlarge,
    R5a12xlarge,
    R5a16xlarge,
    R5a24xlarge,
    R5a2xlarge,
    R5a4xlarge,
    R5a8xlarge,
    R5aLarge,
    R5aXlarge,
    R5ad12xlarge,
    R5ad16xlarge,
    R5ad24xlarge,
    R5ad2xlarge,
    R5ad4xlarge,
    R5ad8xlarge,
    R5adLarge,
    R5adXlarge,
    R5b12xlarge,
    R5b16xlarge,
    R5b24xlarge,
    R5b2xlarge,
    R5b4xlarge,
    R5b8xlarge,
    R5bLarge,
    R5bMetal,
    R5bXlarge,
    R5d12xlarge,
    R5d16xlarge,
    R5d24xlarge,
    R5d2xlarge,
    R5d4xlarge,
    R5d8xlarge,
    R5dLarge,
    R5dMetal,
    R5dXlarge,
    R5dn12xlarge,
    R5dn16xlarge,
    R5dn24xlarge,
    R5dn2xlarge,
    R5dn4xlarge,
    R5dn8xlarge,
    R5dnLarge,
    R5dnMetal,
    R5dnXlarge,
    R5n12xlarge,
    R5n16xlarge,
    R5n24xlarge,
    R5n2xlarge,
    R5n4xlarge,
    R5n8xlarge,
    R5nLarge,
    R5nMetal,
    R5nXlarge,
    R6g12xlarge,
    R6g16xlarge,
    R6g2xlarge,
    R6g4xlarge,
    R6g8xlarge,
    R6gLarge,
    R6gMedium,
    R6gMetal,
    R6gXlarge,
    R6gd12xlarge,
    R6gd16xlarge,
    R6gd2xlarge,
    R6gd4xlarge,
    R6gd8xlarge,
    R6gdLarge,
    R6gdMedium,
    R6gdMetal,
    R6gdXlarge,
    T1Micro,
    T22xlarge,
    T2Large,
    T2Medium,
    T2Micro,
    T2Nano,
    T2Small,
    T2Xlarge,
    T32xlarge,
    T3Large,
    T3Medium,
    T3Micro,
    T3Nano,
    T3Small,
    T3Xlarge,
    T3a2xlarge,
    T3aLarge,
    T3aMedium,
    T3aMicro,
    T3aNano,
    T3aSmall,
    T3aXlarge,
    T4g2xlarge,
    T4gLarge,
    T4gMedium,
    T4gMicro,
    T4gNano,
    T4gSmall,
    T4gXlarge,
    U12tb1112xlarge,
    U12tb1Metal,
    U18tb1Metal,
    U24tb1Metal,
    U6tb1112xlarge,
    U6tb156xlarge,
    U6tb1Metal,
    U9tb1112xlarge,
    U9tb1Metal,
    X116xlarge,
    X132xlarge,
    X1e16xlarge,
    X1e2xlarge,
    X1e32xlarge,
    X1e4xlarge,
    X1e8xlarge,
    X1eXlarge,
    X2gd12xlarge,
    X2gd16xlarge,
    X2gd2xlarge,
    X2gd4xlarge,
    X2gd8xlarge,
    X2gdLarge,
    X2gdMedium,
    X2gdMetal,
    X2gdXlarge,
    Z1d12xlarge,
    Z1d2xlarge,
    Z1d3xlarge,
    Z1d6xlarge,
    Z1dLarge,
    Z1dMetal,
    Z1dXlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceType {
    fn from(s: &str) -> Self {
        match s {
            "a1.2xlarge" => InstanceType::A12xlarge,
            "a1.4xlarge" => InstanceType::A14xlarge,
            "a1.large" => InstanceType::A1Large,
            "a1.medium" => InstanceType::A1Medium,
            "a1.metal" => InstanceType::A1Metal,
            "a1.xlarge" => InstanceType::A1Xlarge,
            "c1.medium" => InstanceType::C1Medium,
            "c1.xlarge" => InstanceType::C1Xlarge,
            "c3.2xlarge" => InstanceType::C32xlarge,
            "c3.4xlarge" => InstanceType::C34xlarge,
            "c3.8xlarge" => InstanceType::C38xlarge,
            "c3.large" => InstanceType::C3Large,
            "c3.xlarge" => InstanceType::C3Xlarge,
            "c4.2xlarge" => InstanceType::C42xlarge,
            "c4.4xlarge" => InstanceType::C44xlarge,
            "c4.8xlarge" => InstanceType::C48xlarge,
            "c4.large" => InstanceType::C4Large,
            "c4.xlarge" => InstanceType::C4Xlarge,
            "c5.12xlarge" => InstanceType::C512xlarge,
            "c5.18xlarge" => InstanceType::C518xlarge,
            "c5.24xlarge" => InstanceType::C524xlarge,
            "c5.2xlarge" => InstanceType::C52xlarge,
            "c5.4xlarge" => InstanceType::C54xlarge,
            "c5.9xlarge" => InstanceType::C59xlarge,
            "c5.large" => InstanceType::C5Large,
            "c5.metal" => InstanceType::C5Metal,
            "c5.xlarge" => InstanceType::C5Xlarge,
            "c5a.12xlarge" => InstanceType::C5a12xlarge,
            "c5a.16xlarge" => InstanceType::C5a16xlarge,
            "c5a.24xlarge" => InstanceType::C5a24xlarge,
            "c5a.2xlarge" => InstanceType::C5a2xlarge,
            "c5a.4xlarge" => InstanceType::C5a4xlarge,
            "c5a.8xlarge" => InstanceType::C5a8xlarge,
            "c5a.large" => InstanceType::C5aLarge,
            "c5a.xlarge" => InstanceType::C5aXlarge,
            "c5ad.12xlarge" => InstanceType::C5ad12xlarge,
            "c5ad.16xlarge" => InstanceType::C5ad16xlarge,
            "c5ad.24xlarge" => InstanceType::C5ad24xlarge,
            "c5ad.2xlarge" => InstanceType::C5ad2xlarge,
            "c5ad.4xlarge" => InstanceType::C5ad4xlarge,
            "c5ad.8xlarge" => InstanceType::C5ad8xlarge,
            "c5ad.large" => InstanceType::C5adLarge,
            "c5ad.xlarge" => InstanceType::C5adXlarge,
            "c5d.12xlarge" => InstanceType::C5d12xlarge,
            "c5d.18xlarge" => InstanceType::C5d18xlarge,
            "c5d.24xlarge" => InstanceType::C5d24xlarge,
            "c5d.2xlarge" => InstanceType::C5d2xlarge,
            "c5d.4xlarge" => InstanceType::C5d4xlarge,
            "c5d.9xlarge" => InstanceType::C5d9xlarge,
            "c5d.large" => InstanceType::C5dLarge,
            "c5d.metal" => InstanceType::C5dMetal,
            "c5d.xlarge" => InstanceType::C5dXlarge,
            "c5n.18xlarge" => InstanceType::C5n18xlarge,
            "c5n.2xlarge" => InstanceType::C5n2xlarge,
            "c5n.4xlarge" => InstanceType::C5n4xlarge,
            "c5n.9xlarge" => InstanceType::C5n9xlarge,
            "c5n.large" => InstanceType::C5nLarge,
            "c5n.metal" => InstanceType::C5nMetal,
            "c5n.xlarge" => InstanceType::C5nXlarge,
            "c6g.12xlarge" => InstanceType::C6g12xlarge,
            "c6g.16xlarge" => InstanceType::C6g16xlarge,
            "c6g.2xlarge" => InstanceType::C6g2xlarge,
            "c6g.4xlarge" => InstanceType::C6g4xlarge,
            "c6g.8xlarge" => InstanceType::C6g8xlarge,
            "c6g.large" => InstanceType::C6gLarge,
            "c6g.medium" => InstanceType::C6gMedium,
            "c6g.metal" => InstanceType::C6gMetal,
            "c6g.xlarge" => InstanceType::C6gXlarge,
            "c6gd.12xlarge" => InstanceType::C6gd12xlarge,
            "c6gd.16xlarge" => InstanceType::C6gd16xlarge,
            "c6gd.2xlarge" => InstanceType::C6gd2xlarge,
            "c6gd.4xlarge" => InstanceType::C6gd4xlarge,
            "c6gd.8xlarge" => InstanceType::C6gd8xlarge,
            "c6gd.large" => InstanceType::C6gdLarge,
            "c6gd.medium" => InstanceType::C6gdMedium,
            "c6gd.metal" => InstanceType::C6gdMetal,
            "c6gd.xlarge" => InstanceType::C6gdXlarge,
            "c6gn.12xlarge" => InstanceType::C6gn12xlarge,
            "c6gn.16xlarge" => InstanceType::C6gn16xlarge,
            "c6gn.2xlarge" => InstanceType::C6gn2xlarge,
            "c6gn.4xlarge" => InstanceType::C6gn4xlarge,
            "c6gn.8xlarge" => InstanceType::C6gn8xlarge,
            "c6gn.large" => InstanceType::C6gnLarge,
            "c6gn.medium" => InstanceType::C6gnMedium,
            "c6gn.xlarge" => InstanceType::C6gnXlarge,
            "cc1.4xlarge" => InstanceType::Cc14xlarge,
            "cc2.8xlarge" => InstanceType::Cc28xlarge,
            "cg1.4xlarge" => InstanceType::Cg14xlarge,
            "cr1.8xlarge" => InstanceType::Cr18xlarge,
            "d2.2xlarge" => InstanceType::D22xlarge,
            "d2.4xlarge" => InstanceType::D24xlarge,
            "d2.8xlarge" => InstanceType::D28xlarge,
            "d2.xlarge" => InstanceType::D2Xlarge,
            "d3.2xlarge" => InstanceType::D32xlarge,
            "d3.4xlarge" => InstanceType::D34xlarge,
            "d3.8xlarge" => InstanceType::D38xlarge,
            "d3.xlarge" => InstanceType::D3Xlarge,
            "d3en.12xlarge" => InstanceType::D3en12xlarge,
            "d3en.2xlarge" => InstanceType::D3en2xlarge,
            "d3en.4xlarge" => InstanceType::D3en4xlarge,
            "d3en.6xlarge" => InstanceType::D3en6xlarge,
            "d3en.8xlarge" => InstanceType::D3en8xlarge,
            "d3en.xlarge" => InstanceType::D3enXlarge,
            "f1.16xlarge" => InstanceType::F116xlarge,
            "f1.2xlarge" => InstanceType::F12xlarge,
            "f1.4xlarge" => InstanceType::F14xlarge,
            "g2.2xlarge" => InstanceType::G22xlarge,
            "g2.8xlarge" => InstanceType::G28xlarge,
            "g3.16xlarge" => InstanceType::G316xlarge,
            "g3.4xlarge" => InstanceType::G34xlarge,
            "g3.8xlarge" => InstanceType::G38xlarge,
            "g3s.xlarge" => InstanceType::G3sXlarge,
            "g4ad.16xlarge" => InstanceType::G4ad16xlarge,
            "g4ad.2xlarge" => InstanceType::G4ad2xlarge,
            "g4ad.4xlarge" => InstanceType::G4ad4xlarge,
            "g4ad.8xlarge" => InstanceType::G4ad8xlarge,
            "g4ad.xlarge" => InstanceType::G4adXlarge,
            "g4dn.12xlarge" => InstanceType::G4dn12xlarge,
            "g4dn.16xlarge" => InstanceType::G4dn16xlarge,
            "g4dn.2xlarge" => InstanceType::G4dn2xlarge,
            "g4dn.4xlarge" => InstanceType::G4dn4xlarge,
            "g4dn.8xlarge" => InstanceType::G4dn8xlarge,
            "g4dn.metal" => InstanceType::G4dnMetal,
            "g4dn.xlarge" => InstanceType::G4dnXlarge,
            "h1.16xlarge" => InstanceType::H116xlarge,
            "h1.2xlarge" => InstanceType::H12xlarge,
            "h1.4xlarge" => InstanceType::H14xlarge,
            "h1.8xlarge" => InstanceType::H18xlarge,
            "hi1.4xlarge" => InstanceType::Hi14xlarge,
            "hs1.8xlarge" => InstanceType::Hs18xlarge,
            "i2.2xlarge" => InstanceType::I22xlarge,
            "i2.4xlarge" => InstanceType::I24xlarge,
            "i2.8xlarge" => InstanceType::I28xlarge,
            "i2.xlarge" => InstanceType::I2Xlarge,
            "i3.16xlarge" => InstanceType::I316xlarge,
            "i3.2xlarge" => InstanceType::I32xlarge,
            "i3.4xlarge" => InstanceType::I34xlarge,
            "i3.8xlarge" => InstanceType::I38xlarge,
            "i3.large" => InstanceType::I3Large,
            "i3.metal" => InstanceType::I3Metal,
            "i3.xlarge" => InstanceType::I3Xlarge,
            "i3en.12xlarge" => InstanceType::I3en12xlarge,
            "i3en.24xlarge" => InstanceType::I3en24xlarge,
            "i3en.2xlarge" => InstanceType::I3en2xlarge,
            "i3en.3xlarge" => InstanceType::I3en3xlarge,
            "i3en.6xlarge" => InstanceType::I3en6xlarge,
            "i3en.large" => InstanceType::I3enLarge,
            "i3en.metal" => InstanceType::I3enMetal,
            "i3en.xlarge" => InstanceType::I3enXlarge,
            "inf1.24xlarge" => InstanceType::Inf124xlarge,
            "inf1.2xlarge" => InstanceType::Inf12xlarge,
            "inf1.6xlarge" => InstanceType::Inf16xlarge,
            "inf1.xlarge" => InstanceType::Inf1Xlarge,
            "m1.large" => InstanceType::M1Large,
            "m1.medium" => InstanceType::M1Medium,
            "m1.small" => InstanceType::M1Small,
            "m1.xlarge" => InstanceType::M1Xlarge,
            "m2.2xlarge" => InstanceType::M22xlarge,
            "m2.4xlarge" => InstanceType::M24xlarge,
            "m2.xlarge" => InstanceType::M2Xlarge,
            "m3.2xlarge" => InstanceType::M32xlarge,
            "m3.large" => InstanceType::M3Large,
            "m3.medium" => InstanceType::M3Medium,
            "m3.xlarge" => InstanceType::M3Xlarge,
            "m4.10xlarge" => InstanceType::M410xlarge,
            "m4.16xlarge" => InstanceType::M416xlarge,
            "m4.2xlarge" => InstanceType::M42xlarge,
            "m4.4xlarge" => InstanceType::M44xlarge,
            "m4.large" => InstanceType::M4Large,
            "m4.xlarge" => InstanceType::M4Xlarge,
            "m5.12xlarge" => InstanceType::M512xlarge,
            "m5.16xlarge" => InstanceType::M516xlarge,
            "m5.24xlarge" => InstanceType::M524xlarge,
            "m5.2xlarge" => InstanceType::M52xlarge,
            "m5.4xlarge" => InstanceType::M54xlarge,
            "m5.8xlarge" => InstanceType::M58xlarge,
            "m5.large" => InstanceType::M5Large,
            "m5.metal" => InstanceType::M5Metal,
            "m5.xlarge" => InstanceType::M5Xlarge,
            "m5a.12xlarge" => InstanceType::M5a12xlarge,
            "m5a.16xlarge" => InstanceType::M5a16xlarge,
            "m5a.24xlarge" => InstanceType::M5a24xlarge,
            "m5a.2xlarge" => InstanceType::M5a2xlarge,
            "m5a.4xlarge" => InstanceType::M5a4xlarge,
            "m5a.8xlarge" => InstanceType::M5a8xlarge,
            "m5a.large" => InstanceType::M5aLarge,
            "m5a.xlarge" => InstanceType::M5aXlarge,
            "m5ad.12xlarge" => InstanceType::M5ad12xlarge,
            "m5ad.16xlarge" => InstanceType::M5ad16xlarge,
            "m5ad.24xlarge" => InstanceType::M5ad24xlarge,
            "m5ad.2xlarge" => InstanceType::M5ad2xlarge,
            "m5ad.4xlarge" => InstanceType::M5ad4xlarge,
            "m5ad.8xlarge" => InstanceType::M5ad8xlarge,
            "m5ad.large" => InstanceType::M5adLarge,
            "m5ad.xlarge" => InstanceType::M5adXlarge,
            "m5d.12xlarge" => InstanceType::M5d12xlarge,
            "m5d.16xlarge" => InstanceType::M5d16xlarge,
            "m5d.24xlarge" => InstanceType::M5d24xlarge,
            "m5d.2xlarge" => InstanceType::M5d2xlarge,
            "m5d.4xlarge" => InstanceType::M5d4xlarge,
            "m5d.8xlarge" => InstanceType::M5d8xlarge,
            "m5d.large" => InstanceType::M5dLarge,
            "m5d.metal" => InstanceType::M5dMetal,
            "m5d.xlarge" => InstanceType::M5dXlarge,
            "m5dn.12xlarge" => InstanceType::M5dn12xlarge,
            "m5dn.16xlarge" => InstanceType::M5dn16xlarge,
            "m5dn.24xlarge" => InstanceType::M5dn24xlarge,
            "m5dn.2xlarge" => InstanceType::M5dn2xlarge,
            "m5dn.4xlarge" => InstanceType::M5dn4xlarge,
            "m5dn.8xlarge" => InstanceType::M5dn8xlarge,
            "m5dn.large" => InstanceType::M5dnLarge,
            "m5dn.metal" => InstanceType::M5dnMetal,
            "m5dn.xlarge" => InstanceType::M5dnXlarge,
            "m5n.12xlarge" => InstanceType::M5n12xlarge,
            "m5n.16xlarge" => InstanceType::M5n16xlarge,
            "m5n.24xlarge" => InstanceType::M5n24xlarge,
            "m5n.2xlarge" => InstanceType::M5n2xlarge,
            "m5n.4xlarge" => InstanceType::M5n4xlarge,
            "m5n.8xlarge" => InstanceType::M5n8xlarge,
            "m5n.large" => InstanceType::M5nLarge,
            "m5n.metal" => InstanceType::M5nMetal,
            "m5n.xlarge" => InstanceType::M5nXlarge,
            "m5zn.12xlarge" => InstanceType::M5zn12xlarge,
            "m5zn.2xlarge" => InstanceType::M5zn2xlarge,
            "m5zn.3xlarge" => InstanceType::M5zn3xlarge,
            "m5zn.6xlarge" => InstanceType::M5zn6xlarge,
            "m5zn.large" => InstanceType::M5znLarge,
            "m5zn.metal" => InstanceType::M5znMetal,
            "m5zn.xlarge" => InstanceType::M5znXlarge,
            "m6g.12xlarge" => InstanceType::M6g12xlarge,
            "m6g.16xlarge" => InstanceType::M6g16xlarge,
            "m6g.2xlarge" => InstanceType::M6g2xlarge,
            "m6g.4xlarge" => InstanceType::M6g4xlarge,
            "m6g.8xlarge" => InstanceType::M6g8xlarge,
            "m6g.large" => InstanceType::M6gLarge,
            "m6g.medium" => InstanceType::M6gMedium,
            "m6g.metal" => InstanceType::M6gMetal,
            "m6g.xlarge" => InstanceType::M6gXlarge,
            "m6gd.12xlarge" => InstanceType::M6gd12xlarge,
            "m6gd.16xlarge" => InstanceType::M6gd16xlarge,
            "m6gd.2xlarge" => InstanceType::M6gd2xlarge,
            "m6gd.4xlarge" => InstanceType::M6gd4xlarge,
            "m6gd.8xlarge" => InstanceType::M6gd8xlarge,
            "m6gd.large" => InstanceType::M6gdLarge,
            "m6gd.medium" => InstanceType::M6gdMedium,
            "m6gd.metal" => InstanceType::M6gdMetal,
            "m6gd.xlarge" => InstanceType::M6gdXlarge,
            "m6i.12xlarge" => InstanceType::M6i12xlarge,
            "m6i.16xlarge" => InstanceType::M6i16xlarge,
            "m6i.24xlarge" => InstanceType::M6i24xlarge,
            "m6i.2xlarge" => InstanceType::M6i2xlarge,
            "m6i.32xlarge" => InstanceType::M6i32xlarge,
            "m6i.4xlarge" => InstanceType::M6i4xlarge,
            "m6i.8xlarge" => InstanceType::M6i8xlarge,
            "m6i.large" => InstanceType::M6iLarge,
            "m6i.xlarge" => InstanceType::M6iXlarge,
            "mac1.metal" => InstanceType::Mac1Metal,
            "p2.16xlarge" => InstanceType::P216xlarge,
            "p2.8xlarge" => InstanceType::P28xlarge,
            "p2.xlarge" => InstanceType::P2Xlarge,
            "p3.16xlarge" => InstanceType::P316xlarge,
            "p3.2xlarge" => InstanceType::P32xlarge,
            "p3.8xlarge" => InstanceType::P38xlarge,
            "p3dn.24xlarge" => InstanceType::P3dn24xlarge,
            "p4d.24xlarge" => InstanceType::P4d24xlarge,
            "r3.2xlarge" => InstanceType::R32xlarge,
            "r3.4xlarge" => InstanceType::R34xlarge,
            "r3.8xlarge" => InstanceType::R38xlarge,
            "r3.large" => InstanceType::R3Large,
            "r3.xlarge" => InstanceType::R3Xlarge,
            "r4.16xlarge" => InstanceType::R416xlarge,
            "r4.2xlarge" => InstanceType::R42xlarge,
            "r4.4xlarge" => InstanceType::R44xlarge,
            "r4.8xlarge" => InstanceType::R48xlarge,
            "r4.large" => InstanceType::R4Large,
            "r4.xlarge" => InstanceType::R4Xlarge,
            "r5.12xlarge" => InstanceType::R512xlarge,
            "r5.16xlarge" => InstanceType::R516xlarge,
            "r5.24xlarge" => InstanceType::R524xlarge,
            "r5.2xlarge" => InstanceType::R52xlarge,
            "r5.4xlarge" => InstanceType::R54xlarge,
            "r5.8xlarge" => InstanceType::R58xlarge,
            "r5.large" => InstanceType::R5Large,
            "r5.metal" => InstanceType::R5Metal,
            "r5.xlarge" => InstanceType::R5Xlarge,
            "r5a.12xlarge" => InstanceType::R5a12xlarge,
            "r5a.16xlarge" => InstanceType::R5a16xlarge,
            "r5a.24xlarge" => InstanceType::R5a24xlarge,
            "r5a.2xlarge" => InstanceType::R5a2xlarge,
            "r5a.4xlarge" => InstanceType::R5a4xlarge,
            "r5a.8xlarge" => InstanceType::R5a8xlarge,
            "r5a.large" => InstanceType::R5aLarge,
            "r5a.xlarge" => InstanceType::R5aXlarge,
            "r5ad.12xlarge" => InstanceType::R5ad12xlarge,
            "r5ad.16xlarge" => InstanceType::R5ad16xlarge,
            "r5ad.24xlarge" => InstanceType::R5ad24xlarge,
            "r5ad.2xlarge" => InstanceType::R5ad2xlarge,
            "r5ad.4xlarge" => InstanceType::R5ad4xlarge,
            "r5ad.8xlarge" => InstanceType::R5ad8xlarge,
            "r5ad.large" => InstanceType::R5adLarge,
            "r5ad.xlarge" => InstanceType::R5adXlarge,
            "r5b.12xlarge" => InstanceType::R5b12xlarge,
            "r5b.16xlarge" => InstanceType::R5b16xlarge,
            "r5b.24xlarge" => InstanceType::R5b24xlarge,
            "r5b.2xlarge" => InstanceType::R5b2xlarge,
            "r5b.4xlarge" => InstanceType::R5b4xlarge,
            "r5b.8xlarge" => InstanceType::R5b8xlarge,
            "r5b.large" => InstanceType::R5bLarge,
            "r5b.metal" => InstanceType::R5bMetal,
            "r5b.xlarge" => InstanceType::R5bXlarge,
            "r5d.12xlarge" => InstanceType::R5d12xlarge,
            "r5d.16xlarge" => InstanceType::R5d16xlarge,
            "r5d.24xlarge" => InstanceType::R5d24xlarge,
            "r5d.2xlarge" => InstanceType::R5d2xlarge,
            "r5d.4xlarge" => InstanceType::R5d4xlarge,
            "r5d.8xlarge" => InstanceType::R5d8xlarge,
            "r5d.large" => InstanceType::R5dLarge,
            "r5d.metal" => InstanceType::R5dMetal,
            "r5d.xlarge" => InstanceType::R5dXlarge,
            "r5dn.12xlarge" => InstanceType::R5dn12xlarge,
            "r5dn.16xlarge" => InstanceType::R5dn16xlarge,
            "r5dn.24xlarge" => InstanceType::R5dn24xlarge,
            "r5dn.2xlarge" => InstanceType::R5dn2xlarge,
            "r5dn.4xlarge" => InstanceType::R5dn4xlarge,
            "r5dn.8xlarge" => InstanceType::R5dn8xlarge,
            "r5dn.large" => InstanceType::R5dnLarge,
            "r5dn.metal" => InstanceType::R5dnMetal,
            "r5dn.xlarge" => InstanceType::R5dnXlarge,
            "r5n.12xlarge" => InstanceType::R5n12xlarge,
            "r5n.16xlarge" => InstanceType::R5n16xlarge,
            "r5n.24xlarge" => InstanceType::R5n24xlarge,
            "r5n.2xlarge" => InstanceType::R5n2xlarge,
            "r5n.4xlarge" => InstanceType::R5n4xlarge,
            "r5n.8xlarge" => InstanceType::R5n8xlarge,
            "r5n.large" => InstanceType::R5nLarge,
            "r5n.metal" => InstanceType::R5nMetal,
            "r5n.xlarge" => InstanceType::R5nXlarge,
            "r6g.12xlarge" => InstanceType::R6g12xlarge,
            "r6g.16xlarge" => InstanceType::R6g16xlarge,
            "r6g.2xlarge" => InstanceType::R6g2xlarge,
            "r6g.4xlarge" => InstanceType::R6g4xlarge,
            "r6g.8xlarge" => InstanceType::R6g8xlarge,
            "r6g.large" => InstanceType::R6gLarge,
            "r6g.medium" => InstanceType::R6gMedium,
            "r6g.metal" => InstanceType::R6gMetal,
            "r6g.xlarge" => InstanceType::R6gXlarge,
            "r6gd.12xlarge" => InstanceType::R6gd12xlarge,
            "r6gd.16xlarge" => InstanceType::R6gd16xlarge,
            "r6gd.2xlarge" => InstanceType::R6gd2xlarge,
            "r6gd.4xlarge" => InstanceType::R6gd4xlarge,
            "r6gd.8xlarge" => InstanceType::R6gd8xlarge,
            "r6gd.large" => InstanceType::R6gdLarge,
            "r6gd.medium" => InstanceType::R6gdMedium,
            "r6gd.metal" => InstanceType::R6gdMetal,
            "r6gd.xlarge" => InstanceType::R6gdXlarge,
            "t1.micro" => InstanceType::T1Micro,
            "t2.2xlarge" => InstanceType::T22xlarge,
            "t2.large" => InstanceType::T2Large,
            "t2.medium" => InstanceType::T2Medium,
            "t2.micro" => InstanceType::T2Micro,
            "t2.nano" => InstanceType::T2Nano,
            "t2.small" => InstanceType::T2Small,
            "t2.xlarge" => InstanceType::T2Xlarge,
            "t3.2xlarge" => InstanceType::T32xlarge,
            "t3.large" => InstanceType::T3Large,
            "t3.medium" => InstanceType::T3Medium,
            "t3.micro" => InstanceType::T3Micro,
            "t3.nano" => InstanceType::T3Nano,
            "t3.small" => InstanceType::T3Small,
            "t3.xlarge" => InstanceType::T3Xlarge,
            "t3a.2xlarge" => InstanceType::T3a2xlarge,
            "t3a.large" => InstanceType::T3aLarge,
            "t3a.medium" => InstanceType::T3aMedium,
            "t3a.micro" => InstanceType::T3aMicro,
            "t3a.nano" => InstanceType::T3aNano,
            "t3a.small" => InstanceType::T3aSmall,
            "t3a.xlarge" => InstanceType::T3aXlarge,
            "t4g.2xlarge" => InstanceType::T4g2xlarge,
            "t4g.large" => InstanceType::T4gLarge,
            "t4g.medium" => InstanceType::T4gMedium,
            "t4g.micro" => InstanceType::T4gMicro,
            "t4g.nano" => InstanceType::T4gNano,
            "t4g.small" => InstanceType::T4gSmall,
            "t4g.xlarge" => InstanceType::T4gXlarge,
            "u-12tb1.112xlarge" => InstanceType::U12tb1112xlarge,
            "u-12tb1.metal" => InstanceType::U12tb1Metal,
            "u-18tb1.metal" => InstanceType::U18tb1Metal,
            "u-24tb1.metal" => InstanceType::U24tb1Metal,
            "u-6tb1.112xlarge" => InstanceType::U6tb1112xlarge,
            "u-6tb1.56xlarge" => InstanceType::U6tb156xlarge,
            "u-6tb1.metal" => InstanceType::U6tb1Metal,
            "u-9tb1.112xlarge" => InstanceType::U9tb1112xlarge,
            "u-9tb1.metal" => InstanceType::U9tb1Metal,
            "x1.16xlarge" => InstanceType::X116xlarge,
            "x1.32xlarge" => InstanceType::X132xlarge,
            "x1e.16xlarge" => InstanceType::X1e16xlarge,
            "x1e.2xlarge" => InstanceType::X1e2xlarge,
            "x1e.32xlarge" => InstanceType::X1e32xlarge,
            "x1e.4xlarge" => InstanceType::X1e4xlarge,
            "x1e.8xlarge" => InstanceType::X1e8xlarge,
            "x1e.xlarge" => InstanceType::X1eXlarge,
            "x2gd.12xlarge" => InstanceType::X2gd12xlarge,
            "x2gd.16xlarge" => InstanceType::X2gd16xlarge,
            "x2gd.2xlarge" => InstanceType::X2gd2xlarge,
            "x2gd.4xlarge" => InstanceType::X2gd4xlarge,
            "x2gd.8xlarge" => InstanceType::X2gd8xlarge,
            "x2gd.large" => InstanceType::X2gdLarge,
            "x2gd.medium" => InstanceType::X2gdMedium,
            "x2gd.metal" => InstanceType::X2gdMetal,
            "x2gd.xlarge" => InstanceType::X2gdXlarge,
            "z1d.12xlarge" => InstanceType::Z1d12xlarge,
            "z1d.2xlarge" => InstanceType::Z1d2xlarge,
            "z1d.3xlarge" => InstanceType::Z1d3xlarge,
            "z1d.6xlarge" => InstanceType::Z1d6xlarge,
            "z1d.large" => InstanceType::Z1dLarge,
            "z1d.metal" => InstanceType::Z1dMetal,
            "z1d.xlarge" => InstanceType::Z1dXlarge,
            other => InstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceType::from(s))
    }
}
impl InstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceType::A12xlarge => "a1.2xlarge",
            InstanceType::A14xlarge => "a1.4xlarge",
            InstanceType::A1Large => "a1.large",
            InstanceType::A1Medium => "a1.medium",
            InstanceType::A1Metal => "a1.metal",
            InstanceType::A1Xlarge => "a1.xlarge",
            InstanceType::C1Medium => "c1.medium",
            InstanceType::C1Xlarge => "c1.xlarge",
            InstanceType::C32xlarge => "c3.2xlarge",
            InstanceType::C34xlarge => "c3.4xlarge",
            InstanceType::C38xlarge => "c3.8xlarge",
            InstanceType::C3Large => "c3.large",
            InstanceType::C3Xlarge => "c3.xlarge",
            InstanceType::C42xlarge => "c4.2xlarge",
            InstanceType::C44xlarge => "c4.4xlarge",
            InstanceType::C48xlarge => "c4.8xlarge",
            InstanceType::C4Large => "c4.large",
            InstanceType::C4Xlarge => "c4.xlarge",
            InstanceType::C512xlarge => "c5.12xlarge",
            InstanceType::C518xlarge => "c5.18xlarge",
            InstanceType::C524xlarge => "c5.24xlarge",
            InstanceType::C52xlarge => "c5.2xlarge",
            InstanceType::C54xlarge => "c5.4xlarge",
            InstanceType::C59xlarge => "c5.9xlarge",
            InstanceType::C5Large => "c5.large",
            InstanceType::C5Metal => "c5.metal",
            InstanceType::C5Xlarge => "c5.xlarge",
            InstanceType::C5a12xlarge => "c5a.12xlarge",
            InstanceType::C5a16xlarge => "c5a.16xlarge",
            InstanceType::C5a24xlarge => "c5a.24xlarge",
            InstanceType::C5a2xlarge => "c5a.2xlarge",
            InstanceType::C5a4xlarge => "c5a.4xlarge",
            InstanceType::C5a8xlarge => "c5a.8xlarge",
            InstanceType::C5aLarge => "c5a.large",
            InstanceType::C5aXlarge => "c5a.xlarge",
            InstanceType::C5ad12xlarge => "c5ad.12xlarge",
            InstanceType::C5ad16xlarge => "c5ad.16xlarge",
            InstanceType::C5ad24xlarge => "c5ad.24xlarge",
            InstanceType::C5ad2xlarge => "c5ad.2xlarge",
            InstanceType::C5ad4xlarge => "c5ad.4xlarge",
            InstanceType::C5ad8xlarge => "c5ad.8xlarge",
            InstanceType::C5adLarge => "c5ad.large",
            InstanceType::C5adXlarge => "c5ad.xlarge",
            InstanceType::C5d12xlarge => "c5d.12xlarge",
            InstanceType::C5d18xlarge => "c5d.18xlarge",
            InstanceType::C5d24xlarge => "c5d.24xlarge",
            InstanceType::C5d2xlarge => "c5d.2xlarge",
            InstanceType::C5d4xlarge => "c5d.4xlarge",
            InstanceType::C5d9xlarge => "c5d.9xlarge",
            InstanceType::C5dLarge => "c5d.large",
            InstanceType::C5dMetal => "c5d.metal",
            InstanceType::C5dXlarge => "c5d.xlarge",
            InstanceType::C5n18xlarge => "c5n.18xlarge",
            InstanceType::C5n2xlarge => "c5n.2xlarge",
            InstanceType::C5n4xlarge => "c5n.4xlarge",
            InstanceType::C5n9xlarge => "c5n.9xlarge",
            InstanceType::C5nLarge => "c5n.large",
            InstanceType::C5nMetal => "c5n.metal",
            InstanceType::C5nXlarge => "c5n.xlarge",
            InstanceType::C6g12xlarge => "c6g.12xlarge",
            InstanceType::C6g16xlarge => "c6g.16xlarge",
            InstanceType::C6g2xlarge => "c6g.2xlarge",
            InstanceType::C6g4xlarge => "c6g.4xlarge",
            InstanceType::C6g8xlarge => "c6g.8xlarge",
            InstanceType::C6gLarge => "c6g.large",
            InstanceType::C6gMedium => "c6g.medium",
            InstanceType::C6gMetal => "c6g.metal",
            InstanceType::C6gXlarge => "c6g.xlarge",
            InstanceType::C6gd12xlarge => "c6gd.12xlarge",
            InstanceType::C6gd16xlarge => "c6gd.16xlarge",
            InstanceType::C6gd2xlarge => "c6gd.2xlarge",
            InstanceType::C6gd4xlarge => "c6gd.4xlarge",
            InstanceType::C6gd8xlarge => "c6gd.8xlarge",
            InstanceType::C6gdLarge => "c6gd.large",
            InstanceType::C6gdMedium => "c6gd.medium",
            InstanceType::C6gdMetal => "c6gd.metal",
            InstanceType::C6gdXlarge => "c6gd.xlarge",
            InstanceType::C6gn12xlarge => "c6gn.12xlarge",
            InstanceType::C6gn16xlarge => "c6gn.16xlarge",
            InstanceType::C6gn2xlarge => "c6gn.2xlarge",
            InstanceType::C6gn4xlarge => "c6gn.4xlarge",
            InstanceType::C6gn8xlarge => "c6gn.8xlarge",
            InstanceType::C6gnLarge => "c6gn.large",
            InstanceType::C6gnMedium => "c6gn.medium",
            InstanceType::C6gnXlarge => "c6gn.xlarge",
            InstanceType::Cc14xlarge => "cc1.4xlarge",
            InstanceType::Cc28xlarge => "cc2.8xlarge",
            InstanceType::Cg14xlarge => "cg1.4xlarge",
            InstanceType::Cr18xlarge => "cr1.8xlarge",
            InstanceType::D22xlarge => "d2.2xlarge",
            InstanceType::D24xlarge => "d2.4xlarge",
            InstanceType::D28xlarge => "d2.8xlarge",
            InstanceType::D2Xlarge => "d2.xlarge",
            InstanceType::D32xlarge => "d3.2xlarge",
            InstanceType::D34xlarge => "d3.4xlarge",
            InstanceType::D38xlarge => "d3.8xlarge",
            InstanceType::D3Xlarge => "d3.xlarge",
            InstanceType::D3en12xlarge => "d3en.12xlarge",
            InstanceType::D3en2xlarge => "d3en.2xlarge",
            InstanceType::D3en4xlarge => "d3en.4xlarge",
            InstanceType::D3en6xlarge => "d3en.6xlarge",
            InstanceType::D3en8xlarge => "d3en.8xlarge",
            InstanceType::D3enXlarge => "d3en.xlarge",
            InstanceType::F116xlarge => "f1.16xlarge",
            InstanceType::F12xlarge => "f1.2xlarge",
            InstanceType::F14xlarge => "f1.4xlarge",
            InstanceType::G22xlarge => "g2.2xlarge",
            InstanceType::G28xlarge => "g2.8xlarge",
            InstanceType::G316xlarge => "g3.16xlarge",
            InstanceType::G34xlarge => "g3.4xlarge",
            InstanceType::G38xlarge => "g3.8xlarge",
            InstanceType::G3sXlarge => "g3s.xlarge",
            InstanceType::G4ad16xlarge => "g4ad.16xlarge",
            InstanceType::G4ad2xlarge => "g4ad.2xlarge",
            InstanceType::G4ad4xlarge => "g4ad.4xlarge",
            InstanceType::G4ad8xlarge => "g4ad.8xlarge",
            InstanceType::G4adXlarge => "g4ad.xlarge",
            InstanceType::G4dn12xlarge => "g4dn.12xlarge",
            InstanceType::G4dn16xlarge => "g4dn.16xlarge",
            InstanceType::G4dn2xlarge => "g4dn.2xlarge",
            InstanceType::G4dn4xlarge => "g4dn.4xlarge",
            InstanceType::G4dn8xlarge => "g4dn.8xlarge",
            InstanceType::G4dnMetal => "g4dn.metal",
            InstanceType::G4dnXlarge => "g4dn.xlarge",
            InstanceType::H116xlarge => "h1.16xlarge",
            InstanceType::H12xlarge => "h1.2xlarge",
            InstanceType::H14xlarge => "h1.4xlarge",
            InstanceType::H18xlarge => "h1.8xlarge",
            InstanceType::Hi14xlarge => "hi1.4xlarge",
            InstanceType::Hs18xlarge => "hs1.8xlarge",
            InstanceType::I22xlarge => "i2.2xlarge",
            InstanceType::I24xlarge => "i2.4xlarge",
            InstanceType::I28xlarge => "i2.8xlarge",
            InstanceType::I2Xlarge => "i2.xlarge",
            InstanceType::I316xlarge => "i3.16xlarge",
            InstanceType::I32xlarge => "i3.2xlarge",
            InstanceType::I34xlarge => "i3.4xlarge",
            InstanceType::I38xlarge => "i3.8xlarge",
            InstanceType::I3Large => "i3.large",
            InstanceType::I3Metal => "i3.metal",
            InstanceType::I3Xlarge => "i3.xlarge",
            InstanceType::I3en12xlarge => "i3en.12xlarge",
            InstanceType::I3en24xlarge => "i3en.24xlarge",
            InstanceType::I3en2xlarge => "i3en.2xlarge",
            InstanceType::I3en3xlarge => "i3en.3xlarge",
            InstanceType::I3en6xlarge => "i3en.6xlarge",
            InstanceType::I3enLarge => "i3en.large",
            InstanceType::I3enMetal => "i3en.metal",
            InstanceType::I3enXlarge => "i3en.xlarge",
            InstanceType::Inf124xlarge => "inf1.24xlarge",
            InstanceType::Inf12xlarge => "inf1.2xlarge",
            InstanceType::Inf16xlarge => "inf1.6xlarge",
            InstanceType::Inf1Xlarge => "inf1.xlarge",
            InstanceType::M1Large => "m1.large",
            InstanceType::M1Medium => "m1.medium",
            InstanceType::M1Small => "m1.small",
            InstanceType::M1Xlarge => "m1.xlarge",
            InstanceType::M22xlarge => "m2.2xlarge",
            InstanceType::M24xlarge => "m2.4xlarge",
            InstanceType::M2Xlarge => "m2.xlarge",
            InstanceType::M32xlarge => "m3.2xlarge",
            InstanceType::M3Large => "m3.large",
            InstanceType::M3Medium => "m3.medium",
            InstanceType::M3Xlarge => "m3.xlarge",
            InstanceType::M410xlarge => "m4.10xlarge",
            InstanceType::M416xlarge => "m4.16xlarge",
            InstanceType::M42xlarge => "m4.2xlarge",
            InstanceType::M44xlarge => "m4.4xlarge",
            InstanceType::M4Large => "m4.large",
            InstanceType::M4Xlarge => "m4.xlarge",
            InstanceType::M512xlarge => "m5.12xlarge",
            InstanceType::M516xlarge => "m5.16xlarge",
            InstanceType::M524xlarge => "m5.24xlarge",
            InstanceType::M52xlarge => "m5.2xlarge",
            InstanceType::M54xlarge => "m5.4xlarge",
            InstanceType::M58xlarge => "m5.8xlarge",
            InstanceType::M5Large => "m5.large",
            InstanceType::M5Metal => "m5.metal",
            InstanceType::M5Xlarge => "m5.xlarge",
            InstanceType::M5a12xlarge => "m5a.12xlarge",
            InstanceType::M5a16xlarge => "m5a.16xlarge",
            InstanceType::M5a24xlarge => "m5a.24xlarge",
            InstanceType::M5a2xlarge => "m5a.2xlarge",
            InstanceType::M5a4xlarge => "m5a.4xlarge",
            InstanceType::M5a8xlarge => "m5a.8xlarge",
            InstanceType::M5aLarge => "m5a.large",
            InstanceType::M5aXlarge => "m5a.xlarge",
            InstanceType::M5ad12xlarge => "m5ad.12xlarge",
            InstanceType::M5ad16xlarge => "m5ad.16xlarge",
            InstanceType::M5ad24xlarge => "m5ad.24xlarge",
            InstanceType::M5ad2xlarge => "m5ad.2xlarge",
            InstanceType::M5ad4xlarge => "m5ad.4xlarge",
            InstanceType::M5ad8xlarge => "m5ad.8xlarge",
            InstanceType::M5adLarge => "m5ad.large",
            InstanceType::M5adXlarge => "m5ad.xlarge",
            InstanceType::M5d12xlarge => "m5d.12xlarge",
            InstanceType::M5d16xlarge => "m5d.16xlarge",
            InstanceType::M5d24xlarge => "m5d.24xlarge",
            InstanceType::M5d2xlarge => "m5d.2xlarge",
            InstanceType::M5d4xlarge => "m5d.4xlarge",
            InstanceType::M5d8xlarge => "m5d.8xlarge",
            InstanceType::M5dLarge => "m5d.large",
            InstanceType::M5dMetal => "m5d.metal",
            InstanceType::M5dXlarge => "m5d.xlarge",
            InstanceType::M5dn12xlarge => "m5dn.12xlarge",
            InstanceType::M5dn16xlarge => "m5dn.16xlarge",
            InstanceType::M5dn24xlarge => "m5dn.24xlarge",
            InstanceType::M5dn2xlarge => "m5dn.2xlarge",
            InstanceType::M5dn4xlarge => "m5dn.4xlarge",
            InstanceType::M5dn8xlarge => "m5dn.8xlarge",
            InstanceType::M5dnLarge => "m5dn.large",
            InstanceType::M5dnMetal => "m5dn.metal",
            InstanceType::M5dnXlarge => "m5dn.xlarge",
            InstanceType::M5n12xlarge => "m5n.12xlarge",
            InstanceType::M5n16xlarge => "m5n.16xlarge",
            InstanceType::M5n24xlarge => "m5n.24xlarge",
            InstanceType::M5n2xlarge => "m5n.2xlarge",
            InstanceType::M5n4xlarge => "m5n.4xlarge",
            InstanceType::M5n8xlarge => "m5n.8xlarge",
            InstanceType::M5nLarge => "m5n.large",
            InstanceType::M5nMetal => "m5n.metal",
            InstanceType::M5nXlarge => "m5n.xlarge",
            InstanceType::M5zn12xlarge => "m5zn.12xlarge",
            InstanceType::M5zn2xlarge => "m5zn.2xlarge",
            InstanceType::M5zn3xlarge => "m5zn.3xlarge",
            InstanceType::M5zn6xlarge => "m5zn.6xlarge",
            InstanceType::M5znLarge => "m5zn.large",
            InstanceType::M5znMetal => "m5zn.metal",
            InstanceType::M5znXlarge => "m5zn.xlarge",
            InstanceType::M6g12xlarge => "m6g.12xlarge",
            InstanceType::M6g16xlarge => "m6g.16xlarge",
            InstanceType::M6g2xlarge => "m6g.2xlarge",
            InstanceType::M6g4xlarge => "m6g.4xlarge",
            InstanceType::M6g8xlarge => "m6g.8xlarge",
            InstanceType::M6gLarge => "m6g.large",
            InstanceType::M6gMedium => "m6g.medium",
            InstanceType::M6gMetal => "m6g.metal",
            InstanceType::M6gXlarge => "m6g.xlarge",
            InstanceType::M6gd12xlarge => "m6gd.12xlarge",
            InstanceType::M6gd16xlarge => "m6gd.16xlarge",
            InstanceType::M6gd2xlarge => "m6gd.2xlarge",
            InstanceType::M6gd4xlarge => "m6gd.4xlarge",
            InstanceType::M6gd8xlarge => "m6gd.8xlarge",
            InstanceType::M6gdLarge => "m6gd.large",
            InstanceType::M6gdMedium => "m6gd.medium",
            InstanceType::M6gdMetal => "m6gd.metal",
            InstanceType::M6gdXlarge => "m6gd.xlarge",
            InstanceType::M6i12xlarge => "m6i.12xlarge",
            InstanceType::M6i16xlarge => "m6i.16xlarge",
            InstanceType::M6i24xlarge => "m6i.24xlarge",
            InstanceType::M6i2xlarge => "m6i.2xlarge",
            InstanceType::M6i32xlarge => "m6i.32xlarge",
            InstanceType::M6i4xlarge => "m6i.4xlarge",
            InstanceType::M6i8xlarge => "m6i.8xlarge",
            InstanceType::M6iLarge => "m6i.large",
            InstanceType::M6iXlarge => "m6i.xlarge",
            InstanceType::Mac1Metal => "mac1.metal",
            InstanceType::P216xlarge => "p2.16xlarge",
            InstanceType::P28xlarge => "p2.8xlarge",
            InstanceType::P2Xlarge => "p2.xlarge",
            InstanceType::P316xlarge => "p3.16xlarge",
            InstanceType::P32xlarge => "p3.2xlarge",
            InstanceType::P38xlarge => "p3.8xlarge",
            InstanceType::P3dn24xlarge => "p3dn.24xlarge",
            InstanceType::P4d24xlarge => "p4d.24xlarge",
            InstanceType::R32xlarge => "r3.2xlarge",
            InstanceType::R34xlarge => "r3.4xlarge",
            InstanceType::R38xlarge => "r3.8xlarge",
            InstanceType::R3Large => "r3.large",
            InstanceType::R3Xlarge => "r3.xlarge",
            InstanceType::R416xlarge => "r4.16xlarge",
            InstanceType::R42xlarge => "r4.2xlarge",
            InstanceType::R44xlarge => "r4.4xlarge",
            InstanceType::R48xlarge => "r4.8xlarge",
            InstanceType::R4Large => "r4.large",
            InstanceType::R4Xlarge => "r4.xlarge",
            InstanceType::R512xlarge => "r5.12xlarge",
            InstanceType::R516xlarge => "r5.16xlarge",
            InstanceType::R524xlarge => "r5.24xlarge",
            InstanceType::R52xlarge => "r5.2xlarge",
            InstanceType::R54xlarge => "r5.4xlarge",
            InstanceType::R58xlarge => "r5.8xlarge",
            InstanceType::R5Large => "r5.large",
            InstanceType::R5Metal => "r5.metal",
            InstanceType::R5Xlarge => "r5.xlarge",
            InstanceType::R5a12xlarge => "r5a.12xlarge",
            InstanceType::R5a16xlarge => "r5a.16xlarge",
            InstanceType::R5a24xlarge => "r5a.24xlarge",
            InstanceType::R5a2xlarge => "r5a.2xlarge",
            InstanceType::R5a4xlarge => "r5a.4xlarge",
            InstanceType::R5a8xlarge => "r5a.8xlarge",
            InstanceType::R5aLarge => "r5a.large",
            InstanceType::R5aXlarge => "r5a.xlarge",
            InstanceType::R5ad12xlarge => "r5ad.12xlarge",
            InstanceType::R5ad16xlarge => "r5ad.16xlarge",
            InstanceType::R5ad24xlarge => "r5ad.24xlarge",
            InstanceType::R5ad2xlarge => "r5ad.2xlarge",
            InstanceType::R5ad4xlarge => "r5ad.4xlarge",
            InstanceType::R5ad8xlarge => "r5ad.8xlarge",
            InstanceType::R5adLarge => "r5ad.large",
            InstanceType::R5adXlarge => "r5ad.xlarge",
            InstanceType::R5b12xlarge => "r5b.12xlarge",
            InstanceType::R5b16xlarge => "r5b.16xlarge",
            InstanceType::R5b24xlarge => "r5b.24xlarge",
            InstanceType::R5b2xlarge => "r5b.2xlarge",
            InstanceType::R5b4xlarge => "r5b.4xlarge",
            InstanceType::R5b8xlarge => "r5b.8xlarge",
            InstanceType::R5bLarge => "r5b.large",
            InstanceType::R5bMetal => "r5b.metal",
            InstanceType::R5bXlarge => "r5b.xlarge",
            InstanceType::R5d12xlarge => "r5d.12xlarge",
            InstanceType::R5d16xlarge => "r5d.16xlarge",
            InstanceType::R5d24xlarge => "r5d.24xlarge",
            InstanceType::R5d2xlarge => "r5d.2xlarge",
            InstanceType::R5d4xlarge => "r5d.4xlarge",
            InstanceType::R5d8xlarge => "r5d.8xlarge",
            InstanceType::R5dLarge => "r5d.large",
            InstanceType::R5dMetal => "r5d.metal",
            InstanceType::R5dXlarge => "r5d.xlarge",
            InstanceType::R5dn12xlarge => "r5dn.12xlarge",
            InstanceType::R5dn16xlarge => "r5dn.16xlarge",
            InstanceType::R5dn24xlarge => "r5dn.24xlarge",
            InstanceType::R5dn2xlarge => "r5dn.2xlarge",
            InstanceType::R5dn4xlarge => "r5dn.4xlarge",
            InstanceType::R5dn8xlarge => "r5dn.8xlarge",
            InstanceType::R5dnLarge => "r5dn.large",
            InstanceType::R5dnMetal => "r5dn.metal",
            InstanceType::R5dnXlarge => "r5dn.xlarge",
            InstanceType::R5n12xlarge => "r5n.12xlarge",
            InstanceType::R5n16xlarge => "r5n.16xlarge",
            InstanceType::R5n24xlarge => "r5n.24xlarge",
            InstanceType::R5n2xlarge => "r5n.2xlarge",
            InstanceType::R5n4xlarge => "r5n.4xlarge",
            InstanceType::R5n8xlarge => "r5n.8xlarge",
            InstanceType::R5nLarge => "r5n.large",
            InstanceType::R5nMetal => "r5n.metal",
            InstanceType::R5nXlarge => "r5n.xlarge",
            InstanceType::R6g12xlarge => "r6g.12xlarge",
            InstanceType::R6g16xlarge => "r6g.16xlarge",
            InstanceType::R6g2xlarge => "r6g.2xlarge",
            InstanceType::R6g4xlarge => "r6g.4xlarge",
            InstanceType::R6g8xlarge => "r6g.8xlarge",
            InstanceType::R6gLarge => "r6g.large",
            InstanceType::R6gMedium => "r6g.medium",
            InstanceType::R6gMetal => "r6g.metal",
            InstanceType::R6gXlarge => "r6g.xlarge",
            InstanceType::R6gd12xlarge => "r6gd.12xlarge",
            InstanceType::R6gd16xlarge => "r6gd.16xlarge",
            InstanceType::R6gd2xlarge => "r6gd.2xlarge",
            InstanceType::R6gd4xlarge => "r6gd.4xlarge",
            InstanceType::R6gd8xlarge => "r6gd.8xlarge",
            InstanceType::R6gdLarge => "r6gd.large",
            InstanceType::R6gdMedium => "r6gd.medium",
            InstanceType::R6gdMetal => "r6gd.metal",
            InstanceType::R6gdXlarge => "r6gd.xlarge",
            InstanceType::T1Micro => "t1.micro",
            InstanceType::T22xlarge => "t2.2xlarge",
            InstanceType::T2Large => "t2.large",
            InstanceType::T2Medium => "t2.medium",
            InstanceType::T2Micro => "t2.micro",
            InstanceType::T2Nano => "t2.nano",
            InstanceType::T2Small => "t2.small",
            InstanceType::T2Xlarge => "t2.xlarge",
            InstanceType::T32xlarge => "t3.2xlarge",
            InstanceType::T3Large => "t3.large",
            InstanceType::T3Medium => "t3.medium",
            InstanceType::T3Micro => "t3.micro",
            InstanceType::T3Nano => "t3.nano",
            InstanceType::T3Small => "t3.small",
            InstanceType::T3Xlarge => "t3.xlarge",
            InstanceType::T3a2xlarge => "t3a.2xlarge",
            InstanceType::T3aLarge => "t3a.large",
            InstanceType::T3aMedium => "t3a.medium",
            InstanceType::T3aMicro => "t3a.micro",
            InstanceType::T3aNano => "t3a.nano",
            InstanceType::T3aSmall => "t3a.small",
            InstanceType::T3aXlarge => "t3a.xlarge",
            InstanceType::T4g2xlarge => "t4g.2xlarge",
            InstanceType::T4gLarge => "t4g.large",
            InstanceType::T4gMedium => "t4g.medium",
            InstanceType::T4gMicro => "t4g.micro",
            InstanceType::T4gNano => "t4g.nano",
            InstanceType::T4gSmall => "t4g.small",
            InstanceType::T4gXlarge => "t4g.xlarge",
            InstanceType::U12tb1112xlarge => "u-12tb1.112xlarge",
            InstanceType::U12tb1Metal => "u-12tb1.metal",
            InstanceType::U18tb1Metal => "u-18tb1.metal",
            InstanceType::U24tb1Metal => "u-24tb1.metal",
            InstanceType::U6tb1112xlarge => "u-6tb1.112xlarge",
            InstanceType::U6tb156xlarge => "u-6tb1.56xlarge",
            InstanceType::U6tb1Metal => "u-6tb1.metal",
            InstanceType::U9tb1112xlarge => "u-9tb1.112xlarge",
            InstanceType::U9tb1Metal => "u-9tb1.metal",
            InstanceType::X116xlarge => "x1.16xlarge",
            InstanceType::X132xlarge => "x1.32xlarge",
            InstanceType::X1e16xlarge => "x1e.16xlarge",
            InstanceType::X1e2xlarge => "x1e.2xlarge",
            InstanceType::X1e32xlarge => "x1e.32xlarge",
            InstanceType::X1e4xlarge => "x1e.4xlarge",
            InstanceType::X1e8xlarge => "x1e.8xlarge",
            InstanceType::X1eXlarge => "x1e.xlarge",
            InstanceType::X2gd12xlarge => "x2gd.12xlarge",
            InstanceType::X2gd16xlarge => "x2gd.16xlarge",
            InstanceType::X2gd2xlarge => "x2gd.2xlarge",
            InstanceType::X2gd4xlarge => "x2gd.4xlarge",
            InstanceType::X2gd8xlarge => "x2gd.8xlarge",
            InstanceType::X2gdLarge => "x2gd.large",
            InstanceType::X2gdMedium => "x2gd.medium",
            InstanceType::X2gdMetal => "x2gd.metal",
            InstanceType::X2gdXlarge => "x2gd.xlarge",
            InstanceType::Z1d12xlarge => "z1d.12xlarge",
            InstanceType::Z1d2xlarge => "z1d.2xlarge",
            InstanceType::Z1d3xlarge => "z1d.3xlarge",
            InstanceType::Z1d6xlarge => "z1d.6xlarge",
            InstanceType::Z1dLarge => "z1d.large",
            InstanceType::Z1dMetal => "z1d.metal",
            InstanceType::Z1dXlarge => "z1d.xlarge",
            InstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "a1.2xlarge",
            "a1.4xlarge",
            "a1.large",
            "a1.medium",
            "a1.metal",
            "a1.xlarge",
            "c1.medium",
            "c1.xlarge",
            "c3.2xlarge",
            "c3.4xlarge",
            "c3.8xlarge",
            "c3.large",
            "c3.xlarge",
            "c4.2xlarge",
            "c4.4xlarge",
            "c4.8xlarge",
            "c4.large",
            "c4.xlarge",
            "c5.12xlarge",
            "c5.18xlarge",
            "c5.24xlarge",
            "c5.2xlarge",
            "c5.4xlarge",
            "c5.9xlarge",
            "c5.large",
            "c5.metal",
            "c5.xlarge",
            "c5a.12xlarge",
            "c5a.16xlarge",
            "c5a.24xlarge",
            "c5a.2xlarge",
            "c5a.4xlarge",
            "c5a.8xlarge",
            "c5a.large",
            "c5a.xlarge",
            "c5ad.12xlarge",
            "c5ad.16xlarge",
            "c5ad.24xlarge",
            "c5ad.2xlarge",
            "c5ad.4xlarge",
            "c5ad.8xlarge",
            "c5ad.large",
            "c5ad.xlarge",
            "c5d.12xlarge",
            "c5d.18xlarge",
            "c5d.24xlarge",
            "c5d.2xlarge",
            "c5d.4xlarge",
            "c5d.9xlarge",
            "c5d.large",
            "c5d.metal",
            "c5d.xlarge",
            "c5n.18xlarge",
            "c5n.2xlarge",
            "c5n.4xlarge",
            "c5n.9xlarge",
            "c5n.large",
            "c5n.metal",
            "c5n.xlarge",
            "c6g.12xlarge",
            "c6g.16xlarge",
            "c6g.2xlarge",
            "c6g.4xlarge",
            "c6g.8xlarge",
            "c6g.large",
            "c6g.medium",
            "c6g.metal",
            "c6g.xlarge",
            "c6gd.12xlarge",
            "c6gd.16xlarge",
            "c6gd.2xlarge",
            "c6gd.4xlarge",
            "c6gd.8xlarge",
            "c6gd.large",
            "c6gd.medium",
            "c6gd.metal",
            "c6gd.xlarge",
            "c6gn.12xlarge",
            "c6gn.16xlarge",
            "c6gn.2xlarge",
            "c6gn.4xlarge",
            "c6gn.8xlarge",
            "c6gn.large",
            "c6gn.medium",
            "c6gn.xlarge",
            "cc1.4xlarge",
            "cc2.8xlarge",
            "cg1.4xlarge",
            "cr1.8xlarge",
            "d2.2xlarge",
            "d2.4xlarge",
            "d2.8xlarge",
            "d2.xlarge",
            "d3.2xlarge",
            "d3.4xlarge",
            "d3.8xlarge",
            "d3.xlarge",
            "d3en.12xlarge",
            "d3en.2xlarge",
            "d3en.4xlarge",
            "d3en.6xlarge",
            "d3en.8xlarge",
            "d3en.xlarge",
            "f1.16xlarge",
            "f1.2xlarge",
            "f1.4xlarge",
            "g2.2xlarge",
            "g2.8xlarge",
            "g3.16xlarge",
            "g3.4xlarge",
            "g3.8xlarge",
            "g3s.xlarge",
            "g4ad.16xlarge",
            "g4ad.2xlarge",
            "g4ad.4xlarge",
            "g4ad.8xlarge",
            "g4ad.xlarge",
            "g4dn.12xlarge",
            "g4dn.16xlarge",
            "g4dn.2xlarge",
            "g4dn.4xlarge",
            "g4dn.8xlarge",
            "g4dn.metal",
            "g4dn.xlarge",
            "h1.16xlarge",
            "h1.2xlarge",
            "h1.4xlarge",
            "h1.8xlarge",
            "hi1.4xlarge",
            "hs1.8xlarge",
            "i2.2xlarge",
            "i2.4xlarge",
            "i2.8xlarge",
            "i2.xlarge",
            "i3.16xlarge",
            "i3.2xlarge",
            "i3.4xlarge",
            "i3.8xlarge",
            "i3.large",
            "i3.metal",
            "i3.xlarge",
            "i3en.12xlarge",
            "i3en.24xlarge",
            "i3en.2xlarge",
            "i3en.3xlarge",
            "i3en.6xlarge",
            "i3en.large",
            "i3en.metal",
            "i3en.xlarge",
            "inf1.24xlarge",
            "inf1.2xlarge",
            "inf1.6xlarge",
            "inf1.xlarge",
            "m1.large",
            "m1.medium",
            "m1.small",
            "m1.xlarge",
            "m2.2xlarge",
            "m2.4xlarge",
            "m2.xlarge",
            "m3.2xlarge",
            "m3.large",
            "m3.medium",
            "m3.xlarge",
            "m4.10xlarge",
            "m4.16xlarge",
            "m4.2xlarge",
            "m4.4xlarge",
            "m4.large",
            "m4.xlarge",
            "m5.12xlarge",
            "m5.16xlarge",
            "m5.24xlarge",
            "m5.2xlarge",
            "m5.4xlarge",
            "m5.8xlarge",
            "m5.large",
            "m5.metal",
            "m5.xlarge",
            "m5a.12xlarge",
            "m5a.16xlarge",
            "m5a.24xlarge",
            "m5a.2xlarge",
            "m5a.4xlarge",
            "m5a.8xlarge",
            "m5a.large",
            "m5a.xlarge",
            "m5ad.12xlarge",
            "m5ad.16xlarge",
            "m5ad.24xlarge",
            "m5ad.2xlarge",
            "m5ad.4xlarge",
            "m5ad.8xlarge",
            "m5ad.large",
            "m5ad.xlarge",
            "m5d.12xlarge",
            "m5d.16xlarge",
            "m5d.24xlarge",
            "m5d.2xlarge",
            "m5d.4xlarge",
            "m5d.8xlarge",
            "m5d.large",
            "m5d.metal",
            "m5d.xlarge",
            "m5dn.12xlarge",
            "m5dn.16xlarge",
            "m5dn.24xlarge",
            "m5dn.2xlarge",
            "m5dn.4xlarge",
            "m5dn.8xlarge",
            "m5dn.large",
            "m5dn.metal",
            "m5dn.xlarge",
            "m5n.12xlarge",
            "m5n.16xlarge",
            "m5n.24xlarge",
            "m5n.2xlarge",
            "m5n.4xlarge",
            "m5n.8xlarge",
            "m5n.large",
            "m5n.metal",
            "m5n.xlarge",
            "m5zn.12xlarge",
            "m5zn.2xlarge",
            "m5zn.3xlarge",
            "m5zn.6xlarge",
            "m5zn.large",
            "m5zn.metal",
            "m5zn.xlarge",
            "m6g.12xlarge",
            "m6g.16xlarge",
            "m6g.2xlarge",
            "m6g.4xlarge",
            "m6g.8xlarge",
            "m6g.large",
            "m6g.medium",
            "m6g.metal",
            "m6g.xlarge",
            "m6gd.12xlarge",
            "m6gd.16xlarge",
            "m6gd.2xlarge",
            "m6gd.4xlarge",
            "m6gd.8xlarge",
            "m6gd.large",
            "m6gd.medium",
            "m6gd.metal",
            "m6gd.xlarge",
            "m6i.12xlarge",
            "m6i.16xlarge",
            "m6i.24xlarge",
            "m6i.2xlarge",
            "m6i.32xlarge",
            "m6i.4xlarge",
            "m6i.8xlarge",
            "m6i.large",
            "m6i.xlarge",
            "mac1.metal",
            "p2.16xlarge",
            "p2.8xlarge",
            "p2.xlarge",
            "p3.16xlarge",
            "p3.2xlarge",
            "p3.8xlarge",
            "p3dn.24xlarge",
            "p4d.24xlarge",
            "r3.2xlarge",
            "r3.4xlarge",
            "r3.8xlarge",
            "r3.large",
            "r3.xlarge",
            "r4.16xlarge",
            "r4.2xlarge",
            "r4.4xlarge",
            "r4.8xlarge",
            "r4.large",
            "r4.xlarge",
            "r5.12xlarge",
            "r5.16xlarge",
            "r5.24xlarge",
            "r5.2xlarge",
            "r5.4xlarge",
            "r5.8xlarge",
            "r5.large",
            "r5.metal",
            "r5.xlarge",
            "r5a.12xlarge",
            "r5a.16xlarge",
            "r5a.24xlarge",
            "r5a.2xlarge",
            "r5a.4xlarge",
            "r5a.8xlarge",
            "r5a.large",
            "r5a.xlarge",
            "r5ad.12xlarge",
            "r5ad.16xlarge",
            "r5ad.24xlarge",
            "r5ad.2xlarge",
            "r5ad.4xlarge",
            "r5ad.8xlarge",
            "r5ad.large",
            "r5ad.xlarge",
            "r5b.12xlarge",
            "r5b.16xlarge",
            "r5b.24xlarge",
            "r5b.2xlarge",
            "r5b.4xlarge",
            "r5b.8xlarge",
            "r5b.large",
            "r5b.metal",
            "r5b.xlarge",
            "r5d.12xlarge",
            "r5d.16xlarge",
            "r5d.24xlarge",
            "r5d.2xlarge",
            "r5d.4xlarge",
            "r5d.8xlarge",
            "r5d.large",
            "r5d.metal",
            "r5d.xlarge",
            "r5dn.12xlarge",
            "r5dn.16xlarge",
            "r5dn.24xlarge",
            "r5dn.2xlarge",
            "r5dn.4xlarge",
            "r5dn.8xlarge",
            "r5dn.large",
            "r5dn.metal",
            "r5dn.xlarge",
            "r5n.12xlarge",
            "r5n.16xlarge",
            "r5n.24xlarge",
            "r5n.2xlarge",
            "r5n.4xlarge",
            "r5n.8xlarge",
            "r5n.large",
            "r5n.metal",
            "r5n.xlarge",
            "r6g.12xlarge",
            "r6g.16xlarge",
            "r6g.2xlarge",
            "r6g.4xlarge",
            "r6g.8xlarge",
            "r6g.large",
            "r6g.medium",
            "r6g.metal",
            "r6g.xlarge",
            "r6gd.12xlarge",
            "r6gd.16xlarge",
            "r6gd.2xlarge",
            "r6gd.4xlarge",
            "r6gd.8xlarge",
            "r6gd.large",
            "r6gd.medium",
            "r6gd.metal",
            "r6gd.xlarge",
            "t1.micro",
            "t2.2xlarge",
            "t2.large",
            "t2.medium",
            "t2.micro",
            "t2.nano",
            "t2.small",
            "t2.xlarge",
            "t3.2xlarge",
            "t3.large",
            "t3.medium",
            "t3.micro",
            "t3.nano",
            "t3.small",
            "t3.xlarge",
            "t3a.2xlarge",
            "t3a.large",
            "t3a.medium",
            "t3a.micro",
            "t3a.nano",
            "t3a.small",
            "t3a.xlarge",
            "t4g.2xlarge",
            "t4g.large",
            "t4g.medium",
            "t4g.micro",
            "t4g.nano",
            "t4g.small",
            "t4g.xlarge",
            "u-12tb1.112xlarge",
            "u-12tb1.metal",
            "u-18tb1.metal",
            "u-24tb1.metal",
            "u-6tb1.112xlarge",
            "u-6tb1.56xlarge",
            "u-6tb1.metal",
            "u-9tb1.112xlarge",
            "u-9tb1.metal",
            "x1.16xlarge",
            "x1.32xlarge",
            "x1e.16xlarge",
            "x1e.2xlarge",
            "x1e.32xlarge",
            "x1e.4xlarge",
            "x1e.8xlarge",
            "x1e.xlarge",
            "x2gd.12xlarge",
            "x2gd.16xlarge",
            "x2gd.2xlarge",
            "x2gd.4xlarge",
            "x2gd.8xlarge",
            "x2gd.large",
            "x2gd.medium",
            "x2gd.metal",
            "x2gd.xlarge",
            "z1d.12xlarge",
            "z1d.2xlarge",
            "z1d.3xlarge",
            "z1d.6xlarge",
            "z1d.large",
            "z1d.metal",
            "z1d.xlarge",
        ]
    }
}
impl AsRef<str> for InstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information,
/// see <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html">
/// What is Amazon Web Services Nitro Enclaves?</a> in the <i>Amazon Web Services Nitro Enclaves User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnclaveOptionsRequest {
    /// <p>To enable the instance for Amazon Web Services Nitro Enclaves, set this parameter to <code>true</code>.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for EnclaveOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnclaveOptionsRequest");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`EnclaveOptionsRequest`](crate::model::EnclaveOptionsRequest)
pub mod enclave_options_request {
    /// A builder for [`EnclaveOptionsRequest`](crate::model::EnclaveOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>To enable the instance for Amazon Web Services Nitro Enclaves, set this parameter to <code>true</code>.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`EnclaveOptionsRequest`](crate::model::EnclaveOptionsRequest)
        pub fn build(self) -> crate::model::EnclaveOptionsRequest {
            crate::model::EnclaveOptionsRequest {
                enabled: self.enabled,
            }
        }
    }
}
impl EnclaveOptionsRequest {
    /// Creates a new builder-style object to manufacture [`EnclaveOptionsRequest`](crate::model::EnclaveOptionsRequest)
    pub fn builder() -> crate::model::enclave_options_request::Builder {
        crate::model::enclave_options_request::Builder::default()
    }
}

/// <p>The metadata options for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMetadataOptionsRequest {
    /// <p>The state of token usage for your instance metadata requests. If the parameter is not
    /// specified in the request, the default state is <code>optional</code>.</p>
    /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
    /// with or without a signed token header on your request. If you retrieve the IAM role
    /// credentials without a token, the version 1.0 role credentials are returned. If you
    /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
    /// credentials are returned.</p>
    /// <p>If the state is <code>required</code>, you must send a signed token header with any
    /// instance metadata retrieval requests. In this state, retrieving the IAM role credentials
    /// always returns the version 2.0 credentials; the version 1.0 credentials are not
    /// available.</p>
    pub http_tokens: std::option::Option<crate::model::HttpTokensState>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
    /// number, the further instance metadata requests can travel.</p>
    /// <p>Default: 1</p>
    /// <p>Possible values: Integers from 1 to 64</p>
    pub http_put_response_hop_limit: std::option::Option<i32>,
    /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
    /// the parameter is not specified, the default state is <code>enabled</code>.</p>
    /// <note>
    /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your
    /// instance metadata.</p>
    /// </note>
    pub http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
    /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
    pub http_protocol_ipv6: std::option::Option<crate::model::InstanceMetadataProtocolState>,
}
impl std::fmt::Debug for InstanceMetadataOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMetadataOptionsRequest");
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field("http_protocol_ipv6", &self.http_protocol_ipv6);
        formatter.finish()
    }
}
/// See [`InstanceMetadataOptionsRequest`](crate::model::InstanceMetadataOptionsRequest)
pub mod instance_metadata_options_request {
    /// A builder for [`InstanceMetadataOptionsRequest`](crate::model::InstanceMetadataOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_tokens: std::option::Option<crate::model::HttpTokensState>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        pub(crate) http_protocol_ipv6:
            std::option::Option<crate::model::InstanceMetadataProtocolState>,
    }
    impl Builder {
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not
        /// specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
        /// with or without a signed token header on your request. If you retrieve the IAM role
        /// credentials without a token, the version 1.0 role credentials are returned. If you
        /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
        /// credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any
        /// instance metadata retrieval requests. In this state, retrieving the IAM role credentials
        /// always returns the version 2.0 credentials; the version 1.0 credentials are not
        /// available.</p>
        pub fn http_tokens(mut self, input: crate::model::HttpTokensState) -> Self {
            self.http_tokens = Some(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::HttpTokensState>,
        ) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
        /// number, the further instance metadata requests can travel.</p>
        /// <p>Default: 1</p>
        /// <p>Possible values: Integers from 1 to 64</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
        /// the parameter is not specified, the default state is <code>enabled</code>.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your
        /// instance metadata.</p>
        /// </note>
        pub fn http_endpoint(mut self, input: crate::model::InstanceMetadataEndpointState) -> Self {
            self.http_endpoint = Some(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
        pub fn http_protocol_ipv6(
            mut self,
            input: crate::model::InstanceMetadataProtocolState,
        ) -> Self {
            self.http_protocol_ipv6 = Some(input);
            self
        }
        pub fn set_http_protocol_ipv6(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataProtocolState>,
        ) -> Self {
            self.http_protocol_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMetadataOptionsRequest`](crate::model::InstanceMetadataOptionsRequest)
        pub fn build(self) -> crate::model::InstanceMetadataOptionsRequest {
            crate::model::InstanceMetadataOptionsRequest {
                http_tokens: self.http_tokens,
                http_put_response_hop_limit: self.http_put_response_hop_limit,
                http_endpoint: self.http_endpoint,
                http_protocol_ipv6: self.http_protocol_ipv6,
            }
        }
    }
}
impl InstanceMetadataOptionsRequest {
    /// Creates a new builder-style object to manufacture [`InstanceMetadataOptionsRequest`](crate::model::InstanceMetadataOptionsRequest)
    pub fn builder() -> crate::model::instance_metadata_options_request::Builder {
        crate::model::instance_metadata_options_request::Builder::default()
    }
}

/// <p>Describes a license configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseConfigurationRequest {
    /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LicenseConfigurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseConfigurationRequest");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`LicenseConfigurationRequest`](crate::model::LicenseConfigurationRequest)
pub mod license_configuration_request {
    /// A builder for [`LicenseConfigurationRequest`](crate::model::LicenseConfigurationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseConfigurationRequest`](crate::model::LicenseConfigurationRequest)
        pub fn build(self) -> crate::model::LicenseConfigurationRequest {
            crate::model::LicenseConfigurationRequest {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl LicenseConfigurationRequest {
    /// Creates a new builder-style object to manufacture [`LicenseConfigurationRequest`](crate::model::LicenseConfigurationRequest)
    pub fn builder() -> crate::model::license_configuration_request::Builder {
        crate::model::license_configuration_request::Builder::default()
    }
}

/// <p>Indicates whether your instance is configured for hibernation. This parameter is valid
/// only if the instance meets the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites">hibernation
/// prerequisites</a>. For
/// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate your instance</a> in the
/// <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HibernationOptionsRequest {
    /// <p>If you set this parameter to <code>true</code>, your instance is enabled for
    /// hibernation.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub configured: std::option::Option<bool>,
}
impl std::fmt::Debug for HibernationOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HibernationOptionsRequest");
        formatter.field("configured", &self.configured);
        formatter.finish()
    }
}
/// See [`HibernationOptionsRequest`](crate::model::HibernationOptionsRequest)
pub mod hibernation_options_request {
    /// A builder for [`HibernationOptionsRequest`](crate::model::HibernationOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If you set this parameter to <code>true</code>, your instance is enabled for
        /// hibernation.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn configured(mut self, input: bool) -> Self {
            self.configured = Some(input);
            self
        }
        pub fn set_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.configured = input;
            self
        }
        /// Consumes the builder and constructs a [`HibernationOptionsRequest`](crate::model::HibernationOptionsRequest)
        pub fn build(self) -> crate::model::HibernationOptionsRequest {
            crate::model::HibernationOptionsRequest {
                configured: self.configured,
            }
        }
    }
}
impl HibernationOptionsRequest {
    /// Creates a new builder-style object to manufacture [`HibernationOptionsRequest`](crate::model::HibernationOptionsRequest)
    pub fn builder() -> crate::model::hibernation_options_request::Builder {
        crate::model::hibernation_options_request::Builder::default()
    }
}

/// <p>Describes an instance's Capacity Reservation targeting option. You can specify only one parameter
/// at a time. If you specify <code>CapacityReservationPreference</code> and
/// <code>CapacityReservationTarget</code>, the request fails.</p>
/// <p>Use the <code>CapacityReservationPreference</code> parameter to configure the instance
/// to run as an On-Demand Instance or to run in any <code>open</code> Capacity Reservation that has
/// matching attributes (instance type, platform, Availability Zone). Use the
/// <code>CapacityReservationTarget</code> parameter to explicitly target a specific
/// Capacity Reservation or a Capacity Reservation group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationSpecification {
    /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
    /// (instance type, platform, Availability Zone).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The
    /// instance runs as an On-Demand Instance.</p>
    /// </li>
    /// </ul>
    pub capacity_reservation_preference:
        std::option::Option<crate::model::CapacityReservationPreference>,
    /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
    pub capacity_reservation_target: std::option::Option<crate::model::CapacityReservationTarget>,
}
impl std::fmt::Debug for CapacityReservationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationSpecification");
        formatter.field(
            "capacity_reservation_preference",
            &self.capacity_reservation_preference,
        );
        formatter.field(
            "capacity_reservation_target",
            &self.capacity_reservation_target,
        );
        formatter.finish()
    }
}
/// See [`CapacityReservationSpecification`](crate::model::CapacityReservationSpecification)
pub mod capacity_reservation_specification {
    /// A builder for [`CapacityReservationSpecification`](crate::model::CapacityReservationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_preference:
            std::option::Option<crate::model::CapacityReservationPreference>,
        pub(crate) capacity_reservation_target:
            std::option::Option<crate::model::CapacityReservationTarget>,
    }
    impl Builder {
        /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
        /// (instance type, platform, Availability Zone).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The
        /// instance runs as an On-Demand Instance.</p>
        /// </li>
        /// </ul>
        pub fn capacity_reservation_preference(
            mut self,
            input: crate::model::CapacityReservationPreference,
        ) -> Self {
            self.capacity_reservation_preference = Some(input);
            self
        }
        pub fn set_capacity_reservation_preference(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationPreference>,
        ) -> Self {
            self.capacity_reservation_preference = input;
            self
        }
        /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
        pub fn capacity_reservation_target(
            mut self,
            input: crate::model::CapacityReservationTarget,
        ) -> Self {
            self.capacity_reservation_target = Some(input);
            self
        }
        pub fn set_capacity_reservation_target(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTarget>,
        ) -> Self {
            self.capacity_reservation_target = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationSpecification`](crate::model::CapacityReservationSpecification)
        pub fn build(self) -> crate::model::CapacityReservationSpecification {
            crate::model::CapacityReservationSpecification {
                capacity_reservation_preference: self.capacity_reservation_preference,
                capacity_reservation_target: self.capacity_reservation_target,
            }
        }
    }
}
impl CapacityReservationSpecification {
    /// Creates a new builder-style object to manufacture [`CapacityReservationSpecification`](crate::model::CapacityReservationSpecification)
    pub fn builder() -> crate::model::capacity_reservation_specification::Builder {
        crate::model::capacity_reservation_specification::Builder::default()
    }
}

/// <p>Describes a target Capacity Reservation or Capacity Reservation group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationTarget {
    /// <p>The ID of the Capacity Reservation in which to run the instance.</p>
    pub capacity_reservation_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the Capacity Reservation resource group in which to run the instance.</p>
    pub capacity_reservation_resource_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CapacityReservationTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationTarget");
        formatter.field("capacity_reservation_id", &self.capacity_reservation_id);
        formatter.field(
            "capacity_reservation_resource_group_arn",
            &self.capacity_reservation_resource_group_arn,
        );
        formatter.finish()
    }
}
/// See [`CapacityReservationTarget`](crate::model::CapacityReservationTarget)
pub mod capacity_reservation_target {
    /// A builder for [`CapacityReservationTarget`](crate::model::CapacityReservationTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_id: std::option::Option<std::string::String>,
        pub(crate) capacity_reservation_resource_group_arn:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Capacity Reservation in which to run the instance.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_reservation_id = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_id = input;
            self
        }
        /// <p>The ARN of the Capacity Reservation resource group in which to run the instance.</p>
        pub fn capacity_reservation_resource_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.capacity_reservation_resource_group_arn = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_resource_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationTarget`](crate::model::CapacityReservationTarget)
        pub fn build(self) -> crate::model::CapacityReservationTarget {
            crate::model::CapacityReservationTarget {
                capacity_reservation_id: self.capacity_reservation_id,
                capacity_reservation_resource_group_arn: self
                    .capacity_reservation_resource_group_arn,
            }
        }
    }
}
impl CapacityReservationTarget {
    /// Creates a new builder-style object to manufacture [`CapacityReservationTarget`](crate::model::CapacityReservationTarget)
    pub fn builder() -> crate::model::capacity_reservation_target::Builder {
        crate::model::capacity_reservation_target::Builder::default()
    }
}

/// <p>The CPU options for the instance. Both the core count and threads per core must be
/// specified in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CpuOptionsRequest {
    /// <p>The number of CPU cores for the instance.</p>
    pub core_count: std::option::Option<i32>,
    /// <p>The number of threads per CPU core. To disable multithreading for
    /// the instance, specify a value of <code>1</code>. Otherwise, specify the default value of
    /// <code>2</code>.</p>
    pub threads_per_core: std::option::Option<i32>,
}
impl std::fmt::Debug for CpuOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CpuOptionsRequest");
        formatter.field("core_count", &self.core_count);
        formatter.field("threads_per_core", &self.threads_per_core);
        formatter.finish()
    }
}
/// See [`CpuOptionsRequest`](crate::model::CpuOptionsRequest)
pub mod cpu_options_request {
    /// A builder for [`CpuOptionsRequest`](crate::model::CpuOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_count: std::option::Option<i32>,
        pub(crate) threads_per_core: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of CPU cores for the instance.</p>
        pub fn core_count(mut self, input: i32) -> Self {
            self.core_count = Some(input);
            self
        }
        pub fn set_core_count(mut self, input: std::option::Option<i32>) -> Self {
            self.core_count = input;
            self
        }
        /// <p>The number of threads per CPU core. To disable multithreading for
        /// the instance, specify a value of <code>1</code>. Otherwise, specify the default value of
        /// <code>2</code>.</p>
        pub fn threads_per_core(mut self, input: i32) -> Self {
            self.threads_per_core = Some(input);
            self
        }
        pub fn set_threads_per_core(mut self, input: std::option::Option<i32>) -> Self {
            self.threads_per_core = input;
            self
        }
        /// Consumes the builder and constructs a [`CpuOptionsRequest`](crate::model::CpuOptionsRequest)
        pub fn build(self) -> crate::model::CpuOptionsRequest {
            crate::model::CpuOptionsRequest {
                core_count: self.core_count,
                threads_per_core: self.threads_per_core,
            }
        }
    }
}
impl CpuOptionsRequest {
    /// Creates a new builder-style object to manufacture [`CpuOptionsRequest`](crate::model::CpuOptionsRequest)
    pub fn builder() -> crate::model::cpu_options_request::Builder {
        crate::model::cpu_options_request::Builder::default()
    }
}

/// <p>The credit option for CPU usage of a T2, T3, or T3a instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreditSpecificationRequest {
    /// <p>The credit option for CPU usage of a T2, T3, or T3a instance. Valid values are
    /// <code>standard</code> and <code>unlimited</code>.</p>
    pub cpu_credits: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreditSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreditSpecificationRequest");
        formatter.field("cpu_credits", &self.cpu_credits);
        formatter.finish()
    }
}
/// See [`CreditSpecificationRequest`](crate::model::CreditSpecificationRequest)
pub mod credit_specification_request {
    /// A builder for [`CreditSpecificationRequest`](crate::model::CreditSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu_credits: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The credit option for CPU usage of a T2, T3, or T3a instance. Valid values are
        /// <code>standard</code> and <code>unlimited</code>.</p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_credits = Some(input.into());
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu_credits = input;
            self
        }
        /// Consumes the builder and constructs a [`CreditSpecificationRequest`](crate::model::CreditSpecificationRequest)
        pub fn build(self) -> crate::model::CreditSpecificationRequest {
            crate::model::CreditSpecificationRequest {
                cpu_credits: self.cpu_credits,
            }
        }
    }
}
impl CreditSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`CreditSpecificationRequest`](crate::model::CreditSpecificationRequest)
    pub fn builder() -> crate::model::credit_specification_request::Builder {
        crate::model::credit_specification_request::Builder::default()
    }
}

/// <p>Describes the market (purchasing) option for the instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMarketOptionsRequest {
    /// <p>The market type.</p>
    pub market_type: std::option::Option<crate::model::MarketType>,
    /// <p>The options for Spot Instances.</p>
    pub spot_options: std::option::Option<crate::model::SpotMarketOptions>,
}
impl std::fmt::Debug for InstanceMarketOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMarketOptionsRequest");
        formatter.field("market_type", &self.market_type);
        formatter.field("spot_options", &self.spot_options);
        formatter.finish()
    }
}
/// See [`InstanceMarketOptionsRequest`](crate::model::InstanceMarketOptionsRequest)
pub mod instance_market_options_request {
    /// A builder for [`InstanceMarketOptionsRequest`](crate::model::InstanceMarketOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) market_type: std::option::Option<crate::model::MarketType>,
        pub(crate) spot_options: std::option::Option<crate::model::SpotMarketOptions>,
    }
    impl Builder {
        /// <p>The market type.</p>
        pub fn market_type(mut self, input: crate::model::MarketType) -> Self {
            self.market_type = Some(input);
            self
        }
        pub fn set_market_type(
            mut self,
            input: std::option::Option<crate::model::MarketType>,
        ) -> Self {
            self.market_type = input;
            self
        }
        /// <p>The options for Spot Instances.</p>
        pub fn spot_options(mut self, input: crate::model::SpotMarketOptions) -> Self {
            self.spot_options = Some(input);
            self
        }
        pub fn set_spot_options(
            mut self,
            input: std::option::Option<crate::model::SpotMarketOptions>,
        ) -> Self {
            self.spot_options = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMarketOptionsRequest`](crate::model::InstanceMarketOptionsRequest)
        pub fn build(self) -> crate::model::InstanceMarketOptionsRequest {
            crate::model::InstanceMarketOptionsRequest {
                market_type: self.market_type,
                spot_options: self.spot_options,
            }
        }
    }
}
impl InstanceMarketOptionsRequest {
    /// Creates a new builder-style object to manufacture [`InstanceMarketOptionsRequest`](crate::model::InstanceMarketOptionsRequest)
    pub fn builder() -> crate::model::instance_market_options_request::Builder {
        crate::model::instance_market_options_request::Builder::default()
    }
}

/// <p>The options for Spot Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotMarketOptions {
    /// <p>The maximum hourly price you're willing to pay for the Spot Instances. The default is
    /// the On-Demand price.</p>
    pub max_price: std::option::Option<std::string::String>,
    /// <p>The Spot Instance request type. For <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances">RunInstances</a>, persistent Spot
    /// Instance requests are only supported when the instance interruption behavior is either <code>hibernate</code> or
    /// <code>stop</code>.</p>
    pub spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
    /// <p>Deprecated.</p>
    pub block_duration_minutes: std::option::Option<i32>,
    /// <p>The end date of the request, in UTC format
    /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// Supported only for persistent requests.</p>
    /// <ul>
    /// <li>
    /// <p>For a persistent request, the request remains active until the
    /// <code>ValidUntil</code> date and time is reached. Otherwise, the request
    /// remains active until you cancel it.</p>
    /// </li>
    /// <li>
    /// <p>For a one-time request, <code>ValidUntil</code> is not supported. The request
    /// remains active until all instances launch or you cancel the request.</p>
    /// </li>
    /// </ul>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>The behavior when a Spot Instance is interrupted. The default is
    /// <code>terminate</code>.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::InstanceInterruptionBehavior>,
}
impl std::fmt::Debug for SpotMarketOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotMarketOptions");
        formatter.field("max_price", &self.max_price);
        formatter.field("spot_instance_type", &self.spot_instance_type);
        formatter.field("block_duration_minutes", &self.block_duration_minutes);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.finish()
    }
}
/// See [`SpotMarketOptions`](crate::model::SpotMarketOptions)
pub mod spot_market_options {
    /// A builder for [`SpotMarketOptions`](crate::model::SpotMarketOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_price: std::option::Option<std::string::String>,
        pub(crate) spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
        pub(crate) block_duration_minutes: std::option::Option<i32>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::InstanceInterruptionBehavior>,
    }
    impl Builder {
        /// <p>The maximum hourly price you're willing to pay for the Spot Instances. The default is
        /// the On-Demand price.</p>
        pub fn max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_price = Some(input.into());
            self
        }
        pub fn set_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_price = input;
            self
        }
        /// <p>The Spot Instance request type. For <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances">RunInstances</a>, persistent Spot
        /// Instance requests are only supported when the instance interruption behavior is either <code>hibernate</code> or
        /// <code>stop</code>.</p>
        pub fn spot_instance_type(mut self, input: crate::model::SpotInstanceType) -> Self {
            self.spot_instance_type = Some(input);
            self
        }
        pub fn set_spot_instance_type(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceType>,
        ) -> Self {
            self.spot_instance_type = input;
            self
        }
        /// <p>Deprecated.</p>
        pub fn block_duration_minutes(mut self, input: i32) -> Self {
            self.block_duration_minutes = Some(input);
            self
        }
        pub fn set_block_duration_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.block_duration_minutes = input;
            self
        }
        /// <p>The end date of the request, in UTC format
        /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// Supported only for persistent requests.</p>
        /// <ul>
        /// <li>
        /// <p>For a persistent request, the request remains active until the
        /// <code>ValidUntil</code> date and time is reached. Otherwise, the request
        /// remains active until you cancel it.</p>
        /// </li>
        /// <li>
        /// <p>For a one-time request, <code>ValidUntil</code> is not supported. The request
        /// remains active until all instances launch or you cancel the request.</p>
        /// </li>
        /// </ul>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is
        /// <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotMarketOptions`](crate::model::SpotMarketOptions)
        pub fn build(self) -> crate::model::SpotMarketOptions {
            crate::model::SpotMarketOptions {
                max_price: self.max_price,
                spot_instance_type: self.spot_instance_type,
                block_duration_minutes: self.block_duration_minutes,
                valid_until: self.valid_until,
                instance_interruption_behavior: self.instance_interruption_behavior,
            }
        }
    }
}
impl SpotMarketOptions {
    /// Creates a new builder-style object to manufacture [`SpotMarketOptions`](crate::model::SpotMarketOptions)
    pub fn builder() -> crate::model::spot_market_options::Builder {
        crate::model::spot_market_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceInterruptionBehavior {
    Hibernate,
    Stop,
    Terminate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceInterruptionBehavior {
    fn from(s: &str) -> Self {
        match s {
            "hibernate" => InstanceInterruptionBehavior::Hibernate,
            "stop" => InstanceInterruptionBehavior::Stop,
            "terminate" => InstanceInterruptionBehavior::Terminate,
            other => InstanceInterruptionBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceInterruptionBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceInterruptionBehavior::from(s))
    }
}
impl InstanceInterruptionBehavior {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceInterruptionBehavior::Hibernate => "hibernate",
            InstanceInterruptionBehavior::Stop => "stop",
            InstanceInterruptionBehavior::Terminate => "terminate",
            InstanceInterruptionBehavior::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["hibernate", "stop", "terminate"]
    }
}
impl AsRef<str> for InstanceInterruptionBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpotInstanceType {
    OneTime,
    Persistent,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpotInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "one-time" => SpotInstanceType::OneTime,
            "persistent" => SpotInstanceType::Persistent,
            other => SpotInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpotInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpotInstanceType::from(s))
    }
}
impl SpotInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            SpotInstanceType::OneTime => "one-time",
            SpotInstanceType::Persistent => "persistent",
            SpotInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["one-time", "persistent"]
    }
}
impl AsRef<str> for SpotInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MarketType {
    Spot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MarketType {
    fn from(s: &str) -> Self {
        match s {
            "spot" => MarketType::Spot,
            other => MarketType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MarketType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MarketType::from(s))
    }
}
impl MarketType {
    pub fn as_str(&self) -> &str {
        match self {
            MarketType::Spot => "spot",
            MarketType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["spot"]
    }
}
impl AsRef<str> for MarketType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The launch template to use. You must specify either the launch template ID or
/// launch template name in the request, but not both.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateSpecification {
    /// <p>The ID of the launch template.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The version number of the launch template.</p>
    /// <p>Default: The default version for the launch template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateSpecification");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
pub mod launch_template_specification {
    /// A builder for [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the launch template.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The version number of the launch template.</p>
        /// <p>Default: The default version for the launch template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
        pub fn build(self) -> crate::model::LaunchTemplateSpecification {
            crate::model::LaunchTemplateSpecification {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version: self.version,
            }
        }
    }
}
impl LaunchTemplateSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
    pub fn builder() -> crate::model::launch_template_specification::Builder {
        crate::model::launch_template_specification::Builder::default()
    }
}

/// <p>
/// Describes an elastic inference accelerator.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticInferenceAccelerator {
    /// <p>
    /// The type of elastic inference accelerator. The possible values are <code>eia1.medium</code>, <code>eia1.large</code>, <code>eia1.xlarge</code>, <code>eia2.medium</code>, <code>eia2.large</code>, and <code>eia2.xlarge</code>.
    /// </p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>
    /// The number of elastic inference accelerators to attach to the instance.
    /// </p>
    /// <p>Default: 1</p>
    pub count: std::option::Option<i32>,
}
impl std::fmt::Debug for ElasticInferenceAccelerator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticInferenceAccelerator");
        formatter.field("r#type", &self.r#type);
        formatter.field("count", &self.count);
        formatter.finish()
    }
}
/// See [`ElasticInferenceAccelerator`](crate::model::ElasticInferenceAccelerator)
pub mod elastic_inference_accelerator {
    /// A builder for [`ElasticInferenceAccelerator`](crate::model::ElasticInferenceAccelerator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>
        /// The type of elastic inference accelerator. The possible values are <code>eia1.medium</code>, <code>eia1.large</code>, <code>eia1.xlarge</code>, <code>eia2.medium</code>, <code>eia2.large</code>, and <code>eia2.xlarge</code>.
        /// </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>
        /// The number of elastic inference accelerators to attach to the instance.
        /// </p>
        /// <p>Default: 1</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticInferenceAccelerator`](crate::model::ElasticInferenceAccelerator)
        pub fn build(self) -> crate::model::ElasticInferenceAccelerator {
            crate::model::ElasticInferenceAccelerator {
                r#type: self.r#type,
                count: self.count,
            }
        }
    }
}
impl ElasticInferenceAccelerator {
    /// Creates a new builder-style object to manufacture [`ElasticInferenceAccelerator`](crate::model::ElasticInferenceAccelerator)
    pub fn builder() -> crate::model::elastic_inference_accelerator::Builder {
        crate::model::elastic_inference_accelerator::Builder::default()
    }
}

/// <p>A specification for an Elastic Graphics accelerator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticGpuSpecification {
    /// <p>The type of Elastic Graphics accelerator. For more information about the values to specify for
    /// <code>Type</code>, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics">Elastic Graphics Basics</a>, specifically the Elastic Graphics accelerator column, in the <i>Amazon Elastic Compute Cloud User Guide for Windows
    /// Instances</i>.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ElasticGpuSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticGpuSpecification");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ElasticGpuSpecification`](crate::model::ElasticGpuSpecification)
pub mod elastic_gpu_specification {
    /// A builder for [`ElasticGpuSpecification`](crate::model::ElasticGpuSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of Elastic Graphics accelerator. For more information about the values to specify for
        /// <code>Type</code>, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics">Elastic Graphics Basics</a>, specifically the Elastic Graphics accelerator column, in the <i>Amazon Elastic Compute Cloud User Guide for Windows
        /// Instances</i>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticGpuSpecification`](crate::model::ElasticGpuSpecification)
        pub fn build(self) -> crate::model::ElasticGpuSpecification {
            crate::model::ElasticGpuSpecification {
                r#type: self.r#type,
            }
        }
    }
}
impl ElasticGpuSpecification {
    /// Creates a new builder-style object to manufacture [`ElasticGpuSpecification`](crate::model::ElasticGpuSpecification)
    pub fn builder() -> crate::model::elastic_gpu_specification::Builder {
        crate::model::elastic_gpu_specification::Builder::default()
    }
}

/// <p>Describes a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceNetworkInterfaceSpecification {
    /// <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The
    /// public IP address can only be assigned to a network interface for eth0, and can only be
    /// assigned to a new network interface, not an existing one. You cannot specify more than one
    /// network interface in the request. If launching into a default subnet, the default value is
    /// <code>true</code>.</p>
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can
    /// specify <code>true</code> only if creating a new network interface when launching an
    /// instance.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The position of the network interface in the attachment order.
    /// A primary network interface has a device index of 0.</p>
    /// <p>If you specify a network interface when launching an instance,
    /// you must specify the device index.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses
    /// the IPv6 addresses from the range of the subnet. You cannot specify this option and the
    /// option to assign specific IPv6 addresses in the same request. You can specify this
    /// option if you've specified a minimum number of instances to launch.</p>
    pub ipv6_address_count: std::option::Option<i32>,
    /// <p>One or more IPv6 addresses to assign to the network interface. You cannot specify
    /// this option and the option to assign a number of IPv6 addresses in the same request. You
    /// cannot specify this option if you've specified a minimum number of instances to
    /// launch.</p>
    pub ipv6_addresses: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
    /// <p>The ID of the network interface.</p>
    /// <p>If you are creating a Spot Fleet, omit this parameter because you can’t specify a network interface ID in a launch specification.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching
    /// more than one instance in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a> request.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're
    /// launching more than one instance in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a> request.</p>
    pub private_ip_addresses:
        std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
    /// <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're
    /// launching more than one instance in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a> request.</p>
    pub secondary_private_ip_address_count: std::option::Option<i32>,
    /// <p>The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether to assign a carrier IP address to the network interface.</p>
    /// <p>You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone.
    /// For more information about carrier IP addresses, see Carrier IP addresses in the Amazon Web Services Wavelength Developer Guide.</p>
    pub associate_carrier_ip_address: std::option::Option<bool>,
    /// <p>The type of network interface.</p>
    /// <p>To create an Elastic Fabric Adapter (EFA), specify
    /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// <p>Valid values: <code>interface</code> | <code>efa</code>
    /// </p>
    pub interface_type: std::option::Option<std::string::String>,
    /// <p>The index of the network card. Some instance types support multiple network cards.
    /// The primary network interface must be assigned to network card index 0.
    /// The default is network card index 0.</p>
    /// <p>If you are using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">RequestSpotInstances</a> to create Spot Instances, omit this parameter because
    /// you can’t specify the network card index when using this API. To specify the network
    /// card index, use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a>.</p>
    pub network_card_index: std::option::Option<i32>,
    /// <p>One or more IPv4 delegated prefixes to be assigned to the network interface. You cannot
    /// use this option if you use the <code>Ipv4PrefixCount</code> option.</p>
    pub ipv4_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
    /// <p>The number of IPv4 delegated prefixes to be automatically assigned to the network interface.
    /// You cannot use this option if you use the <code>Ipv4Prefix</code> option.</p>
    pub ipv4_prefix_count: std::option::Option<i32>,
    /// <p>One or more IPv6 delegated prefixes to be assigned to the network interface. You cannot
    /// use this option if you use the <code>Ipv6PrefixCount</code> option.</p>
    pub ipv6_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
    /// <p>The number of IPv6 delegated prefixes to be automatically assigned to the network interface.
    /// You cannot use this option if you use the <code>Ipv6Prefix</code> option.</p>
    pub ipv6_prefix_count: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceNetworkInterfaceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceNetworkInterfaceSpecification");
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("description", &self.description);
        formatter.field("device_index", &self.device_index);
        formatter.field("groups", &self.groups);
        formatter.field("ipv6_address_count", &self.ipv6_address_count);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field(
            "secondary_private_ip_address_count",
            &self.secondary_private_ip_address_count,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field(
            "associate_carrier_ip_address",
            &self.associate_carrier_ip_address,
        );
        formatter.field("interface_type", &self.interface_type);
        formatter.field("network_card_index", &self.network_card_index);
        formatter.field("ipv4_prefixes", &self.ipv4_prefixes);
        formatter.field("ipv4_prefix_count", &self.ipv4_prefix_count);
        formatter.field("ipv6_prefixes", &self.ipv6_prefixes);
        formatter.field("ipv6_prefix_count", &self.ipv6_prefix_count);
        formatter.finish()
    }
}
/// See [`InstanceNetworkInterfaceSpecification`](crate::model::InstanceNetworkInterfaceSpecification)
pub mod instance_network_interface_specification {
    /// A builder for [`InstanceNetworkInterfaceSpecification`](crate::model::InstanceNetworkInterfaceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ipv6_address_count: std::option::Option<i32>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        pub(crate) secondary_private_ip_address_count: std::option::Option<i32>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_carrier_ip_address: std::option::Option<bool>,
        pub(crate) interface_type: std::option::Option<std::string::String>,
        pub(crate) network_card_index: std::option::Option<i32>,
        pub(crate) ipv4_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
        pub(crate) ipv4_prefix_count: std::option::Option<i32>,
        pub(crate) ipv6_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
        pub(crate) ipv6_prefix_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The
        /// public IP address can only be assigned to a network interface for eth0, and can only be
        /// assigned to a new network interface, not an existing one. You cannot specify more than one
        /// network interface in the request. If launching into a default subnet, the default value is
        /// <code>true</code>.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can
        /// specify <code>true</code> only if creating a new network interface when launching an
        /// instance.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The position of the network interface in the attachment order.
        /// A primary network interface has a device index of 0.</p>
        /// <p>If you specify a network interface when launching an instance,
        /// you must specify the device index.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses
        /// the IPv6 addresses from the range of the subnet. You cannot specify this option and the
        /// option to assign specific IPv6 addresses in the same request. You can specify this
        /// option if you've specified a minimum number of instances to launch.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.ipv6_address_count = Some(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_address_count = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::InstanceIpv6Address>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        /// <p>If you are creating a Spot Fleet, omit this parameter because you can’t specify a network interface ID in a launch specification.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching
        /// more than one instance in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a> request.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_addresses(
            mut self,
            input: impl Into<crate::model::PrivateIpAddressSpecification>,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.private_ip_addresses = Some(v);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're
        /// launching more than one instance in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a> request.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.secondary_private_ip_address_count = Some(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.secondary_private_ip_address_count = input;
            self
        }
        /// <p>The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>Indicates whether to assign a carrier IP address to the network interface.</p>
        /// <p>You can only assign a carrier IP address to a network interface that is in a subnet in a Wavelength Zone.
        /// For more information about carrier IP addresses, see Carrier IP addresses in the Amazon Web Services Wavelength Developer Guide.</p>
        pub fn associate_carrier_ip_address(mut self, input: bool) -> Self {
            self.associate_carrier_ip_address = Some(input);
            self
        }
        pub fn set_associate_carrier_ip_address(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.associate_carrier_ip_address = input;
            self
        }
        /// <p>The type of network interface.</p>
        /// <p>To create an Elastic Fabric Adapter (EFA), specify
        /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>Valid values: <code>interface</code> | <code>efa</code>
        /// </p>
        pub fn interface_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_type = Some(input.into());
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interface_type = input;
            self
        }
        /// <p>The index of the network card. Some instance types support multiple network cards.
        /// The primary network interface must be assigned to network card index 0.
        /// The default is network card index 0.</p>
        /// <p>If you are using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">RequestSpotInstances</a> to create Spot Instances, omit this parameter because
        /// you can’t specify the network card index when using this API. To specify the network
        /// card index, use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a>.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        pub fn ipv4_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv4PrefixSpecificationRequest>,
        ) -> Self {
            let mut v = self.ipv4_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv4_prefixes = Some(v);
            self
        }
        pub fn set_ipv4_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
        ) -> Self {
            self.ipv4_prefixes = input;
            self
        }
        /// <p>The number of IPv4 delegated prefixes to be automatically assigned to the network interface.
        /// You cannot use this option if you use the <code>Ipv4Prefix</code> option.</p>
        pub fn ipv4_prefix_count(mut self, input: i32) -> Self {
            self.ipv4_prefix_count = Some(input);
            self
        }
        pub fn set_ipv4_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv4_prefix_count = input;
            self
        }
        pub fn ipv6_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv6PrefixSpecificationRequest>,
        ) -> Self {
            let mut v = self.ipv6_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv6_prefixes = Some(v);
            self
        }
        pub fn set_ipv6_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
        ) -> Self {
            self.ipv6_prefixes = input;
            self
        }
        /// <p>The number of IPv6 delegated prefixes to be automatically assigned to the network interface.
        /// You cannot use this option if you use the <code>Ipv6Prefix</code> option.</p>
        pub fn ipv6_prefix_count(mut self, input: i32) -> Self {
            self.ipv6_prefix_count = Some(input);
            self
        }
        pub fn set_ipv6_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_prefix_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNetworkInterfaceSpecification`](crate::model::InstanceNetworkInterfaceSpecification)
        pub fn build(self) -> crate::model::InstanceNetworkInterfaceSpecification {
            crate::model::InstanceNetworkInterfaceSpecification {
                associate_public_ip_address: self.associate_public_ip_address,
                delete_on_termination: self.delete_on_termination,
                description: self.description,
                device_index: self.device_index,
                groups: self.groups,
                ipv6_address_count: self.ipv6_address_count,
                ipv6_addresses: self.ipv6_addresses,
                network_interface_id: self.network_interface_id,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                secondary_private_ip_address_count: self.secondary_private_ip_address_count,
                subnet_id: self.subnet_id,
                associate_carrier_ip_address: self.associate_carrier_ip_address,
                interface_type: self.interface_type,
                network_card_index: self.network_card_index,
                ipv4_prefixes: self.ipv4_prefixes,
                ipv4_prefix_count: self.ipv4_prefix_count,
                ipv6_prefixes: self.ipv6_prefixes,
                ipv6_prefix_count: self.ipv6_prefix_count,
            }
        }
    }
}
impl InstanceNetworkInterfaceSpecification {
    /// Creates a new builder-style object to manufacture [`InstanceNetworkInterfaceSpecification`](crate::model::InstanceNetworkInterfaceSpecification)
    pub fn builder() -> crate::model::instance_network_interface_specification::Builder {
        crate::model::instance_network_interface_specification::Builder::default()
    }
}

/// <p>Describes the IPv4 prefix option for a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6PrefixSpecificationRequest {
    /// <p>The IPv6 prefix.</p>
    pub ipv6_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6PrefixSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6PrefixSpecificationRequest");
        formatter.field("ipv6_prefix", &self.ipv6_prefix);
        formatter.finish()
    }
}
/// See [`Ipv6PrefixSpecificationRequest`](crate::model::Ipv6PrefixSpecificationRequest)
pub mod ipv6_prefix_specification_request {
    /// A builder for [`Ipv6PrefixSpecificationRequest`](crate::model::Ipv6PrefixSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 prefix.</p>
        pub fn ipv6_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_prefix = Some(input.into());
            self
        }
        pub fn set_ipv6_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6PrefixSpecificationRequest`](crate::model::Ipv6PrefixSpecificationRequest)
        pub fn build(self) -> crate::model::Ipv6PrefixSpecificationRequest {
            crate::model::Ipv6PrefixSpecificationRequest {
                ipv6_prefix: self.ipv6_prefix,
            }
        }
    }
}
impl Ipv6PrefixSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`Ipv6PrefixSpecificationRequest`](crate::model::Ipv6PrefixSpecificationRequest)
    pub fn builder() -> crate::model::ipv6_prefix_specification_request::Builder {
        crate::model::ipv6_prefix_specification_request::Builder::default()
    }
}

/// <p>Describes the IPv4 prefix option for a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv4PrefixSpecificationRequest {
    /// <p>The IPv4 prefix. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html">
    /// Assigning prefixes to Amazon EC2 network interfaces</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub ipv4_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv4PrefixSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv4PrefixSpecificationRequest");
        formatter.field("ipv4_prefix", &self.ipv4_prefix);
        formatter.finish()
    }
}
/// See [`Ipv4PrefixSpecificationRequest`](crate::model::Ipv4PrefixSpecificationRequest)
pub mod ipv4_prefix_specification_request {
    /// A builder for [`Ipv4PrefixSpecificationRequest`](crate::model::Ipv4PrefixSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv4_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 prefix. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html">
        /// Assigning prefixes to Amazon EC2 network interfaces</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn ipv4_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_prefix = Some(input.into());
            self
        }
        pub fn set_ipv4_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv4PrefixSpecificationRequest`](crate::model::Ipv4PrefixSpecificationRequest)
        pub fn build(self) -> crate::model::Ipv4PrefixSpecificationRequest {
            crate::model::Ipv4PrefixSpecificationRequest {
                ipv4_prefix: self.ipv4_prefix,
            }
        }
    }
}
impl Ipv4PrefixSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`Ipv4PrefixSpecificationRequest`](crate::model::Ipv4PrefixSpecificationRequest)
    pub fn builder() -> crate::model::ipv4_prefix_specification_request::Builder {
        crate::model::ipv4_prefix_specification_request::Builder::default()
    }
}

/// <p>Describes a secondary private IPv4 address for a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrivateIpAddressSpecification {
    /// <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only
    /// one IPv4 address can be designated as primary.</p>
    pub primary: std::option::Option<bool>,
    /// <p>The private IPv4 addresses.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrivateIpAddressSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrivateIpAddressSpecification");
        formatter.field("primary", &self.primary);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`PrivateIpAddressSpecification`](crate::model::PrivateIpAddressSpecification)
pub mod private_ip_address_specification {
    /// A builder for [`PrivateIpAddressSpecification`](crate::model::PrivateIpAddressSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary: std::option::Option<bool>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only
        /// one IPv4 address can be designated as primary.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// <p>The private IPv4 addresses.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`PrivateIpAddressSpecification`](crate::model::PrivateIpAddressSpecification)
        pub fn build(self) -> crate::model::PrivateIpAddressSpecification {
            crate::model::PrivateIpAddressSpecification {
                primary: self.primary,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl PrivateIpAddressSpecification {
    /// Creates a new builder-style object to manufacture [`PrivateIpAddressSpecification`](crate::model::PrivateIpAddressSpecification)
    pub fn builder() -> crate::model::private_ip_address_specification::Builder {
        crate::model::private_ip_address_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShutdownBehavior {
    Stop,
    Terminate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ShutdownBehavior {
    fn from(s: &str) -> Self {
        match s {
            "stop" => ShutdownBehavior::Stop,
            "terminate" => ShutdownBehavior::Terminate,
            other => ShutdownBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ShutdownBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShutdownBehavior::from(s))
    }
}
impl ShutdownBehavior {
    pub fn as_str(&self) -> &str {
        match self {
            ShutdownBehavior::Stop => "stop",
            ShutdownBehavior::Terminate => "terminate",
            ShutdownBehavior::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["stop", "terminate"]
    }
}
impl AsRef<str> for ShutdownBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IAM instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamInstanceProfileSpecification {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the instance profile.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IamInstanceProfileSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamInstanceProfileSpecification");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`IamInstanceProfileSpecification`](crate::model::IamInstanceProfileSpecification)
pub mod iam_instance_profile_specification {
    /// A builder for [`IamInstanceProfileSpecification`](crate::model::IamInstanceProfileSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the instance profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`IamInstanceProfileSpecification`](crate::model::IamInstanceProfileSpecification)
        pub fn build(self) -> crate::model::IamInstanceProfileSpecification {
            crate::model::IamInstanceProfileSpecification {
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl IamInstanceProfileSpecification {
    /// Creates a new builder-style object to manufacture [`IamInstanceProfileSpecification`](crate::model::IamInstanceProfileSpecification)
    pub fn builder() -> crate::model::iam_instance_profile_specification::Builder {
        crate::model::iam_instance_profile_specification::Builder::default()
    }
}

/// <p>Describes the monitoring of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RunInstancesMonitoringEnabled {
    /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
    /// enabled.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for RunInstancesMonitoringEnabled {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RunInstancesMonitoringEnabled");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`RunInstancesMonitoringEnabled`](crate::model::RunInstancesMonitoringEnabled)
pub mod run_instances_monitoring_enabled {
    /// A builder for [`RunInstancesMonitoringEnabled`](crate::model::RunInstancesMonitoringEnabled)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
        /// enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`RunInstancesMonitoringEnabled`](crate::model::RunInstancesMonitoringEnabled)
        pub fn build(self) -> crate::model::RunInstancesMonitoringEnabled {
            crate::model::RunInstancesMonitoringEnabled {
                enabled: self.enabled,
            }
        }
    }
}
impl RunInstancesMonitoringEnabled {
    /// Creates a new builder-style object to manufacture [`RunInstancesMonitoringEnabled`](crate::model::RunInstancesMonitoringEnabled)
    pub fn builder() -> crate::model::run_instances_monitoring_enabled::Builder {
        crate::model::run_instances_monitoring_enabled::Builder::default()
    }
}

/// <p>Describes a block device mapping, which defines the EBS volumes and instance store
/// volumes to attach to an instance at launch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlockDeviceMapping {
    /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered
    /// starting from 0. An instance type with 2 available instance store volumes can specify
    /// mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of
    /// available instance store volumes depends on the instance type. After you connect to the
    /// instance, you must mount the volume.</p>
    /// <p>NVMe instance store volumes are automatically enumerated and assigned a device name.
    /// Including them in your block device mapping has no effect.</p>
    /// <p>Constraints: For M3 instances, you must specify instance store volumes in the block
    /// device mapping for the instance. When you launch an M3 instance, we ignore any instance
    /// store volumes specified in the block device mapping for the AMI.</p>
    pub virtual_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to automatically set up EBS volumes when the instance is
    /// launched.</p>
    pub ebs: std::option::Option<crate::model::EbsBlockDevice>,
    /// <p>To omit the device from the block device mapping, specify an empty string. When this
    /// property is specified, the device is removed from the block device mapping regardless of
    /// the assigned value.</p>
    pub no_device: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlockDeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlockDeviceMapping");
        formatter.field("device_name", &self.device_name);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.finish()
    }
}
/// See [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
pub mod block_device_mapping {
    /// A builder for [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::EbsBlockDevice>,
        pub(crate) no_device: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered
        /// starting from 0. An instance type with 2 available instance store volumes can specify
        /// mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of
        /// available instance store volumes depends on the instance type. After you connect to the
        /// instance, you must mount the volume.</p>
        /// <p>NVMe instance store volumes are automatically enumerated and assigned a device name.
        /// Including them in your block device mapping has no effect.</p>
        /// <p>Constraints: For M3 instances, you must specify instance store volumes in the block
        /// device mapping for the instance. When you launch an M3 instance, we ignore any instance
        /// store volumes specified in the block device mapping for the AMI.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// <p>Parameters used to automatically set up EBS volumes when the instance is
        /// launched.</p>
        pub fn ebs(mut self, input: crate::model::EbsBlockDevice) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(mut self, input: std::option::Option<crate::model::EbsBlockDevice>) -> Self {
            self.ebs = input;
            self
        }
        /// <p>To omit the device from the block device mapping, specify an empty string. When this
        /// property is specified, the device is removed from the block device mapping regardless of
        /// the assigned value.</p>
        pub fn no_device(mut self, input: impl Into<std::string::String>) -> Self {
            self.no_device = Some(input.into());
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.no_device = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
        pub fn build(self) -> crate::model::BlockDeviceMapping {
            crate::model::BlockDeviceMapping {
                device_name: self.device_name,
                virtual_name: self.virtual_name,
                ebs: self.ebs,
                no_device: self.no_device,
            }
        }
    }
}
impl BlockDeviceMapping {
    /// Creates a new builder-style object to manufacture [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
    pub fn builder() -> crate::model::block_device_mapping::Builder {
        crate::model::block_device_mapping::Builder::default()
    }
}

/// <p>Describes a block device for an EBS volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsBlockDevice {
    /// <p>Indicates whether the EBS volume is deleted on instance termination. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination">Preserving Amazon EBS volumes on instance termination</a> in the
    /// <i>Amazon EC2 User Guide</i>.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this
    /// represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this
    /// represents the baseline performance of the volume and the rate at which the volume accumulates
    /// I/O credits for bursting.</p>
    /// <p>The following are the supported values for each volume type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp3</code>: 3,000-16,000 IOPS</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code>: 100-64,000 IOPS</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io2</code>: 100-64,000 IOPS</p>
    /// </li>
    /// </ul>
    /// <p>For <code>io1</code> and <code>io2</code> volumes, we guarantee 64,000 IOPS only for
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a>. Other instance families guarantee performance
    /// up to 32,000 IOPS.</p>
    /// <p>This parameter is required for <code>io1</code> and <code>io2</code> volumes.
    /// The default for <code>gp3</code> volumes is 3,000 IOPS.
    /// This parameter is not supported for <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
    pub iops: std::option::Option<i32>,
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
    /// If you specify a snapshot, the default is the snapshot size. You can specify a volume
    /// size that is equal to or larger than the snapshot size.</p>
    /// <p>The following are the supported volumes sizes for each volume type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp2</code> and <code>gp3</code>:1-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>standard</code>: 1-1,024</p>
    /// </li>
    /// </ul>
    pub volume_size: std::option::Option<i32>,
    /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
    /// <i>Amazon EC2 User Guide</i>. If the volume type is <code>io1</code> or <code>io2</code>,
    /// you must specify the IOPS that the volume supports.</p>
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under
    /// which the EBS volume is encrypted.</p>
    /// <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html">RequestSpotFleet</a>,
    /// and <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">RequestSpotInstances</a>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The throughput that the volume supports, in MiB/s.</p>
    /// <p>This parameter is valid only for <code>gp3</code> volumes.</p>
    /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
    pub throughput: std::option::Option<i32>,
    /// <p>The ARN of the Outpost on which the snapshot is stored.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>Indicates whether the encryption state of an EBS volume is changed while being
    /// restored from a backing snapshot.
    /// The effect of setting the encryption state to <code>true</code> depends on
    /// the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled.
    /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters">Amazon EBS encryption</a>
    /// in the <i>Amazon EC2 User Guide</i>.</p>
    /// <p>In no case can you remove encryption from an encrypted volume.</p>
    /// <p>Encrypted volumes can only be attached to instances that support Amazon EBS
    /// encryption. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances">Supported instance types</a>.</p>
    /// <p>This parameter is not returned by .</p>
    pub encrypted: std::option::Option<bool>,
}
impl std::fmt::Debug for EbsBlockDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsBlockDevice");
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("iops", &self.iops);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("throughput", &self.throughput);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("encrypted", &self.encrypted);
        formatter.finish()
    }
}
/// See [`EbsBlockDevice`](crate::model::EbsBlockDevice)
pub mod ebs_block_device {
    /// A builder for [`EbsBlockDevice`](crate::model::EbsBlockDevice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) throughput: std::option::Option<i32>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether the EBS volume is deleted on instance termination. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination">Preserving Amazon EBS volumes on instance termination</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this
        /// represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this
        /// represents the baseline performance of the volume and the rate at which the volume accumulates
        /// I/O credits for bursting.</p>
        /// <p>The following are the supported values for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp3</code>: 3,000-16,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 100-64,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io2</code>: 100-64,000 IOPS</p>
        /// </li>
        /// </ul>
        /// <p>For <code>io1</code> and <code>io2</code> volumes, we guarantee 64,000 IOPS only for
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a>. Other instance families guarantee performance
        /// up to 32,000 IOPS.</p>
        /// <p>This parameter is required for <code>io1</code> and <code>io2</code> volumes.
        /// The default for <code>gp3</code> volumes is 3,000 IOPS.
        /// This parameter is not supported for <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        /// If you specify a snapshot, the default is the snapshot size. You can specify a volume
        /// size that is equal to or larger than the snapshot size.</p>
        /// <p>The following are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp2</code> and <code>gp3</code>:1-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>standard</code>: 1-1,024</p>
        /// </li>
        /// </ul>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
        /// <i>Amazon EC2 User Guide</i>. If the volume type is <code>io1</code> or <code>io2</code>,
        /// you must specify the IOPS that the volume supports.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under
        /// which the EBS volume is encrypted.</p>
        /// <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a>, <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html">RequestSpotFleet</a>,
        /// and <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">RequestSpotInstances</a>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The throughput that the volume supports, in MiB/s.</p>
        /// <p>This parameter is valid only for <code>gp3</code> volumes.</p>
        /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// <p>The ARN of the Outpost on which the snapshot is stored.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>Indicates whether the encryption state of an EBS volume is changed while being
        /// restored from a backing snapshot.
        /// The effect of setting the encryption state to <code>true</code> depends on
        /// the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters">Amazon EBS encryption</a>
        /// in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p>In no case can you remove encryption from an encrypted volume.</p>
        /// <p>Encrypted volumes can only be attached to instances that support Amazon EBS
        /// encryption. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances">Supported instance types</a>.</p>
        /// <p>This parameter is not returned by .</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsBlockDevice`](crate::model::EbsBlockDevice)
        pub fn build(self) -> crate::model::EbsBlockDevice {
            crate::model::EbsBlockDevice {
                delete_on_termination: self.delete_on_termination,
                iops: self.iops,
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size,
                volume_type: self.volume_type,
                kms_key_id: self.kms_key_id,
                throughput: self.throughput,
                outpost_arn: self.outpost_arn,
                encrypted: self.encrypted,
            }
        }
    }
}
impl EbsBlockDevice {
    /// Creates a new builder-style object to manufacture [`EbsBlockDevice`](crate::model::EbsBlockDevice)
    pub fn builder() -> crate::model::ebs_block_device::Builder {
        crate::model::ebs_block_device::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeType {
    Gp2,
    Gp3,
    Io1,
    Io2,
    Sc1,
    St1,
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeType {
    fn from(s: &str) -> Self {
        match s {
            "gp2" => VolumeType::Gp2,
            "gp3" => VolumeType::Gp3,
            "io1" => VolumeType::Io1,
            "io2" => VolumeType::Io2,
            "sc1" => VolumeType::Sc1,
            "st1" => VolumeType::St1,
            "standard" => VolumeType::Standard,
            other => VolumeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeType::from(s))
    }
}
impl VolumeType {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeType::Gp2 => "gp2",
            VolumeType::Gp3 => "gp3",
            VolumeType::Io1 => "io1",
            VolumeType::Io2 => "io2",
            VolumeType::Sc1 => "sc1",
            VolumeType::St1 => "st1",
            VolumeType::Standard => "standard",
            VolumeType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["gp2", "gp3", "io1", "io2", "sc1", "st1", "standard"]
    }
}
impl AsRef<str> for VolumeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the state of an authorization rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnAuthorizationRuleStatus {
    /// <p>The state of the authorization rule.</p>
    pub code: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatusCode>,
    /// <p>A message about the status of the authorization rule, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnAuthorizationRuleStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnAuthorizationRuleStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientVpnAuthorizationRuleStatus`](crate::model::ClientVpnAuthorizationRuleStatus)
pub mod client_vpn_authorization_rule_status {
    /// A builder for [`ClientVpnAuthorizationRuleStatus`](crate::model::ClientVpnAuthorizationRuleStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the authorization rule.</p>
        pub fn code(mut self, input: crate::model::ClientVpnAuthorizationRuleStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the authorization rule, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnAuthorizationRuleStatus`](crate::model::ClientVpnAuthorizationRuleStatus)
        pub fn build(self) -> crate::model::ClientVpnAuthorizationRuleStatus {
            crate::model::ClientVpnAuthorizationRuleStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientVpnAuthorizationRuleStatus {
    /// Creates a new builder-style object to manufacture [`ClientVpnAuthorizationRuleStatus`](crate::model::ClientVpnAuthorizationRuleStatus)
    pub fn builder() -> crate::model::client_vpn_authorization_rule_status::Builder {
        crate::model::client_vpn_authorization_rule_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnAuthorizationRuleStatusCode {
    Active,
    Authorizing,
    Failed,
    Revoking,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnAuthorizationRuleStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => ClientVpnAuthorizationRuleStatusCode::Active,
            "authorizing" => ClientVpnAuthorizationRuleStatusCode::Authorizing,
            "failed" => ClientVpnAuthorizationRuleStatusCode::Failed,
            "revoking" => ClientVpnAuthorizationRuleStatusCode::Revoking,
            other => ClientVpnAuthorizationRuleStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnAuthorizationRuleStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnAuthorizationRuleStatusCode::from(s))
    }
}
impl ClientVpnAuthorizationRuleStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnAuthorizationRuleStatusCode::Active => "active",
            ClientVpnAuthorizationRuleStatusCode::Authorizing => "authorizing",
            ClientVpnAuthorizationRuleStatusCode::Failed => "failed",
            ClientVpnAuthorizationRuleStatusCode::Revoking => "revoking",
            ClientVpnAuthorizationRuleStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "authorizing", "failed", "revoking"]
    }
}
impl AsRef<str> for ClientVpnAuthorizationRuleStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a managed prefix list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedPrefixList {
    /// <p>The ID of the prefix list.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The IP address version.</p>
    pub address_family: std::option::Option<std::string::String>,
    /// <p>The current state of the prefix list.</p>
    pub state: std::option::Option<crate::model::PrefixListState>,
    /// <p>The state message.</p>
    pub state_message: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the prefix list.</p>
    pub prefix_list_arn: std::option::Option<std::string::String>,
    /// <p>The name of the prefix list.</p>
    pub prefix_list_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of entries for the prefix list.</p>
    pub max_entries: std::option::Option<i32>,
    /// <p>The version of the prefix list.</p>
    pub version: std::option::Option<i64>,
    /// <p>The tags for the prefix list.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the owner of the prefix list.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ManagedPrefixList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedPrefixList");
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("address_family", &self.address_family);
        formatter.field("state", &self.state);
        formatter.field("state_message", &self.state_message);
        formatter.field("prefix_list_arn", &self.prefix_list_arn);
        formatter.field("prefix_list_name", &self.prefix_list_name);
        formatter.field("max_entries", &self.max_entries);
        formatter.field("version", &self.version);
        formatter.field("tags", &self.tags);
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`ManagedPrefixList`](crate::model::ManagedPrefixList)
pub mod managed_prefix_list {
    /// A builder for [`ManagedPrefixList`](crate::model::ManagedPrefixList)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) address_family: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::PrefixListState>,
        pub(crate) state_message: std::option::Option<std::string::String>,
        pub(crate) prefix_list_arn: std::option::Option<std::string::String>,
        pub(crate) prefix_list_name: std::option::Option<std::string::String>,
        pub(crate) max_entries: std::option::Option<i32>,
        pub(crate) version: std::option::Option<i64>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The IP address version.</p>
        pub fn address_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.address_family = Some(input.into());
            self
        }
        pub fn set_address_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.address_family = input;
            self
        }
        /// <p>The current state of the prefix list.</p>
        pub fn state(mut self, input: crate::model::PrefixListState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::PrefixListState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state message.</p>
        pub fn state_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_message = Some(input.into());
            self
        }
        pub fn set_state_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_message = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the prefix list.</p>
        pub fn prefix_list_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_arn = Some(input.into());
            self
        }
        pub fn set_prefix_list_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_arn = input;
            self
        }
        /// <p>The name of the prefix list.</p>
        pub fn prefix_list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_name = Some(input.into());
            self
        }
        pub fn set_prefix_list_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_name = input;
            self
        }
        /// <p>The maximum number of entries for the prefix list.</p>
        pub fn max_entries(mut self, input: i32) -> Self {
            self.max_entries = Some(input);
            self
        }
        pub fn set_max_entries(mut self, input: std::option::Option<i32>) -> Self {
            self.max_entries = input;
            self
        }
        /// <p>The version of the prefix list.</p>
        pub fn version(mut self, input: i64) -> Self {
            self.version = Some(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i64>) -> Self {
            self.version = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the owner of the prefix list.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedPrefixList`](crate::model::ManagedPrefixList)
        pub fn build(self) -> crate::model::ManagedPrefixList {
            crate::model::ManagedPrefixList {
                prefix_list_id: self.prefix_list_id,
                address_family: self.address_family,
                state: self.state,
                state_message: self.state_message,
                prefix_list_arn: self.prefix_list_arn,
                prefix_list_name: self.prefix_list_name,
                max_entries: self.max_entries,
                version: self.version,
                tags: self.tags,
                owner_id: self.owner_id,
            }
        }
    }
}
impl ManagedPrefixList {
    /// Creates a new builder-style object to manufacture [`ManagedPrefixList`](crate::model::ManagedPrefixList)
    pub fn builder() -> crate::model::managed_prefix_list::Builder {
        crate::model::managed_prefix_list::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrefixListState {
    CreateComplete,
    CreateFailed,
    CreateInProgress,
    DeleteComplete,
    DeleteFailed,
    DeleteInProgress,
    ModifyComplete,
    ModifyFailed,
    ModifyInProgress,
    RestoreComplete,
    RestoreFailed,
    RestoreInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PrefixListState {
    fn from(s: &str) -> Self {
        match s {
            "create-complete" => PrefixListState::CreateComplete,
            "create-failed" => PrefixListState::CreateFailed,
            "create-in-progress" => PrefixListState::CreateInProgress,
            "delete-complete" => PrefixListState::DeleteComplete,
            "delete-failed" => PrefixListState::DeleteFailed,
            "delete-in-progress" => PrefixListState::DeleteInProgress,
            "modify-complete" => PrefixListState::ModifyComplete,
            "modify-failed" => PrefixListState::ModifyFailed,
            "modify-in-progress" => PrefixListState::ModifyInProgress,
            "restore-complete" => PrefixListState::RestoreComplete,
            "restore-failed" => PrefixListState::RestoreFailed,
            "restore-in-progress" => PrefixListState::RestoreInProgress,
            other => PrefixListState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PrefixListState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrefixListState::from(s))
    }
}
impl PrefixListState {
    pub fn as_str(&self) -> &str {
        match self {
            PrefixListState::CreateComplete => "create-complete",
            PrefixListState::CreateFailed => "create-failed",
            PrefixListState::CreateInProgress => "create-in-progress",
            PrefixListState::DeleteComplete => "delete-complete",
            PrefixListState::DeleteFailed => "delete-failed",
            PrefixListState::DeleteInProgress => "delete-in-progress",
            PrefixListState::ModifyComplete => "modify-complete",
            PrefixListState::ModifyFailed => "modify-failed",
            PrefixListState::ModifyInProgress => "modify-in-progress",
            PrefixListState::RestoreComplete => "restore-complete",
            PrefixListState::RestoreFailed => "restore-failed",
            PrefixListState::RestoreInProgress => "restore-in-progress",
            PrefixListState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "create-complete",
            "create-failed",
            "create-in-progress",
            "delete-complete",
            "delete-failed",
            "delete-in-progress",
            "modify-complete",
            "modify-failed",
            "modify-in-progress",
            "restore-complete",
            "restore-failed",
            "restore-in-progress",
        ]
    }
}
impl AsRef<str> for PrefixListState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    InClassic,
    InVpc,
    MoveInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "InClassic" => Status::InClassic,
            "InVpc" => Status::InVpc,
            "MoveInProgress" => Status::MoveInProgress,
            other => Status::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    pub fn as_str(&self) -> &str {
        match self {
            Status::InClassic => "InClassic",
            Status::InVpc => "InVpc",
            Status::MoveInProgress => "MoveInProgress",
            Status::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["InClassic", "InVpc", "MoveInProgress"]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotAttributeName {
    CreateVolumePermission,
    ProductCodes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SnapshotAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "createVolumePermission" => SnapshotAttributeName::CreateVolumePermission,
            "productCodes" => SnapshotAttributeName::ProductCodes,
            other => SnapshotAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SnapshotAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotAttributeName::from(s))
    }
}
impl SnapshotAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotAttributeName::CreateVolumePermission => "createVolumePermission",
            SnapshotAttributeName::ProductCodes => "productCodes",
            SnapshotAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["createVolumePermission", "productCodes"]
    }
}
impl AsRef<str> for SnapshotAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceAttributeName {
    BlockDeviceMapping,
    DisableApiTermination,
    EbsOptimized,
    EnaSupport,
    EnclaveOptions,
    GroupSet,
    InstanceInitiatedShutdownBehavior,
    InstanceType,
    Kernel,
    ProductCodes,
    Ramdisk,
    RootDeviceName,
    SourceDestCheck,
    SriovNetSupport,
    UserData,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "blockDeviceMapping" => InstanceAttributeName::BlockDeviceMapping,
            "disableApiTermination" => InstanceAttributeName::DisableApiTermination,
            "ebsOptimized" => InstanceAttributeName::EbsOptimized,
            "enaSupport" => InstanceAttributeName::EnaSupport,
            "enclaveOptions" => InstanceAttributeName::EnclaveOptions,
            "groupSet" => InstanceAttributeName::GroupSet,
            "instanceInitiatedShutdownBehavior" => {
                InstanceAttributeName::InstanceInitiatedShutdownBehavior
            }
            "instanceType" => InstanceAttributeName::InstanceType,
            "kernel" => InstanceAttributeName::Kernel,
            "productCodes" => InstanceAttributeName::ProductCodes,
            "ramdisk" => InstanceAttributeName::Ramdisk,
            "rootDeviceName" => InstanceAttributeName::RootDeviceName,
            "sourceDestCheck" => InstanceAttributeName::SourceDestCheck,
            "sriovNetSupport" => InstanceAttributeName::SriovNetSupport,
            "userData" => InstanceAttributeName::UserData,
            other => InstanceAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceAttributeName::from(s))
    }
}
impl InstanceAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceAttributeName::BlockDeviceMapping => "blockDeviceMapping",
            InstanceAttributeName::DisableApiTermination => "disableApiTermination",
            InstanceAttributeName::EbsOptimized => "ebsOptimized",
            InstanceAttributeName::EnaSupport => "enaSupport",
            InstanceAttributeName::EnclaveOptions => "enclaveOptions",
            InstanceAttributeName::GroupSet => "groupSet",
            InstanceAttributeName::InstanceInitiatedShutdownBehavior => {
                "instanceInitiatedShutdownBehavior"
            }
            InstanceAttributeName::InstanceType => "instanceType",
            InstanceAttributeName::Kernel => "kernel",
            InstanceAttributeName::ProductCodes => "productCodes",
            InstanceAttributeName::Ramdisk => "ramdisk",
            InstanceAttributeName::RootDeviceName => "rootDeviceName",
            InstanceAttributeName::SourceDestCheck => "sourceDestCheck",
            InstanceAttributeName::SriovNetSupport => "sriovNetSupport",
            InstanceAttributeName::UserData => "userData",
            InstanceAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "blockDeviceMapping",
            "disableApiTermination",
            "ebsOptimized",
            "enaSupport",
            "enclaveOptions",
            "groupSet",
            "instanceInitiatedShutdownBehavior",
            "instanceType",
            "kernel",
            "productCodes",
            "ramdisk",
            "rootDeviceName",
            "sourceDestCheck",
            "sriovNetSupport",
            "userData",
        ]
    }
}
impl AsRef<str> for InstanceAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResetImageAttributeName {
    LaunchPermission,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResetImageAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "launchPermission" => ResetImageAttributeName::LaunchPermission,
            other => ResetImageAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResetImageAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResetImageAttributeName::from(s))
    }
}
impl ResetImageAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            ResetImageAttributeName::LaunchPermission => "launchPermission",
            ResetImageAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["launchPermission"]
    }
}
impl AsRef<str> for ResetImageAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResetFpgaImageAttributeName {
    LoadPermission,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResetFpgaImageAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "loadPermission" => ResetFpgaImageAttributeName::LoadPermission,
            other => ResetFpgaImageAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResetFpgaImageAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResetFpgaImageAttributeName::from(s))
    }
}
impl ResetFpgaImageAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            ResetFpgaImageAttributeName::LoadPermission => "loadPermission",
            ResetFpgaImageAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["loadPermission"]
    }
}
impl AsRef<str> for ResetFpgaImageAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The attributes associated with an Elastic IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddressAttribute {
    /// <p>The public IP address.</p>
    pub public_ip: std::option::Option<std::string::String>,
    /// <p>[EC2-VPC] The allocation ID.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The pointer (PTR) record for the IP address.</p>
    pub ptr_record: std::option::Option<std::string::String>,
    /// <p>The updated PTR record for the IP address.</p>
    pub ptr_record_update: std::option::Option<crate::model::PtrUpdateStatus>,
}
impl std::fmt::Debug for AddressAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddressAttribute");
        formatter.field("public_ip", &self.public_ip);
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("ptr_record", &self.ptr_record);
        formatter.field("ptr_record_update", &self.ptr_record_update);
        formatter.finish()
    }
}
/// See [`AddressAttribute`](crate::model::AddressAttribute)
pub mod address_attribute {
    /// A builder for [`AddressAttribute`](crate::model::AddressAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) public_ip: std::option::Option<std::string::String>,
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) ptr_record: std::option::Option<std::string::String>,
        pub(crate) ptr_record_update: std::option::Option<crate::model::PtrUpdateStatus>,
    }
    impl Builder {
        /// <p>The public IP address.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// <p>[EC2-VPC] The allocation ID.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The pointer (PTR) record for the IP address.</p>
        pub fn ptr_record(mut self, input: impl Into<std::string::String>) -> Self {
            self.ptr_record = Some(input.into());
            self
        }
        pub fn set_ptr_record(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ptr_record = input;
            self
        }
        /// <p>The updated PTR record for the IP address.</p>
        pub fn ptr_record_update(mut self, input: crate::model::PtrUpdateStatus) -> Self {
            self.ptr_record_update = Some(input);
            self
        }
        pub fn set_ptr_record_update(
            mut self,
            input: std::option::Option<crate::model::PtrUpdateStatus>,
        ) -> Self {
            self.ptr_record_update = input;
            self
        }
        /// Consumes the builder and constructs a [`AddressAttribute`](crate::model::AddressAttribute)
        pub fn build(self) -> crate::model::AddressAttribute {
            crate::model::AddressAttribute {
                public_ip: self.public_ip,
                allocation_id: self.allocation_id,
                ptr_record: self.ptr_record,
                ptr_record_update: self.ptr_record_update,
            }
        }
    }
}
impl AddressAttribute {
    /// Creates a new builder-style object to manufacture [`AddressAttribute`](crate::model::AddressAttribute)
    pub fn builder() -> crate::model::address_attribute::Builder {
        crate::model::address_attribute::Builder::default()
    }
}

/// <p>The status of an updated pointer (PTR) record for an Elastic IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PtrUpdateStatus {
    /// <p>The value for the PTR record update.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The status of the PTR record update.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The reason for the PTR record update.</p>
    pub reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PtrUpdateStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PtrUpdateStatus");
        formatter.field("value", &self.value);
        formatter.field("status", &self.status);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
/// See [`PtrUpdateStatus`](crate::model::PtrUpdateStatus)
pub mod ptr_update_status {
    /// A builder for [`PtrUpdateStatus`](crate::model::PtrUpdateStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value for the PTR record update.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The status of the PTR record update.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason for the PTR record update.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`PtrUpdateStatus`](crate::model::PtrUpdateStatus)
        pub fn build(self) -> crate::model::PtrUpdateStatus {
            crate::model::PtrUpdateStatus {
                value: self.value,
                status: self.status,
                reason: self.reason,
            }
        }
    }
}
impl PtrUpdateStatus {
    /// Creates a new builder-style object to manufacture [`PtrUpdateStatus`](crate::model::PtrUpdateStatus)
    pub fn builder() -> crate::model::ptr_update_status::Builder {
        crate::model::ptr_update_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AddressAttributeName {
    DomainName,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AddressAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "domain-name" => AddressAttributeName::DomainName,
            other => AddressAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AddressAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AddressAttributeName::from(s))
    }
}
impl AddressAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            AddressAttributeName::DomainName => "domain-name",
            AddressAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["domain-name"]
    }
}
impl AsRef<str> for AddressAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Spot Instance request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotInstanceRequest {
    /// <p>Deprecated.</p>
    pub actual_block_hourly_price: std::option::Option<std::string::String>,
    /// <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot Instance requests, all Spot Instances are launched in the same Availability Zone.</p>
    pub availability_zone_group: std::option::Option<std::string::String>,
    /// <p>Deprecated.</p>
    pub block_duration_minutes: std::option::Option<i32>,
    /// <p>The date and time when the Spot Instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The fault codes for the Spot Instance request, if any.</p>
    pub fault: std::option::Option<crate::model::SpotInstanceStateFault>,
    /// <p>The instance ID, if an instance has been launched to fulfill the Spot Instance request.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance launch group. Launch groups are Spot Instances that launch together and terminate together.</p>
    pub launch_group: std::option::Option<std::string::String>,
    /// <p>Additional information for launching instances.</p>
    pub launch_specification: std::option::Option<crate::model::LaunchSpecification>,
    /// <p>The Availability Zone in which the request is launched.</p>
    pub launched_availability_zone: std::option::Option<std::string::String>,
    /// <p>The product description associated with the Spot Instance.</p>
    pub product_description: std::option::Option<crate::model::RiProductDescription>,
    /// <p>The ID of the Spot Instance request.</p>
    pub spot_instance_request_id: std::option::Option<std::string::String>,
    /// <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The state of the Spot Instance request. Spot status information helps track your Spot
    /// Instance requests. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot status</a> in the
    /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub state: std::option::Option<crate::model::SpotInstanceState>,
    /// <p>The status code and status message describing the Spot Instance request.</p>
    pub status: std::option::Option<crate::model::SpotInstanceStatus>,
    /// <p>Any tags assigned to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Spot Instance request type.</p>
    pub r#type: std::option::Option<crate::model::SpotInstanceType>,
    /// <p>The start date of the request, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// The request becomes active at this date and time.</p>
    pub valid_from: std::option::Option<smithy_types::Instant>,
    /// <p>The end date of the request, in UTC format
    /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    /// <ul>
    /// <li>
    /// <p>For a persistent request, the request remains active until the <code>validUntil</code> date
    /// and time is reached. Otherwise, the request remains active until you cancel it.
    /// </p>
    /// </li>
    /// <li>
    /// <p>For a one-time request, the request remains active until all instances launch,
    /// the request is canceled, or the <code>validUntil</code> date and time is reached. By default, the
    /// request is valid for 7 days from the date the request was created.</p>
    /// </li>
    /// </ul>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>The behavior when a Spot Instance is interrupted.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::InstanceInterruptionBehavior>,
}
impl std::fmt::Debug for SpotInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotInstanceRequest");
        formatter.field("actual_block_hourly_price", &self.actual_block_hourly_price);
        formatter.field("availability_zone_group", &self.availability_zone_group);
        formatter.field("block_duration_minutes", &self.block_duration_minutes);
        formatter.field("create_time", &self.create_time);
        formatter.field("fault", &self.fault);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("launch_group", &self.launch_group);
        formatter.field("launch_specification", &self.launch_specification);
        formatter.field(
            "launched_availability_zone",
            &self.launched_availability_zone,
        );
        formatter.field("product_description", &self.product_description);
        formatter.field("spot_instance_request_id", &self.spot_instance_request_id);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("state", &self.state);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.field("valid_from", &self.valid_from);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.finish()
    }
}
/// See [`SpotInstanceRequest`](crate::model::SpotInstanceRequest)
pub mod spot_instance_request {
    /// A builder for [`SpotInstanceRequest`](crate::model::SpotInstanceRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) actual_block_hourly_price: std::option::Option<std::string::String>,
        pub(crate) availability_zone_group: std::option::Option<std::string::String>,
        pub(crate) block_duration_minutes: std::option::Option<i32>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) fault: std::option::Option<crate::model::SpotInstanceStateFault>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) launch_group: std::option::Option<std::string::String>,
        pub(crate) launch_specification: std::option::Option<crate::model::LaunchSpecification>,
        pub(crate) launched_availability_zone: std::option::Option<std::string::String>,
        pub(crate) product_description: std::option::Option<crate::model::RiProductDescription>,
        pub(crate) spot_instance_request_id: std::option::Option<std::string::String>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::SpotInstanceState>,
        pub(crate) status: std::option::Option<crate::model::SpotInstanceStatus>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) r#type: std::option::Option<crate::model::SpotInstanceType>,
        pub(crate) valid_from: std::option::Option<smithy_types::Instant>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::InstanceInterruptionBehavior>,
    }
    impl Builder {
        /// <p>Deprecated.</p>
        pub fn actual_block_hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.actual_block_hourly_price = Some(input.into());
            self
        }
        pub fn set_actual_block_hourly_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.actual_block_hourly_price = input;
            self
        }
        /// <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot Instance requests, all Spot Instances are launched in the same Availability Zone.</p>
        pub fn availability_zone_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_group = Some(input.into());
            self
        }
        pub fn set_availability_zone_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_group = input;
            self
        }
        /// <p>Deprecated.</p>
        pub fn block_duration_minutes(mut self, input: i32) -> Self {
            self.block_duration_minutes = Some(input);
            self
        }
        pub fn set_block_duration_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.block_duration_minutes = input;
            self
        }
        /// <p>The date and time when the Spot Instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The fault codes for the Spot Instance request, if any.</p>
        pub fn fault(mut self, input: crate::model::SpotInstanceStateFault) -> Self {
            self.fault = Some(input);
            self
        }
        pub fn set_fault(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceStateFault>,
        ) -> Self {
            self.fault = input;
            self
        }
        /// <p>The instance ID, if an instance has been launched to fulfill the Spot Instance request.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance launch group. Launch groups are Spot Instances that launch together and terminate together.</p>
        pub fn launch_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_group = Some(input.into());
            self
        }
        pub fn set_launch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_group = input;
            self
        }
        /// <p>Additional information for launching instances.</p>
        pub fn launch_specification(mut self, input: crate::model::LaunchSpecification) -> Self {
            self.launch_specification = Some(input);
            self
        }
        pub fn set_launch_specification(
            mut self,
            input: std::option::Option<crate::model::LaunchSpecification>,
        ) -> Self {
            self.launch_specification = input;
            self
        }
        /// <p>The Availability Zone in which the request is launched.</p>
        pub fn launched_availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.launched_availability_zone = Some(input.into());
            self
        }
        pub fn set_launched_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launched_availability_zone = input;
            self
        }
        /// <p>The product description associated with the Spot Instance.</p>
        pub fn product_description(mut self, input: crate::model::RiProductDescription) -> Self {
            self.product_description = Some(input);
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<crate::model::RiProductDescription>,
        ) -> Self {
            self.product_description = input;
            self
        }
        /// <p>The ID of the Spot Instance request.</p>
        pub fn spot_instance_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_instance_request_id = Some(input.into());
            self
        }
        pub fn set_spot_instance_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_instance_request_id = input;
            self
        }
        /// <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The state of the Spot Instance request. Spot status information helps track your Spot
        /// Instance requests. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot status</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn state(mut self, input: crate::model::SpotInstanceState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code and status message describing the Spot Instance request.</p>
        pub fn status(mut self, input: crate::model::SpotInstanceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Spot Instance request type.</p>
        pub fn r#type(mut self, input: crate::model::SpotInstanceType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The start date of the request, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// The request becomes active at this date and time.</p>
        pub fn valid_from(mut self, input: smithy_types::Instant) -> Self {
            self.valid_from = Some(input);
            self
        }
        pub fn set_valid_from(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.valid_from = input;
            self
        }
        /// <p>The end date of the request, in UTC format
        /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        /// <ul>
        /// <li>
        /// <p>For a persistent request, the request remains active until the <code>validUntil</code> date
        /// and time is reached. Otherwise, the request remains active until you cancel it.
        /// </p>
        /// </li>
        /// <li>
        /// <p>For a one-time request, the request remains active until all instances launch,
        /// the request is canceled, or the <code>validUntil</code> date and time is reached. By default, the
        /// request is valid for 7 days from the date the request was created.</p>
        /// </li>
        /// </ul>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotInstanceRequest`](crate::model::SpotInstanceRequest)
        pub fn build(self) -> crate::model::SpotInstanceRequest {
            crate::model::SpotInstanceRequest {
                actual_block_hourly_price: self.actual_block_hourly_price,
                availability_zone_group: self.availability_zone_group,
                block_duration_minutes: self.block_duration_minutes,
                create_time: self.create_time,
                fault: self.fault,
                instance_id: self.instance_id,
                launch_group: self.launch_group,
                launch_specification: self.launch_specification,
                launched_availability_zone: self.launched_availability_zone,
                product_description: self.product_description,
                spot_instance_request_id: self.spot_instance_request_id,
                spot_price: self.spot_price,
                state: self.state,
                status: self.status,
                tags: self.tags,
                r#type: self.r#type,
                valid_from: self.valid_from,
                valid_until: self.valid_until,
                instance_interruption_behavior: self.instance_interruption_behavior,
            }
        }
    }
}
impl SpotInstanceRequest {
    /// Creates a new builder-style object to manufacture [`SpotInstanceRequest`](crate::model::SpotInstanceRequest)
    pub fn builder() -> crate::model::spot_instance_request::Builder {
        crate::model::spot_instance_request::Builder::default()
    }
}

/// <p>Describes the status of a Spot Instance request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotInstanceStatus {
    /// <p>The status code. For a list of status codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot status codes</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The description for the status code.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The date and time of the most recent status update, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for SpotInstanceStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotInstanceStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`SpotInstanceStatus`](crate::model::SpotInstanceStatus)
pub mod spot_instance_status {
    /// A builder for [`SpotInstanceStatus`](crate::model::SpotInstanceStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The status code. For a list of status codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot status codes</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The description for the status code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The date and time of the most recent status update, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotInstanceStatus`](crate::model::SpotInstanceStatus)
        pub fn build(self) -> crate::model::SpotInstanceStatus {
            crate::model::SpotInstanceStatus {
                code: self.code,
                message: self.message,
                update_time: self.update_time,
            }
        }
    }
}
impl SpotInstanceStatus {
    /// Creates a new builder-style object to manufacture [`SpotInstanceStatus`](crate::model::SpotInstanceStatus)
    pub fn builder() -> crate::model::spot_instance_status::Builder {
        crate::model::spot_instance_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpotInstanceState {
    Active,
    Cancelled,
    Closed,
    Failed,
    Open,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpotInstanceState {
    fn from(s: &str) -> Self {
        match s {
            "active" => SpotInstanceState::Active,
            "cancelled" => SpotInstanceState::Cancelled,
            "closed" => SpotInstanceState::Closed,
            "failed" => SpotInstanceState::Failed,
            "open" => SpotInstanceState::Open,
            other => SpotInstanceState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpotInstanceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpotInstanceState::from(s))
    }
}
impl SpotInstanceState {
    pub fn as_str(&self) -> &str {
        match self {
            SpotInstanceState::Active => "active",
            SpotInstanceState::Cancelled => "cancelled",
            SpotInstanceState::Closed => "closed",
            SpotInstanceState::Failed => "failed",
            SpotInstanceState::Open => "open",
            SpotInstanceState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "closed", "failed", "open"]
    }
}
impl AsRef<str> for SpotInstanceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub struct RiProductDescription(String);
impl RiProductDescription {
    pub fn as_str(&self) -> &str {
        &self.0
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Linux/UNIX",
            "Linux/UNIX (Amazon VPC)",
            "Windows",
            "Windows (Amazon VPC)",
        ]
    }
}
impl<T> std::convert::From<T> for RiProductDescription
where
    T: std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        RiProductDescription(s.as_ref().to_owned())
    }
}

/// <p>Describes the launch specification for an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchSpecification {
    /// <p>The Base64-encoded user data for the instance.</p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
    pub security_groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>Deprecated.</p>
    pub addressing_type: std::option::Option<std::string::String>,
    /// <p>One or more block device mapping entries.</p>
    pub block_device_mappings: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
    /// <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile: std::option::Option<crate::model::IamInstanceProfileSpecification>,
    /// <p>The ID of the AMI.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The ID of the kernel.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>One or more network interfaces. If you specify a network interface, you must specify
    /// subnet IDs and security group IDs using the network interface.</p>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
    /// <p>The placement information for the instance.</p>
    pub placement: std::option::Option<crate::model::SpotPlacement>,
    /// <p>The ID of the RAM disk.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet in which to launch the instance.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>Describes the monitoring of an instance.</p>
    pub monitoring: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
}
impl std::fmt::Debug for LaunchSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchSpecification");
        formatter.field("user_data", &self.user_data);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("addressing_type", &self.addressing_type);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("monitoring", &self.monitoring);
        formatter.finish()
    }
}
/// See [`LaunchSpecification`](crate::model::LaunchSpecification)
pub mod launch_specification {
    /// A builder for [`LaunchSpecification`](crate::model::LaunchSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) security_groups:
            std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) addressing_type: std::option::Option<std::string::String>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::IamInstanceProfileSpecification>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
        pub(crate) placement: std::option::Option<crate::model::SpotPlacement>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
    }
    impl Builder {
        /// <p>The Base64-encoded user data for the instance.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Deprecated.</p>
        pub fn addressing_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.addressing_type = Some(input.into());
            self
        }
        pub fn set_addressing_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.addressing_type = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the kernel.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::InstanceNetworkInterfaceSpecification>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The placement information for the instance.</p>
        pub fn placement(mut self, input: crate::model::SpotPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::SpotPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// <p>The ID of the subnet in which to launch the instance.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>Describes the monitoring of an instance.</p>
        pub fn monitoring(mut self, input: crate::model::RunInstancesMonitoringEnabled) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchSpecification`](crate::model::LaunchSpecification)
        pub fn build(self) -> crate::model::LaunchSpecification {
            crate::model::LaunchSpecification {
                user_data: self.user_data,
                security_groups: self.security_groups,
                addressing_type: self.addressing_type,
                block_device_mappings: self.block_device_mappings,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                image_id: self.image_id,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                network_interfaces: self.network_interfaces,
                placement: self.placement,
                ramdisk_id: self.ramdisk_id,
                subnet_id: self.subnet_id,
                monitoring: self.monitoring,
            }
        }
    }
}
impl LaunchSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchSpecification`](crate::model::LaunchSpecification)
    pub fn builder() -> crate::model::launch_specification::Builder {
        crate::model::launch_specification::Builder::default()
    }
}

/// <p>Describes Spot Instance placement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotPlacement {
    /// <p>The Availability Zone.</p>
    /// <p>[Spot Fleet only] To specify multiple Availability Zones, separate them using commas;
    /// for example, "us-west-2a, us-west-2b".</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The name of the placement group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a
    /// tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code>
    /// tenancy is not supported for Spot Instances.</p>
    pub tenancy: std::option::Option<crate::model::Tenancy>,
}
impl std::fmt::Debug for SpotPlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotPlacement");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("group_name", &self.group_name);
        formatter.field("tenancy", &self.tenancy);
        formatter.finish()
    }
}
/// See [`SpotPlacement`](crate::model::SpotPlacement)
pub mod spot_placement {
    /// A builder for [`SpotPlacement`](crate::model::SpotPlacement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<crate::model::Tenancy>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        /// <p>[Spot Fleet only] To specify multiple Availability Zones, separate them using commas;
        /// for example, "us-west-2a, us-west-2b".</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The name of the placement group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a
        /// tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code>
        /// tenancy is not supported for Spot Instances.</p>
        pub fn tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        pub fn set_tenancy(mut self, input: std::option::Option<crate::model::Tenancy>) -> Self {
            self.tenancy = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotPlacement`](crate::model::SpotPlacement)
        pub fn build(self) -> crate::model::SpotPlacement {
            crate::model::SpotPlacement {
                availability_zone: self.availability_zone,
                group_name: self.group_name,
                tenancy: self.tenancy,
            }
        }
    }
}
impl SpotPlacement {
    /// Creates a new builder-style object to manufacture [`SpotPlacement`](crate::model::SpotPlacement)
    pub fn builder() -> crate::model::spot_placement::Builder {
        crate::model::spot_placement::Builder::default()
    }
}

/// <p>Describes a Spot Instance state change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotInstanceStateFault {
    /// <p>The reason code for the Spot Instance state change.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The message for the Spot Instance state change.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SpotInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotInstanceStateFault");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`SpotInstanceStateFault`](crate::model::SpotInstanceStateFault)
pub mod spot_instance_state_fault {
    /// A builder for [`SpotInstanceStateFault`](crate::model::SpotInstanceStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The reason code for the Spot Instance state change.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The message for the Spot Instance state change.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotInstanceStateFault`](crate::model::SpotInstanceStateFault)
        pub fn build(self) -> crate::model::SpotInstanceStateFault {
            crate::model::SpotInstanceStateFault {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl SpotInstanceStateFault {
    /// Creates a new builder-style object to manufacture [`SpotInstanceStateFault`](crate::model::SpotInstanceStateFault)
    pub fn builder() -> crate::model::spot_instance_state_fault::Builder {
        crate::model::spot_instance_state_fault::Builder::default()
    }
}

/// <p>Describes the launch specification for an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestSpotLaunchSpecification {
    /// <p>One or more security group IDs.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Deprecated.</p>
    pub addressing_type: std::option::Option<std::string::String>,
    /// <p>One or more block device mapping entries. You can't specify both a snapshot ID and an encryption value.
    /// This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume,
    /// it is not blank and its encryption status is used for the volume encryption status.</p>
    pub block_device_mappings: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
    /// <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile: std::option::Option<crate::model::IamInstanceProfileSpecification>,
    /// <p>The ID of the AMI.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The ID of the kernel.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p>
    /// <p>Default: Disabled</p>
    pub monitoring: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
    /// <p>One or more network interfaces. If you specify a network interface, you must specify
    /// subnet IDs and security group IDs using the network interface.</p>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
    /// <p>The placement information for the instance.</p>
    pub placement: std::option::Option<crate::model::SpotPlacement>,
    /// <p>The ID of the RAM disk.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet in which to launch the instance.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Base64-encoded user data for the instance. User data is limited to 16 KB.</p>
    pub user_data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestSpotLaunchSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestSpotLaunchSpecification");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("addressing_type", &self.addressing_type);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &self.user_data);
        formatter.finish()
    }
}
/// See [`RequestSpotLaunchSpecification`](crate::model::RequestSpotLaunchSpecification)
pub mod request_spot_launch_specification {
    /// A builder for [`RequestSpotLaunchSpecification`](crate::model::RequestSpotLaunchSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) addressing_type: std::option::Option<std::string::String>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::IamInstanceProfileSpecification>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
        pub(crate) placement: std::option::Option<crate::model::SpotPlacement>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Deprecated.</p>
        pub fn addressing_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.addressing_type = Some(input.into());
            self
        }
        pub fn set_addressing_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.addressing_type = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the kernel.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p>
        /// <p>Default: Disabled</p>
        pub fn monitoring(mut self, input: crate::model::RunInstancesMonitoringEnabled) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::InstanceNetworkInterfaceSpecification>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The placement information for the instance.</p>
        pub fn placement(mut self, input: crate::model::SpotPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::SpotPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// <p>The ID of the subnet in which to launch the instance.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Base64-encoded user data for the instance. User data is limited to 16 KB.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestSpotLaunchSpecification`](crate::model::RequestSpotLaunchSpecification)
        pub fn build(self) -> crate::model::RequestSpotLaunchSpecification {
            crate::model::RequestSpotLaunchSpecification {
                security_group_ids: self.security_group_ids,
                security_groups: self.security_groups,
                addressing_type: self.addressing_type,
                block_device_mappings: self.block_device_mappings,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                image_id: self.image_id,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                monitoring: self.monitoring,
                network_interfaces: self.network_interfaces,
                placement: self.placement,
                ramdisk_id: self.ramdisk_id,
                subnet_id: self.subnet_id,
                user_data: self.user_data,
            }
        }
    }
}
impl RequestSpotLaunchSpecification {
    /// Creates a new builder-style object to manufacture [`RequestSpotLaunchSpecification`](crate::model::RequestSpotLaunchSpecification)
    pub fn builder() -> crate::model::request_spot_launch_specification::Builder {
        crate::model::request_spot_launch_specification::Builder::default()
    }
}

/// <p>Describes the configuration of a Spot Fleet request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotFleetRequestConfigData {
    /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
    /// the Spot Fleet request.</p>
    /// <p>If the allocation strategy is <code>lowestPrice</code>, Spot Fleet launches instances from
    /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
    /// <p>If the allocation strategy is <code>diversified</code>, Spot Fleet launches instances from
    /// all the Spot Instance pools that you specify.</p>
    /// <p>If the allocation strategy is <code>capacityOptimized</code> (recommended), Spot Fleet
    /// launches instances from Spot Instance pools with optimal capacity for the number of instances
    /// that are launching. To give certain instance types a higher chance of launching first,
    /// use <code>capacityOptimizedPrioritized</code>. Set a priority for each instance type by
    /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You
    /// can assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2
    /// implements the priorities on a best-effort basis, but optimizes for capacity first.
    /// <code>capacityOptimizedPrioritized</code> is supported only if your Spot Fleet uses a
    /// launch template. Note that if the <code>OnDemandAllocationStrategy</code> is set to
    /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
    /// capacity.</p>
    pub allocation_strategy: std::option::Option<crate::model::AllocationStrategy>,
    /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
    /// you specify <code>lowestPrice</code>, Spot Fleet uses price to determine the order, launching
    /// the lowest price first. If you specify <code>prioritized</code>, Spot Fleet uses the priority
    /// that you assign to each Spot Fleet launch template override, launching the highest priority
    /// first. If you do not specify a value, Spot Fleet defaults to <code>lowestPrice</code>.</p>
    pub on_demand_allocation_strategy:
        std::option::Option<crate::model::OnDemandAllocationStrategy>,
    /// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
    /// interrupted.</p>
    pub spot_maintenance_strategies: std::option::Option<crate::model::SpotMaintenanceStrategies>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of your
    /// listings. This helps to avoid duplicate listings. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Indicates whether running Spot Instances should be terminated if you decrease the
    /// target capacity of the Spot Fleet request below the current size of the Spot
    /// Fleet.</p>
    pub excess_capacity_termination_policy:
        std::option::Option<crate::model::ExcessCapacityTerminationPolicy>,
    /// <p>The number of units fulfilled by this request compared to the set target capacity. You
    /// cannot set this value.</p>
    pub fulfilled_capacity: std::option::Option<f64>,
    /// <p>The number of On-Demand units fulfilled by this request compared to the set target
    /// On-Demand capacity.</p>
    pub on_demand_fulfilled_capacity: std::option::Option<f64>,
    /// <p>The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that
    /// grants the Spot Fleet the permission to request, launch, terminate, and tag instances on
    /// your behalf. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites">Spot
    /// Fleet prerequisites</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>. Spot Fleet
    /// can terminate Spot Instances on your behalf when you cancel its Spot Fleet request using
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CancelSpotFleetRequests">CancelSpotFleetRequests</a> or when the Spot Fleet request expires, if you set
    /// <code>TerminateInstancesWithExpiration</code>.</p>
    pub iam_fleet_role: std::option::Option<std::string::String>,
    /// <p>The launch specifications for the Spot Fleet request. If you specify
    /// <code>LaunchSpecifications</code>, you can't specify
    /// <code>LaunchTemplateConfigs</code>. If you include On-Demand capacity in your
    /// request, you must use <code>LaunchTemplateConfigs</code>.</p>
    pub launch_specifications:
        std::option::Option<std::vec::Vec<crate::model::SpotFleetLaunchSpecification>>,
    /// <p>The launch template and overrides. If you specify <code>LaunchTemplateConfigs</code>,
    /// you can't specify <code>LaunchSpecifications</code>. If you include On-Demand capacity
    /// in your request, you must use <code>LaunchTemplateConfigs</code>.</p>
    pub launch_template_configs:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateConfig>>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. The
    /// default is the On-Demand price.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The number of units to request for the Spot Fleet. You can choose to set the target
    /// capacity in terms of instances or a performance characteristic that is important to your
    /// application workload, such as vCPUs, memory, or I/O. If the request type is
    /// <code>maintain</code>, you can specify a target capacity of 0 and add capacity
    /// later.</p>
    pub target_capacity: std::option::Option<i32>,
    /// <p>The number of On-Demand units to request. You can choose to set the target capacity in
    /// terms of instances or a performance characteristic that is important to your application
    /// workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>,
    /// you can specify a target capacity of 0 and add capacity later.</p>
    pub on_demand_target_capacity: std::option::Option<i32>,
    /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay. You
    /// can use the <code>onDemandMaxTotalPrice</code> parameter, the
    /// <code>spotMaxTotalPrice</code> parameter, or both parameters to ensure that your
    /// fleet cost does not exceed your budget. If you set a maximum price per hour for the
    /// On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the
    /// maximum amount you're willing to pay. When the maximum amount you're willing to pay is
    /// reached, the fleet stops launching instances even if it hasn’t met the target
    /// capacity.</p>
    pub on_demand_max_total_price: std::option::Option<std::string::String>,
    /// <p>The maximum amount per hour for Spot Instances that you're willing to pay. You can use
    /// the <code>spotdMaxTotalPrice</code> parameter, the <code>onDemandMaxTotalPrice</code>
    /// parameter, or both parameters to ensure that your fleet cost does not exceed your
    /// budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request,
    /// Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay.
    /// When the maximum amount you're willing to pay is reached, the fleet stops launching
    /// instances even if it hasn’t met the target capacity.</p>
    pub spot_max_total_price: std::option::Option<std::string::String>,
    /// <p>Indicates whether running Spot Instances are terminated when the Spot Fleet request
    /// expires.</p>
    pub terminate_instances_with_expiration: std::option::Option<bool>,
    /// <p>The type of request. Indicates whether the Spot Fleet only requests the target
    /// capacity or also attempts to maintain it. When this value is <code>request</code>, the
    /// Spot Fleet only places the required requests. It does not attempt to replenish Spot
    /// Instances if capacity is diminished, nor does it submit requests in alternative Spot
    /// pools if capacity is not available. When this value is <code>maintain</code>, the Spot
    /// Fleet maintains the target capacity. The Spot Fleet places the required requests to meet
    /// capacity and automatically replenishes any interrupted instances. Default:
    /// <code>maintain</code>. <code>instant</code> is listed but is not used by Spot
    /// Fleet.</p>
    pub r#type: std::option::Option<crate::model::FleetType>,
    /// <p>The start date and time of the request, in UTC format
    /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// By default, Amazon EC2 starts fulfilling the request immediately.</p>
    pub valid_from: std::option::Option<smithy_types::Instant>,
    /// <p>The end date and time of the request, in UTC format
    /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// After the end date and time, no new Spot Instance requests are placed or able to fulfill
    /// the request. If no value is specified, the Spot Fleet request remains until you cancel
    /// it.</p>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates whether Spot Fleet should replace unhealthy instances.</p>
    pub replace_unhealthy_instances: std::option::Option<bool>,
    /// <p>The behavior when a Spot Instance is interrupted. The default is
    /// <code>terminate</code>.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::InstanceInterruptionBehavior>,
    /// <p>One or more Classic Load Balancers and target groups to attach to the Spot Fleet
    /// request. Spot Fleet registers the running Spot Instances with the specified Classic Load
    /// Balancers and target groups.</p>
    /// <p>With Network Load Balancers, Spot Fleet cannot register instances that have the
    /// following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2,
    /// M3, and T1.</p>
    pub load_balancers_config: std::option::Option<crate::model::LoadBalancersConfig>,
    /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid
    /// only when Spot <b>AllocationStrategy</b> is set to
    /// <code>lowest-price</code>. Spot Fleet selects the cheapest Spot pools and evenly
    /// allocates your target Spot capacity across the number of Spot pools that you
    /// specify.</p>
    /// <p>Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a
    /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
    /// capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest
    /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
    /// the number of pools that you specified. Similarly, if most of the pools have no Spot
    /// capacity, you might receive your full target capacity from fewer than the number of
    /// pools that you specified.</p>
    pub instance_pools_to_use_count: std::option::Option<i32>,
    /// <p>Reserved.</p>
    pub context: std::option::Option<std::string::String>,
    /// <p>The key-value pair for tagging the Spot Fleet request on creation. The value for
    /// <code>ResourceType</code> must be <code>spot-fleet-request</code>, otherwise the
    /// Spot Fleet request fails. To tag instances at launch, specify the tags in the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template">launch
    /// template</a> (valid only if you use <code>LaunchTemplateConfigs</code>) or in
    /// the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html">
    /// <code>SpotFleetTagSpecification</code>
    /// </a> (valid only if you use
    /// <code>LaunchSpecifications</code>). For information about tagging after launch, see
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources">Tagging Your Resources</a>.</p>
    pub tag_specifications: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
}
impl std::fmt::Debug for SpotFleetRequestConfigData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetRequestConfigData");
        formatter.field("allocation_strategy", &self.allocation_strategy);
        formatter.field(
            "on_demand_allocation_strategy",
            &self.on_demand_allocation_strategy,
        );
        formatter.field(
            "spot_maintenance_strategies",
            &self.spot_maintenance_strategies,
        );
        formatter.field("client_token", &self.client_token);
        formatter.field(
            "excess_capacity_termination_policy",
            &self.excess_capacity_termination_policy,
        );
        formatter.field("fulfilled_capacity", &self.fulfilled_capacity);
        formatter.field(
            "on_demand_fulfilled_capacity",
            &self.on_demand_fulfilled_capacity,
        );
        formatter.field("iam_fleet_role", &self.iam_fleet_role);
        formatter.field("launch_specifications", &self.launch_specifications);
        formatter.field("launch_template_configs", &self.launch_template_configs);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("target_capacity", &self.target_capacity);
        formatter.field("on_demand_target_capacity", &self.on_demand_target_capacity);
        formatter.field("on_demand_max_total_price", &self.on_demand_max_total_price);
        formatter.field("spot_max_total_price", &self.spot_max_total_price);
        formatter.field(
            "terminate_instances_with_expiration",
            &self.terminate_instances_with_expiration,
        );
        formatter.field("r#type", &self.r#type);
        formatter.field("valid_from", &self.valid_from);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "replace_unhealthy_instances",
            &self.replace_unhealthy_instances,
        );
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.field("load_balancers_config", &self.load_balancers_config);
        formatter.field(
            "instance_pools_to_use_count",
            &self.instance_pools_to_use_count,
        );
        formatter.field("context", &self.context);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.finish()
    }
}
/// See [`SpotFleetRequestConfigData`](crate::model::SpotFleetRequestConfigData)
pub mod spot_fleet_request_config_data {
    /// A builder for [`SpotFleetRequestConfigData`](crate::model::SpotFleetRequestConfigData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_strategy: std::option::Option<crate::model::AllocationStrategy>,
        pub(crate) on_demand_allocation_strategy:
            std::option::Option<crate::model::OnDemandAllocationStrategy>,
        pub(crate) spot_maintenance_strategies:
            std::option::Option<crate::model::SpotMaintenanceStrategies>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) excess_capacity_termination_policy:
            std::option::Option<crate::model::ExcessCapacityTerminationPolicy>,
        pub(crate) fulfilled_capacity: std::option::Option<f64>,
        pub(crate) on_demand_fulfilled_capacity: std::option::Option<f64>,
        pub(crate) iam_fleet_role: std::option::Option<std::string::String>,
        pub(crate) launch_specifications:
            std::option::Option<std::vec::Vec<crate::model::SpotFleetLaunchSpecification>>,
        pub(crate) launch_template_configs:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateConfig>>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) target_capacity: std::option::Option<i32>,
        pub(crate) on_demand_target_capacity: std::option::Option<i32>,
        pub(crate) on_demand_max_total_price: std::option::Option<std::string::String>,
        pub(crate) spot_max_total_price: std::option::Option<std::string::String>,
        pub(crate) terminate_instances_with_expiration: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<crate::model::FleetType>,
        pub(crate) valid_from: std::option::Option<smithy_types::Instant>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) replace_unhealthy_instances: std::option::Option<bool>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::InstanceInterruptionBehavior>,
        pub(crate) load_balancers_config: std::option::Option<crate::model::LoadBalancersConfig>,
        pub(crate) instance_pools_to_use_count: std::option::Option<i32>,
        pub(crate) context: std::option::Option<std::string::String>,
        pub(crate) tag_specifications:
            std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
    }
    impl Builder {
        /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
        /// the Spot Fleet request.</p>
        /// <p>If the allocation strategy is <code>lowestPrice</code>, Spot Fleet launches instances from
        /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
        /// <p>If the allocation strategy is <code>diversified</code>, Spot Fleet launches instances from
        /// all the Spot Instance pools that you specify.</p>
        /// <p>If the allocation strategy is <code>capacityOptimized</code> (recommended), Spot Fleet
        /// launches instances from Spot Instance pools with optimal capacity for the number of instances
        /// that are launching. To give certain instance types a higher chance of launching first,
        /// use <code>capacityOptimizedPrioritized</code>. Set a priority for each instance type by
        /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You
        /// can assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2
        /// implements the priorities on a best-effort basis, but optimizes for capacity first.
        /// <code>capacityOptimizedPrioritized</code> is supported only if your Spot Fleet uses a
        /// launch template. Note that if the <code>OnDemandAllocationStrategy</code> is set to
        /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
        /// capacity.</p>
        pub fn allocation_strategy(mut self, input: crate::model::AllocationStrategy) -> Self {
            self.allocation_strategy = Some(input);
            self
        }
        pub fn set_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::AllocationStrategy>,
        ) -> Self {
            self.allocation_strategy = input;
            self
        }
        /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
        /// you specify <code>lowestPrice</code>, Spot Fleet uses price to determine the order, launching
        /// the lowest price first. If you specify <code>prioritized</code>, Spot Fleet uses the priority
        /// that you assign to each Spot Fleet launch template override, launching the highest priority
        /// first. If you do not specify a value, Spot Fleet defaults to <code>lowestPrice</code>.</p>
        pub fn on_demand_allocation_strategy(
            mut self,
            input: crate::model::OnDemandAllocationStrategy,
        ) -> Self {
            self.on_demand_allocation_strategy = Some(input);
            self
        }
        pub fn set_on_demand_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::OnDemandAllocationStrategy>,
        ) -> Self {
            self.on_demand_allocation_strategy = input;
            self
        }
        /// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
        /// interrupted.</p>
        pub fn spot_maintenance_strategies(
            mut self,
            input: crate::model::SpotMaintenanceStrategies,
        ) -> Self {
            self.spot_maintenance_strategies = Some(input);
            self
        }
        pub fn set_spot_maintenance_strategies(
            mut self,
            input: std::option::Option<crate::model::SpotMaintenanceStrategies>,
        ) -> Self {
            self.spot_maintenance_strategies = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of your
        /// listings. This helps to avoid duplicate listings. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>Indicates whether running Spot Instances should be terminated if you decrease the
        /// target capacity of the Spot Fleet request below the current size of the Spot
        /// Fleet.</p>
        pub fn excess_capacity_termination_policy(
            mut self,
            input: crate::model::ExcessCapacityTerminationPolicy,
        ) -> Self {
            self.excess_capacity_termination_policy = Some(input);
            self
        }
        pub fn set_excess_capacity_termination_policy(
            mut self,
            input: std::option::Option<crate::model::ExcessCapacityTerminationPolicy>,
        ) -> Self {
            self.excess_capacity_termination_policy = input;
            self
        }
        /// <p>The number of units fulfilled by this request compared to the set target capacity. You
        /// cannot set this value.</p>
        pub fn fulfilled_capacity(mut self, input: f64) -> Self {
            self.fulfilled_capacity = Some(input);
            self
        }
        pub fn set_fulfilled_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.fulfilled_capacity = input;
            self
        }
        /// <p>The number of On-Demand units fulfilled by this request compared to the set target
        /// On-Demand capacity.</p>
        pub fn on_demand_fulfilled_capacity(mut self, input: f64) -> Self {
            self.on_demand_fulfilled_capacity = Some(input);
            self
        }
        pub fn set_on_demand_fulfilled_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.on_demand_fulfilled_capacity = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that
        /// grants the Spot Fleet the permission to request, launch, terminate, and tag instances on
        /// your behalf. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites">Spot
        /// Fleet prerequisites</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>. Spot Fleet
        /// can terminate Spot Instances on your behalf when you cancel its Spot Fleet request using
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CancelSpotFleetRequests">CancelSpotFleetRequests</a> or when the Spot Fleet request expires, if you set
        /// <code>TerminateInstancesWithExpiration</code>.</p>
        pub fn iam_fleet_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_fleet_role = Some(input.into());
            self
        }
        pub fn set_iam_fleet_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_fleet_role = input;
            self
        }
        pub fn launch_specifications(
            mut self,
            input: impl Into<crate::model::SpotFleetLaunchSpecification>,
        ) -> Self {
            let mut v = self.launch_specifications.unwrap_or_default();
            v.push(input.into());
            self.launch_specifications = Some(v);
            self
        }
        pub fn set_launch_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SpotFleetLaunchSpecification>>,
        ) -> Self {
            self.launch_specifications = input;
            self
        }
        pub fn launch_template_configs(
            mut self,
            input: impl Into<crate::model::LaunchTemplateConfig>,
        ) -> Self {
            let mut v = self.launch_template_configs.unwrap_or_default();
            v.push(input.into());
            self.launch_template_configs = Some(v);
            self
        }
        pub fn set_launch_template_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateConfig>>,
        ) -> Self {
            self.launch_template_configs = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. The
        /// default is the On-Demand price.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The number of units to request for the Spot Fleet. You can choose to set the target
        /// capacity in terms of instances or a performance characteristic that is important to your
        /// application workload, such as vCPUs, memory, or I/O. If the request type is
        /// <code>maintain</code>, you can specify a target capacity of 0 and add capacity
        /// later.</p>
        pub fn target_capacity(mut self, input: i32) -> Self {
            self.target_capacity = Some(input);
            self
        }
        pub fn set_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.target_capacity = input;
            self
        }
        /// <p>The number of On-Demand units to request. You can choose to set the target capacity in
        /// terms of instances or a performance characteristic that is important to your application
        /// workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>,
        /// you can specify a target capacity of 0 and add capacity later.</p>
        pub fn on_demand_target_capacity(mut self, input: i32) -> Self {
            self.on_demand_target_capacity = Some(input);
            self
        }
        pub fn set_on_demand_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.on_demand_target_capacity = input;
            self
        }
        /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay. You
        /// can use the <code>onDemandMaxTotalPrice</code> parameter, the
        /// <code>spotMaxTotalPrice</code> parameter, or both parameters to ensure that your
        /// fleet cost does not exceed your budget. If you set a maximum price per hour for the
        /// On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the
        /// maximum amount you're willing to pay. When the maximum amount you're willing to pay is
        /// reached, the fleet stops launching instances even if it hasn’t met the target
        /// capacity.</p>
        pub fn on_demand_max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_max_total_price = Some(input.into());
            self
        }
        pub fn set_on_demand_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_max_total_price = input;
            self
        }
        /// <p>The maximum amount per hour for Spot Instances that you're willing to pay. You can use
        /// the <code>spotdMaxTotalPrice</code> parameter, the <code>onDemandMaxTotalPrice</code>
        /// parameter, or both parameters to ensure that your fleet cost does not exceed your
        /// budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request,
        /// Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay.
        /// When the maximum amount you're willing to pay is reached, the fleet stops launching
        /// instances even if it hasn’t met the target capacity.</p>
        pub fn spot_max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_max_total_price = Some(input.into());
            self
        }
        pub fn set_spot_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_max_total_price = input;
            self
        }
        /// <p>Indicates whether running Spot Instances are terminated when the Spot Fleet request
        /// expires.</p>
        pub fn terminate_instances_with_expiration(mut self, input: bool) -> Self {
            self.terminate_instances_with_expiration = Some(input);
            self
        }
        pub fn set_terminate_instances_with_expiration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.terminate_instances_with_expiration = input;
            self
        }
        /// <p>The type of request. Indicates whether the Spot Fleet only requests the target
        /// capacity or also attempts to maintain it. When this value is <code>request</code>, the
        /// Spot Fleet only places the required requests. It does not attempt to replenish Spot
        /// Instances if capacity is diminished, nor does it submit requests in alternative Spot
        /// pools if capacity is not available. When this value is <code>maintain</code>, the Spot
        /// Fleet maintains the target capacity. The Spot Fleet places the required requests to meet
        /// capacity and automatically replenishes any interrupted instances. Default:
        /// <code>maintain</code>. <code>instant</code> is listed but is not used by Spot
        /// Fleet.</p>
        pub fn r#type(mut self, input: crate::model::FleetType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::FleetType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The start date and time of the request, in UTC format
        /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// By default, Amazon EC2 starts fulfilling the request immediately.</p>
        pub fn valid_from(mut self, input: smithy_types::Instant) -> Self {
            self.valid_from = Some(input);
            self
        }
        pub fn set_valid_from(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.valid_from = input;
            self
        }
        /// <p>The end date and time of the request, in UTC format
        /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// After the end date and time, no new Spot Instance requests are placed or able to fulfill
        /// the request. If no value is specified, the Spot Fleet request remains until you cancel
        /// it.</p>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>Indicates whether Spot Fleet should replace unhealthy instances.</p>
        pub fn replace_unhealthy_instances(mut self, input: bool) -> Self {
            self.replace_unhealthy_instances = Some(input);
            self
        }
        pub fn set_replace_unhealthy_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.replace_unhealthy_instances = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is
        /// <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// <p>One or more Classic Load Balancers and target groups to attach to the Spot Fleet
        /// request. Spot Fleet registers the running Spot Instances with the specified Classic Load
        /// Balancers and target groups.</p>
        /// <p>With Network Load Balancers, Spot Fleet cannot register instances that have the
        /// following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2,
        /// M3, and T1.</p>
        pub fn load_balancers_config(mut self, input: crate::model::LoadBalancersConfig) -> Self {
            self.load_balancers_config = Some(input);
            self
        }
        pub fn set_load_balancers_config(
            mut self,
            input: std::option::Option<crate::model::LoadBalancersConfig>,
        ) -> Self {
            self.load_balancers_config = input;
            self
        }
        /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid
        /// only when Spot <b>AllocationStrategy</b> is set to
        /// <code>lowest-price</code>. Spot Fleet selects the cheapest Spot pools and evenly
        /// allocates your target Spot capacity across the number of Spot pools that you
        /// specify.</p>
        /// <p>Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a
        /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
        /// capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest
        /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
        /// the number of pools that you specified. Similarly, if most of the pools have no Spot
        /// capacity, you might receive your full target capacity from fewer than the number of
        /// pools that you specified.</p>
        pub fn instance_pools_to_use_count(mut self, input: i32) -> Self {
            self.instance_pools_to_use_count = Some(input);
            self
        }
        pub fn set_instance_pools_to_use_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_pools_to_use_count = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        pub fn tag_specifications(
            mut self,
            input: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            let mut v = self.tag_specifications.unwrap_or_default();
            v.push(input.into());
            self.tag_specifications = Some(v);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.tag_specifications = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotFleetRequestConfigData`](crate::model::SpotFleetRequestConfigData)
        pub fn build(self) -> crate::model::SpotFleetRequestConfigData {
            crate::model::SpotFleetRequestConfigData {
                allocation_strategy: self.allocation_strategy,
                on_demand_allocation_strategy: self.on_demand_allocation_strategy,
                spot_maintenance_strategies: self.spot_maintenance_strategies,
                client_token: self.client_token,
                excess_capacity_termination_policy: self.excess_capacity_termination_policy,
                fulfilled_capacity: self.fulfilled_capacity,
                on_demand_fulfilled_capacity: self.on_demand_fulfilled_capacity,
                iam_fleet_role: self.iam_fleet_role,
                launch_specifications: self.launch_specifications,
                launch_template_configs: self.launch_template_configs,
                spot_price: self.spot_price,
                target_capacity: self.target_capacity,
                on_demand_target_capacity: self.on_demand_target_capacity,
                on_demand_max_total_price: self.on_demand_max_total_price,
                spot_max_total_price: self.spot_max_total_price,
                terminate_instances_with_expiration: self.terminate_instances_with_expiration,
                r#type: self.r#type,
                valid_from: self.valid_from,
                valid_until: self.valid_until,
                replace_unhealthy_instances: self.replace_unhealthy_instances,
                instance_interruption_behavior: self.instance_interruption_behavior,
                load_balancers_config: self.load_balancers_config,
                instance_pools_to_use_count: self.instance_pools_to_use_count,
                context: self.context,
                tag_specifications: self.tag_specifications,
            }
        }
    }
}
impl SpotFleetRequestConfigData {
    /// Creates a new builder-style object to manufacture [`SpotFleetRequestConfigData`](crate::model::SpotFleetRequestConfigData)
    pub fn builder() -> crate::model::spot_fleet_request_config_data::Builder {
        crate::model::spot_fleet_request_config_data::Builder::default()
    }
}

/// <p>Describes the Classic Load Balancers and target groups to attach to a Spot Fleet
/// request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadBalancersConfig {
    /// <p>The Classic Load Balancers.</p>
    pub classic_load_balancers_config:
        std::option::Option<crate::model::ClassicLoadBalancersConfig>,
    /// <p>The target groups.</p>
    pub target_groups_config: std::option::Option<crate::model::TargetGroupsConfig>,
}
impl std::fmt::Debug for LoadBalancersConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadBalancersConfig");
        formatter.field(
            "classic_load_balancers_config",
            &self.classic_load_balancers_config,
        );
        formatter.field("target_groups_config", &self.target_groups_config);
        formatter.finish()
    }
}
/// See [`LoadBalancersConfig`](crate::model::LoadBalancersConfig)
pub mod load_balancers_config {
    /// A builder for [`LoadBalancersConfig`](crate::model::LoadBalancersConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classic_load_balancers_config:
            std::option::Option<crate::model::ClassicLoadBalancersConfig>,
        pub(crate) target_groups_config: std::option::Option<crate::model::TargetGroupsConfig>,
    }
    impl Builder {
        /// <p>The Classic Load Balancers.</p>
        pub fn classic_load_balancers_config(
            mut self,
            input: crate::model::ClassicLoadBalancersConfig,
        ) -> Self {
            self.classic_load_balancers_config = Some(input);
            self
        }
        pub fn set_classic_load_balancers_config(
            mut self,
            input: std::option::Option<crate::model::ClassicLoadBalancersConfig>,
        ) -> Self {
            self.classic_load_balancers_config = input;
            self
        }
        /// <p>The target groups.</p>
        pub fn target_groups_config(mut self, input: crate::model::TargetGroupsConfig) -> Self {
            self.target_groups_config = Some(input);
            self
        }
        pub fn set_target_groups_config(
            mut self,
            input: std::option::Option<crate::model::TargetGroupsConfig>,
        ) -> Self {
            self.target_groups_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadBalancersConfig`](crate::model::LoadBalancersConfig)
        pub fn build(self) -> crate::model::LoadBalancersConfig {
            crate::model::LoadBalancersConfig {
                classic_load_balancers_config: self.classic_load_balancers_config,
                target_groups_config: self.target_groups_config,
            }
        }
    }
}
impl LoadBalancersConfig {
    /// Creates a new builder-style object to manufacture [`LoadBalancersConfig`](crate::model::LoadBalancersConfig)
    pub fn builder() -> crate::model::load_balancers_config::Builder {
        crate::model::load_balancers_config::Builder::default()
    }
}

/// <p>Describes the target groups to attach to a Spot Fleet. Spot Fleet registers the
/// running Spot Instances with these target groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetGroupsConfig {
    /// <p>One or more target groups.</p>
    pub target_groups: std::option::Option<std::vec::Vec<crate::model::TargetGroup>>,
}
impl std::fmt::Debug for TargetGroupsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetGroupsConfig");
        formatter.field("target_groups", &self.target_groups);
        formatter.finish()
    }
}
/// See [`TargetGroupsConfig`](crate::model::TargetGroupsConfig)
pub mod target_groups_config {
    /// A builder for [`TargetGroupsConfig`](crate::model::TargetGroupsConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_groups: std::option::Option<std::vec::Vec<crate::model::TargetGroup>>,
    }
    impl Builder {
        pub fn target_groups(mut self, input: impl Into<crate::model::TargetGroup>) -> Self {
            let mut v = self.target_groups.unwrap_or_default();
            v.push(input.into());
            self.target_groups = Some(v);
            self
        }
        pub fn set_target_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetGroup>>,
        ) -> Self {
            self.target_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetGroupsConfig`](crate::model::TargetGroupsConfig)
        pub fn build(self) -> crate::model::TargetGroupsConfig {
            crate::model::TargetGroupsConfig {
                target_groups: self.target_groups,
            }
        }
    }
}
impl TargetGroupsConfig {
    /// Creates a new builder-style object to manufacture [`TargetGroupsConfig`](crate::model::TargetGroupsConfig)
    pub fn builder() -> crate::model::target_groups_config::Builder {
        crate::model::target_groups_config::Builder::default()
    }
}

/// <p>Describes a load balancer target group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetGroup {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetGroup");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TargetGroup`](crate::model::TargetGroup)
pub mod target_group {
    /// A builder for [`TargetGroup`](crate::model::TargetGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetGroup`](crate::model::TargetGroup)
        pub fn build(self) -> crate::model::TargetGroup {
            crate::model::TargetGroup { arn: self.arn }
        }
    }
}
impl TargetGroup {
    /// Creates a new builder-style object to manufacture [`TargetGroup`](crate::model::TargetGroup)
    pub fn builder() -> crate::model::target_group::Builder {
        crate::model::target_group::Builder::default()
    }
}

/// <p>Describes the Classic Load Balancers to attach to a Spot Fleet. Spot Fleet registers
/// the running Spot Instances with these Classic Load Balancers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassicLoadBalancersConfig {
    /// <p>One or more Classic Load Balancers.</p>
    pub classic_load_balancers:
        std::option::Option<std::vec::Vec<crate::model::ClassicLoadBalancer>>,
}
impl std::fmt::Debug for ClassicLoadBalancersConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassicLoadBalancersConfig");
        formatter.field("classic_load_balancers", &self.classic_load_balancers);
        formatter.finish()
    }
}
/// See [`ClassicLoadBalancersConfig`](crate::model::ClassicLoadBalancersConfig)
pub mod classic_load_balancers_config {
    /// A builder for [`ClassicLoadBalancersConfig`](crate::model::ClassicLoadBalancersConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classic_load_balancers:
            std::option::Option<std::vec::Vec<crate::model::ClassicLoadBalancer>>,
    }
    impl Builder {
        pub fn classic_load_balancers(
            mut self,
            input: impl Into<crate::model::ClassicLoadBalancer>,
        ) -> Self {
            let mut v = self.classic_load_balancers.unwrap_or_default();
            v.push(input.into());
            self.classic_load_balancers = Some(v);
            self
        }
        pub fn set_classic_load_balancers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClassicLoadBalancer>>,
        ) -> Self {
            self.classic_load_balancers = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassicLoadBalancersConfig`](crate::model::ClassicLoadBalancersConfig)
        pub fn build(self) -> crate::model::ClassicLoadBalancersConfig {
            crate::model::ClassicLoadBalancersConfig {
                classic_load_balancers: self.classic_load_balancers,
            }
        }
    }
}
impl ClassicLoadBalancersConfig {
    /// Creates a new builder-style object to manufacture [`ClassicLoadBalancersConfig`](crate::model::ClassicLoadBalancersConfig)
    pub fn builder() -> crate::model::classic_load_balancers_config::Builder {
        crate::model::classic_load_balancers_config::Builder::default()
    }
}

/// <p>Describes a Classic Load Balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassicLoadBalancer {
    /// <p>The name of the load balancer.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClassicLoadBalancer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassicLoadBalancer");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`ClassicLoadBalancer`](crate::model::ClassicLoadBalancer)
pub mod classic_load_balancer {
    /// A builder for [`ClassicLoadBalancer`](crate::model::ClassicLoadBalancer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassicLoadBalancer`](crate::model::ClassicLoadBalancer)
        pub fn build(self) -> crate::model::ClassicLoadBalancer {
            crate::model::ClassicLoadBalancer { name: self.name }
        }
    }
}
impl ClassicLoadBalancer {
    /// Creates a new builder-style object to manufacture [`ClassicLoadBalancer`](crate::model::ClassicLoadBalancer)
    pub fn builder() -> crate::model::classic_load_balancer::Builder {
        crate::model::classic_load_balancer::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetType {
    Instant,
    Maintain,
    Request,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetType {
    fn from(s: &str) -> Self {
        match s {
            "instant" => FleetType::Instant,
            "maintain" => FleetType::Maintain,
            "request" => FleetType::Request,
            other => FleetType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetType::from(s))
    }
}
impl FleetType {
    pub fn as_str(&self) -> &str {
        match self {
            FleetType::Instant => "instant",
            FleetType::Maintain => "maintain",
            FleetType::Request => "request",
            FleetType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["instant", "maintain", "request"]
    }
}
impl AsRef<str> for FleetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a launch template and overrides.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateConfig {
    /// <p>The launch template.</p>
    pub launch_template_specification:
        std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
    /// <p>Any parameters that you specify override the same parameters in the launch
    /// template.</p>
    pub overrides: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
}
impl std::fmt::Debug for LaunchTemplateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateConfig");
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`LaunchTemplateConfig`](crate::model::LaunchTemplateConfig)
pub mod launch_template_config {
    /// A builder for [`LaunchTemplateConfig`](crate::model::LaunchTemplateConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        pub(crate) overrides:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
    }
    impl Builder {
        /// <p>The launch template.</p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::FleetLaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        pub fn overrides(
            mut self,
            input: impl Into<crate::model::LaunchTemplateOverrides>,
        ) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input.into());
            self.overrides = Some(v);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateConfig`](crate::model::LaunchTemplateConfig)
        pub fn build(self) -> crate::model::LaunchTemplateConfig {
            crate::model::LaunchTemplateConfig {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl LaunchTemplateConfig {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateConfig`](crate::model::LaunchTemplateConfig)
    pub fn builder() -> crate::model::launch_template_config::Builder {
        crate::model::launch_template_config::Builder::default()
    }
}

/// <p>Describes overrides for a launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateOverrides {
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot
    /// Instance.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet in which to launch the instances.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which to launch the instances.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of units provided by the specified instance type.</p>
    pub weighted_capacity: std::option::Option<f64>,
    /// <p>The priority for the launch template override. The highest priority is launched
    /// first.</p>
    /// <p>If <code>OnDemandAllocationStrategy</code> is set to <code>prioritized</code>, Spot Fleet
    /// uses priority to determine which launch template override to use first in fulfilling
    /// On-Demand capacity.</p>
    /// <p>If the Spot <code>AllocationStrategy</code> is set to
    /// <code>capacityOptimizedPrioritized</code>, Spot Fleet uses priority on a best-effort basis
    /// to determine which launch template override to use in fulfilling Spot capacity, but
    /// optimizes for capacity first.</p>
    /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
    /// higher the priority. If no number is set, the launch template override has the lowest
    /// priority. You can set the same priority for different launch template overrides.</p>
    pub priority: std::option::Option<f64>,
}
impl std::fmt::Debug for LaunchTemplateOverrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateOverrides");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("priority", &self.priority);
        formatter.finish()
    }
}
/// See [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
pub mod launch_template_overrides {
    /// A builder for [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<f64>,
        pub(crate) priority: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot
        /// Instance.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The ID of the subnet in which to launch the instances.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Availability Zone in which to launch the instances.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of units provided by the specified instance type.</p>
        pub fn weighted_capacity(mut self, input: f64) -> Self {
            self.weighted_capacity = Some(input);
            self
        }
        pub fn set_weighted_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// <p>The priority for the launch template override. The highest priority is launched
        /// first.</p>
        /// <p>If <code>OnDemandAllocationStrategy</code> is set to <code>prioritized</code>, Spot Fleet
        /// uses priority to determine which launch template override to use first in fulfilling
        /// On-Demand capacity.</p>
        /// <p>If the Spot <code>AllocationStrategy</code> is set to
        /// <code>capacityOptimizedPrioritized</code>, Spot Fleet uses priority on a best-effort basis
        /// to determine which launch template override to use in fulfilling Spot capacity, but
        /// optimizes for capacity first.</p>
        /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
        /// higher the priority. If no number is set, the launch template override has the lowest
        /// priority. You can set the same priority for different launch template overrides.</p>
        pub fn priority(mut self, input: f64) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<f64>) -> Self {
            self.priority = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
        pub fn build(self) -> crate::model::LaunchTemplateOverrides {
            crate::model::LaunchTemplateOverrides {
                instance_type: self.instance_type,
                spot_price: self.spot_price,
                subnet_id: self.subnet_id,
                availability_zone: self.availability_zone,
                weighted_capacity: self.weighted_capacity,
                priority: self.priority,
            }
        }
    }
}
impl LaunchTemplateOverrides {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
    pub fn builder() -> crate::model::launch_template_overrides::Builder {
        crate::model::launch_template_overrides::Builder::default()
    }
}

/// <p>Describes the Amazon EC2 launch template and the launch template version that can be used
/// by a Spot Fleet request to configure Amazon EC2 instances. For information about launch templates,
/// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html">Launching an instance from a launch template</a> in the
/// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateSpecification {
    /// <p>The ID of the launch template. If you specify the template ID, you can't specify the
    /// template name.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template. If you specify the template name, you can't specify
    /// the template ID.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The launch template version number, <code>$Latest</code>, or <code>$Default</code>.
    /// You must specify a value, otherwise the request fails.</p>
    /// <p>If the value is <code>$Latest</code>, Amazon EC2 uses the latest version of the launch
    /// template.</p>
    /// <p>If the value is <code>$Default</code>, Amazon EC2 uses the default version of the launch
    /// template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FleetLaunchTemplateSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateSpecification");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateSpecification`](crate::model::FleetLaunchTemplateSpecification)
pub mod fleet_launch_template_specification {
    /// A builder for [`FleetLaunchTemplateSpecification`](crate::model::FleetLaunchTemplateSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the launch template. If you specify the template ID, you can't specify the
        /// template name.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template. If you specify the template name, you can't specify
        /// the template ID.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The launch template version number, <code>$Latest</code>, or <code>$Default</code>.
        /// You must specify a value, otherwise the request fails.</p>
        /// <p>If the value is <code>$Latest</code>, Amazon EC2 uses the latest version of the launch
        /// template.</p>
        /// <p>If the value is <code>$Default</code>, Amazon EC2 uses the default version of the launch
        /// template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateSpecification`](crate::model::FleetLaunchTemplateSpecification)
        pub fn build(self) -> crate::model::FleetLaunchTemplateSpecification {
            crate::model::FleetLaunchTemplateSpecification {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version: self.version,
            }
        }
    }
}
impl FleetLaunchTemplateSpecification {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateSpecification`](crate::model::FleetLaunchTemplateSpecification)
    pub fn builder() -> crate::model::fleet_launch_template_specification::Builder {
        crate::model::fleet_launch_template_specification::Builder::default()
    }
}

/// <p>Describes the launch specification for one or more Spot Instances. If you include
/// On-Demand capacity in your fleet request or want to specify an EFA network device, you
/// can't use <code>SpotFleetLaunchSpecification</code>; you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotFleetLaunchSpecification {
    /// <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
    pub security_groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>Deprecated.</p>
    pub addressing_type: std::option::Option<std::string::String>,
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both
    /// a snapshot ID and an encryption value. This is because only blank volumes can be
    /// encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its
    /// encryption status is used for the volume encryption status.</p>
    pub block_device_mappings: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile: std::option::Option<crate::model::IamInstanceProfileSpecification>,
    /// <p>The ID of the AMI.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The ID of the kernel.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>Enable or disable monitoring for the instances.</p>
    pub monitoring: std::option::Option<crate::model::SpotFleetMonitoring>,
    /// <p>One or more network interfaces. If you specify a network interface, you must specify
    /// subnet IDs and security group IDs using the network interface.</p>
    /// <note>
    /// <p>
    /// <code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    pub network_interfaces:
        std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
    /// <p>The placement information.</p>
    pub placement: std::option::Option<crate::model::SpotPlacement>,
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel
    /// requirements for information about whether you need to specify a RAM disk. To find kernel
    /// requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.
    /// If this value is not specified, the default is the Spot price specified for the fleet.
    /// To determine the Spot price per unit hour, divide the Spot price by the
    /// value of <code>WeightedCapacity</code>.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate
    /// them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Base64-encoded user data that instances use when starting up.</p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub weighted_capacity: std::option::Option<f64>,
    /// <p>The tags to apply during creation.</p>
    pub tag_specifications:
        std::option::Option<std::vec::Vec<crate::model::SpotFleetTagSpecification>>,
}
impl std::fmt::Debug for SpotFleetLaunchSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetLaunchSpecification");
        formatter.field("security_groups", &self.security_groups);
        formatter.field("addressing_type", &self.addressing_type);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &self.user_data);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.finish()
    }
}
/// See [`SpotFleetLaunchSpecification`](crate::model::SpotFleetLaunchSpecification)
pub mod spot_fleet_launch_specification {
    /// A builder for [`SpotFleetLaunchSpecification`](crate::model::SpotFleetLaunchSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_groups:
            std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) addressing_type: std::option::Option<std::string::String>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::IamInstanceProfileSpecification>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::SpotFleetMonitoring>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>>,
        pub(crate) placement: std::option::Option<crate::model::SpotPlacement>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<f64>,
        pub(crate) tag_specifications:
            std::option::Option<std::vec::Vec<crate::model::SpotFleetTagSpecification>>,
    }
    impl Builder {
        pub fn security_groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Deprecated.</p>
        pub fn addressing_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.addressing_type = Some(input.into());
            self
        }
        pub fn set_addressing_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.addressing_type = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the kernel.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>Enable or disable monitoring for the instances.</p>
        pub fn monitoring(mut self, input: crate::model::SpotFleetMonitoring) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::SpotFleetMonitoring>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::InstanceNetworkInterfaceSpecification>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The placement information.</p>
        pub fn placement(mut self, input: crate::model::SpotPlacement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::SpotPlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel
        /// requirements for information about whether you need to specify a RAM disk. To find kernel
        /// requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.
        /// If this value is not specified, the default is the Spot price specified for the fleet.
        /// To determine the Spot price per unit hour, divide the Spot price by the
        /// value of <code>WeightedCapacity</code>.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate
        /// them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Base64-encoded user data that instances use when starting up.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
        /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
        pub fn weighted_capacity(mut self, input: f64) -> Self {
            self.weighted_capacity = Some(input);
            self
        }
        pub fn set_weighted_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.weighted_capacity = input;
            self
        }
        pub fn tag_specifications(
            mut self,
            input: impl Into<crate::model::SpotFleetTagSpecification>,
        ) -> Self {
            let mut v = self.tag_specifications.unwrap_or_default();
            v.push(input.into());
            self.tag_specifications = Some(v);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SpotFleetTagSpecification>>,
        ) -> Self {
            self.tag_specifications = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotFleetLaunchSpecification`](crate::model::SpotFleetLaunchSpecification)
        pub fn build(self) -> crate::model::SpotFleetLaunchSpecification {
            crate::model::SpotFleetLaunchSpecification {
                security_groups: self.security_groups,
                addressing_type: self.addressing_type,
                block_device_mappings: self.block_device_mappings,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                image_id: self.image_id,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                key_name: self.key_name,
                monitoring: self.monitoring,
                network_interfaces: self.network_interfaces,
                placement: self.placement,
                ramdisk_id: self.ramdisk_id,
                spot_price: self.spot_price,
                subnet_id: self.subnet_id,
                user_data: self.user_data,
                weighted_capacity: self.weighted_capacity,
                tag_specifications: self.tag_specifications,
            }
        }
    }
}
impl SpotFleetLaunchSpecification {
    /// Creates a new builder-style object to manufacture [`SpotFleetLaunchSpecification`](crate::model::SpotFleetLaunchSpecification)
    pub fn builder() -> crate::model::spot_fleet_launch_specification::Builder {
        crate::model::spot_fleet_launch_specification::Builder::default()
    }
}

/// <p>The tags for a Spot Fleet resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotFleetTagSpecification {
    /// <p>The type of resource. Currently, the only resource type that is supported is
    /// <code>instance</code>. To tag the Spot Fleet request on creation, use the
    /// <code>TagSpecifications</code> parameter in <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html">
    /// <code>SpotFleetRequestConfigData</code>
    /// </a>.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for SpotFleetTagSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetTagSpecification");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SpotFleetTagSpecification`](crate::model::SpotFleetTagSpecification)
pub mod spot_fleet_tag_specification {
    /// A builder for [`SpotFleetTagSpecification`](crate::model::SpotFleetTagSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The type of resource. Currently, the only resource type that is supported is
        /// <code>instance</code>. To tag the Spot Fleet request on creation, use the
        /// <code>TagSpecifications</code> parameter in <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html">
        /// <code>SpotFleetRequestConfigData</code>
        /// </a>.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotFleetTagSpecification`](crate::model::SpotFleetTagSpecification)
        pub fn build(self) -> crate::model::SpotFleetTagSpecification {
            crate::model::SpotFleetTagSpecification {
                resource_type: self.resource_type,
                tags: self.tags,
            }
        }
    }
}
impl SpotFleetTagSpecification {
    /// Creates a new builder-style object to manufacture [`SpotFleetTagSpecification`](crate::model::SpotFleetTagSpecification)
    pub fn builder() -> crate::model::spot_fleet_tag_specification::Builder {
        crate::model::spot_fleet_tag_specification::Builder::default()
    }
}

/// <p>Describes whether monitoring is enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotFleetMonitoring {
    /// <p>Enables monitoring for the instance.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for SpotFleetMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetMonitoring");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`SpotFleetMonitoring`](crate::model::SpotFleetMonitoring)
pub mod spot_fleet_monitoring {
    /// A builder for [`SpotFleetMonitoring`](crate::model::SpotFleetMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Enables monitoring for the instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotFleetMonitoring`](crate::model::SpotFleetMonitoring)
        pub fn build(self) -> crate::model::SpotFleetMonitoring {
            crate::model::SpotFleetMonitoring {
                enabled: self.enabled,
            }
        }
    }
}
impl SpotFleetMonitoring {
    /// Creates a new builder-style object to manufacture [`SpotFleetMonitoring`](crate::model::SpotFleetMonitoring)
    pub fn builder() -> crate::model::spot_fleet_monitoring::Builder {
        crate::model::spot_fleet_monitoring::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExcessCapacityTerminationPolicy {
    Default,
    NoTermination,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExcessCapacityTerminationPolicy {
    fn from(s: &str) -> Self {
        match s {
            "default" => ExcessCapacityTerminationPolicy::Default,
            "noTermination" => ExcessCapacityTerminationPolicy::NoTermination,
            other => ExcessCapacityTerminationPolicy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExcessCapacityTerminationPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExcessCapacityTerminationPolicy::from(s))
    }
}
impl ExcessCapacityTerminationPolicy {
    pub fn as_str(&self) -> &str {
        match self {
            ExcessCapacityTerminationPolicy::Default => "default",
            ExcessCapacityTerminationPolicy::NoTermination => "noTermination",
            ExcessCapacityTerminationPolicy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["default", "noTermination"]
    }
}
impl AsRef<str> for ExcessCapacityTerminationPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
/// interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotMaintenanceStrategies {
    /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
    /// elevated risk of being interrupted.</p>
    pub capacity_rebalance: std::option::Option<crate::model::SpotCapacityRebalance>,
}
impl std::fmt::Debug for SpotMaintenanceStrategies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotMaintenanceStrategies");
        formatter.field("capacity_rebalance", &self.capacity_rebalance);
        formatter.finish()
    }
}
/// See [`SpotMaintenanceStrategies`](crate::model::SpotMaintenanceStrategies)
pub mod spot_maintenance_strategies {
    /// A builder for [`SpotMaintenanceStrategies`](crate::model::SpotMaintenanceStrategies)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_rebalance: std::option::Option<crate::model::SpotCapacityRebalance>,
    }
    impl Builder {
        /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
        /// elevated risk of being interrupted.</p>
        pub fn capacity_rebalance(mut self, input: crate::model::SpotCapacityRebalance) -> Self {
            self.capacity_rebalance = Some(input);
            self
        }
        pub fn set_capacity_rebalance(
            mut self,
            input: std::option::Option<crate::model::SpotCapacityRebalance>,
        ) -> Self {
            self.capacity_rebalance = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotMaintenanceStrategies`](crate::model::SpotMaintenanceStrategies)
        pub fn build(self) -> crate::model::SpotMaintenanceStrategies {
            crate::model::SpotMaintenanceStrategies {
                capacity_rebalance: self.capacity_rebalance,
            }
        }
    }
}
impl SpotMaintenanceStrategies {
    /// Creates a new builder-style object to manufacture [`SpotMaintenanceStrategies`](crate::model::SpotMaintenanceStrategies)
    pub fn builder() -> crate::model::spot_maintenance_strategies::Builder {
        crate::model::spot_maintenance_strategies::Builder::default()
    }
}

/// <p>The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your
/// Spot Instance is at an elevated risk of being interrupted. For more information, see
/// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-configuration-strategies.html#spot-fleet-capacity-rebalance">Capacity rebalancing</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotCapacityRebalance {
    /// <p>The replacement strategy to use. Only available for fleets of type
    /// <code>maintain</code>. You must specify a value, otherwise you get an error.</p>
    /// <p>To allow Spot Fleet to launch a replacement Spot Instance when an instance rebalance
    /// notification is emitted for a Spot Instance in the fleet, specify
    /// <code>launch</code>.</p>
    /// <note>
    /// <p>When a replacement instance is launched, the instance marked for rebalance is not
    /// automatically terminated. You can terminate it, or you can leave it running. You are
    /// charged for all instances while they are running.</p>
    /// </note>
    pub replacement_strategy: std::option::Option<crate::model::ReplacementStrategy>,
}
impl std::fmt::Debug for SpotCapacityRebalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotCapacityRebalance");
        formatter.field("replacement_strategy", &self.replacement_strategy);
        formatter.finish()
    }
}
/// See [`SpotCapacityRebalance`](crate::model::SpotCapacityRebalance)
pub mod spot_capacity_rebalance {
    /// A builder for [`SpotCapacityRebalance`](crate::model::SpotCapacityRebalance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) replacement_strategy: std::option::Option<crate::model::ReplacementStrategy>,
    }
    impl Builder {
        /// <p>The replacement strategy to use. Only available for fleets of type
        /// <code>maintain</code>. You must specify a value, otherwise you get an error.</p>
        /// <p>To allow Spot Fleet to launch a replacement Spot Instance when an instance rebalance
        /// notification is emitted for a Spot Instance in the fleet, specify
        /// <code>launch</code>.</p>
        /// <note>
        /// <p>When a replacement instance is launched, the instance marked for rebalance is not
        /// automatically terminated. You can terminate it, or you can leave it running. You are
        /// charged for all instances while they are running.</p>
        /// </note>
        pub fn replacement_strategy(mut self, input: crate::model::ReplacementStrategy) -> Self {
            self.replacement_strategy = Some(input);
            self
        }
        pub fn set_replacement_strategy(
            mut self,
            input: std::option::Option<crate::model::ReplacementStrategy>,
        ) -> Self {
            self.replacement_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotCapacityRebalance`](crate::model::SpotCapacityRebalance)
        pub fn build(self) -> crate::model::SpotCapacityRebalance {
            crate::model::SpotCapacityRebalance {
                replacement_strategy: self.replacement_strategy,
            }
        }
    }
}
impl SpotCapacityRebalance {
    /// Creates a new builder-style object to manufacture [`SpotCapacityRebalance`](crate::model::SpotCapacityRebalance)
    pub fn builder() -> crate::model::spot_capacity_rebalance::Builder {
        crate::model::spot_capacity_rebalance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplacementStrategy {
    Launch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReplacementStrategy {
    fn from(s: &str) -> Self {
        match s {
            "launch" => ReplacementStrategy::Launch,
            other => ReplacementStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReplacementStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplacementStrategy::from(s))
    }
}
impl ReplacementStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            ReplacementStrategy::Launch => "launch",
            ReplacementStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["launch"]
    }
}
impl AsRef<str> for ReplacementStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OnDemandAllocationStrategy {
    LowestPrice,
    Prioritized,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OnDemandAllocationStrategy {
    fn from(s: &str) -> Self {
        match s {
            "lowestPrice" => OnDemandAllocationStrategy::LowestPrice,
            "prioritized" => OnDemandAllocationStrategy::Prioritized,
            other => OnDemandAllocationStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OnDemandAllocationStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OnDemandAllocationStrategy::from(s))
    }
}
impl OnDemandAllocationStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            OnDemandAllocationStrategy::LowestPrice => "lowestPrice",
            OnDemandAllocationStrategy::Prioritized => "prioritized",
            OnDemandAllocationStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["lowestPrice", "prioritized"]
    }
}
impl AsRef<str> for OnDemandAllocationStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AllocationStrategy {
    CapacityOptimized,
    CapacityOptimizedPrioritized,
    Diversified,
    LowestPrice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AllocationStrategy {
    fn from(s: &str) -> Self {
        match s {
            "capacityOptimized" => AllocationStrategy::CapacityOptimized,
            "capacityOptimizedPrioritized" => AllocationStrategy::CapacityOptimizedPrioritized,
            "diversified" => AllocationStrategy::Diversified,
            "lowestPrice" => AllocationStrategy::LowestPrice,
            other => AllocationStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AllocationStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AllocationStrategy::from(s))
    }
}
impl AllocationStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            AllocationStrategy::CapacityOptimized => "capacityOptimized",
            AllocationStrategy::CapacityOptimizedPrioritized => "capacityOptimizedPrioritized",
            AllocationStrategy::Diversified => "diversified",
            AllocationStrategy::LowestPrice => "lowestPrice",
            AllocationStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "capacityOptimized",
            "capacityOptimizedPrioritized",
            "diversified",
            "lowestPrice",
        ]
    }
}
impl AsRef<str> for AllocationStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportStatusType {
    Impaired,
    Ok,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReportStatusType {
    fn from(s: &str) -> Self {
        match s {
            "impaired" => ReportStatusType::Impaired,
            "ok" => ReportStatusType::Ok,
            other => ReportStatusType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReportStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportStatusType::from(s))
    }
}
impl ReportStatusType {
    pub fn as_str(&self) -> &str {
        match self {
            ReportStatusType::Impaired => "impaired",
            ReportStatusType::Ok => "ok",
            ReportStatusType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["impaired", "ok"]
    }
}
impl AsRef<str> for ReportStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportInstanceReasonCodes {
    InstanceStuckInState,
    NotAcceptingCredentials,
    Other,
    PasswordNotAvailable,
    PerformanceEbsVolume,
    PerformanceInstanceStore,
    PerformanceNetwork,
    PerformanceOther,
    Unresponsive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReportInstanceReasonCodes {
    fn from(s: &str) -> Self {
        match s {
            "instance-stuck-in-state" => ReportInstanceReasonCodes::InstanceStuckInState,
            "not-accepting-credentials" => ReportInstanceReasonCodes::NotAcceptingCredentials,
            "other" => ReportInstanceReasonCodes::Other,
            "password-not-available" => ReportInstanceReasonCodes::PasswordNotAvailable,
            "performance-ebs-volume" => ReportInstanceReasonCodes::PerformanceEbsVolume,
            "performance-instance-store" => ReportInstanceReasonCodes::PerformanceInstanceStore,
            "performance-network" => ReportInstanceReasonCodes::PerformanceNetwork,
            "performance-other" => ReportInstanceReasonCodes::PerformanceOther,
            "unresponsive" => ReportInstanceReasonCodes::Unresponsive,
            other => ReportInstanceReasonCodes::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReportInstanceReasonCodes {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportInstanceReasonCodes::from(s))
    }
}
impl ReportInstanceReasonCodes {
    pub fn as_str(&self) -> &str {
        match self {
            ReportInstanceReasonCodes::InstanceStuckInState => "instance-stuck-in-state",
            ReportInstanceReasonCodes::NotAcceptingCredentials => "not-accepting-credentials",
            ReportInstanceReasonCodes::Other => "other",
            ReportInstanceReasonCodes::PasswordNotAvailable => "password-not-available",
            ReportInstanceReasonCodes::PerformanceEbsVolume => "performance-ebs-volume",
            ReportInstanceReasonCodes::PerformanceInstanceStore => "performance-instance-store",
            ReportInstanceReasonCodes::PerformanceNetwork => "performance-network",
            ReportInstanceReasonCodes::PerformanceOther => "performance-other",
            ReportInstanceReasonCodes::Unresponsive => "unresponsive",
            ReportInstanceReasonCodes::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "instance-stuck-in-state",
            "not-accepting-credentials",
            "other",
            "password-not-available",
            "performance-ebs-volume",
            "performance-instance-store",
            "performance-network",
            "performance-other",
            "unresponsive",
        ]
    }
}
impl AsRef<str> for ReportInstanceReasonCodes {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the state of an association between a route table and a subnet or gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RouteTableAssociationState {
    /// <p>The state of the association.</p>
    pub state: std::option::Option<crate::model::RouteTableAssociationStateCode>,
    /// <p>The status message, if applicable.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RouteTableAssociationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RouteTableAssociationState");
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`RouteTableAssociationState`](crate::model::RouteTableAssociationState)
pub mod route_table_association_state {
    /// A builder for [`RouteTableAssociationState`](crate::model::RouteTableAssociationState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::RouteTableAssociationStateCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::RouteTableAssociationStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::RouteTableAssociationStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status message, if applicable.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`RouteTableAssociationState`](crate::model::RouteTableAssociationState)
        pub fn build(self) -> crate::model::RouteTableAssociationState {
            crate::model::RouteTableAssociationState {
                state: self.state,
                status_message: self.status_message,
            }
        }
    }
}
impl RouteTableAssociationState {
    /// Creates a new builder-style object to manufacture [`RouteTableAssociationState`](crate::model::RouteTableAssociationState)
    pub fn builder() -> crate::model::route_table_association_state::Builder {
        crate::model::route_table_association_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RouteTableAssociationStateCode {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RouteTableAssociationStateCode {
    fn from(s: &str) -> Self {
        match s {
            "associated" => RouteTableAssociationStateCode::Associated,
            "associating" => RouteTableAssociationStateCode::Associating,
            "disassociated" => RouteTableAssociationStateCode::Disassociated,
            "disassociating" => RouteTableAssociationStateCode::Disassociating,
            "failed" => RouteTableAssociationStateCode::Failed,
            other => RouteTableAssociationStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RouteTableAssociationStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RouteTableAssociationStateCode::from(s))
    }
}
impl RouteTableAssociationStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            RouteTableAssociationStateCode::Associated => "associated",
            RouteTableAssociationStateCode::Associating => "associating",
            RouteTableAssociationStateCode::Disassociated => "disassociated",
            RouteTableAssociationStateCode::Disassociating => "disassociating",
            RouteTableAssociationStateCode::Failed => "failed",
            RouteTableAssociationStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
            "failed",
        ]
    }
}
impl AsRef<str> for RouteTableAssociationStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuleAction {
    Allow,
    Deny,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RuleAction {
    fn from(s: &str) -> Self {
        match s {
            "allow" => RuleAction::Allow,
            "deny" => RuleAction::Deny,
            other => RuleAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RuleAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuleAction::from(s))
    }
}
impl RuleAction {
    pub fn as_str(&self) -> &str {
        match self {
            RuleAction::Allow => "allow",
            RuleAction::Deny => "deny",
            RuleAction::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["allow", "deny"]
    }
}
impl AsRef<str> for RuleAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the ICMP type and code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IcmpTypeCode {
    /// <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
    pub code: std::option::Option<i32>,
    /// <p>The ICMP type. A value of -1 means all types.</p>
    pub r#type: std::option::Option<i32>,
}
impl std::fmt::Debug for IcmpTypeCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IcmpTypeCode");
        formatter.field("code", &self.code);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`IcmpTypeCode`](crate::model::IcmpTypeCode)
pub mod icmp_type_code {
    /// A builder for [`IcmpTypeCode`](crate::model::IcmpTypeCode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>The ICMP type. A value of -1 means all types.</p>
        pub fn r#type(mut self, input: i32) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<i32>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`IcmpTypeCode`](crate::model::IcmpTypeCode)
        pub fn build(self) -> crate::model::IcmpTypeCode {
            crate::model::IcmpTypeCode {
                code: self.code,
                r#type: self.r#type,
            }
        }
    }
}
impl IcmpTypeCode {
    /// Creates a new builder-style object to manufacture [`IcmpTypeCode`](crate::model::IcmpTypeCode)
    pub fn builder() -> crate::model::icmp_type_code::Builder {
        crate::model::icmp_type_code::Builder::default()
    }
}

/// <p>Describes an association between an IAM instance profile and an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IamInstanceProfileAssociation {
    /// <p>The ID of the association.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile: std::option::Option<crate::model::IamInstanceProfile>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<crate::model::IamInstanceProfileAssociationState>,
    /// <p>The time the IAM instance profile was associated with the instance.</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for IamInstanceProfileAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IamInstanceProfileAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("state", &self.state);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`IamInstanceProfileAssociation`](crate::model::IamInstanceProfileAssociation)
pub mod iam_instance_profile_association {
    /// A builder for [`IamInstanceProfileAssociation`](crate::model::IamInstanceProfileAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) iam_instance_profile: std::option::Option<crate::model::IamInstanceProfile>,
        pub(crate) state: std::option::Option<crate::model::IamInstanceProfileAssociationState>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(mut self, input: crate::model::IamInstanceProfile) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfile>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::IamInstanceProfileAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileAssociationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time the IAM instance profile was associated with the instance.</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`IamInstanceProfileAssociation`](crate::model::IamInstanceProfileAssociation)
        pub fn build(self) -> crate::model::IamInstanceProfileAssociation {
            crate::model::IamInstanceProfileAssociation {
                association_id: self.association_id,
                instance_id: self.instance_id,
                iam_instance_profile: self.iam_instance_profile,
                state: self.state,
                timestamp: self.timestamp,
            }
        }
    }
}
impl IamInstanceProfileAssociation {
    /// Creates a new builder-style object to manufacture [`IamInstanceProfileAssociation`](crate::model::IamInstanceProfileAssociation)
    pub fn builder() -> crate::model::iam_instance_profile_association::Builder {
        crate::model::iam_instance_profile_association::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IamInstanceProfileAssociationState {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IamInstanceProfileAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "associated" => IamInstanceProfileAssociationState::Associated,
            "associating" => IamInstanceProfileAssociationState::Associating,
            "disassociated" => IamInstanceProfileAssociationState::Disassociated,
            "disassociating" => IamInstanceProfileAssociationState::Disassociating,
            other => IamInstanceProfileAssociationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IamInstanceProfileAssociationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IamInstanceProfileAssociationState::from(s))
    }
}
impl IamInstanceProfileAssociationState {
    pub fn as_str(&self) -> &str {
        match self {
            IamInstanceProfileAssociationState::Associated => "associated",
            IamInstanceProfileAssociationState::Associating => "associating",
            IamInstanceProfileAssociationState::Disassociated => "disassociated",
            IamInstanceProfileAssociationState::Disassociating => "disassociating",
            IamInstanceProfileAssociationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
        ]
    }
}
impl AsRef<str> for IamInstanceProfileAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about items that were not successfully processed in a batch call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsuccessfulItem {
    /// <p>Information about the error.</p>
    pub error: std::option::Option<crate::model::UnsuccessfulItemError>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsuccessfulItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsuccessfulItem");
        formatter.field("error", &self.error);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
/// See [`UnsuccessfulItem`](crate::model::UnsuccessfulItem)
pub mod unsuccessful_item {
    /// A builder for [`UnsuccessfulItem`](crate::model::UnsuccessfulItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::UnsuccessfulItemError>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the error.</p>
        pub fn error(mut self, input: crate::model::UnsuccessfulItemError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::UnsuccessfulItemError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsuccessfulItem`](crate::model::UnsuccessfulItem)
        pub fn build(self) -> crate::model::UnsuccessfulItem {
            crate::model::UnsuccessfulItem {
                error: self.error,
                resource_id: self.resource_id,
            }
        }
    }
}
impl UnsuccessfulItem {
    /// Creates a new builder-style object to manufacture [`UnsuccessfulItem`](crate::model::UnsuccessfulItem)
    pub fn builder() -> crate::model::unsuccessful_item::Builder {
        crate::model::unsuccessful_item::Builder::default()
    }
}

/// <p>Information about the error that occurred. For more information about errors, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error codes</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsuccessfulItemError {
    /// <p>The error code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The error message accompanying the error code.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsuccessfulItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsuccessfulItemError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`UnsuccessfulItemError`](crate::model::UnsuccessfulItemError)
pub mod unsuccessful_item_error {
    /// A builder for [`UnsuccessfulItemError`](crate::model::UnsuccessfulItemError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message accompanying the error code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsuccessfulItemError`](crate::model::UnsuccessfulItemError)
        pub fn build(self) -> crate::model::UnsuccessfulItemError {
            crate::model::UnsuccessfulItemError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnsuccessfulItemError {
    /// Creates a new builder-style object to manufacture [`UnsuccessfulItemError`](crate::model::UnsuccessfulItemError)
    pub fn builder() -> crate::model::unsuccessful_item_error::Builder {
        crate::model::unsuccessful_item_error::Builder::default()
    }
}

/// <p>Describes a VPC attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayVpcAttachment {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
    pub vpc_owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the VPC attachment. Note that the <code>initiating</code> state has been deprecated.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
    /// <p>The IDs of the subnets.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The VPC attachment options.</p>
    pub options: std::option::Option<crate::model::TransitGatewayVpcAttachmentOptions>,
    /// <p>The tags for the VPC attachment.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayVpcAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayVpcAttachment");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("vpc_owner_id", &self.vpc_owner_id);
        formatter.field("state", &self.state);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("options", &self.options);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayVpcAttachment`](crate::model::TransitGatewayVpcAttachment)
pub mod transit_gateway_vpc_attachment {
    /// A builder for [`TransitGatewayVpcAttachment`](crate::model::TransitGatewayVpcAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) options: std::option::Option<crate::model::TransitGatewayVpcAttachmentOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
        pub fn vpc_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_owner_id = Some(input.into());
            self
        }
        pub fn set_vpc_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_owner_id = input;
            self
        }
        /// <p>The state of the VPC attachment. Note that the <code>initiating</code> state has been deprecated.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The VPC attachment options.</p>
        pub fn options(mut self, input: crate::model::TransitGatewayVpcAttachmentOptions) -> Self {
            self.options = Some(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayVpcAttachmentOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayVpcAttachment`](crate::model::TransitGatewayVpcAttachment)
        pub fn build(self) -> crate::model::TransitGatewayVpcAttachment {
            crate::model::TransitGatewayVpcAttachment {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                transit_gateway_id: self.transit_gateway_id,
                vpc_id: self.vpc_id,
                vpc_owner_id: self.vpc_owner_id,
                state: self.state,
                subnet_ids: self.subnet_ids,
                creation_time: self.creation_time,
                options: self.options,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayVpcAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayVpcAttachment`](crate::model::TransitGatewayVpcAttachment)
    pub fn builder() -> crate::model::transit_gateway_vpc_attachment::Builder {
        crate::model::transit_gateway_vpc_attachment::Builder::default()
    }
}

/// <p>Describes the VPC attachment options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayVpcAttachmentOptions {
    /// <p>Indicates whether DNS support is enabled.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Indicates whether IPv6 support is disabled.</p>
    pub ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
    /// <p>Indicates whether appliance mode support is enabled.</p>
    pub appliance_mode_support: std::option::Option<crate::model::ApplianceModeSupportValue>,
}
impl std::fmt::Debug for TransitGatewayVpcAttachmentOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayVpcAttachmentOptions");
        formatter.field("dns_support", &self.dns_support);
        formatter.field("ipv6_support", &self.ipv6_support);
        formatter.field("appliance_mode_support", &self.appliance_mode_support);
        formatter.finish()
    }
}
/// See [`TransitGatewayVpcAttachmentOptions`](crate::model::TransitGatewayVpcAttachmentOptions)
pub mod transit_gateway_vpc_attachment_options {
    /// A builder for [`TransitGatewayVpcAttachmentOptions`](crate::model::TransitGatewayVpcAttachmentOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
        pub(crate) appliance_mode_support:
            std::option::Option<crate::model::ApplianceModeSupportValue>,
    }
    impl Builder {
        /// <p>Indicates whether DNS support is enabled.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Indicates whether IPv6 support is disabled.</p>
        pub fn ipv6_support(mut self, input: crate::model::Ipv6SupportValue) -> Self {
            self.ipv6_support = Some(input);
            self
        }
        pub fn set_ipv6_support(
            mut self,
            input: std::option::Option<crate::model::Ipv6SupportValue>,
        ) -> Self {
            self.ipv6_support = input;
            self
        }
        /// <p>Indicates whether appliance mode support is enabled.</p>
        pub fn appliance_mode_support(
            mut self,
            input: crate::model::ApplianceModeSupportValue,
        ) -> Self {
            self.appliance_mode_support = Some(input);
            self
        }
        pub fn set_appliance_mode_support(
            mut self,
            input: std::option::Option<crate::model::ApplianceModeSupportValue>,
        ) -> Self {
            self.appliance_mode_support = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayVpcAttachmentOptions`](crate::model::TransitGatewayVpcAttachmentOptions)
        pub fn build(self) -> crate::model::TransitGatewayVpcAttachmentOptions {
            crate::model::TransitGatewayVpcAttachmentOptions {
                dns_support: self.dns_support,
                ipv6_support: self.ipv6_support,
                appliance_mode_support: self.appliance_mode_support,
            }
        }
    }
}
impl TransitGatewayVpcAttachmentOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayVpcAttachmentOptions`](crate::model::TransitGatewayVpcAttachmentOptions)
    pub fn builder() -> crate::model::transit_gateway_vpc_attachment_options::Builder {
        crate::model::transit_gateway_vpc_attachment_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplianceModeSupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ApplianceModeSupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => ApplianceModeSupportValue::Disable,
            "enable" => ApplianceModeSupportValue::Enable,
            other => ApplianceModeSupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ApplianceModeSupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplianceModeSupportValue::from(s))
    }
}
impl ApplianceModeSupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            ApplianceModeSupportValue::Disable => "disable",
            ApplianceModeSupportValue::Enable => "enable",
            ApplianceModeSupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for ApplianceModeSupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Ipv6SupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Ipv6SupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => Ipv6SupportValue::Disable,
            "enable" => Ipv6SupportValue::Enable,
            other => Ipv6SupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Ipv6SupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Ipv6SupportValue::from(s))
    }
}
impl Ipv6SupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            Ipv6SupportValue::Disable => "disable",
            Ipv6SupportValue::Enable => "enable",
            Ipv6SupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for Ipv6SupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DnsSupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DnsSupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => DnsSupportValue::Disable,
            "enable" => DnsSupportValue::Enable,
            other => DnsSupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DnsSupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DnsSupportValue::from(s))
    }
}
impl DnsSupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            DnsSupportValue::Disable => "disable",
            DnsSupportValue::Enable => "enable",
            DnsSupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for DnsSupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayAttachmentState {
    Available,
    Deleted,
    Deleting,
    Failed,
    Failing,
    Initiating,
    InitiatingRequest,
    Modifying,
    Pending,
    PendingAcceptance,
    Rejected,
    Rejecting,
    RollingBack,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayAttachmentState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayAttachmentState::Available,
            "deleted" => TransitGatewayAttachmentState::Deleted,
            "deleting" => TransitGatewayAttachmentState::Deleting,
            "failed" => TransitGatewayAttachmentState::Failed,
            "failing" => TransitGatewayAttachmentState::Failing,
            "initiating" => TransitGatewayAttachmentState::Initiating,
            "initiatingRequest" => TransitGatewayAttachmentState::InitiatingRequest,
            "modifying" => TransitGatewayAttachmentState::Modifying,
            "pending" => TransitGatewayAttachmentState::Pending,
            "pendingAcceptance" => TransitGatewayAttachmentState::PendingAcceptance,
            "rejected" => TransitGatewayAttachmentState::Rejected,
            "rejecting" => TransitGatewayAttachmentState::Rejecting,
            "rollingBack" => TransitGatewayAttachmentState::RollingBack,
            other => TransitGatewayAttachmentState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayAttachmentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayAttachmentState::from(s))
    }
}
impl TransitGatewayAttachmentState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayAttachmentState::Available => "available",
            TransitGatewayAttachmentState::Deleted => "deleted",
            TransitGatewayAttachmentState::Deleting => "deleting",
            TransitGatewayAttachmentState::Failed => "failed",
            TransitGatewayAttachmentState::Failing => "failing",
            TransitGatewayAttachmentState::Initiating => "initiating",
            TransitGatewayAttachmentState::InitiatingRequest => "initiatingRequest",
            TransitGatewayAttachmentState::Modifying => "modifying",
            TransitGatewayAttachmentState::Pending => "pending",
            TransitGatewayAttachmentState::PendingAcceptance => "pendingAcceptance",
            TransitGatewayAttachmentState::Rejected => "rejected",
            TransitGatewayAttachmentState::Rejecting => "rejecting",
            TransitGatewayAttachmentState::RollingBack => "rollingBack",
            TransitGatewayAttachmentState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "available",
            "deleted",
            "deleting",
            "failed",
            "failing",
            "initiating",
            "initiatingRequest",
            "modifying",
            "pending",
            "pendingAcceptance",
            "rejected",
            "rejecting",
            "rollingBack",
        ]
    }
}
impl AsRef<str> for TransitGatewayAttachmentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the transit gateway peering attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayPeeringAttachment {
    /// <p>The ID of the transit gateway peering attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>Information about the requester transit gateway.</p>
    pub requester_tgw_info: std::option::Option<crate::model::PeeringTgwInfo>,
    /// <p>Information about the accepter transit gateway.</p>
    pub accepter_tgw_info: std::option::Option<crate::model::PeeringTgwInfo>,
    /// <p>The status of the transit gateway peering attachment.</p>
    pub status: std::option::Option<crate::model::PeeringAttachmentStatus>,
    /// <p>The state of the transit gateway peering attachment. Note that the <code>initiating</code> state has been deprecated.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
    /// <p>The time the transit gateway peering attachment was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The tags for the transit gateway peering attachment.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayPeeringAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayPeeringAttachment");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("requester_tgw_info", &self.requester_tgw_info);
        formatter.field("accepter_tgw_info", &self.accepter_tgw_info);
        formatter.field("status", &self.status);
        formatter.field("state", &self.state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayPeeringAttachment`](crate::model::TransitGatewayPeeringAttachment)
pub mod transit_gateway_peering_attachment {
    /// A builder for [`TransitGatewayPeeringAttachment`](crate::model::TransitGatewayPeeringAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) requester_tgw_info: std::option::Option<crate::model::PeeringTgwInfo>,
        pub(crate) accepter_tgw_info: std::option::Option<crate::model::PeeringTgwInfo>,
        pub(crate) status: std::option::Option<crate::model::PeeringAttachmentStatus>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway peering attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>Information about the requester transit gateway.</p>
        pub fn requester_tgw_info(mut self, input: crate::model::PeeringTgwInfo) -> Self {
            self.requester_tgw_info = Some(input);
            self
        }
        pub fn set_requester_tgw_info(
            mut self,
            input: std::option::Option<crate::model::PeeringTgwInfo>,
        ) -> Self {
            self.requester_tgw_info = input;
            self
        }
        /// <p>Information about the accepter transit gateway.</p>
        pub fn accepter_tgw_info(mut self, input: crate::model::PeeringTgwInfo) -> Self {
            self.accepter_tgw_info = Some(input);
            self
        }
        pub fn set_accepter_tgw_info(
            mut self,
            input: std::option::Option<crate::model::PeeringTgwInfo>,
        ) -> Self {
            self.accepter_tgw_info = input;
            self
        }
        /// <p>The status of the transit gateway peering attachment.</p>
        pub fn status(mut self, input: crate::model::PeeringAttachmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PeeringAttachmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The state of the transit gateway peering attachment. Note that the <code>initiating</code> state has been deprecated.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time the transit gateway peering attachment was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayPeeringAttachment`](crate::model::TransitGatewayPeeringAttachment)
        pub fn build(self) -> crate::model::TransitGatewayPeeringAttachment {
            crate::model::TransitGatewayPeeringAttachment {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                requester_tgw_info: self.requester_tgw_info,
                accepter_tgw_info: self.accepter_tgw_info,
                status: self.status,
                state: self.state,
                creation_time: self.creation_time,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayPeeringAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayPeeringAttachment`](crate::model::TransitGatewayPeeringAttachment)
    pub fn builder() -> crate::model::transit_gateway_peering_attachment::Builder {
        crate::model::transit_gateway_peering_attachment::Builder::default()
    }
}

/// <p>The status of the transit gateway peering attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PeeringAttachmentStatus {
    /// <p>The status code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The status message, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PeeringAttachmentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PeeringAttachmentStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`PeeringAttachmentStatus`](crate::model::PeeringAttachmentStatus)
pub mod peering_attachment_status {
    /// A builder for [`PeeringAttachmentStatus`](crate::model::PeeringAttachmentStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The status message, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PeeringAttachmentStatus`](crate::model::PeeringAttachmentStatus)
        pub fn build(self) -> crate::model::PeeringAttachmentStatus {
            crate::model::PeeringAttachmentStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl PeeringAttachmentStatus {
    /// Creates a new builder-style object to manufacture [`PeeringAttachmentStatus`](crate::model::PeeringAttachmentStatus)
    pub fn builder() -> crate::model::peering_attachment_status::Builder {
        crate::model::peering_attachment_status::Builder::default()
    }
}

/// <p>Information about the transit gateway in the peering attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PeeringTgwInfo {
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Region of the transit gateway.</p>
    pub region: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PeeringTgwInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PeeringTgwInfo");
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("region", &self.region);
        formatter.finish()
    }
}
/// See [`PeeringTgwInfo`](crate::model::PeeringTgwInfo)
pub mod peering_tgw_info {
    /// A builder for [`PeeringTgwInfo`](crate::model::PeeringTgwInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Region of the transit gateway.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`PeeringTgwInfo`](crate::model::PeeringTgwInfo)
        pub fn build(self) -> crate::model::PeeringTgwInfo {
            crate::model::PeeringTgwInfo {
                transit_gateway_id: self.transit_gateway_id,
                owner_id: self.owner_id,
                region: self.region,
            }
        }
    }
}
impl PeeringTgwInfo {
    /// Creates a new builder-style object to manufacture [`PeeringTgwInfo`](crate::model::PeeringTgwInfo)
    pub fn builder() -> crate::model::peering_tgw_info::Builder {
        crate::model::peering_tgw_info::Builder::default()
    }
}

/// <p>Describes the multicast domain associations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDomainAssociations {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource, for example a VPC attachment.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p> The ID of the Amazon Web Services account that owns the resource.</p>
    pub resource_owner_id: std::option::Option<std::string::String>,
    /// <p>The subnets associated with the multicast domain.</p>
    pub subnets: std::option::Option<std::vec::Vec<crate::model::SubnetAssociation>>,
}
impl std::fmt::Debug for TransitGatewayMulticastDomainAssociations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDomainAssociations");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_owner_id", &self.resource_owner_id);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDomainAssociations`](crate::model::TransitGatewayMulticastDomainAssociations)
pub mod transit_gateway_multicast_domain_associations {
    /// A builder for [`TransitGatewayMulticastDomainAssociations`](crate::model::TransitGatewayMulticastDomainAssociations)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) resource_owner_id: std::option::Option<std::string::String>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<crate::model::SubnetAssociation>>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource, for example a VPC attachment.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p> The ID of the Amazon Web Services account that owns the resource.</p>
        pub fn resource_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner_id = Some(input.into());
            self
        }
        pub fn set_resource_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner_id = input;
            self
        }
        pub fn subnets(mut self, input: impl Into<crate::model::SubnetAssociation>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetAssociation>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDomainAssociations`](crate::model::TransitGatewayMulticastDomainAssociations)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDomainAssociations {
            crate::model::TransitGatewayMulticastDomainAssociations {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_owner_id: self.resource_owner_id,
                subnets: self.subnets,
            }
        }
    }
}
impl TransitGatewayMulticastDomainAssociations {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDomainAssociations`](crate::model::TransitGatewayMulticastDomainAssociations)
    pub fn builder() -> crate::model::transit_gateway_multicast_domain_associations::Builder {
        crate::model::transit_gateway_multicast_domain_associations::Builder::default()
    }
}

/// <p>Describes the subnet association with the transit gateway multicast domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetAssociation {
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The state of the subnet association.</p>
    pub state: std::option::Option<crate::model::TransitGatewayMulitcastDomainAssociationState>,
}
impl std::fmt::Debug for SubnetAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetAssociation");
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`SubnetAssociation`](crate::model::SubnetAssociation)
pub mod subnet_association {
    /// A builder for [`SubnetAssociation`](crate::model::SubnetAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) state:
            std::option::Option<crate::model::TransitGatewayMulitcastDomainAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The state of the subnet association.</p>
        pub fn state(
            mut self,
            input: crate::model::TransitGatewayMulitcastDomainAssociationState,
        ) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayMulitcastDomainAssociationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetAssociation`](crate::model::SubnetAssociation)
        pub fn build(self) -> crate::model::SubnetAssociation {
            crate::model::SubnetAssociation {
                subnet_id: self.subnet_id,
                state: self.state,
            }
        }
    }
}
impl SubnetAssociation {
    /// Creates a new builder-style object to manufacture [`SubnetAssociation`](crate::model::SubnetAssociation)
    pub fn builder() -> crate::model::subnet_association::Builder {
        crate::model::subnet_association::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayMulitcastDomainAssociationState {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    Failed,
    PendingAcceptance,
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayMulitcastDomainAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "associated" => TransitGatewayMulitcastDomainAssociationState::Associated,
            "associating" => TransitGatewayMulitcastDomainAssociationState::Associating,
            "disassociated" => TransitGatewayMulitcastDomainAssociationState::Disassociated,
            "disassociating" => TransitGatewayMulitcastDomainAssociationState::Disassociating,
            "failed" => TransitGatewayMulitcastDomainAssociationState::Failed,
            "pendingAcceptance" => TransitGatewayMulitcastDomainAssociationState::PendingAcceptance,
            "rejected" => TransitGatewayMulitcastDomainAssociationState::Rejected,
            other => TransitGatewayMulitcastDomainAssociationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayMulitcastDomainAssociationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayMulitcastDomainAssociationState::from(s))
    }
}
impl TransitGatewayMulitcastDomainAssociationState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayMulitcastDomainAssociationState::Associated => "associated",
            TransitGatewayMulitcastDomainAssociationState::Associating => "associating",
            TransitGatewayMulitcastDomainAssociationState::Disassociated => "disassociated",
            TransitGatewayMulitcastDomainAssociationState::Disassociating => "disassociating",
            TransitGatewayMulitcastDomainAssociationState::Failed => "failed",
            TransitGatewayMulitcastDomainAssociationState::PendingAcceptance => "pendingAcceptance",
            TransitGatewayMulitcastDomainAssociationState::Rejected => "rejected",
            TransitGatewayMulitcastDomainAssociationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
            "failed",
            "pendingAcceptance",
            "rejected",
        ]
    }
}
impl AsRef<str> for TransitGatewayMulitcastDomainAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the members registered with the  transit gateway multicast group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastRegisteredGroupSources {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the network interfaces members registered with the  transit gateway multicast group.</p>
    pub registered_network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IP address assigned to the  transit gateway multicast group.</p>
    pub group_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransitGatewayMulticastRegisteredGroupSources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastRegisteredGroupSources");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field(
            "registered_network_interface_ids",
            &self.registered_network_interface_ids,
        );
        formatter.field("group_ip_address", &self.group_ip_address);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastRegisteredGroupSources`](crate::model::TransitGatewayMulticastRegisteredGroupSources)
pub mod transit_gateway_multicast_registered_group_sources {
    /// A builder for [`TransitGatewayMulticastRegisteredGroupSources`](crate::model::TransitGatewayMulticastRegisteredGroupSources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) registered_network_interface_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        pub fn registered_network_interface_ids(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.registered_network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.registered_network_interface_ids = Some(v);
            self
        }
        pub fn set_registered_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.registered_network_interface_ids = input;
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_ip_address = Some(input.into());
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastRegisteredGroupSources`](crate::model::TransitGatewayMulticastRegisteredGroupSources)
        pub fn build(self) -> crate::model::TransitGatewayMulticastRegisteredGroupSources {
            crate::model::TransitGatewayMulticastRegisteredGroupSources {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                registered_network_interface_ids: self.registered_network_interface_ids,
                group_ip_address: self.group_ip_address,
            }
        }
    }
}
impl TransitGatewayMulticastRegisteredGroupSources {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastRegisteredGroupSources`](crate::model::TransitGatewayMulticastRegisteredGroupSources)
    pub fn builder() -> crate::model::transit_gateway_multicast_registered_group_sources::Builder {
        crate::model::transit_gateway_multicast_registered_group_sources::Builder::default()
    }
}

/// <p>Describes the registered  transit gateway multicast group members.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastRegisteredGroupMembers {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The ID of the registered network interfaces.</p>
    pub registered_network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IP address assigned to the  transit gateway multicast group.</p>
    pub group_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransitGatewayMulticastRegisteredGroupMembers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastRegisteredGroupMembers");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field(
            "registered_network_interface_ids",
            &self.registered_network_interface_ids,
        );
        formatter.field("group_ip_address", &self.group_ip_address);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastRegisteredGroupMembers`](crate::model::TransitGatewayMulticastRegisteredGroupMembers)
pub mod transit_gateway_multicast_registered_group_members {
    /// A builder for [`TransitGatewayMulticastRegisteredGroupMembers`](crate::model::TransitGatewayMulticastRegisteredGroupMembers)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) registered_network_interface_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        pub fn registered_network_interface_ids(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.registered_network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.registered_network_interface_ids = Some(v);
            self
        }
        pub fn set_registered_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.registered_network_interface_ids = input;
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_ip_address = Some(input.into());
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastRegisteredGroupMembers`](crate::model::TransitGatewayMulticastRegisteredGroupMembers)
        pub fn build(self) -> crate::model::TransitGatewayMulticastRegisteredGroupMembers {
            crate::model::TransitGatewayMulticastRegisteredGroupMembers {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                registered_network_interface_ids: self.registered_network_interface_ids,
                group_ip_address: self.group_ip_address,
            }
        }
    }
}
impl TransitGatewayMulticastRegisteredGroupMembers {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastRegisteredGroupMembers`](crate::model::TransitGatewayMulticastRegisteredGroupMembers)
    pub fn builder() -> crate::model::transit_gateway_multicast_registered_group_members::Builder {
        crate::model::transit_gateway_multicast_registered_group_members::Builder::default()
    }
}

/// <p>Describes the registered tag keys for the current Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceTagNotificationAttribute {
    /// <p>The registered tag keys.</p>
    pub instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates wheter all tag keys in the current Region are registered to appear in scheduled event notifications.
    /// <code>true</code> indicates that all tag keys in the current Region are registered.</p>
    pub include_all_tags_of_instance: std::option::Option<bool>,
}
impl std::fmt::Debug for InstanceTagNotificationAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceTagNotificationAttribute");
        formatter.field("instance_tag_keys", &self.instance_tag_keys);
        formatter.field(
            "include_all_tags_of_instance",
            &self.include_all_tags_of_instance,
        );
        formatter.finish()
    }
}
/// See [`InstanceTagNotificationAttribute`](crate::model::InstanceTagNotificationAttribute)
pub mod instance_tag_notification_attribute {
    /// A builder for [`InstanceTagNotificationAttribute`](crate::model::InstanceTagNotificationAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) include_all_tags_of_instance: std::option::Option<bool>,
    }
    impl Builder {
        pub fn instance_tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_tag_keys.unwrap_or_default();
            v.push(input.into());
            self.instance_tag_keys = Some(v);
            self
        }
        pub fn set_instance_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_tag_keys = input;
            self
        }
        /// <p>Indicates wheter all tag keys in the current Region are registered to appear in scheduled event notifications.
        /// <code>true</code> indicates that all tag keys in the current Region are registered.</p>
        pub fn include_all_tags_of_instance(mut self, input: bool) -> Self {
            self.include_all_tags_of_instance = Some(input);
            self
        }
        pub fn set_include_all_tags_of_instance(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_all_tags_of_instance = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTagNotificationAttribute`](crate::model::InstanceTagNotificationAttribute)
        pub fn build(self) -> crate::model::InstanceTagNotificationAttribute {
            crate::model::InstanceTagNotificationAttribute {
                instance_tag_keys: self.instance_tag_keys,
                include_all_tags_of_instance: self.include_all_tags_of_instance,
            }
        }
    }
}
impl InstanceTagNotificationAttribute {
    /// Creates a new builder-style object to manufacture [`InstanceTagNotificationAttribute`](crate::model::InstanceTagNotificationAttribute)
    pub fn builder() -> crate::model::instance_tag_notification_attribute::Builder {
        crate::model::instance_tag_notification_attribute::Builder::default()
    }
}

/// <p>Information about the tag keys to register for the current Region. You can either specify
/// individual tag keys or register all tag keys in the current Region. You must specify either
/// <code>IncludeAllTagsOfInstance</code> or <code>InstanceTagKeys</code> in the request</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterInstanceTagAttributeRequest {
    /// <p>Indicates whether to register all tag keys in the current Region. Specify <code>true</code>
    /// to register all tag keys.</p>
    pub include_all_tags_of_instance: std::option::Option<bool>,
    /// <p>The tag keys to register.</p>
    pub instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for RegisterInstanceTagAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterInstanceTagAttributeRequest");
        formatter.field(
            "include_all_tags_of_instance",
            &self.include_all_tags_of_instance,
        );
        formatter.field("instance_tag_keys", &self.instance_tag_keys);
        formatter.finish()
    }
}
/// See [`RegisterInstanceTagAttributeRequest`](crate::model::RegisterInstanceTagAttributeRequest)
pub mod register_instance_tag_attribute_request {
    /// A builder for [`RegisterInstanceTagAttributeRequest`](crate::model::RegisterInstanceTagAttributeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_all_tags_of_instance: std::option::Option<bool>,
        pub(crate) instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Indicates whether to register all tag keys in the current Region. Specify <code>true</code>
        /// to register all tag keys.</p>
        pub fn include_all_tags_of_instance(mut self, input: bool) -> Self {
            self.include_all_tags_of_instance = Some(input);
            self
        }
        pub fn set_include_all_tags_of_instance(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_all_tags_of_instance = input;
            self
        }
        pub fn instance_tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_tag_keys.unwrap_or_default();
            v.push(input.into());
            self.instance_tag_keys = Some(v);
            self
        }
        pub fn set_instance_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterInstanceTagAttributeRequest`](crate::model::RegisterInstanceTagAttributeRequest)
        pub fn build(self) -> crate::model::RegisterInstanceTagAttributeRequest {
            crate::model::RegisterInstanceTagAttributeRequest {
                include_all_tags_of_instance: self.include_all_tags_of_instance,
                instance_tag_keys: self.instance_tag_keys,
            }
        }
    }
}
impl RegisterInstanceTagAttributeRequest {
    /// Creates a new builder-style object to manufacture [`RegisterInstanceTagAttributeRequest`](crate::model::RegisterInstanceTagAttributeRequest)
    pub fn builder() -> crate::model::register_instance_tag_attribute_request::Builder {
        crate::model::register_instance_tag_attribute_request::Builder::default()
    }
}

/// <p>Describes a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstance {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The date when the Scheduled Instance was purchased.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>The hourly price for a single instance.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The number of instances.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
    pub network_platform: std::option::Option<std::string::String>,
    /// <p>The time for the next schedule to start.</p>
    pub next_slot_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The time that the previous schedule ended or will end.</p>
    pub previous_slot_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The schedule recurrence.</p>
    pub recurrence: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
    /// <p>The Scheduled Instance ID.</p>
    pub scheduled_instance_id: std::option::Option<std::string::String>,
    /// <p>The number of hours in the schedule.</p>
    pub slot_duration_in_hours: std::option::Option<i32>,
    /// <p>The end date for the Scheduled Instance.</p>
    pub term_end_date: std::option::Option<smithy_types::Instant>,
    /// <p>The start date for the Scheduled Instance.</p>
    pub term_start_date: std::option::Option<smithy_types::Instant>,
    /// <p>The total number of hours for a single instance for the entire term.</p>
    pub total_scheduled_instance_hours: std::option::Option<i32>,
}
impl std::fmt::Debug for ScheduledInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstance");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("create_date", &self.create_date);
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("network_platform", &self.network_platform);
        formatter.field("next_slot_start_time", &self.next_slot_start_time);
        formatter.field("platform", &self.platform);
        formatter.field("previous_slot_end_time", &self.previous_slot_end_time);
        formatter.field("recurrence", &self.recurrence);
        formatter.field("scheduled_instance_id", &self.scheduled_instance_id);
        formatter.field("slot_duration_in_hours", &self.slot_duration_in_hours);
        formatter.field("term_end_date", &self.term_end_date);
        formatter.field("term_start_date", &self.term_start_date);
        formatter.field(
            "total_scheduled_instance_hours",
            &self.total_scheduled_instance_hours,
        );
        formatter.finish()
    }
}
/// See [`ScheduledInstance`](crate::model::ScheduledInstance)
pub mod scheduled_instance {
    /// A builder for [`ScheduledInstance`](crate::model::ScheduledInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) network_platform: std::option::Option<std::string::String>,
        pub(crate) next_slot_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) previous_slot_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) recurrence: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
        pub(crate) scheduled_instance_id: std::option::Option<std::string::String>,
        pub(crate) slot_duration_in_hours: std::option::Option<i32>,
        pub(crate) term_end_date: std::option::Option<smithy_types::Instant>,
        pub(crate) term_start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) total_scheduled_instance_hours: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The date when the Scheduled Instance was purchased.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The hourly price for a single instance.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The number of instances.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
        pub fn network_platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_platform = Some(input.into());
            self
        }
        pub fn set_network_platform(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_platform = input;
            self
        }
        /// <p>The time for the next schedule to start.</p>
        pub fn next_slot_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.next_slot_start_time = Some(input);
            self
        }
        pub fn set_next_slot_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.next_slot_start_time = input;
            self
        }
        /// <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The time that the previous schedule ended or will end.</p>
        pub fn previous_slot_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.previous_slot_end_time = Some(input);
            self
        }
        pub fn set_previous_slot_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.previous_slot_end_time = input;
            self
        }
        /// <p>The schedule recurrence.</p>
        pub fn recurrence(mut self, input: crate::model::ScheduledInstanceRecurrence) -> Self {
            self.recurrence = Some(input);
            self
        }
        pub fn set_recurrence(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
        ) -> Self {
            self.recurrence = input;
            self
        }
        /// <p>The Scheduled Instance ID.</p>
        pub fn scheduled_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_instance_id = Some(input.into());
            self
        }
        pub fn set_scheduled_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_instance_id = input;
            self
        }
        /// <p>The number of hours in the schedule.</p>
        pub fn slot_duration_in_hours(mut self, input: i32) -> Self {
            self.slot_duration_in_hours = Some(input);
            self
        }
        pub fn set_slot_duration_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.slot_duration_in_hours = input;
            self
        }
        /// <p>The end date for the Scheduled Instance.</p>
        pub fn term_end_date(mut self, input: smithy_types::Instant) -> Self {
            self.term_end_date = Some(input);
            self
        }
        pub fn set_term_end_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.term_end_date = input;
            self
        }
        /// <p>The start date for the Scheduled Instance.</p>
        pub fn term_start_date(mut self, input: smithy_types::Instant) -> Self {
            self.term_start_date = Some(input);
            self
        }
        pub fn set_term_start_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.term_start_date = input;
            self
        }
        /// <p>The total number of hours for a single instance for the entire term.</p>
        pub fn total_scheduled_instance_hours(mut self, input: i32) -> Self {
            self.total_scheduled_instance_hours = Some(input);
            self
        }
        pub fn set_total_scheduled_instance_hours(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.total_scheduled_instance_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstance`](crate::model::ScheduledInstance)
        pub fn build(self) -> crate::model::ScheduledInstance {
            crate::model::ScheduledInstance {
                availability_zone: self.availability_zone,
                create_date: self.create_date,
                hourly_price: self.hourly_price,
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                network_platform: self.network_platform,
                next_slot_start_time: self.next_slot_start_time,
                platform: self.platform,
                previous_slot_end_time: self.previous_slot_end_time,
                recurrence: self.recurrence,
                scheduled_instance_id: self.scheduled_instance_id,
                slot_duration_in_hours: self.slot_duration_in_hours,
                term_end_date: self.term_end_date,
                term_start_date: self.term_start_date,
                total_scheduled_instance_hours: self.total_scheduled_instance_hours,
            }
        }
    }
}
impl ScheduledInstance {
    /// Creates a new builder-style object to manufacture [`ScheduledInstance`](crate::model::ScheduledInstance)
    pub fn builder() -> crate::model::scheduled_instance::Builder {
        crate::model::scheduled_instance::Builder::default()
    }
}

/// <p>Describes the recurring schedule for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstanceRecurrence {
    /// <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
    pub frequency: std::option::Option<std::string::String>,
    /// <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2
    /// weeks or every 2 months.</p>
    pub interval: std::option::Option<i32>,
    /// <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>
    pub occurrence_day_set: std::option::Option<std::vec::Vec<i32>>,
    /// <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
    pub occurrence_relative_to_end: std::option::Option<bool>,
    /// <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
    pub occurrence_unit: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstanceRecurrence {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstanceRecurrence");
        formatter.field("frequency", &self.frequency);
        formatter.field("interval", &self.interval);
        formatter.field("occurrence_day_set", &self.occurrence_day_set);
        formatter.field(
            "occurrence_relative_to_end",
            &self.occurrence_relative_to_end,
        );
        formatter.field("occurrence_unit", &self.occurrence_unit);
        formatter.finish()
    }
}
/// See [`ScheduledInstanceRecurrence`](crate::model::ScheduledInstanceRecurrence)
pub mod scheduled_instance_recurrence {
    /// A builder for [`ScheduledInstanceRecurrence`](crate::model::ScheduledInstanceRecurrence)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) frequency: std::option::Option<std::string::String>,
        pub(crate) interval: std::option::Option<i32>,
        pub(crate) occurrence_day_set: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) occurrence_relative_to_end: std::option::Option<bool>,
        pub(crate) occurrence_unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
        pub fn frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.frequency = Some(input.into());
            self
        }
        pub fn set_frequency(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.frequency = input;
            self
        }
        /// <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2
        /// weeks or every 2 months.</p>
        pub fn interval(mut self, input: i32) -> Self {
            self.interval = Some(input);
            self
        }
        pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.interval = input;
            self
        }
        pub fn occurrence_day_set(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.occurrence_day_set.unwrap_or_default();
            v.push(input.into());
            self.occurrence_day_set = Some(v);
            self
        }
        pub fn set_occurrence_day_set(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.occurrence_day_set = input;
            self
        }
        /// <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
        pub fn occurrence_relative_to_end(mut self, input: bool) -> Self {
            self.occurrence_relative_to_end = Some(input);
            self
        }
        pub fn set_occurrence_relative_to_end(mut self, input: std::option::Option<bool>) -> Self {
            self.occurrence_relative_to_end = input;
            self
        }
        /// <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
        pub fn occurrence_unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.occurrence_unit = Some(input.into());
            self
        }
        pub fn set_occurrence_unit(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.occurrence_unit = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstanceRecurrence`](crate::model::ScheduledInstanceRecurrence)
        pub fn build(self) -> crate::model::ScheduledInstanceRecurrence {
            crate::model::ScheduledInstanceRecurrence {
                frequency: self.frequency,
                interval: self.interval,
                occurrence_day_set: self.occurrence_day_set,
                occurrence_relative_to_end: self.occurrence_relative_to_end,
                occurrence_unit: self.occurrence_unit,
            }
        }
    }
}
impl ScheduledInstanceRecurrence {
    /// Creates a new builder-style object to manufacture [`ScheduledInstanceRecurrence`](crate::model::ScheduledInstanceRecurrence)
    pub fn builder() -> crate::model::scheduled_instance_recurrence::Builder {
        crate::model::scheduled_instance_recurrence::Builder::default()
    }
}

/// <p>Describes a request to purchase Scheduled Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PurchaseRequest {
    /// <p>The number of instances.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The purchase token.</p>
    pub purchase_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PurchaseRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PurchaseRequest");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("purchase_token", &self.purchase_token);
        formatter.finish()
    }
}
/// See [`PurchaseRequest`](crate::model::PurchaseRequest)
pub mod purchase_request {
    /// A builder for [`PurchaseRequest`](crate::model::PurchaseRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) purchase_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of instances.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The purchase token.</p>
        pub fn purchase_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.purchase_token = Some(input.into());
            self
        }
        pub fn set_purchase_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.purchase_token = input;
            self
        }
        /// Consumes the builder and constructs a [`PurchaseRequest`](crate::model::PurchaseRequest)
        pub fn build(self) -> crate::model::PurchaseRequest {
            crate::model::PurchaseRequest {
                instance_count: self.instance_count,
                purchase_token: self.purchase_token,
            }
        }
    }
}
impl PurchaseRequest {
    /// Creates a new builder-style object to manufacture [`PurchaseRequest`](crate::model::PurchaseRequest)
    pub fn builder() -> crate::model::purchase_request::Builder {
        crate::model::purchase_request::Builder::default()
    }
}

/// <p>Describes the limit price of a Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstanceLimitPrice {
    /// <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
    pub amount: std::option::Option<f64>,
    /// <p>The currency in which the <code>limitPrice</code> amount is specified.
    /// At this time, the only supported currency is <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
}
impl std::fmt::Debug for ReservedInstanceLimitPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstanceLimitPrice");
        formatter.field("amount", &self.amount);
        formatter.field("currency_code", &self.currency_code);
        formatter.finish()
    }
}
/// See [`ReservedInstanceLimitPrice`](crate::model::ReservedInstanceLimitPrice)
pub mod reserved_instance_limit_price {
    /// A builder for [`ReservedInstanceLimitPrice`](crate::model::ReservedInstanceLimitPrice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    }
    impl Builder {
        /// <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
        pub fn amount(mut self, input: f64) -> Self {
            self.amount = Some(input);
            self
        }
        pub fn set_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The currency in which the <code>limitPrice</code> amount is specified.
        /// At this time, the only supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstanceLimitPrice`](crate::model::ReservedInstanceLimitPrice)
        pub fn build(self) -> crate::model::ReservedInstanceLimitPrice {
            crate::model::ReservedInstanceLimitPrice {
                amount: self.amount,
                currency_code: self.currency_code,
            }
        }
    }
}
impl ReservedInstanceLimitPrice {
    /// Creates a new builder-style object to manufacture [`ReservedInstanceLimitPrice`](crate::model::ReservedInstanceLimitPrice)
    pub fn builder() -> crate::model::reserved_instance_limit_price::Builder {
        crate::model::reserved_instance_limit_price::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CurrencyCodeValues {
    Usd,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CurrencyCodeValues {
    fn from(s: &str) -> Self {
        match s {
            "USD" => CurrencyCodeValues::Usd,
            other => CurrencyCodeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CurrencyCodeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CurrencyCodeValues::from(s))
    }
}
impl CurrencyCodeValues {
    pub fn as_str(&self) -> &str {
        match self {
            CurrencyCodeValues::Usd => "USD",
            CurrencyCodeValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["USD"]
    }
}
impl AsRef<str> for CurrencyCodeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the result of the purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Purchase {
    /// <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code>
    /// amounts are specified. At this time, the only supported currency is
    /// <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The duration of the reservation's term in seconds.</p>
    pub duration: std::option::Option<i32>,
    /// <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
    pub host_id_set: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the reservation.</p>
    pub host_reservation_id: std::option::Option<std::string::String>,
    /// <p>The hourly price of the reservation per hour.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The instance family on the Dedicated Host that the reservation can be associated
    /// with.</p>
    pub instance_family: std::option::Option<std::string::String>,
    /// <p>The payment option for the reservation.</p>
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The upfront price of the reservation.</p>
    pub upfront_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Purchase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Purchase");
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("host_id_set", &self.host_id_set);
        formatter.field("host_reservation_id", &self.host_reservation_id);
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("instance_family", &self.instance_family);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("upfront_price", &self.upfront_price);
        formatter.finish()
    }
}
/// See [`Purchase`](crate::model::Purchase)
pub mod purchase {
    /// A builder for [`Purchase`](crate::model::Purchase)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) host_id_set: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) host_reservation_id: std::option::Option<std::string::String>,
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) instance_family: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) upfront_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code>
        /// amounts are specified. At this time, the only supported currency is
        /// <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The duration of the reservation's term in seconds.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        pub fn host_id_set(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.host_id_set.unwrap_or_default();
            v.push(input.into());
            self.host_id_set = Some(v);
            self
        }
        pub fn set_host_id_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.host_id_set = input;
            self
        }
        /// <p>The ID of the reservation.</p>
        pub fn host_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_reservation_id = Some(input.into());
            self
        }
        pub fn set_host_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_reservation_id = input;
            self
        }
        /// <p>The hourly price of the reservation per hour.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The instance family on the Dedicated Host that the reservation can be associated
        /// with.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_family = Some(input.into());
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The payment option for the reservation.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The upfront price of the reservation.</p>
        pub fn upfront_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.upfront_price = Some(input.into());
            self
        }
        pub fn set_upfront_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upfront_price = input;
            self
        }
        /// Consumes the builder and constructs a [`Purchase`](crate::model::Purchase)
        pub fn build(self) -> crate::model::Purchase {
            crate::model::Purchase {
                currency_code: self.currency_code,
                duration: self.duration,
                host_id_set: self.host_id_set,
                host_reservation_id: self.host_reservation_id,
                hourly_price: self.hourly_price,
                instance_family: self.instance_family,
                payment_option: self.payment_option,
                upfront_price: self.upfront_price,
            }
        }
    }
}
impl Purchase {
    /// Creates a new builder-style object to manufacture [`Purchase`](crate::model::Purchase)
    pub fn builder() -> crate::model::purchase::Builder {
        crate::model::purchase::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaymentOption {
    AllUpfront,
    NoUpfront,
    PartialUpfront,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PaymentOption {
    fn from(s: &str) -> Self {
        match s {
            "AllUpfront" => PaymentOption::AllUpfront,
            "NoUpfront" => PaymentOption::NoUpfront,
            "PartialUpfront" => PaymentOption::PartialUpfront,
            other => PaymentOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PaymentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaymentOption::from(s))
    }
}
impl PaymentOption {
    pub fn as_str(&self) -> &str {
        match self {
            PaymentOption::AllUpfront => "AllUpfront",
            PaymentOption::NoUpfront => "NoUpfront",
            PaymentOption::PartialUpfront => "PartialUpfront",
            PaymentOption::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AllUpfront", "NoUpfront", "PartialUpfront"]
    }
}
impl AsRef<str> for PaymentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides authorization for Amazon to bring a specific IP address range to a specific
/// Amazon Web Services account using bring your own IP addresses (BYOIP). For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#prepare-for-byoip">Configuring your BYOIP address range</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CidrAuthorizationContext {
    /// <p>The plain-text authorization message for the prefix and account.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The signed authorization message for the prefix and account.</p>
    pub signature: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CidrAuthorizationContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CidrAuthorizationContext");
        formatter.field("message", &self.message);
        formatter.field("signature", &self.signature);
        formatter.finish()
    }
}
/// See [`CidrAuthorizationContext`](crate::model::CidrAuthorizationContext)
pub mod cidr_authorization_context {
    /// A builder for [`CidrAuthorizationContext`](crate::model::CidrAuthorizationContext)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) signature: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The plain-text authorization message for the prefix and account.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The signed authorization message for the prefix and account.</p>
        pub fn signature(mut self, input: impl Into<std::string::String>) -> Self {
            self.signature = Some(input.into());
            self
        }
        pub fn set_signature(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.signature = input;
            self
        }
        /// Consumes the builder and constructs a [`CidrAuthorizationContext`](crate::model::CidrAuthorizationContext)
        pub fn build(self) -> crate::model::CidrAuthorizationContext {
            crate::model::CidrAuthorizationContext {
                message: self.message,
                signature: self.signature,
            }
        }
    }
}
impl CidrAuthorizationContext {
    /// Creates a new builder-style object to manufacture [`CidrAuthorizationContext`](crate::model::CidrAuthorizationContext)
    pub fn builder() -> crate::model::cidr_authorization_context::Builder {
        crate::model::cidr_authorization_context::Builder::default()
    }
}

/// <p>Describes a VPN connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnConnection {
    /// <p>The configuration information for the VPN connection's customer gateway (in the native XML
    /// format). This element is always present in the <a>CreateVpnConnection</a> response; however,
    /// it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in
    /// the <code>pending</code> or <code>available</code> state.</p>
    pub customer_gateway_configuration: std::option::Option<std::string::String>,
    /// <p>The ID of the customer gateway at your end of the VPN connection.</p>
    pub customer_gateway_id: std::option::Option<std::string::String>,
    /// <p>The category of the VPN connection. A value of <code>VPN</code> indicates an AWS VPN
    /// connection. A value of <code>VPN-Classic</code> indicates an AWS Classic VPN connection.</p>
    pub category: std::option::Option<std::string::String>,
    /// <p>The current state of the VPN connection.</p>
    pub state: std::option::Option<crate::model::VpnState>,
    /// <p>The type of VPN connection.</p>
    pub r#type: std::option::Option<crate::model::GatewayType>,
    /// <p>The ID of the VPN connection.</p>
    pub vpn_connection_id: std::option::Option<std::string::String>,
    /// <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
    pub vpn_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway associated with the VPN connection.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The VPN connection options.</p>
    pub options: std::option::Option<crate::model::VpnConnectionOptions>,
    /// <p>The static routes associated with the VPN connection.</p>
    pub routes: std::option::Option<std::vec::Vec<crate::model::VpnStaticRoute>>,
    /// <p>Any tags assigned to the VPN connection.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Information about the VPN tunnel.</p>
    pub vgw_telemetry: std::option::Option<std::vec::Vec<crate::model::VgwTelemetry>>,
}
impl std::fmt::Debug for VpnConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnConnection");
        formatter.field(
            "customer_gateway_configuration",
            &self.customer_gateway_configuration,
        );
        formatter.field("customer_gateway_id", &self.customer_gateway_id);
        formatter.field("category", &self.category);
        formatter.field("state", &self.state);
        formatter.field("r#type", &self.r#type);
        formatter.field("vpn_connection_id", &self.vpn_connection_id);
        formatter.field("vpn_gateway_id", &self.vpn_gateway_id);
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("options", &self.options);
        formatter.field("routes", &self.routes);
        formatter.field("tags", &self.tags);
        formatter.field("vgw_telemetry", &self.vgw_telemetry);
        formatter.finish()
    }
}
/// See [`VpnConnection`](crate::model::VpnConnection)
pub mod vpn_connection {
    /// A builder for [`VpnConnection`](crate::model::VpnConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_gateway_configuration: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_id: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VpnState>,
        pub(crate) r#type: std::option::Option<crate::model::GatewayType>,
        pub(crate) vpn_connection_id: std::option::Option<std::string::String>,
        pub(crate) vpn_gateway_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<crate::model::VpnConnectionOptions>,
        pub(crate) routes: std::option::Option<std::vec::Vec<crate::model::VpnStaticRoute>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vgw_telemetry: std::option::Option<std::vec::Vec<crate::model::VgwTelemetry>>,
    }
    impl Builder {
        /// <p>The configuration information for the VPN connection's customer gateway (in the native XML
        /// format). This element is always present in the <a>CreateVpnConnection</a> response; however,
        /// it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in
        /// the <code>pending</code> or <code>available</code> state.</p>
        pub fn customer_gateway_configuration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.customer_gateway_configuration = Some(input.into());
            self
        }
        pub fn set_customer_gateway_configuration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_configuration = input;
            self
        }
        /// <p>The ID of the customer gateway at your end of the VPN connection.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_id = Some(input.into());
            self
        }
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_id = input;
            self
        }
        /// <p>The category of the VPN connection. A value of <code>VPN</code> indicates an AWS VPN
        /// connection. A value of <code>VPN-Classic</code> indicates an AWS Classic VPN connection.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>The current state of the VPN connection.</p>
        pub fn state(mut self, input: crate::model::VpnState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::VpnState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The type of VPN connection.</p>
        pub fn r#type(mut self, input: crate::model::GatewayType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::GatewayType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_connection_id = Some(input.into());
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_connection_id = input;
            self
        }
        /// <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_gateway_id = Some(input.into());
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_gateway_id = input;
            self
        }
        /// <p>The ID of the transit gateway associated with the VPN connection.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The VPN connection options.</p>
        pub fn options(mut self, input: crate::model::VpnConnectionOptions) -> Self {
            self.options = Some(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::VpnConnectionOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        pub fn routes(mut self, input: impl Into<crate::model::VpnStaticRoute>) -> Self {
            let mut v = self.routes.unwrap_or_default();
            v.push(input.into());
            self.routes = Some(v);
            self
        }
        pub fn set_routes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpnStaticRoute>>,
        ) -> Self {
            self.routes = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn vgw_telemetry(mut self, input: impl Into<crate::model::VgwTelemetry>) -> Self {
            let mut v = self.vgw_telemetry.unwrap_or_default();
            v.push(input.into());
            self.vgw_telemetry = Some(v);
            self
        }
        pub fn set_vgw_telemetry(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VgwTelemetry>>,
        ) -> Self {
            self.vgw_telemetry = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnConnection`](crate::model::VpnConnection)
        pub fn build(self) -> crate::model::VpnConnection {
            crate::model::VpnConnection {
                customer_gateway_configuration: self.customer_gateway_configuration,
                customer_gateway_id: self.customer_gateway_id,
                category: self.category,
                state: self.state,
                r#type: self.r#type,
                vpn_connection_id: self.vpn_connection_id,
                vpn_gateway_id: self.vpn_gateway_id,
                transit_gateway_id: self.transit_gateway_id,
                options: self.options,
                routes: self.routes,
                tags: self.tags,
                vgw_telemetry: self.vgw_telemetry,
            }
        }
    }
}
impl VpnConnection {
    /// Creates a new builder-style object to manufacture [`VpnConnection`](crate::model::VpnConnection)
    pub fn builder() -> crate::model::vpn_connection::Builder {
        crate::model::vpn_connection::Builder::default()
    }
}

/// <p>Describes telemetry for a VPN tunnel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VgwTelemetry {
    /// <p>The number of accepted routes.</p>
    pub accepted_route_count: std::option::Option<i32>,
    /// <p>The date and time of the last change in status.</p>
    pub last_status_change: std::option::Option<smithy_types::Instant>,
    /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
    pub outside_ip_address: std::option::Option<std::string::String>,
    /// <p>The status of the VPN tunnel.</p>
    pub status: std::option::Option<crate::model::TelemetryStatus>,
    /// <p>If an error occurs, a description of the error.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.</p>
    pub certificate_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VgwTelemetry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VgwTelemetry");
        formatter.field("accepted_route_count", &self.accepted_route_count);
        formatter.field("last_status_change", &self.last_status_change);
        formatter.field("outside_ip_address", &self.outside_ip_address);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("certificate_arn", &self.certificate_arn);
        formatter.finish()
    }
}
/// See [`VgwTelemetry`](crate::model::VgwTelemetry)
pub mod vgw_telemetry {
    /// A builder for [`VgwTelemetry`](crate::model::VgwTelemetry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepted_route_count: std::option::Option<i32>,
        pub(crate) last_status_change: std::option::Option<smithy_types::Instant>,
        pub(crate) outside_ip_address: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TelemetryStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) certificate_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of accepted routes.</p>
        pub fn accepted_route_count(mut self, input: i32) -> Self {
            self.accepted_route_count = Some(input);
            self
        }
        pub fn set_accepted_route_count(mut self, input: std::option::Option<i32>) -> Self {
            self.accepted_route_count = input;
            self
        }
        /// <p>The date and time of the last change in status.</p>
        pub fn last_status_change(mut self, input: smithy_types::Instant) -> Self {
            self.last_status_change = Some(input);
            self
        }
        pub fn set_last_status_change(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_status_change = input;
            self
        }
        /// <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
        pub fn outside_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.outside_ip_address = Some(input.into());
            self
        }
        pub fn set_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outside_ip_address = input;
            self
        }
        /// <p>The status of the VPN tunnel.</p>
        pub fn status(mut self, input: crate::model::TelemetryStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TelemetryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>If an error occurs, a description of the error.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_arn = Some(input.into());
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`VgwTelemetry`](crate::model::VgwTelemetry)
        pub fn build(self) -> crate::model::VgwTelemetry {
            crate::model::VgwTelemetry {
                accepted_route_count: self.accepted_route_count,
                last_status_change: self.last_status_change,
                outside_ip_address: self.outside_ip_address,
                status: self.status,
                status_message: self.status_message,
                certificate_arn: self.certificate_arn,
            }
        }
    }
}
impl VgwTelemetry {
    /// Creates a new builder-style object to manufacture [`VgwTelemetry`](crate::model::VgwTelemetry)
    pub fn builder() -> crate::model::vgw_telemetry::Builder {
        crate::model::vgw_telemetry::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TelemetryStatus {
    Down,
    Up,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TelemetryStatus {
    fn from(s: &str) -> Self {
        match s {
            "DOWN" => TelemetryStatus::Down,
            "UP" => TelemetryStatus::Up,
            other => TelemetryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TelemetryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TelemetryStatus::from(s))
    }
}
impl TelemetryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TelemetryStatus::Down => "DOWN",
            TelemetryStatus::Up => "UP",
            TelemetryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DOWN", "UP"]
    }
}
impl AsRef<str> for TelemetryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a static route for a VPN connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnStaticRoute {
    /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>Indicates how the routes were provided.</p>
    pub source: std::option::Option<crate::model::VpnStaticRouteSource>,
    /// <p>The current state of the static route.</p>
    pub state: std::option::Option<crate::model::VpnState>,
}
impl std::fmt::Debug for VpnStaticRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnStaticRoute");
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field("source", &self.source);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`VpnStaticRoute`](crate::model::VpnStaticRoute)
pub mod vpn_static_route {
    /// A builder for [`VpnStaticRoute`](crate::model::VpnStaticRoute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::VpnStaticRouteSource>,
        pub(crate) state: std::option::Option<crate::model::VpnState>,
    }
    impl Builder {
        /// <p>The CIDR block associated with the local subnet of the customer data center.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>Indicates how the routes were provided.</p>
        pub fn source(mut self, input: crate::model::VpnStaticRouteSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::VpnStaticRouteSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The current state of the static route.</p>
        pub fn state(mut self, input: crate::model::VpnState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::VpnState>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnStaticRoute`](crate::model::VpnStaticRoute)
        pub fn build(self) -> crate::model::VpnStaticRoute {
            crate::model::VpnStaticRoute {
                destination_cidr_block: self.destination_cidr_block,
                source: self.source,
                state: self.state,
            }
        }
    }
}
impl VpnStaticRoute {
    /// Creates a new builder-style object to manufacture [`VpnStaticRoute`](crate::model::VpnStaticRoute)
    pub fn builder() -> crate::model::vpn_static_route::Builder {
        crate::model::vpn_static_route::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpnState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpnState {
    fn from(s: &str) -> Self {
        match s {
            "available" => VpnState::Available,
            "deleted" => VpnState::Deleted,
            "deleting" => VpnState::Deleting,
            "pending" => VpnState::Pending,
            other => VpnState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpnState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpnState::from(s))
    }
}
impl VpnState {
    pub fn as_str(&self) -> &str {
        match self {
            VpnState::Available => "available",
            VpnState::Deleted => "deleted",
            VpnState::Deleting => "deleting",
            VpnState::Pending => "pending",
            VpnState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for VpnState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpnStaticRouteSource {
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpnStaticRouteSource {
    fn from(s: &str) -> Self {
        match s {
            "Static" => VpnStaticRouteSource::Static,
            other => VpnStaticRouteSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpnStaticRouteSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpnStaticRouteSource::from(s))
    }
}
impl VpnStaticRouteSource {
    pub fn as_str(&self) -> &str {
        match self {
            VpnStaticRouteSource::Static => "Static",
            VpnStaticRouteSource::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Static"]
    }
}
impl AsRef<str> for VpnStaticRouteSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes VPN connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnConnectionOptions {
    /// <p>Indicates whether acceleration is enabled for the VPN connection.</p>
    pub enable_acceleration: std::option::Option<bool>,
    /// <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
    pub static_routes_only: std::option::Option<bool>,
    /// <p>The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
    pub local_ipv4_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv4 CIDR on the AWS side of the VPN connection.</p>
    pub remote_ipv4_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
    pub local_ipv6_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR on the AWS side of the VPN connection.</p>
    pub remote_ipv6_network_cidr: std::option::Option<std::string::String>,
    /// <p>Indicates whether the VPN tunnels process IPv4 or IPv6 traffic.</p>
    pub tunnel_inside_ip_version: std::option::Option<crate::model::TunnelInsideIpVersion>,
    /// <p>Indicates the VPN tunnel options.</p>
    pub tunnel_options: std::option::Option<std::vec::Vec<crate::model::TunnelOption>>,
}
impl std::fmt::Debug for VpnConnectionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnConnectionOptions");
        formatter.field("enable_acceleration", &self.enable_acceleration);
        formatter.field("static_routes_only", &self.static_routes_only);
        formatter.field("local_ipv4_network_cidr", &self.local_ipv4_network_cidr);
        formatter.field("remote_ipv4_network_cidr", &self.remote_ipv4_network_cidr);
        formatter.field("local_ipv6_network_cidr", &self.local_ipv6_network_cidr);
        formatter.field("remote_ipv6_network_cidr", &self.remote_ipv6_network_cidr);
        formatter.field("tunnel_inside_ip_version", &self.tunnel_inside_ip_version);
        formatter.field("tunnel_options", &self.tunnel_options);
        formatter.finish()
    }
}
/// See [`VpnConnectionOptions`](crate::model::VpnConnectionOptions)
pub mod vpn_connection_options {
    /// A builder for [`VpnConnectionOptions`](crate::model::VpnConnectionOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_acceleration: std::option::Option<bool>,
        pub(crate) static_routes_only: std::option::Option<bool>,
        pub(crate) local_ipv4_network_cidr: std::option::Option<std::string::String>,
        pub(crate) remote_ipv4_network_cidr: std::option::Option<std::string::String>,
        pub(crate) local_ipv6_network_cidr: std::option::Option<std::string::String>,
        pub(crate) remote_ipv6_network_cidr: std::option::Option<std::string::String>,
        pub(crate) tunnel_inside_ip_version:
            std::option::Option<crate::model::TunnelInsideIpVersion>,
        pub(crate) tunnel_options: std::option::Option<std::vec::Vec<crate::model::TunnelOption>>,
    }
    impl Builder {
        /// <p>Indicates whether acceleration is enabled for the VPN connection.</p>
        pub fn enable_acceleration(mut self, input: bool) -> Self {
            self.enable_acceleration = Some(input);
            self
        }
        pub fn set_enable_acceleration(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_acceleration = input;
            self
        }
        /// <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
        pub fn static_routes_only(mut self, input: bool) -> Self {
            self.static_routes_only = Some(input);
            self
        }
        pub fn set_static_routes_only(mut self, input: std::option::Option<bool>) -> Self {
            self.static_routes_only = input;
            self
        }
        /// <p>The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        pub fn local_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_ipv4_network_cidr = Some(input.into());
            self
        }
        pub fn set_local_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_ipv4_network_cidr = input;
            self
        }
        /// <p>The IPv4 CIDR on the AWS side of the VPN connection.</p>
        pub fn remote_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.remote_ipv4_network_cidr = Some(input.into());
            self
        }
        pub fn set_remote_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_ipv4_network_cidr = input;
            self
        }
        /// <p>The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        pub fn local_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_ipv6_network_cidr = Some(input.into());
            self
        }
        pub fn set_local_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_ipv6_network_cidr = input;
            self
        }
        /// <p>The IPv6 CIDR on the AWS side of the VPN connection.</p>
        pub fn remote_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.remote_ipv6_network_cidr = Some(input.into());
            self
        }
        pub fn set_remote_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_ipv6_network_cidr = input;
            self
        }
        /// <p>Indicates whether the VPN tunnels process IPv4 or IPv6 traffic.</p>
        pub fn tunnel_inside_ip_version(
            mut self,
            input: crate::model::TunnelInsideIpVersion,
        ) -> Self {
            self.tunnel_inside_ip_version = Some(input);
            self
        }
        pub fn set_tunnel_inside_ip_version(
            mut self,
            input: std::option::Option<crate::model::TunnelInsideIpVersion>,
        ) -> Self {
            self.tunnel_inside_ip_version = input;
            self
        }
        pub fn tunnel_options(mut self, input: impl Into<crate::model::TunnelOption>) -> Self {
            let mut v = self.tunnel_options.unwrap_or_default();
            v.push(input.into());
            self.tunnel_options = Some(v);
            self
        }
        pub fn set_tunnel_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TunnelOption>>,
        ) -> Self {
            self.tunnel_options = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnConnectionOptions`](crate::model::VpnConnectionOptions)
        pub fn build(self) -> crate::model::VpnConnectionOptions {
            crate::model::VpnConnectionOptions {
                enable_acceleration: self.enable_acceleration,
                static_routes_only: self.static_routes_only,
                local_ipv4_network_cidr: self.local_ipv4_network_cidr,
                remote_ipv4_network_cidr: self.remote_ipv4_network_cidr,
                local_ipv6_network_cidr: self.local_ipv6_network_cidr,
                remote_ipv6_network_cidr: self.remote_ipv6_network_cidr,
                tunnel_inside_ip_version: self.tunnel_inside_ip_version,
                tunnel_options: self.tunnel_options,
            }
        }
    }
}
impl VpnConnectionOptions {
    /// Creates a new builder-style object to manufacture [`VpnConnectionOptions`](crate::model::VpnConnectionOptions)
    pub fn builder() -> crate::model::vpn_connection_options::Builder {
        crate::model::vpn_connection_options::Builder::default()
    }
}

/// <p>The VPN tunnel options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TunnelOption {
    /// <p>The external IP address of the VPN tunnel.</p>
    pub outside_ip_address: std::option::Option<std::string::String>,
    /// <p>The range of inside IPv4 addresses for the tunnel.</p>
    pub tunnel_inside_cidr: std::option::Option<std::string::String>,
    /// <p>The range of inside IPv6 addresses for the tunnel.</p>
    pub tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual
    /// private gateway and the customer gateway.</p>
    pub pre_shared_key: std::option::Option<std::string::String>,
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    pub phase1_lifetime_seconds: std::option::Option<i32>,
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    pub phase2_lifetime_seconds: std::option::Option<i32>,
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey.</p>
    pub rekey_margin_time_seconds: std::option::Option<i32>,
    /// <p>The percentage of the rekey window determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
    pub rekey_fuzz_percentage: std::option::Option<i32>,
    /// <p>The number of packets in an IKE replay window.</p>
    pub replay_window_size: std::option::Option<i32>,
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    pub dpd_timeout_seconds: std::option::Option<i32>,
    /// <p>The action to take after a DPD timeout occurs.</p>
    pub dpd_timeout_action: std::option::Option<std::string::String>,
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_encryption_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsListValue>>,
    /// <p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_encryption_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsListValue>>,
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsListValue>>,
    /// <p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsListValue>>,
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>
    pub phase1_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersListValue>>,
    /// <p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>
    pub phase2_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersListValue>>,
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    pub ike_versions: std::option::Option<std::vec::Vec<crate::model::IkeVersionsListValue>>,
    /// <p>The action to take when the establishing the VPN tunnels for a VPN connection.</p>
    pub startup_action: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TunnelOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TunnelOption");
        formatter.field("outside_ip_address", &self.outside_ip_address);
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.field("tunnel_inside_ipv6_cidr", &self.tunnel_inside_ipv6_cidr);
        formatter.field("pre_shared_key", &self.pre_shared_key);
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("dpd_timeout_action", &self.dpd_timeout_action);
        formatter.field(
            "phase1_encryption_algorithms",
            &self.phase1_encryption_algorithms,
        );
        formatter.field(
            "phase2_encryption_algorithms",
            &self.phase2_encryption_algorithms,
        );
        formatter.field(
            "phase1_integrity_algorithms",
            &self.phase1_integrity_algorithms,
        );
        formatter.field(
            "phase2_integrity_algorithms",
            &self.phase2_integrity_algorithms,
        );
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("startup_action", &self.startup_action);
        formatter.finish()
    }
}
/// See [`TunnelOption`](crate::model::TunnelOption)
pub mod tunnel_option {
    /// A builder for [`TunnelOption`](crate::model::TunnelOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outside_ip_address: std::option::Option<std::string::String>,
        pub(crate) tunnel_inside_cidr: std::option::Option<std::string::String>,
        pub(crate) tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
        pub(crate) pre_shared_key: std::option::Option<std::string::String>,
        pub(crate) phase1_lifetime_seconds: std::option::Option<i32>,
        pub(crate) phase2_lifetime_seconds: std::option::Option<i32>,
        pub(crate) rekey_margin_time_seconds: std::option::Option<i32>,
        pub(crate) rekey_fuzz_percentage: std::option::Option<i32>,
        pub(crate) replay_window_size: std::option::Option<i32>,
        pub(crate) dpd_timeout_seconds: std::option::Option<i32>,
        pub(crate) dpd_timeout_action: std::option::Option<std::string::String>,
        pub(crate) phase1_encryption_algorithms:
            std::option::Option<std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsListValue>>,
        pub(crate) phase2_encryption_algorithms:
            std::option::Option<std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsListValue>>,
        pub(crate) phase1_integrity_algorithms:
            std::option::Option<std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsListValue>>,
        pub(crate) phase2_integrity_algorithms:
            std::option::Option<std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsListValue>>,
        pub(crate) phase1_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersListValue>>,
        pub(crate) phase2_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersListValue>>,
        pub(crate) ike_versions:
            std::option::Option<std::vec::Vec<crate::model::IkeVersionsListValue>>,
        pub(crate) startup_action: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The external IP address of the VPN tunnel.</p>
        pub fn outside_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.outside_ip_address = Some(input.into());
            self
        }
        pub fn set_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outside_ip_address = input;
            self
        }
        /// <p>The range of inside IPv4 addresses for the tunnel.</p>
        pub fn tunnel_inside_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_cidr = input;
            self
        }
        /// <p>The range of inside IPv6 addresses for the tunnel.</p>
        pub fn tunnel_inside_ipv6_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_ipv6_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_ipv6_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_ipv6_cidr = input;
            self
        }
        /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual
        /// private gateway and the customer gateway.</p>
        pub fn pre_shared_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_shared_key = Some(input.into());
            self
        }
        pub fn set_pre_shared_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_shared_key = input;
            self
        }
        /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
        pub fn phase1_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase1_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase1_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase1_lifetime_seconds = input;
            self
        }
        /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
        pub fn phase2_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase2_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase2_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase2_lifetime_seconds = input;
            self
        }
        /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey.</p>
        pub fn rekey_margin_time_seconds(mut self, input: i32) -> Self {
            self.rekey_margin_time_seconds = Some(input);
            self
        }
        pub fn set_rekey_margin_time_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_margin_time_seconds = input;
            self
        }
        /// <p>The percentage of the rekey window determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>
        pub fn rekey_fuzz_percentage(mut self, input: i32) -> Self {
            self.rekey_fuzz_percentage = Some(input);
            self
        }
        pub fn set_rekey_fuzz_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_fuzz_percentage = input;
            self
        }
        /// <p>The number of packets in an IKE replay window.</p>
        pub fn replay_window_size(mut self, input: i32) -> Self {
            self.replay_window_size = Some(input);
            self
        }
        pub fn set_replay_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.replay_window_size = input;
            self
        }
        /// <p>The number of seconds after which a DPD timeout occurs.</p>
        pub fn dpd_timeout_seconds(mut self, input: i32) -> Self {
            self.dpd_timeout_seconds = Some(input);
            self
        }
        pub fn set_dpd_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.dpd_timeout_seconds = input;
            self
        }
        /// <p>The action to take after a DPD timeout occurs.</p>
        pub fn dpd_timeout_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.dpd_timeout_action = Some(input.into());
            self
        }
        pub fn set_dpd_timeout_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dpd_timeout_action = input;
            self
        }
        pub fn phase1_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1EncryptionAlgorithmsListValue>,
        ) -> Self {
            let mut v = self.phase1_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase1_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsListValue>,
            >,
        ) -> Self {
            self.phase1_encryption_algorithms = input;
            self
        }
        pub fn phase2_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2EncryptionAlgorithmsListValue>,
        ) -> Self {
            let mut v = self.phase2_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase2_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsListValue>,
            >,
        ) -> Self {
            self.phase2_encryption_algorithms = input;
            self
        }
        pub fn phase1_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1IntegrityAlgorithmsListValue>,
        ) -> Self {
            let mut v = self.phase1_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase1_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsListValue>,
            >,
        ) -> Self {
            self.phase1_integrity_algorithms = input;
            self
        }
        pub fn phase2_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2IntegrityAlgorithmsListValue>,
        ) -> Self {
            let mut v = self.phase2_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase2_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsListValue>,
            >,
        ) -> Self {
            self.phase2_integrity_algorithms = input;
            self
        }
        pub fn phase1_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase1DhGroupNumbersListValue>,
        ) -> Self {
            let mut v = self.phase1_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase1_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase1_dh_group_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersListValue>>,
        ) -> Self {
            self.phase1_dh_group_numbers = input;
            self
        }
        pub fn phase2_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase2DhGroupNumbersListValue>,
        ) -> Self {
            let mut v = self.phase2_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase2_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase2_dh_group_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersListValue>>,
        ) -> Self {
            self.phase2_dh_group_numbers = input;
            self
        }
        pub fn ike_versions(
            mut self,
            input: impl Into<crate::model::IkeVersionsListValue>,
        ) -> Self {
            let mut v = self.ike_versions.unwrap_or_default();
            v.push(input.into());
            self.ike_versions = Some(v);
            self
        }
        pub fn set_ike_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IkeVersionsListValue>>,
        ) -> Self {
            self.ike_versions = input;
            self
        }
        /// <p>The action to take when the establishing the VPN tunnels for a VPN connection.</p>
        pub fn startup_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.startup_action = Some(input.into());
            self
        }
        pub fn set_startup_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.startup_action = input;
            self
        }
        /// Consumes the builder and constructs a [`TunnelOption`](crate::model::TunnelOption)
        pub fn build(self) -> crate::model::TunnelOption {
            crate::model::TunnelOption {
                outside_ip_address: self.outside_ip_address,
                tunnel_inside_cidr: self.tunnel_inside_cidr,
                tunnel_inside_ipv6_cidr: self.tunnel_inside_ipv6_cidr,
                pre_shared_key: self.pre_shared_key,
                phase1_lifetime_seconds: self.phase1_lifetime_seconds,
                phase2_lifetime_seconds: self.phase2_lifetime_seconds,
                rekey_margin_time_seconds: self.rekey_margin_time_seconds,
                rekey_fuzz_percentage: self.rekey_fuzz_percentage,
                replay_window_size: self.replay_window_size,
                dpd_timeout_seconds: self.dpd_timeout_seconds,
                dpd_timeout_action: self.dpd_timeout_action,
                phase1_encryption_algorithms: self.phase1_encryption_algorithms,
                phase2_encryption_algorithms: self.phase2_encryption_algorithms,
                phase1_integrity_algorithms: self.phase1_integrity_algorithms,
                phase2_integrity_algorithms: self.phase2_integrity_algorithms,
                phase1_dh_group_numbers: self.phase1_dh_group_numbers,
                phase2_dh_group_numbers: self.phase2_dh_group_numbers,
                ike_versions: self.ike_versions,
                startup_action: self.startup_action,
            }
        }
    }
}
impl TunnelOption {
    /// Creates a new builder-style object to manufacture [`TunnelOption`](crate::model::TunnelOption)
    pub fn builder() -> crate::model::tunnel_option::Builder {
        crate::model::tunnel_option::Builder::default()
    }
}

/// <p>The internet key exchange (IKE) version permitted for the VPN tunnel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IkeVersionsListValue {
    /// <p>The IKE version.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IkeVersionsListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IkeVersionsListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`IkeVersionsListValue`](crate::model::IkeVersionsListValue)
pub mod ike_versions_list_value {
    /// A builder for [`IkeVersionsListValue`](crate::model::IkeVersionsListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IKE version.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`IkeVersionsListValue`](crate::model::IkeVersionsListValue)
        pub fn build(self) -> crate::model::IkeVersionsListValue {
            crate::model::IkeVersionsListValue { value: self.value }
        }
    }
}
impl IkeVersionsListValue {
    /// Creates a new builder-style object to manufacture [`IkeVersionsListValue`](crate::model::IkeVersionsListValue)
    pub fn builder() -> crate::model::ike_versions_list_value::Builder {
        crate::model::ike_versions_list_value::Builder::default()
    }
}

/// <p>The Diffie-Hellmann group number for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2DhGroupNumbersListValue {
    /// <p>The Diffie-Hellmann group number.</p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for Phase2DhGroupNumbersListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2DhGroupNumbersListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2DhGroupNumbersListValue`](crate::model::Phase2DhGroupNumbersListValue)
pub mod phase2_dh_group_numbers_list_value {
    /// A builder for [`Phase2DhGroupNumbersListValue`](crate::model::Phase2DhGroupNumbersListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Diffie-Hellmann group number.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2DhGroupNumbersListValue`](crate::model::Phase2DhGroupNumbersListValue)
        pub fn build(self) -> crate::model::Phase2DhGroupNumbersListValue {
            crate::model::Phase2DhGroupNumbersListValue { value: self.value }
        }
    }
}
impl Phase2DhGroupNumbersListValue {
    /// Creates a new builder-style object to manufacture [`Phase2DhGroupNumbersListValue`](crate::model::Phase2DhGroupNumbersListValue)
    pub fn builder() -> crate::model::phase2_dh_group_numbers_list_value::Builder {
        crate::model::phase2_dh_group_numbers_list_value::Builder::default()
    }
}

/// <p>The Diffie-Hellmann group number for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1DhGroupNumbersListValue {
    /// <p>The Diffie-Hellmann group number.</p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for Phase1DhGroupNumbersListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1DhGroupNumbersListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1DhGroupNumbersListValue`](crate::model::Phase1DhGroupNumbersListValue)
pub mod phase1_dh_group_numbers_list_value {
    /// A builder for [`Phase1DhGroupNumbersListValue`](crate::model::Phase1DhGroupNumbersListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Diffie-Hellmann group number.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1DhGroupNumbersListValue`](crate::model::Phase1DhGroupNumbersListValue)
        pub fn build(self) -> crate::model::Phase1DhGroupNumbersListValue {
            crate::model::Phase1DhGroupNumbersListValue { value: self.value }
        }
    }
}
impl Phase1DhGroupNumbersListValue {
    /// Creates a new builder-style object to manufacture [`Phase1DhGroupNumbersListValue`](crate::model::Phase1DhGroupNumbersListValue)
    pub fn builder() -> crate::model::phase1_dh_group_numbers_list_value::Builder {
        crate::model::phase1_dh_group_numbers_list_value::Builder::default()
    }
}

/// <p>The integrity algorithm for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2IntegrityAlgorithmsListValue {
    /// <p>The integrity algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase2IntegrityAlgorithmsListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2IntegrityAlgorithmsListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2IntegrityAlgorithmsListValue`](crate::model::Phase2IntegrityAlgorithmsListValue)
pub mod phase2_integrity_algorithms_list_value {
    /// A builder for [`Phase2IntegrityAlgorithmsListValue`](crate::model::Phase2IntegrityAlgorithmsListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The integrity algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2IntegrityAlgorithmsListValue`](crate::model::Phase2IntegrityAlgorithmsListValue)
        pub fn build(self) -> crate::model::Phase2IntegrityAlgorithmsListValue {
            crate::model::Phase2IntegrityAlgorithmsListValue { value: self.value }
        }
    }
}
impl Phase2IntegrityAlgorithmsListValue {
    /// Creates a new builder-style object to manufacture [`Phase2IntegrityAlgorithmsListValue`](crate::model::Phase2IntegrityAlgorithmsListValue)
    pub fn builder() -> crate::model::phase2_integrity_algorithms_list_value::Builder {
        crate::model::phase2_integrity_algorithms_list_value::Builder::default()
    }
}

/// <p>The integrity algorithm for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1IntegrityAlgorithmsListValue {
    /// <p>The value for the integrity algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase1IntegrityAlgorithmsListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1IntegrityAlgorithmsListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1IntegrityAlgorithmsListValue`](crate::model::Phase1IntegrityAlgorithmsListValue)
pub mod phase1_integrity_algorithms_list_value {
    /// A builder for [`Phase1IntegrityAlgorithmsListValue`](crate::model::Phase1IntegrityAlgorithmsListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value for the integrity algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1IntegrityAlgorithmsListValue`](crate::model::Phase1IntegrityAlgorithmsListValue)
        pub fn build(self) -> crate::model::Phase1IntegrityAlgorithmsListValue {
            crate::model::Phase1IntegrityAlgorithmsListValue { value: self.value }
        }
    }
}
impl Phase1IntegrityAlgorithmsListValue {
    /// Creates a new builder-style object to manufacture [`Phase1IntegrityAlgorithmsListValue`](crate::model::Phase1IntegrityAlgorithmsListValue)
    pub fn builder() -> crate::model::phase1_integrity_algorithms_list_value::Builder {
        crate::model::phase1_integrity_algorithms_list_value::Builder::default()
    }
}

/// <p>The encryption algorithm for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2EncryptionAlgorithmsListValue {
    /// <p>The encryption algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase2EncryptionAlgorithmsListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2EncryptionAlgorithmsListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2EncryptionAlgorithmsListValue`](crate::model::Phase2EncryptionAlgorithmsListValue)
pub mod phase2_encryption_algorithms_list_value {
    /// A builder for [`Phase2EncryptionAlgorithmsListValue`](crate::model::Phase2EncryptionAlgorithmsListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2EncryptionAlgorithmsListValue`](crate::model::Phase2EncryptionAlgorithmsListValue)
        pub fn build(self) -> crate::model::Phase2EncryptionAlgorithmsListValue {
            crate::model::Phase2EncryptionAlgorithmsListValue { value: self.value }
        }
    }
}
impl Phase2EncryptionAlgorithmsListValue {
    /// Creates a new builder-style object to manufacture [`Phase2EncryptionAlgorithmsListValue`](crate::model::Phase2EncryptionAlgorithmsListValue)
    pub fn builder() -> crate::model::phase2_encryption_algorithms_list_value::Builder {
        crate::model::phase2_encryption_algorithms_list_value::Builder::default()
    }
}

/// <p>The encryption algorithm for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1EncryptionAlgorithmsListValue {
    /// <p>The value for the encryption algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase1EncryptionAlgorithmsListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1EncryptionAlgorithmsListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1EncryptionAlgorithmsListValue`](crate::model::Phase1EncryptionAlgorithmsListValue)
pub mod phase1_encryption_algorithms_list_value {
    /// A builder for [`Phase1EncryptionAlgorithmsListValue`](crate::model::Phase1EncryptionAlgorithmsListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value for the encryption algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1EncryptionAlgorithmsListValue`](crate::model::Phase1EncryptionAlgorithmsListValue)
        pub fn build(self) -> crate::model::Phase1EncryptionAlgorithmsListValue {
            crate::model::Phase1EncryptionAlgorithmsListValue { value: self.value }
        }
    }
}
impl Phase1EncryptionAlgorithmsListValue {
    /// Creates a new builder-style object to manufacture [`Phase1EncryptionAlgorithmsListValue`](crate::model::Phase1EncryptionAlgorithmsListValue)
    pub fn builder() -> crate::model::phase1_encryption_algorithms_list_value::Builder {
        crate::model::phase1_encryption_algorithms_list_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TunnelInsideIpVersion {
    Ipv4,
    Ipv6,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TunnelInsideIpVersion {
    fn from(s: &str) -> Self {
        match s {
            "ipv4" => TunnelInsideIpVersion::Ipv4,
            "ipv6" => TunnelInsideIpVersion::Ipv6,
            other => TunnelInsideIpVersion::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TunnelInsideIpVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TunnelInsideIpVersion::from(s))
    }
}
impl TunnelInsideIpVersion {
    pub fn as_str(&self) -> &str {
        match self {
            TunnelInsideIpVersion::Ipv4 => "ipv4",
            TunnelInsideIpVersion::Ipv6 => "ipv6",
            TunnelInsideIpVersion::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ipv4", "ipv6"]
    }
}
impl AsRef<str> for TunnelInsideIpVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GatewayType {
    Ipsec1,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for GatewayType {
    fn from(s: &str) -> Self {
        match s {
            "ipsec.1" => GatewayType::Ipsec1,
            other => GatewayType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for GatewayType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GatewayType::from(s))
    }
}
impl GatewayType {
    pub fn as_str(&self) -> &str {
        match self {
            GatewayType::Ipsec1 => "ipsec.1",
            GatewayType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ipsec.1"]
    }
}
impl AsRef<str> for GatewayType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The AWS Site-to-Site VPN tunnel options to modify.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModifyVpnTunnelOptionsSpecification {
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique
    /// across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The
    /// following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>169.254.0.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.1.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.2.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.3.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.4.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.5.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.169.252/30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub tunnel_inside_cidr: std::option::Option<std::string::String>,
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual
    /// private gateway and the customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and
    /// underscores (_). Must be between 8 and 64 characters in length and cannot start with
    /// zero (0).</p>
    pub pre_shared_key: std::option::Option<std::string::String>,
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code>
    /// </p>
    pub phase1_lifetime_seconds: std::option::Option<i32>,
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code>
    /// </p>
    pub phase2_lifetime_seconds: std::option::Option<i32>,
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code>
    /// </p>
    pub rekey_margin_time_seconds: std::option::Option<i32>,
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code>
    /// </p>
    pub rekey_fuzz_percentage: std::option::Option<i32>,
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code>
    /// </p>
    pub replay_window_size: std::option::Option<i32>,
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value between 0 and 30.</p>
    /// <p>Default: <code>30</code>
    /// </p>
    pub dpd_timeout_seconds: std::option::Option<i32>,
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code>
    /// </p>
    /// <p>Default: <code>clear</code>
    /// </p>
    pub dpd_timeout_action: std::option::Option<std::string::String>,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code>
    /// </p>
    pub phase1_encryption_algorithms: std::option::Option<
        std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
    >,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code>
    /// </p>
    pub phase2_encryption_algorithms: std::option::Option<
        std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
    >,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code>
    /// </p>
    pub phase1_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code>
    /// </p>
    pub phase2_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code>
    /// </p>
    pub phase1_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code>
    /// </p>
    pub phase2_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>>,
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code>
    /// </p>
    pub ike_versions: std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for AWS to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code>
    /// </p>
    /// <p>Default: <code>add</code>
    /// </p>
    pub startup_action: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModifyVpnTunnelOptionsSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModifyVpnTunnelOptionsSpecification");
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.field("tunnel_inside_ipv6_cidr", &self.tunnel_inside_ipv6_cidr);
        formatter.field("pre_shared_key", &self.pre_shared_key);
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("dpd_timeout_action", &self.dpd_timeout_action);
        formatter.field(
            "phase1_encryption_algorithms",
            &self.phase1_encryption_algorithms,
        );
        formatter.field(
            "phase2_encryption_algorithms",
            &self.phase2_encryption_algorithms,
        );
        formatter.field(
            "phase1_integrity_algorithms",
            &self.phase1_integrity_algorithms,
        );
        formatter.field(
            "phase2_integrity_algorithms",
            &self.phase2_integrity_algorithms,
        );
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("startup_action", &self.startup_action);
        formatter.finish()
    }
}
/// See [`ModifyVpnTunnelOptionsSpecification`](crate::model::ModifyVpnTunnelOptionsSpecification)
pub mod modify_vpn_tunnel_options_specification {
    /// A builder for [`ModifyVpnTunnelOptionsSpecification`](crate::model::ModifyVpnTunnelOptionsSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tunnel_inside_cidr: std::option::Option<std::string::String>,
        pub(crate) tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
        pub(crate) pre_shared_key: std::option::Option<std::string::String>,
        pub(crate) phase1_lifetime_seconds: std::option::Option<i32>,
        pub(crate) phase2_lifetime_seconds: std::option::Option<i32>,
        pub(crate) rekey_margin_time_seconds: std::option::Option<i32>,
        pub(crate) rekey_fuzz_percentage: std::option::Option<i32>,
        pub(crate) replay_window_size: std::option::Option<i32>,
        pub(crate) dpd_timeout_seconds: std::option::Option<i32>,
        pub(crate) dpd_timeout_action: std::option::Option<std::string::String>,
        pub(crate) phase1_encryption_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
        >,
        pub(crate) phase2_encryption_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
        >,
        pub(crate) phase1_integrity_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
        >,
        pub(crate) phase2_integrity_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
        >,
        pub(crate) phase1_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>>,
        pub(crate) phase2_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>>,
        pub(crate) ike_versions:
            std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
        pub(crate) startup_action: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique
        /// across all VPN connections that use the same virtual private gateway. </p>
        /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The
        /// following CIDR blocks are reserved and cannot be used:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>169.254.0.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.1.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.2.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.3.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.4.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.5.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.169.252/30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn tunnel_inside_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_cidr = input;
            self
        }
        /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
        /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
        pub fn tunnel_inside_ipv6_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_ipv6_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_ipv6_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_ipv6_cidr = input;
            self
        }
        /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual
        /// private gateway and the customer gateway.</p>
        /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and
        /// underscores (_). Must be between 8 and 64 characters in length and cannot start with
        /// zero (0).</p>
        pub fn pre_shared_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_shared_key = Some(input.into());
            self
        }
        pub fn set_pre_shared_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_shared_key = input;
            self
        }
        /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
        /// <p>Constraints: A value between 900 and 28,800.</p>
        /// <p>Default: <code>28800</code>
        /// </p>
        pub fn phase1_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase1_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase1_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase1_lifetime_seconds = input;
            self
        }
        /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
        /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
        /// <p>Default: <code>3600</code>
        /// </p>
        pub fn phase2_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase2_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase2_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase2_lifetime_seconds = input;
            self
        }
        /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
        /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
        /// <p>Default: <code>540</code>
        /// </p>
        pub fn rekey_margin_time_seconds(mut self, input: i32) -> Self {
            self.rekey_margin_time_seconds = Some(input);
            self
        }
        pub fn set_rekey_margin_time_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_margin_time_seconds = input;
            self
        }
        /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
        /// <p>Constraints: A value between 0 and 100.</p>
        /// <p>Default: <code>100</code>
        /// </p>
        pub fn rekey_fuzz_percentage(mut self, input: i32) -> Self {
            self.rekey_fuzz_percentage = Some(input);
            self
        }
        pub fn set_rekey_fuzz_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_fuzz_percentage = input;
            self
        }
        /// <p>The number of packets in an IKE replay window.</p>
        /// <p>Constraints: A value between 64 and 2048.</p>
        /// <p>Default: <code>1024</code>
        /// </p>
        pub fn replay_window_size(mut self, input: i32) -> Self {
            self.replay_window_size = Some(input);
            self
        }
        pub fn set_replay_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.replay_window_size = input;
            self
        }
        /// <p>The number of seconds after which a DPD timeout occurs.</p>
        /// <p>Constraints: A value between 0 and 30.</p>
        /// <p>Default: <code>30</code>
        /// </p>
        pub fn dpd_timeout_seconds(mut self, input: i32) -> Self {
            self.dpd_timeout_seconds = Some(input);
            self
        }
        pub fn set_dpd_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.dpd_timeout_seconds = input;
            self
        }
        /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
        /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code>
        /// </p>
        /// <p>Default: <code>clear</code>
        /// </p>
        pub fn dpd_timeout_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.dpd_timeout_action = Some(input.into());
            self
        }
        pub fn set_dpd_timeout_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dpd_timeout_action = input;
            self
        }
        pub fn phase1_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase1_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase1_encryption_algorithms = input;
            self
        }
        pub fn phase2_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase2_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase2_encryption_algorithms = input;
            self
        }
        pub fn phase1_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase1_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase1_integrity_algorithms = input;
            self
        }
        pub fn phase2_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase2_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase2_integrity_algorithms = input;
            self
        }
        pub fn phase1_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase1DhGroupNumbersRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase1_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase1_dh_group_numbers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>,
            >,
        ) -> Self {
            self.phase1_dh_group_numbers = input;
            self
        }
        pub fn phase2_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase2DhGroupNumbersRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase2_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase2_dh_group_numbers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>,
            >,
        ) -> Self {
            self.phase2_dh_group_numbers = input;
            self
        }
        pub fn ike_versions(
            mut self,
            input: impl Into<crate::model::IkeVersionsRequestListValue>,
        ) -> Self {
            let mut v = self.ike_versions.unwrap_or_default();
            v.push(input.into());
            self.ike_versions = Some(v);
            self
        }
        pub fn set_ike_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
        ) -> Self {
            self.ike_versions = input;
            self
        }
        /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for AWS to initiate the IKE negotiation.</p>
        /// <p>Valid Values: <code>add</code> | <code>start</code>
        /// </p>
        /// <p>Default: <code>add</code>
        /// </p>
        pub fn startup_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.startup_action = Some(input.into());
            self
        }
        pub fn set_startup_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.startup_action = input;
            self
        }
        /// Consumes the builder and constructs a [`ModifyVpnTunnelOptionsSpecification`](crate::model::ModifyVpnTunnelOptionsSpecification)
        pub fn build(self) -> crate::model::ModifyVpnTunnelOptionsSpecification {
            crate::model::ModifyVpnTunnelOptionsSpecification {
                tunnel_inside_cidr: self.tunnel_inside_cidr,
                tunnel_inside_ipv6_cidr: self.tunnel_inside_ipv6_cidr,
                pre_shared_key: self.pre_shared_key,
                phase1_lifetime_seconds: self.phase1_lifetime_seconds,
                phase2_lifetime_seconds: self.phase2_lifetime_seconds,
                rekey_margin_time_seconds: self.rekey_margin_time_seconds,
                rekey_fuzz_percentage: self.rekey_fuzz_percentage,
                replay_window_size: self.replay_window_size,
                dpd_timeout_seconds: self.dpd_timeout_seconds,
                dpd_timeout_action: self.dpd_timeout_action,
                phase1_encryption_algorithms: self.phase1_encryption_algorithms,
                phase2_encryption_algorithms: self.phase2_encryption_algorithms,
                phase1_integrity_algorithms: self.phase1_integrity_algorithms,
                phase2_integrity_algorithms: self.phase2_integrity_algorithms,
                phase1_dh_group_numbers: self.phase1_dh_group_numbers,
                phase2_dh_group_numbers: self.phase2_dh_group_numbers,
                ike_versions: self.ike_versions,
                startup_action: self.startup_action,
            }
        }
    }
}
impl ModifyVpnTunnelOptionsSpecification {
    /// Creates a new builder-style object to manufacture [`ModifyVpnTunnelOptionsSpecification`](crate::model::ModifyVpnTunnelOptionsSpecification)
    pub fn builder() -> crate::model::modify_vpn_tunnel_options_specification::Builder {
        crate::model::modify_vpn_tunnel_options_specification::Builder::default()
    }
}

/// <p>The IKE version that is permitted for the VPN tunnel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IkeVersionsRequestListValue {
    /// <p>The IKE version.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IkeVersionsRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IkeVersionsRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`IkeVersionsRequestListValue`](crate::model::IkeVersionsRequestListValue)
pub mod ike_versions_request_list_value {
    /// A builder for [`IkeVersionsRequestListValue`](crate::model::IkeVersionsRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IKE version.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`IkeVersionsRequestListValue`](crate::model::IkeVersionsRequestListValue)
        pub fn build(self) -> crate::model::IkeVersionsRequestListValue {
            crate::model::IkeVersionsRequestListValue { value: self.value }
        }
    }
}
impl IkeVersionsRequestListValue {
    /// Creates a new builder-style object to manufacture [`IkeVersionsRequestListValue`](crate::model::IkeVersionsRequestListValue)
    pub fn builder() -> crate::model::ike_versions_request_list_value::Builder {
        crate::model::ike_versions_request_list_value::Builder::default()
    }
}

/// <p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2DhGroupNumbersRequestListValue {
    /// <p>The Diffie-Hellmann group number.</p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for Phase2DhGroupNumbersRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2DhGroupNumbersRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2DhGroupNumbersRequestListValue`](crate::model::Phase2DhGroupNumbersRequestListValue)
pub mod phase2_dh_group_numbers_request_list_value {
    /// A builder for [`Phase2DhGroupNumbersRequestListValue`](crate::model::Phase2DhGroupNumbersRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Diffie-Hellmann group number.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2DhGroupNumbersRequestListValue`](crate::model::Phase2DhGroupNumbersRequestListValue)
        pub fn build(self) -> crate::model::Phase2DhGroupNumbersRequestListValue {
            crate::model::Phase2DhGroupNumbersRequestListValue { value: self.value }
        }
    }
}
impl Phase2DhGroupNumbersRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase2DhGroupNumbersRequestListValue`](crate::model::Phase2DhGroupNumbersRequestListValue)
    pub fn builder() -> crate::model::phase2_dh_group_numbers_request_list_value::Builder {
        crate::model::phase2_dh_group_numbers_request_list_value::Builder::default()
    }
}

/// <p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1DhGroupNumbersRequestListValue {
    /// <p>The Diffie-Hellmann group number.</p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for Phase1DhGroupNumbersRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1DhGroupNumbersRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1DhGroupNumbersRequestListValue`](crate::model::Phase1DhGroupNumbersRequestListValue)
pub mod phase1_dh_group_numbers_request_list_value {
    /// A builder for [`Phase1DhGroupNumbersRequestListValue`](crate::model::Phase1DhGroupNumbersRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Diffie-Hellmann group number.</p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1DhGroupNumbersRequestListValue`](crate::model::Phase1DhGroupNumbersRequestListValue)
        pub fn build(self) -> crate::model::Phase1DhGroupNumbersRequestListValue {
            crate::model::Phase1DhGroupNumbersRequestListValue { value: self.value }
        }
    }
}
impl Phase1DhGroupNumbersRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase1DhGroupNumbersRequestListValue`](crate::model::Phase1DhGroupNumbersRequestListValue)
    pub fn builder() -> crate::model::phase1_dh_group_numbers_request_list_value::Builder {
        crate::model::phase1_dh_group_numbers_request_list_value::Builder::default()
    }
}

/// <p>Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2IntegrityAlgorithmsRequestListValue {
    /// <p>The integrity algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase2IntegrityAlgorithmsRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2IntegrityAlgorithmsRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2IntegrityAlgorithmsRequestListValue`](crate::model::Phase2IntegrityAlgorithmsRequestListValue)
pub mod phase2_integrity_algorithms_request_list_value {
    /// A builder for [`Phase2IntegrityAlgorithmsRequestListValue`](crate::model::Phase2IntegrityAlgorithmsRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The integrity algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2IntegrityAlgorithmsRequestListValue`](crate::model::Phase2IntegrityAlgorithmsRequestListValue)
        pub fn build(self) -> crate::model::Phase2IntegrityAlgorithmsRequestListValue {
            crate::model::Phase2IntegrityAlgorithmsRequestListValue { value: self.value }
        }
    }
}
impl Phase2IntegrityAlgorithmsRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase2IntegrityAlgorithmsRequestListValue`](crate::model::Phase2IntegrityAlgorithmsRequestListValue)
    pub fn builder() -> crate::model::phase2_integrity_algorithms_request_list_value::Builder {
        crate::model::phase2_integrity_algorithms_request_list_value::Builder::default()
    }
}

/// <p>Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1IntegrityAlgorithmsRequestListValue {
    /// <p>The value for the integrity algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase1IntegrityAlgorithmsRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1IntegrityAlgorithmsRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1IntegrityAlgorithmsRequestListValue`](crate::model::Phase1IntegrityAlgorithmsRequestListValue)
pub mod phase1_integrity_algorithms_request_list_value {
    /// A builder for [`Phase1IntegrityAlgorithmsRequestListValue`](crate::model::Phase1IntegrityAlgorithmsRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value for the integrity algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1IntegrityAlgorithmsRequestListValue`](crate::model::Phase1IntegrityAlgorithmsRequestListValue)
        pub fn build(self) -> crate::model::Phase1IntegrityAlgorithmsRequestListValue {
            crate::model::Phase1IntegrityAlgorithmsRequestListValue { value: self.value }
        }
    }
}
impl Phase1IntegrityAlgorithmsRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase1IntegrityAlgorithmsRequestListValue`](crate::model::Phase1IntegrityAlgorithmsRequestListValue)
    pub fn builder() -> crate::model::phase1_integrity_algorithms_request_list_value::Builder {
        crate::model::phase1_integrity_algorithms_request_list_value::Builder::default()
    }
}

/// <p>Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase2EncryptionAlgorithmsRequestListValue {
    /// <p>The encryption algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase2EncryptionAlgorithmsRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase2EncryptionAlgorithmsRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase2EncryptionAlgorithmsRequestListValue`](crate::model::Phase2EncryptionAlgorithmsRequestListValue)
pub mod phase2_encryption_algorithms_request_list_value {
    /// A builder for [`Phase2EncryptionAlgorithmsRequestListValue`](crate::model::Phase2EncryptionAlgorithmsRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase2EncryptionAlgorithmsRequestListValue`](crate::model::Phase2EncryptionAlgorithmsRequestListValue)
        pub fn build(self) -> crate::model::Phase2EncryptionAlgorithmsRequestListValue {
            crate::model::Phase2EncryptionAlgorithmsRequestListValue { value: self.value }
        }
    }
}
impl Phase2EncryptionAlgorithmsRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase2EncryptionAlgorithmsRequestListValue`](crate::model::Phase2EncryptionAlgorithmsRequestListValue)
    pub fn builder() -> crate::model::phase2_encryption_algorithms_request_list_value::Builder {
        crate::model::phase2_encryption_algorithms_request_list_value::Builder::default()
    }
}

/// <p>Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Phase1EncryptionAlgorithmsRequestListValue {
    /// <p>The value for the encryption algorithm.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Phase1EncryptionAlgorithmsRequestListValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Phase1EncryptionAlgorithmsRequestListValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Phase1EncryptionAlgorithmsRequestListValue`](crate::model::Phase1EncryptionAlgorithmsRequestListValue)
pub mod phase1_encryption_algorithms_request_list_value {
    /// A builder for [`Phase1EncryptionAlgorithmsRequestListValue`](crate::model::Phase1EncryptionAlgorithmsRequestListValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value for the encryption algorithm.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Phase1EncryptionAlgorithmsRequestListValue`](crate::model::Phase1EncryptionAlgorithmsRequestListValue)
        pub fn build(self) -> crate::model::Phase1EncryptionAlgorithmsRequestListValue {
            crate::model::Phase1EncryptionAlgorithmsRequestListValue { value: self.value }
        }
    }
}
impl Phase1EncryptionAlgorithmsRequestListValue {
    /// Creates a new builder-style object to manufacture [`Phase1EncryptionAlgorithmsRequestListValue`](crate::model::Phase1EncryptionAlgorithmsRequestListValue)
    pub fn builder() -> crate::model::phase1_encryption_algorithms_request_list_value::Builder {
        crate::model::phase1_encryption_algorithms_request_list_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcTenancy {
    Default,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcTenancy {
    fn from(s: &str) -> Self {
        match s {
            "default" => VpcTenancy::Default,
            other => VpcTenancy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcTenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcTenancy::from(s))
    }
}
impl VpcTenancy {
    pub fn as_str(&self) -> &str {
        match self {
            VpcTenancy::Default => "default",
            VpcTenancy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["default"]
    }
}
impl AsRef<str> for VpcTenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the VPC peering connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PeeringConnectionOptions {
    /// <p>If true, the public DNS hostnames of instances in the specified VPC resolve to private
    /// IP addresses when queried from instances in the peer VPC.</p>
    pub allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
    /// <p>If true, enables outbound communication from an EC2-Classic instance that's linked to
    /// a local VPC using ClassicLink to instances in a peer VPC.</p>
    pub allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
    /// <p>If true, enables outbound communication from instances in a local VPC to an
    /// EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
    pub allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
}
impl std::fmt::Debug for PeeringConnectionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PeeringConnectionOptions");
        formatter.field(
            "allow_dns_resolution_from_remote_vpc",
            &self.allow_dns_resolution_from_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_classic_link_to_remote_vpc",
            &self.allow_egress_from_local_classic_link_to_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_vpc_to_remote_classic_link",
            &self.allow_egress_from_local_vpc_to_remote_classic_link,
        );
        formatter.finish()
    }
}
/// See [`PeeringConnectionOptions`](crate::model::PeeringConnectionOptions)
pub mod peering_connection_options {
    /// A builder for [`PeeringConnectionOptions`](crate::model::PeeringConnectionOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If true, the public DNS hostnames of instances in the specified VPC resolve to private
        /// IP addresses when queried from instances in the peer VPC.</p>
        pub fn allow_dns_resolution_from_remote_vpc(mut self, input: bool) -> Self {
            self.allow_dns_resolution_from_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_dns_resolution_from_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_dns_resolution_from_remote_vpc = input;
            self
        }
        /// <p>If true, enables outbound communication from an EC2-Classic instance that's linked to
        /// a local VPC using ClassicLink to instances in a peer VPC.</p>
        pub fn allow_egress_from_local_classic_link_to_remote_vpc(mut self, input: bool) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_classic_link_to_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = input;
            self
        }
        /// <p>If true, enables outbound communication from instances in a local VPC to an
        /// EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
        pub fn allow_egress_from_local_vpc_to_remote_classic_link(mut self, input: bool) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_vpc_to_remote_classic_link(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = input;
            self
        }
        /// Consumes the builder and constructs a [`PeeringConnectionOptions`](crate::model::PeeringConnectionOptions)
        pub fn build(self) -> crate::model::PeeringConnectionOptions {
            crate::model::PeeringConnectionOptions {
                allow_dns_resolution_from_remote_vpc: self.allow_dns_resolution_from_remote_vpc,
                allow_egress_from_local_classic_link_to_remote_vpc: self
                    .allow_egress_from_local_classic_link_to_remote_vpc,
                allow_egress_from_local_vpc_to_remote_classic_link: self
                    .allow_egress_from_local_vpc_to_remote_classic_link,
            }
        }
    }
}
impl PeeringConnectionOptions {
    /// Creates a new builder-style object to manufacture [`PeeringConnectionOptions`](crate::model::PeeringConnectionOptions)
    pub fn builder() -> crate::model::peering_connection_options::Builder {
        crate::model::peering_connection_options::Builder::default()
    }
}

/// <p>The VPC peering connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PeeringConnectionOptionsRequest {
    /// <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
    pub allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
    /// <p>If true, enables outbound communication from an EC2-Classic instance that's linked to
    /// a local VPC using ClassicLink to instances in a peer VPC.</p>
    pub allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
    /// <p>If true, enables outbound communication from instances in a local VPC to an
    /// EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
    pub allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
}
impl std::fmt::Debug for PeeringConnectionOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PeeringConnectionOptionsRequest");
        formatter.field(
            "allow_dns_resolution_from_remote_vpc",
            &self.allow_dns_resolution_from_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_classic_link_to_remote_vpc",
            &self.allow_egress_from_local_classic_link_to_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_vpc_to_remote_classic_link",
            &self.allow_egress_from_local_vpc_to_remote_classic_link,
        );
        formatter.finish()
    }
}
/// See [`PeeringConnectionOptionsRequest`](crate::model::PeeringConnectionOptionsRequest)
pub mod peering_connection_options_request {
    /// A builder for [`PeeringConnectionOptionsRequest`](crate::model::PeeringConnectionOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
        pub fn allow_dns_resolution_from_remote_vpc(mut self, input: bool) -> Self {
            self.allow_dns_resolution_from_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_dns_resolution_from_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_dns_resolution_from_remote_vpc = input;
            self
        }
        /// <p>If true, enables outbound communication from an EC2-Classic instance that's linked to
        /// a local VPC using ClassicLink to instances in a peer VPC.</p>
        pub fn allow_egress_from_local_classic_link_to_remote_vpc(mut self, input: bool) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_classic_link_to_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = input;
            self
        }
        /// <p>If true, enables outbound communication from instances in a local VPC to an
        /// EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
        pub fn allow_egress_from_local_vpc_to_remote_classic_link(mut self, input: bool) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_vpc_to_remote_classic_link(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = input;
            self
        }
        /// Consumes the builder and constructs a [`PeeringConnectionOptionsRequest`](crate::model::PeeringConnectionOptionsRequest)
        pub fn build(self) -> crate::model::PeeringConnectionOptionsRequest {
            crate::model::PeeringConnectionOptionsRequest {
                allow_dns_resolution_from_remote_vpc: self.allow_dns_resolution_from_remote_vpc,
                allow_egress_from_local_classic_link_to_remote_vpc: self
                    .allow_egress_from_local_classic_link_to_remote_vpc,
                allow_egress_from_local_vpc_to_remote_classic_link: self
                    .allow_egress_from_local_vpc_to_remote_classic_link,
            }
        }
    }
}
impl PeeringConnectionOptionsRequest {
    /// Creates a new builder-style object to manufacture [`PeeringConnectionOptionsRequest`](crate::model::PeeringConnectionOptionsRequest)
    pub fn builder() -> crate::model::peering_connection_options_request::Builder {
        crate::model::peering_connection_options_request::Builder::default()
    }
}

/// <p>Describes a value for a resource attribute that is a Boolean value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeBooleanValue {
    /// <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
    pub value: std::option::Option<bool>,
}
impl std::fmt::Debug for AttributeBooleanValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeBooleanValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AttributeBooleanValue`](crate::model::AttributeBooleanValue)
pub mod attribute_boolean_value {
    /// A builder for [`AttributeBooleanValue`](crate::model::AttributeBooleanValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
        pub fn value(mut self, input: bool) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<bool>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeBooleanValue`](crate::model::AttributeBooleanValue)
        pub fn build(self) -> crate::model::AttributeBooleanValue {
            crate::model::AttributeBooleanValue { value: self.value }
        }
    }
}
impl AttributeBooleanValue {
    /// Creates a new builder-style object to manufacture [`AttributeBooleanValue`](crate::model::AttributeBooleanValue)
    pub fn builder() -> crate::model::attribute_boolean_value::Builder {
        crate::model::attribute_boolean_value::Builder::default()
    }
}

/// <p>Describes the modification status of an EBS volume.</p>
/// <p>If the volume has never been modified, some element values will be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeModification {
    /// <p>The ID of the volume.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>The current modification state. The modification state is null for unmodified
    /// volumes.</p>
    pub modification_state: std::option::Option<crate::model::VolumeModificationState>,
    /// <p>A status message about the modification progress or failure.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The target size of the volume, in GiB.</p>
    pub target_size: std::option::Option<i32>,
    /// <p>The target IOPS rate of the volume.</p>
    pub target_iops: std::option::Option<i32>,
    /// <p>The target EBS volume type of the volume.</p>
    pub target_volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>The target throughput of the volume, in MiB/s.</p>
    pub target_throughput: std::option::Option<i32>,
    /// <p>The target setting for Amazon EBS Multi-Attach.</p>
    pub target_multi_attach_enabled: std::option::Option<bool>,
    /// <p>The original size of the volume, in GiB.</p>
    pub original_size: std::option::Option<i32>,
    /// <p>The original IOPS rate of the volume.</p>
    pub original_iops: std::option::Option<i32>,
    /// <p>The original EBS volume type of the volume.</p>
    pub original_volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>The original throughput of the volume, in MiB/s.</p>
    pub original_throughput: std::option::Option<i32>,
    /// <p>The original setting for Amazon EBS Multi-Attach.</p>
    pub original_multi_attach_enabled: std::option::Option<bool>,
    /// <p>The modification progress, from 0 to 100 percent complete.</p>
    pub progress: std::option::Option<i64>,
    /// <p>The modification start time.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The modification completion or failure time.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for VolumeModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeModification");
        formatter.field("volume_id", &self.volume_id);
        formatter.field("modification_state", &self.modification_state);
        formatter.field("status_message", &self.status_message);
        formatter.field("target_size", &self.target_size);
        formatter.field("target_iops", &self.target_iops);
        formatter.field("target_volume_type", &self.target_volume_type);
        formatter.field("target_throughput", &self.target_throughput);
        formatter.field(
            "target_multi_attach_enabled",
            &self.target_multi_attach_enabled,
        );
        formatter.field("original_size", &self.original_size);
        formatter.field("original_iops", &self.original_iops);
        formatter.field("original_volume_type", &self.original_volume_type);
        formatter.field("original_throughput", &self.original_throughput);
        formatter.field(
            "original_multi_attach_enabled",
            &self.original_multi_attach_enabled,
        );
        formatter.field("progress", &self.progress);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}
/// See [`VolumeModification`](crate::model::VolumeModification)
pub mod volume_modification {
    /// A builder for [`VolumeModification`](crate::model::VolumeModification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) modification_state: std::option::Option<crate::model::VolumeModificationState>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) target_size: std::option::Option<i32>,
        pub(crate) target_iops: std::option::Option<i32>,
        pub(crate) target_volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) target_throughput: std::option::Option<i32>,
        pub(crate) target_multi_attach_enabled: std::option::Option<bool>,
        pub(crate) original_size: std::option::Option<i32>,
        pub(crate) original_iops: std::option::Option<i32>,
        pub(crate) original_volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) original_throughput: std::option::Option<i32>,
        pub(crate) original_multi_attach_enabled: std::option::Option<bool>,
        pub(crate) progress: std::option::Option<i64>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>The current modification state. The modification state is null for unmodified
        /// volumes.</p>
        pub fn modification_state(mut self, input: crate::model::VolumeModificationState) -> Self {
            self.modification_state = Some(input);
            self
        }
        pub fn set_modification_state(
            mut self,
            input: std::option::Option<crate::model::VolumeModificationState>,
        ) -> Self {
            self.modification_state = input;
            self
        }
        /// <p>A status message about the modification progress or failure.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The target size of the volume, in GiB.</p>
        pub fn target_size(mut self, input: i32) -> Self {
            self.target_size = Some(input);
            self
        }
        pub fn set_target_size(mut self, input: std::option::Option<i32>) -> Self {
            self.target_size = input;
            self
        }
        /// <p>The target IOPS rate of the volume.</p>
        pub fn target_iops(mut self, input: i32) -> Self {
            self.target_iops = Some(input);
            self
        }
        pub fn set_target_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.target_iops = input;
            self
        }
        /// <p>The target EBS volume type of the volume.</p>
        pub fn target_volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.target_volume_type = Some(input);
            self
        }
        pub fn set_target_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.target_volume_type = input;
            self
        }
        /// <p>The target throughput of the volume, in MiB/s.</p>
        pub fn target_throughput(mut self, input: i32) -> Self {
            self.target_throughput = Some(input);
            self
        }
        pub fn set_target_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.target_throughput = input;
            self
        }
        /// <p>The target setting for Amazon EBS Multi-Attach.</p>
        pub fn target_multi_attach_enabled(mut self, input: bool) -> Self {
            self.target_multi_attach_enabled = Some(input);
            self
        }
        pub fn set_target_multi_attach_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.target_multi_attach_enabled = input;
            self
        }
        /// <p>The original size of the volume, in GiB.</p>
        pub fn original_size(mut self, input: i32) -> Self {
            self.original_size = Some(input);
            self
        }
        pub fn set_original_size(mut self, input: std::option::Option<i32>) -> Self {
            self.original_size = input;
            self
        }
        /// <p>The original IOPS rate of the volume.</p>
        pub fn original_iops(mut self, input: i32) -> Self {
            self.original_iops = Some(input);
            self
        }
        pub fn set_original_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.original_iops = input;
            self
        }
        /// <p>The original EBS volume type of the volume.</p>
        pub fn original_volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.original_volume_type = Some(input);
            self
        }
        pub fn set_original_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.original_volume_type = input;
            self
        }
        /// <p>The original throughput of the volume, in MiB/s.</p>
        pub fn original_throughput(mut self, input: i32) -> Self {
            self.original_throughput = Some(input);
            self
        }
        pub fn set_original_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.original_throughput = input;
            self
        }
        /// <p>The original setting for Amazon EBS Multi-Attach.</p>
        pub fn original_multi_attach_enabled(mut self, input: bool) -> Self {
            self.original_multi_attach_enabled = Some(input);
            self
        }
        pub fn set_original_multi_attach_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.original_multi_attach_enabled = input;
            self
        }
        /// <p>The modification progress, from 0 to 100 percent complete.</p>
        pub fn progress(mut self, input: i64) -> Self {
            self.progress = Some(input);
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<i64>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The modification start time.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The modification completion or failure time.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeModification`](crate::model::VolumeModification)
        pub fn build(self) -> crate::model::VolumeModification {
            crate::model::VolumeModification {
                volume_id: self.volume_id,
                modification_state: self.modification_state,
                status_message: self.status_message,
                target_size: self.target_size,
                target_iops: self.target_iops,
                target_volume_type: self.target_volume_type,
                target_throughput: self.target_throughput,
                target_multi_attach_enabled: self.target_multi_attach_enabled,
                original_size: self.original_size,
                original_iops: self.original_iops,
                original_volume_type: self.original_volume_type,
                original_throughput: self.original_throughput,
                original_multi_attach_enabled: self.original_multi_attach_enabled,
                progress: self.progress,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl VolumeModification {
    /// Creates a new builder-style object to manufacture [`VolumeModification`](crate::model::VolumeModification)
    pub fn builder() -> crate::model::volume_modification::Builder {
        crate::model::volume_modification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeModificationState {
    Completed,
    Failed,
    Modifying,
    Optimizing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeModificationState {
    fn from(s: &str) -> Self {
        match s {
            "completed" => VolumeModificationState::Completed,
            "failed" => VolumeModificationState::Failed,
            "modifying" => VolumeModificationState::Modifying,
            "optimizing" => VolumeModificationState::Optimizing,
            other => VolumeModificationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeModificationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeModificationState::from(s))
    }
}
impl VolumeModificationState {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeModificationState::Completed => "completed",
            VolumeModificationState::Failed => "failed",
            VolumeModificationState::Modifying => "modifying",
            VolumeModificationState::Optimizing => "optimizing",
            VolumeModificationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["completed", "failed", "modifying", "optimizing"]
    }
}
impl AsRef<str> for VolumeModificationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the options for a VPC attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModifyTransitGatewayVpcAttachmentRequestOptions {
    /// <p>Enable or disable DNS support. The default is <code>enable</code>.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Enable or disable IPv6 support. The default is <code>enable</code>.</p>
    pub ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
    /// <p>Enable or disable support for appliance mode. If enabled, a traffic flow between a source and destination uses the same Availability Zone for the VPC attachment for the lifetime of that flow. The default is <code>disable</code>.</p>
    pub appliance_mode_support: std::option::Option<crate::model::ApplianceModeSupportValue>,
}
impl std::fmt::Debug for ModifyTransitGatewayVpcAttachmentRequestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModifyTransitGatewayVpcAttachmentRequestOptions");
        formatter.field("dns_support", &self.dns_support);
        formatter.field("ipv6_support", &self.ipv6_support);
        formatter.field("appliance_mode_support", &self.appliance_mode_support);
        formatter.finish()
    }
}
/// See [`ModifyTransitGatewayVpcAttachmentRequestOptions`](crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions)
pub mod modify_transit_gateway_vpc_attachment_request_options {
    /// A builder for [`ModifyTransitGatewayVpcAttachmentRequestOptions`](crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
        pub(crate) appliance_mode_support:
            std::option::Option<crate::model::ApplianceModeSupportValue>,
    }
    impl Builder {
        /// <p>Enable or disable DNS support. The default is <code>enable</code>.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Enable or disable IPv6 support. The default is <code>enable</code>.</p>
        pub fn ipv6_support(mut self, input: crate::model::Ipv6SupportValue) -> Self {
            self.ipv6_support = Some(input);
            self
        }
        pub fn set_ipv6_support(
            mut self,
            input: std::option::Option<crate::model::Ipv6SupportValue>,
        ) -> Self {
            self.ipv6_support = input;
            self
        }
        /// <p>Enable or disable support for appliance mode. If enabled, a traffic flow between a source and destination uses the same Availability Zone for the VPC attachment for the lifetime of that flow. The default is <code>disable</code>.</p>
        pub fn appliance_mode_support(
            mut self,
            input: crate::model::ApplianceModeSupportValue,
        ) -> Self {
            self.appliance_mode_support = Some(input);
            self
        }
        pub fn set_appliance_mode_support(
            mut self,
            input: std::option::Option<crate::model::ApplianceModeSupportValue>,
        ) -> Self {
            self.appliance_mode_support = input;
            self
        }
        /// Consumes the builder and constructs a [`ModifyTransitGatewayVpcAttachmentRequestOptions`](crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions)
        pub fn build(self) -> crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions {
            crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions {
                dns_support: self.dns_support,
                ipv6_support: self.ipv6_support,
                appliance_mode_support: self.appliance_mode_support,
            }
        }
    }
}
impl ModifyTransitGatewayVpcAttachmentRequestOptions {
    /// Creates a new builder-style object to manufacture [`ModifyTransitGatewayVpcAttachmentRequestOptions`](crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions)
    pub fn builder() -> crate::model::modify_transit_gateway_vpc_attachment_request_options::Builder
    {
        crate::model::modify_transit_gateway_vpc_attachment_request_options::Builder::default()
    }
}

/// <p>Describes a prefix list reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayPrefixListReference {
    /// <p>The ID of the transit gateway route table.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list owner.</p>
    pub prefix_list_owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the prefix list reference.</p>
    pub state: std::option::Option<crate::model::TransitGatewayPrefixListReferenceState>,
    /// <p>Indicates whether traffic that matches this route is dropped.</p>
    pub blackhole: std::option::Option<bool>,
    /// <p>Information about the transit gateway attachment.</p>
    pub transit_gateway_attachment:
        std::option::Option<crate::model::TransitGatewayPrefixListAttachment>,
}
impl std::fmt::Debug for TransitGatewayPrefixListReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayPrefixListReference");
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("prefix_list_owner_id", &self.prefix_list_owner_id);
        formatter.field("state", &self.state);
        formatter.field("blackhole", &self.blackhole);
        formatter.field(
            "transit_gateway_attachment",
            &self.transit_gateway_attachment,
        );
        formatter.finish()
    }
}
/// See [`TransitGatewayPrefixListReference`](crate::model::TransitGatewayPrefixListReference)
pub mod transit_gateway_prefix_list_reference {
    /// A builder for [`TransitGatewayPrefixListReference`](crate::model::TransitGatewayPrefixListReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) prefix_list_owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayPrefixListReferenceState>,
        pub(crate) blackhole: std::option::Option<bool>,
        pub(crate) transit_gateway_attachment:
            std::option::Option<crate::model::TransitGatewayPrefixListAttachment>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The ID of the prefix list owner.</p>
        pub fn prefix_list_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_owner_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_owner_id = input;
            self
        }
        /// <p>The state of the prefix list reference.</p>
        pub fn state(
            mut self,
            input: crate::model::TransitGatewayPrefixListReferenceState,
        ) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayPrefixListReferenceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates whether traffic that matches this route is dropped.</p>
        pub fn blackhole(mut self, input: bool) -> Self {
            self.blackhole = Some(input);
            self
        }
        pub fn set_blackhole(mut self, input: std::option::Option<bool>) -> Self {
            self.blackhole = input;
            self
        }
        /// <p>Information about the transit gateway attachment.</p>
        pub fn transit_gateway_attachment(
            mut self,
            input: crate::model::TransitGatewayPrefixListAttachment,
        ) -> Self {
            self.transit_gateway_attachment = Some(input);
            self
        }
        pub fn set_transit_gateway_attachment(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayPrefixListAttachment>,
        ) -> Self {
            self.transit_gateway_attachment = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayPrefixListReference`](crate::model::TransitGatewayPrefixListReference)
        pub fn build(self) -> crate::model::TransitGatewayPrefixListReference {
            crate::model::TransitGatewayPrefixListReference {
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                prefix_list_id: self.prefix_list_id,
                prefix_list_owner_id: self.prefix_list_owner_id,
                state: self.state,
                blackhole: self.blackhole,
                transit_gateway_attachment: self.transit_gateway_attachment,
            }
        }
    }
}
impl TransitGatewayPrefixListReference {
    /// Creates a new builder-style object to manufacture [`TransitGatewayPrefixListReference`](crate::model::TransitGatewayPrefixListReference)
    pub fn builder() -> crate::model::transit_gateway_prefix_list_reference::Builder {
        crate::model::transit_gateway_prefix_list_reference::Builder::default()
    }
}

/// <p>Describes a transit gateway prefix list attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayPrefixListAttachment {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransitGatewayPrefixListAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayPrefixListAttachment");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.finish()
    }
}
/// See [`TransitGatewayPrefixListAttachment`](crate::model::TransitGatewayPrefixListAttachment)
pub mod transit_gateway_prefix_list_attachment {
    /// A builder for [`TransitGatewayPrefixListAttachment`](crate::model::TransitGatewayPrefixListAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayPrefixListAttachment`](crate::model::TransitGatewayPrefixListAttachment)
        pub fn build(self) -> crate::model::TransitGatewayPrefixListAttachment {
            crate::model::TransitGatewayPrefixListAttachment {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
            }
        }
    }
}
impl TransitGatewayPrefixListAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayPrefixListAttachment`](crate::model::TransitGatewayPrefixListAttachment)
    pub fn builder() -> crate::model::transit_gateway_prefix_list_attachment::Builder {
        crate::model::transit_gateway_prefix_list_attachment::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayPrefixListReferenceState {
    Available,
    Deleting,
    Modifying,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayPrefixListReferenceState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayPrefixListReferenceState::Available,
            "deleting" => TransitGatewayPrefixListReferenceState::Deleting,
            "modifying" => TransitGatewayPrefixListReferenceState::Modifying,
            "pending" => TransitGatewayPrefixListReferenceState::Pending,
            other => TransitGatewayPrefixListReferenceState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayPrefixListReferenceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayPrefixListReferenceState::from(s))
    }
}
impl TransitGatewayPrefixListReferenceState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayPrefixListReferenceState::Available => "available",
            TransitGatewayPrefixListReferenceState::Deleting => "deleting",
            TransitGatewayPrefixListReferenceState::Modifying => "modifying",
            TransitGatewayPrefixListReferenceState::Pending => "pending",
            TransitGatewayPrefixListReferenceState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleting", "modifying", "pending"]
    }
}
impl AsRef<str> for TransitGatewayPrefixListReferenceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a transit gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGateway {
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub transit_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The state of the transit gateway.</p>
    pub state: std::option::Option<crate::model::TransitGatewayState>,
    /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The description of the transit gateway.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The transit gateway options.</p>
    pub options: std::option::Option<crate::model::TransitGatewayOptions>,
    /// <p>The tags for the transit gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGateway");
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("transit_gateway_arn", &self.transit_gateway_arn);
        formatter.field("state", &self.state);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("options", &self.options);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGateway`](crate::model::TransitGateway)
pub mod transit_gateway {
    /// A builder for [`TransitGateway`](crate::model::TransitGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayState>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) options: std::option::Option<crate::model::TransitGatewayOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// <p>The state of the transit gateway.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The description of the transit gateway.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The transit gateway options.</p>
        pub fn options(mut self, input: crate::model::TransitGatewayOptions) -> Self {
            self.options = Some(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGateway`](crate::model::TransitGateway)
        pub fn build(self) -> crate::model::TransitGateway {
            crate::model::TransitGateway {
                transit_gateway_id: self.transit_gateway_id,
                transit_gateway_arn: self.transit_gateway_arn,
                state: self.state,
                owner_id: self.owner_id,
                description: self.description,
                creation_time: self.creation_time,
                options: self.options,
                tags: self.tags,
            }
        }
    }
}
impl TransitGateway {
    /// Creates a new builder-style object to manufacture [`TransitGateway`](crate::model::TransitGateway)
    pub fn builder() -> crate::model::transit_gateway::Builder {
        crate::model::transit_gateway::Builder::default()
    }
}

/// <p>Describes the options for a transit gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayOptions {
    /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
    /// The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.</p>
    pub amazon_side_asn: std::option::Option<i64>,
    /// <p>The transit gateway CIDR blocks.</p>
    pub transit_gateway_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether attachment requests are automatically accepted.</p>
    pub auto_accept_shared_attachments:
        std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
    /// <p>Indicates whether resource attachments are automatically associated with the default association route table.</p>
    pub default_route_table_association:
        std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
    /// <p>The ID of the default association route table.</p>
    pub association_default_route_table_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether resource attachments automatically propagate routes to the default propagation route table.</p>
    pub default_route_table_propagation:
        std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
    /// <p>The ID of the default propagation route table.</p>
    pub propagation_default_route_table_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether Equal Cost Multipath Protocol support is enabled.</p>
    pub vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
    /// <p>Indicates whether DNS support is enabled.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Indicates whether multicast is enabled on the transit gateway</p>
    pub multicast_support: std::option::Option<crate::model::MulticastSupportValue>,
}
impl std::fmt::Debug for TransitGatewayOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayOptions");
        formatter.field("amazon_side_asn", &self.amazon_side_asn);
        formatter.field(
            "transit_gateway_cidr_blocks",
            &self.transit_gateway_cidr_blocks,
        );
        formatter.field(
            "auto_accept_shared_attachments",
            &self.auto_accept_shared_attachments,
        );
        formatter.field(
            "default_route_table_association",
            &self.default_route_table_association,
        );
        formatter.field(
            "association_default_route_table_id",
            &self.association_default_route_table_id,
        );
        formatter.field(
            "default_route_table_propagation",
            &self.default_route_table_propagation,
        );
        formatter.field(
            "propagation_default_route_table_id",
            &self.propagation_default_route_table_id,
        );
        formatter.field("vpn_ecmp_support", &self.vpn_ecmp_support);
        formatter.field("dns_support", &self.dns_support);
        formatter.field("multicast_support", &self.multicast_support);
        formatter.finish()
    }
}
/// See [`TransitGatewayOptions`](crate::model::TransitGatewayOptions)
pub mod transit_gateway_options {
    /// A builder for [`TransitGatewayOptions`](crate::model::TransitGatewayOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amazon_side_asn: std::option::Option<i64>,
        pub(crate) transit_gateway_cidr_blocks:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) auto_accept_shared_attachments:
            std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        pub(crate) default_route_table_association:
            std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        pub(crate) association_default_route_table_id: std::option::Option<std::string::String>,
        pub(crate) default_route_table_propagation:
            std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        pub(crate) propagation_default_route_table_id: std::option::Option<std::string::String>,
        pub(crate) vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) multicast_support: std::option::Option<crate::model::MulticastSupportValue>,
    }
    impl Builder {
        /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        /// The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.</p>
        pub fn amazon_side_asn(mut self, input: i64) -> Self {
            self.amazon_side_asn = Some(input);
            self
        }
        pub fn set_amazon_side_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.amazon_side_asn = input;
            self
        }
        pub fn transit_gateway_cidr_blocks(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.transit_gateway_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_cidr_blocks = Some(v);
            self
        }
        pub fn set_transit_gateway_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_cidr_blocks = input;
            self
        }
        /// <p>Indicates whether attachment requests are automatically accepted.</p>
        pub fn auto_accept_shared_attachments(
            mut self,
            input: crate::model::AutoAcceptSharedAttachmentsValue,
        ) -> Self {
            self.auto_accept_shared_attachments = Some(input);
            self
        }
        pub fn set_auto_accept_shared_attachments(
            mut self,
            input: std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        ) -> Self {
            self.auto_accept_shared_attachments = input;
            self
        }
        /// <p>Indicates whether resource attachments are automatically associated with the default association route table.</p>
        pub fn default_route_table_association(
            mut self,
            input: crate::model::DefaultRouteTableAssociationValue,
        ) -> Self {
            self.default_route_table_association = Some(input);
            self
        }
        pub fn set_default_route_table_association(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        ) -> Self {
            self.default_route_table_association = input;
            self
        }
        /// <p>The ID of the default association route table.</p>
        pub fn association_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = Some(input.into());
            self
        }
        pub fn set_association_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = input;
            self
        }
        /// <p>Indicates whether resource attachments automatically propagate routes to the default propagation route table.</p>
        pub fn default_route_table_propagation(
            mut self,
            input: crate::model::DefaultRouteTablePropagationValue,
        ) -> Self {
            self.default_route_table_propagation = Some(input);
            self
        }
        pub fn set_default_route_table_propagation(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        ) -> Self {
            self.default_route_table_propagation = input;
            self
        }
        /// <p>The ID of the default propagation route table.</p>
        pub fn propagation_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = Some(input.into());
            self
        }
        pub fn set_propagation_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = input;
            self
        }
        /// <p>Indicates whether Equal Cost Multipath Protocol support is enabled.</p>
        pub fn vpn_ecmp_support(mut self, input: crate::model::VpnEcmpSupportValue) -> Self {
            self.vpn_ecmp_support = Some(input);
            self
        }
        pub fn set_vpn_ecmp_support(
            mut self,
            input: std::option::Option<crate::model::VpnEcmpSupportValue>,
        ) -> Self {
            self.vpn_ecmp_support = input;
            self
        }
        /// <p>Indicates whether DNS support is enabled.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Indicates whether multicast is enabled on the transit gateway</p>
        pub fn multicast_support(mut self, input: crate::model::MulticastSupportValue) -> Self {
            self.multicast_support = Some(input);
            self
        }
        pub fn set_multicast_support(
            mut self,
            input: std::option::Option<crate::model::MulticastSupportValue>,
        ) -> Self {
            self.multicast_support = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayOptions`](crate::model::TransitGatewayOptions)
        pub fn build(self) -> crate::model::TransitGatewayOptions {
            crate::model::TransitGatewayOptions {
                amazon_side_asn: self.amazon_side_asn,
                transit_gateway_cidr_blocks: self.transit_gateway_cidr_blocks,
                auto_accept_shared_attachments: self.auto_accept_shared_attachments,
                default_route_table_association: self.default_route_table_association,
                association_default_route_table_id: self.association_default_route_table_id,
                default_route_table_propagation: self.default_route_table_propagation,
                propagation_default_route_table_id: self.propagation_default_route_table_id,
                vpn_ecmp_support: self.vpn_ecmp_support,
                dns_support: self.dns_support,
                multicast_support: self.multicast_support,
            }
        }
    }
}
impl TransitGatewayOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayOptions`](crate::model::TransitGatewayOptions)
    pub fn builder() -> crate::model::transit_gateway_options::Builder {
        crate::model::transit_gateway_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MulticastSupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MulticastSupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => MulticastSupportValue::Disable,
            "enable" => MulticastSupportValue::Enable,
            other => MulticastSupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MulticastSupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MulticastSupportValue::from(s))
    }
}
impl MulticastSupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            MulticastSupportValue::Disable => "disable",
            MulticastSupportValue::Enable => "enable",
            MulticastSupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for MulticastSupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpnEcmpSupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpnEcmpSupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => VpnEcmpSupportValue::Disable,
            "enable" => VpnEcmpSupportValue::Enable,
            other => VpnEcmpSupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpnEcmpSupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpnEcmpSupportValue::from(s))
    }
}
impl VpnEcmpSupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            VpnEcmpSupportValue::Disable => "disable",
            VpnEcmpSupportValue::Enable => "enable",
            VpnEcmpSupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for VpnEcmpSupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DefaultRouteTablePropagationValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DefaultRouteTablePropagationValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => DefaultRouteTablePropagationValue::Disable,
            "enable" => DefaultRouteTablePropagationValue::Enable,
            other => DefaultRouteTablePropagationValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DefaultRouteTablePropagationValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DefaultRouteTablePropagationValue::from(s))
    }
}
impl DefaultRouteTablePropagationValue {
    pub fn as_str(&self) -> &str {
        match self {
            DefaultRouteTablePropagationValue::Disable => "disable",
            DefaultRouteTablePropagationValue::Enable => "enable",
            DefaultRouteTablePropagationValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for DefaultRouteTablePropagationValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DefaultRouteTableAssociationValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DefaultRouteTableAssociationValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => DefaultRouteTableAssociationValue::Disable,
            "enable" => DefaultRouteTableAssociationValue::Enable,
            other => DefaultRouteTableAssociationValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DefaultRouteTableAssociationValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DefaultRouteTableAssociationValue::from(s))
    }
}
impl DefaultRouteTableAssociationValue {
    pub fn as_str(&self) -> &str {
        match self {
            DefaultRouteTableAssociationValue::Disable => "disable",
            DefaultRouteTableAssociationValue::Enable => "enable",
            DefaultRouteTableAssociationValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for DefaultRouteTableAssociationValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoAcceptSharedAttachmentsValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoAcceptSharedAttachmentsValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => AutoAcceptSharedAttachmentsValue::Disable,
            "enable" => AutoAcceptSharedAttachmentsValue::Enable,
            other => AutoAcceptSharedAttachmentsValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoAcceptSharedAttachmentsValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoAcceptSharedAttachmentsValue::from(s))
    }
}
impl AutoAcceptSharedAttachmentsValue {
    pub fn as_str(&self) -> &str {
        match self {
            AutoAcceptSharedAttachmentsValue::Disable => "disable",
            AutoAcceptSharedAttachmentsValue::Enable => "enable",
            AutoAcceptSharedAttachmentsValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for AutoAcceptSharedAttachmentsValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayState {
    Available,
    Deleted,
    Deleting,
    Modifying,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayState::Available,
            "deleted" => TransitGatewayState::Deleted,
            "deleting" => TransitGatewayState::Deleting,
            "modifying" => TransitGatewayState::Modifying,
            "pending" => TransitGatewayState::Pending,
            other => TransitGatewayState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayState::from(s))
    }
}
impl TransitGatewayState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayState::Available => "available",
            TransitGatewayState::Deleted => "deleted",
            TransitGatewayState::Deleting => "deleting",
            TransitGatewayState::Modifying => "modifying",
            TransitGatewayState::Pending => "pending",
            TransitGatewayState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "modifying", "pending"]
    }
}
impl AsRef<str> for TransitGatewayState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The transit gateway options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModifyTransitGatewayOptions {
    /// <p>Adds IPv4 or IPv6 CIDR blocks for the transit gateway. Must be a size /24 CIDR block or larger for IPv4, or a size /64 CIDR block or larger for IPv6.</p>
    pub add_transit_gateway_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Removes CIDR blocks for the transit gateway.</p>
    pub remove_transit_gateway_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Enable or disable Equal Cost Multipath Protocol support.</p>
    pub vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
    /// <p>Enable or disable DNS support.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Enable or disable automatic acceptance of attachment requests.</p>
    pub auto_accept_shared_attachments:
        std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
    /// <p>Enable or disable automatic association with the default association route table.</p>
    pub default_route_table_association:
        std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
    /// <p>The ID of the default association route table.</p>
    pub association_default_route_table_id: std::option::Option<std::string::String>,
    /// <p>Enable or disable automatic propagation of routes to the default propagation route table.</p>
    pub default_route_table_propagation:
        std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
    /// <p>The ID of the default propagation route table.</p>
    pub propagation_default_route_table_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModifyTransitGatewayOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModifyTransitGatewayOptions");
        formatter.field(
            "add_transit_gateway_cidr_blocks",
            &self.add_transit_gateway_cidr_blocks,
        );
        formatter.field(
            "remove_transit_gateway_cidr_blocks",
            &self.remove_transit_gateway_cidr_blocks,
        );
        formatter.field("vpn_ecmp_support", &self.vpn_ecmp_support);
        formatter.field("dns_support", &self.dns_support);
        formatter.field(
            "auto_accept_shared_attachments",
            &self.auto_accept_shared_attachments,
        );
        formatter.field(
            "default_route_table_association",
            &self.default_route_table_association,
        );
        formatter.field(
            "association_default_route_table_id",
            &self.association_default_route_table_id,
        );
        formatter.field(
            "default_route_table_propagation",
            &self.default_route_table_propagation,
        );
        formatter.field(
            "propagation_default_route_table_id",
            &self.propagation_default_route_table_id,
        );
        formatter.finish()
    }
}
/// See [`ModifyTransitGatewayOptions`](crate::model::ModifyTransitGatewayOptions)
pub mod modify_transit_gateway_options {
    /// A builder for [`ModifyTransitGatewayOptions`](crate::model::ModifyTransitGatewayOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add_transit_gateway_cidr_blocks:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) remove_transit_gateway_cidr_blocks:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) auto_accept_shared_attachments:
            std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        pub(crate) default_route_table_association:
            std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        pub(crate) association_default_route_table_id: std::option::Option<std::string::String>,
        pub(crate) default_route_table_propagation:
            std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        pub(crate) propagation_default_route_table_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn add_transit_gateway_cidr_blocks(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.add_transit_gateway_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.add_transit_gateway_cidr_blocks = Some(v);
            self
        }
        pub fn set_add_transit_gateway_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.add_transit_gateway_cidr_blocks = input;
            self
        }
        pub fn remove_transit_gateway_cidr_blocks(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.remove_transit_gateway_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.remove_transit_gateway_cidr_blocks = Some(v);
            self
        }
        pub fn set_remove_transit_gateway_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.remove_transit_gateway_cidr_blocks = input;
            self
        }
        /// <p>Enable or disable Equal Cost Multipath Protocol support.</p>
        pub fn vpn_ecmp_support(mut self, input: crate::model::VpnEcmpSupportValue) -> Self {
            self.vpn_ecmp_support = Some(input);
            self
        }
        pub fn set_vpn_ecmp_support(
            mut self,
            input: std::option::Option<crate::model::VpnEcmpSupportValue>,
        ) -> Self {
            self.vpn_ecmp_support = input;
            self
        }
        /// <p>Enable or disable DNS support.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Enable or disable automatic acceptance of attachment requests.</p>
        pub fn auto_accept_shared_attachments(
            mut self,
            input: crate::model::AutoAcceptSharedAttachmentsValue,
        ) -> Self {
            self.auto_accept_shared_attachments = Some(input);
            self
        }
        pub fn set_auto_accept_shared_attachments(
            mut self,
            input: std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        ) -> Self {
            self.auto_accept_shared_attachments = input;
            self
        }
        /// <p>Enable or disable automatic association with the default association route table.</p>
        pub fn default_route_table_association(
            mut self,
            input: crate::model::DefaultRouteTableAssociationValue,
        ) -> Self {
            self.default_route_table_association = Some(input);
            self
        }
        pub fn set_default_route_table_association(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        ) -> Self {
            self.default_route_table_association = input;
            self
        }
        /// <p>The ID of the default association route table.</p>
        pub fn association_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = Some(input.into());
            self
        }
        pub fn set_association_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_default_route_table_id = input;
            self
        }
        /// <p>Enable or disable automatic propagation of routes to the default propagation route table.</p>
        pub fn default_route_table_propagation(
            mut self,
            input: crate::model::DefaultRouteTablePropagationValue,
        ) -> Self {
            self.default_route_table_propagation = Some(input);
            self
        }
        pub fn set_default_route_table_propagation(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        ) -> Self {
            self.default_route_table_propagation = input;
            self
        }
        /// <p>The ID of the default propagation route table.</p>
        pub fn propagation_default_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = Some(input.into());
            self
        }
        pub fn set_propagation_default_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.propagation_default_route_table_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ModifyTransitGatewayOptions`](crate::model::ModifyTransitGatewayOptions)
        pub fn build(self) -> crate::model::ModifyTransitGatewayOptions {
            crate::model::ModifyTransitGatewayOptions {
                add_transit_gateway_cidr_blocks: self.add_transit_gateway_cidr_blocks,
                remove_transit_gateway_cidr_blocks: self.remove_transit_gateway_cidr_blocks,
                vpn_ecmp_support: self.vpn_ecmp_support,
                dns_support: self.dns_support,
                auto_accept_shared_attachments: self.auto_accept_shared_attachments,
                default_route_table_association: self.default_route_table_association,
                association_default_route_table_id: self.association_default_route_table_id,
                default_route_table_propagation: self.default_route_table_propagation,
                propagation_default_route_table_id: self.propagation_default_route_table_id,
            }
        }
    }
}
impl ModifyTransitGatewayOptions {
    /// Creates a new builder-style object to manufacture [`ModifyTransitGatewayOptions`](crate::model::ModifyTransitGatewayOptions)
    pub fn builder() -> crate::model::modify_transit_gateway_options::Builder {
        crate::model::modify_transit_gateway_options::Builder::default()
    }
}

/// <p>Describes a Traffic Mirror session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorSession {
    /// <p>The ID for the Traffic Mirror session.</p>
    pub traffic_mirror_session_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Traffic Mirror target.</p>
    pub traffic_mirror_target_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Traffic Mirror filter.</p>
    pub traffic_mirror_filter_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Traffic Mirror session's network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of the account that owns the Traffic Mirror session.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The number of bytes in each packet to mirror. These are the bytes after the VXLAN header. To mirror a subset, set this to the length (in bytes) to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. Do not specify this parameter when you want to mirror the entire packet</p>
    pub packet_length: std::option::Option<i32>,
    /// <p>The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets.</p>
    /// <p>Valid values are 1-32766.</p>
    pub session_number: std::option::Option<i32>,
    /// <p>The virtual network ID associated with the Traffic Mirror session.</p>
    pub virtual_network_id: std::option::Option<i32>,
    /// <p>The description of the Traffic Mirror session.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the Traffic Mirror session.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TrafficMirrorSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorSession");
        formatter.field("traffic_mirror_session_id", &self.traffic_mirror_session_id);
        formatter.field("traffic_mirror_target_id", &self.traffic_mirror_target_id);
        formatter.field("traffic_mirror_filter_id", &self.traffic_mirror_filter_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("packet_length", &self.packet_length);
        formatter.field("session_number", &self.session_number);
        formatter.field("virtual_network_id", &self.virtual_network_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrafficMirrorSession`](crate::model::TrafficMirrorSession)
pub mod traffic_mirror_session {
    /// A builder for [`TrafficMirrorSession`](crate::model::TrafficMirrorSession)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_mirror_session_id: std::option::Option<std::string::String>,
        pub(crate) traffic_mirror_target_id: std::option::Option<std::string::String>,
        pub(crate) traffic_mirror_filter_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) packet_length: std::option::Option<i32>,
        pub(crate) session_number: std::option::Option<i32>,
        pub(crate) virtual_network_id: std::option::Option<i32>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID for the Traffic Mirror session.</p>
        pub fn traffic_mirror_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_session_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_session_id = input;
            self
        }
        /// <p>The ID of the Traffic Mirror target.</p>
        pub fn traffic_mirror_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_target_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_target_id = input;
            self
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_filter_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_filter_id = input;
            self
        }
        /// <p>The ID of the Traffic Mirror session's network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The ID of the account that owns the Traffic Mirror session.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The number of bytes in each packet to mirror. These are the bytes after the VXLAN header. To mirror a subset, set this to the length (in bytes) to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. Do not specify this parameter when you want to mirror the entire packet</p>
        pub fn packet_length(mut self, input: i32) -> Self {
            self.packet_length = Some(input);
            self
        }
        pub fn set_packet_length(mut self, input: std::option::Option<i32>) -> Self {
            self.packet_length = input;
            self
        }
        /// <p>The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets.</p>
        /// <p>Valid values are 1-32766.</p>
        pub fn session_number(mut self, input: i32) -> Self {
            self.session_number = Some(input);
            self
        }
        pub fn set_session_number(mut self, input: std::option::Option<i32>) -> Self {
            self.session_number = input;
            self
        }
        /// <p>The virtual network ID associated with the Traffic Mirror session.</p>
        pub fn virtual_network_id(mut self, input: i32) -> Self {
            self.virtual_network_id = Some(input);
            self
        }
        pub fn set_virtual_network_id(mut self, input: std::option::Option<i32>) -> Self {
            self.virtual_network_id = input;
            self
        }
        /// <p>The description of the Traffic Mirror session.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorSession`](crate::model::TrafficMirrorSession)
        pub fn build(self) -> crate::model::TrafficMirrorSession {
            crate::model::TrafficMirrorSession {
                traffic_mirror_session_id: self.traffic_mirror_session_id,
                traffic_mirror_target_id: self.traffic_mirror_target_id,
                traffic_mirror_filter_id: self.traffic_mirror_filter_id,
                network_interface_id: self.network_interface_id,
                owner_id: self.owner_id,
                packet_length: self.packet_length,
                session_number: self.session_number,
                virtual_network_id: self.virtual_network_id,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl TrafficMirrorSession {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorSession`](crate::model::TrafficMirrorSession)
    pub fn builder() -> crate::model::traffic_mirror_session::Builder {
        crate::model::traffic_mirror_session::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficMirrorSessionField {
    Description,
    PacketLength,
    VirtualNetworkId,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficMirrorSessionField {
    fn from(s: &str) -> Self {
        match s {
            "description" => TrafficMirrorSessionField::Description,
            "packet-length" => TrafficMirrorSessionField::PacketLength,
            "virtual-network-id" => TrafficMirrorSessionField::VirtualNetworkId,
            other => TrafficMirrorSessionField::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficMirrorSessionField {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficMirrorSessionField::from(s))
    }
}
impl TrafficMirrorSessionField {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficMirrorSessionField::Description => "description",
            TrafficMirrorSessionField::PacketLength => "packet-length",
            TrafficMirrorSessionField::VirtualNetworkId => "virtual-network-id",
            TrafficMirrorSessionField::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["description", "packet-length", "virtual-network-id"]
    }
}
impl AsRef<str> for TrafficMirrorSessionField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Traffic Mirror rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorFilterRule {
    /// <p>The ID of the Traffic Mirror rule.</p>
    pub traffic_mirror_filter_rule_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Traffic Mirror filter that the rule is associated with.</p>
    pub traffic_mirror_filter_id: std::option::Option<std::string::String>,
    /// <p>The traffic direction assigned to the Traffic Mirror rule.</p>
    pub traffic_direction: std::option::Option<crate::model::TrafficDirection>,
    /// <p>The rule number of the Traffic Mirror rule.</p>
    pub rule_number: std::option::Option<i32>,
    /// <p>The action assigned to the Traffic Mirror rule.</p>
    pub rule_action: std::option::Option<crate::model::TrafficMirrorRuleAction>,
    /// <p>The protocol assigned to the Traffic Mirror rule.</p>
    pub protocol: std::option::Option<i32>,
    /// <p>The destination port range assigned to the Traffic Mirror rule.</p>
    pub destination_port_range: std::option::Option<crate::model::TrafficMirrorPortRange>,
    /// <p>The source port range assigned to the Traffic Mirror rule.</p>
    pub source_port_range: std::option::Option<crate::model::TrafficMirrorPortRange>,
    /// <p>The destination CIDR block assigned to the Traffic Mirror rule.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The source CIDR block assigned to the Traffic Mirror rule.</p>
    pub source_cidr_block: std::option::Option<std::string::String>,
    /// <p>The description of the Traffic Mirror rule.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrafficMirrorFilterRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorFilterRule");
        formatter.field(
            "traffic_mirror_filter_rule_id",
            &self.traffic_mirror_filter_rule_id,
        );
        formatter.field("traffic_mirror_filter_id", &self.traffic_mirror_filter_id);
        formatter.field("traffic_direction", &self.traffic_direction);
        formatter.field("rule_number", &self.rule_number);
        formatter.field("rule_action", &self.rule_action);
        formatter.field("protocol", &self.protocol);
        formatter.field("destination_port_range", &self.destination_port_range);
        formatter.field("source_port_range", &self.source_port_range);
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field("source_cidr_block", &self.source_cidr_block);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`TrafficMirrorFilterRule`](crate::model::TrafficMirrorFilterRule)
pub mod traffic_mirror_filter_rule {
    /// A builder for [`TrafficMirrorFilterRule`](crate::model::TrafficMirrorFilterRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_mirror_filter_rule_id: std::option::Option<std::string::String>,
        pub(crate) traffic_mirror_filter_id: std::option::Option<std::string::String>,
        pub(crate) traffic_direction: std::option::Option<crate::model::TrafficDirection>,
        pub(crate) rule_number: std::option::Option<i32>,
        pub(crate) rule_action: std::option::Option<crate::model::TrafficMirrorRuleAction>,
        pub(crate) protocol: std::option::Option<i32>,
        pub(crate) destination_port_range:
            std::option::Option<crate::model::TrafficMirrorPortRange>,
        pub(crate) source_port_range: std::option::Option<crate::model::TrafficMirrorPortRange>,
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) source_cidr_block: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Traffic Mirror rule.</p>
        pub fn traffic_mirror_filter_rule_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.traffic_mirror_filter_rule_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_filter_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_filter_rule_id = input;
            self
        }
        /// <p>The ID of the Traffic Mirror filter that the rule is associated with.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_filter_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_filter_id = input;
            self
        }
        /// <p>The traffic direction assigned to the Traffic Mirror rule.</p>
        pub fn traffic_direction(mut self, input: crate::model::TrafficDirection) -> Self {
            self.traffic_direction = Some(input);
            self
        }
        pub fn set_traffic_direction(
            mut self,
            input: std::option::Option<crate::model::TrafficDirection>,
        ) -> Self {
            self.traffic_direction = input;
            self
        }
        /// <p>The rule number of the Traffic Mirror rule.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.rule_number = Some(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.rule_number = input;
            self
        }
        /// <p>The action assigned to the Traffic Mirror rule.</p>
        pub fn rule_action(mut self, input: crate::model::TrafficMirrorRuleAction) -> Self {
            self.rule_action = Some(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorRuleAction>,
        ) -> Self {
            self.rule_action = input;
            self
        }
        /// <p>The protocol assigned to the Traffic Mirror rule.</p>
        pub fn protocol(mut self, input: i32) -> Self {
            self.protocol = Some(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<i32>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The destination port range assigned to the Traffic Mirror rule.</p>
        pub fn destination_port_range(
            mut self,
            input: crate::model::TrafficMirrorPortRange,
        ) -> Self {
            self.destination_port_range = Some(input);
            self
        }
        pub fn set_destination_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRange>,
        ) -> Self {
            self.destination_port_range = input;
            self
        }
        /// <p>The source port range assigned to the Traffic Mirror rule.</p>
        pub fn source_port_range(mut self, input: crate::model::TrafficMirrorPortRange) -> Self {
            self.source_port_range = Some(input);
            self
        }
        pub fn set_source_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRange>,
        ) -> Self {
            self.source_port_range = input;
            self
        }
        /// <p>The destination CIDR block assigned to the Traffic Mirror rule.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>The source CIDR block assigned to the Traffic Mirror rule.</p>
        pub fn source_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_cidr_block = Some(input.into());
            self
        }
        pub fn set_source_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_cidr_block = input;
            self
        }
        /// <p>The description of the Traffic Mirror rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorFilterRule`](crate::model::TrafficMirrorFilterRule)
        pub fn build(self) -> crate::model::TrafficMirrorFilterRule {
            crate::model::TrafficMirrorFilterRule {
                traffic_mirror_filter_rule_id: self.traffic_mirror_filter_rule_id,
                traffic_mirror_filter_id: self.traffic_mirror_filter_id,
                traffic_direction: self.traffic_direction,
                rule_number: self.rule_number,
                rule_action: self.rule_action,
                protocol: self.protocol,
                destination_port_range: self.destination_port_range,
                source_port_range: self.source_port_range,
                destination_cidr_block: self.destination_cidr_block,
                source_cidr_block: self.source_cidr_block,
                description: self.description,
            }
        }
    }
}
impl TrafficMirrorFilterRule {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorFilterRule`](crate::model::TrafficMirrorFilterRule)
    pub fn builder() -> crate::model::traffic_mirror_filter_rule::Builder {
        crate::model::traffic_mirror_filter_rule::Builder::default()
    }
}

/// <p>Describes the Traffic Mirror port range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorPortRange {
    /// <p>The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
    pub from_port: std::option::Option<i32>,
    /// <p>The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
    pub to_port: std::option::Option<i32>,
}
impl std::fmt::Debug for TrafficMirrorPortRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorPortRange");
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.finish()
    }
}
/// See [`TrafficMirrorPortRange`](crate::model::TrafficMirrorPortRange)
pub mod traffic_mirror_port_range {
    /// A builder for [`TrafficMirrorPortRange`](crate::model::TrafficMirrorPortRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorPortRange`](crate::model::TrafficMirrorPortRange)
        pub fn build(self) -> crate::model::TrafficMirrorPortRange {
            crate::model::TrafficMirrorPortRange {
                from_port: self.from_port,
                to_port: self.to_port,
            }
        }
    }
}
impl TrafficMirrorPortRange {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorPortRange`](crate::model::TrafficMirrorPortRange)
    pub fn builder() -> crate::model::traffic_mirror_port_range::Builder {
        crate::model::traffic_mirror_port_range::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficMirrorRuleAction {
    Accept,
    Reject,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficMirrorRuleAction {
    fn from(s: &str) -> Self {
        match s {
            "accept" => TrafficMirrorRuleAction::Accept,
            "reject" => TrafficMirrorRuleAction::Reject,
            other => TrafficMirrorRuleAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficMirrorRuleAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficMirrorRuleAction::from(s))
    }
}
impl TrafficMirrorRuleAction {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficMirrorRuleAction::Accept => "accept",
            TrafficMirrorRuleAction::Reject => "reject",
            TrafficMirrorRuleAction::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["accept", "reject"]
    }
}
impl AsRef<str> for TrafficMirrorRuleAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficDirection {
    Egress,
    Ingress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficDirection {
    fn from(s: &str) -> Self {
        match s {
            "egress" => TrafficDirection::Egress,
            "ingress" => TrafficDirection::Ingress,
            other => TrafficDirection::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficDirection::from(s))
    }
}
impl TrafficDirection {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficDirection::Egress => "egress",
            TrafficDirection::Ingress => "ingress",
            TrafficDirection::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["egress", "ingress"]
    }
}
impl AsRef<str> for TrafficDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficMirrorFilterRuleField {
    Description,
    DestinationPortRange,
    Protocol,
    SourcePortRange,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficMirrorFilterRuleField {
    fn from(s: &str) -> Self {
        match s {
            "description" => TrafficMirrorFilterRuleField::Description,
            "destination-port-range" => TrafficMirrorFilterRuleField::DestinationPortRange,
            "protocol" => TrafficMirrorFilterRuleField::Protocol,
            "source-port-range" => TrafficMirrorFilterRuleField::SourcePortRange,
            other => TrafficMirrorFilterRuleField::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficMirrorFilterRuleField {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficMirrorFilterRuleField::from(s))
    }
}
impl TrafficMirrorFilterRuleField {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficMirrorFilterRuleField::Description => "description",
            TrafficMirrorFilterRuleField::DestinationPortRange => "destination-port-range",
            TrafficMirrorFilterRuleField::Protocol => "protocol",
            TrafficMirrorFilterRuleField::SourcePortRange => "source-port-range",
            TrafficMirrorFilterRuleField::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "description",
            "destination-port-range",
            "protocol",
            "source-port-range",
        ]
    }
}
impl AsRef<str> for TrafficMirrorFilterRuleField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the Traffic Mirror filter rule port range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorPortRangeRequest {
    /// <p>The first port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
    pub from_port: std::option::Option<i32>,
    /// <p>The last port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
    pub to_port: std::option::Option<i32>,
}
impl std::fmt::Debug for TrafficMirrorPortRangeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorPortRangeRequest");
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.finish()
    }
}
/// See [`TrafficMirrorPortRangeRequest`](crate::model::TrafficMirrorPortRangeRequest)
pub mod traffic_mirror_port_range_request {
    /// A builder for [`TrafficMirrorPortRangeRequest`](crate::model::TrafficMirrorPortRangeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The first port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The last port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorPortRangeRequest`](crate::model::TrafficMirrorPortRangeRequest)
        pub fn build(self) -> crate::model::TrafficMirrorPortRangeRequest {
            crate::model::TrafficMirrorPortRangeRequest {
                from_port: self.from_port,
                to_port: self.to_port,
            }
        }
    }
}
impl TrafficMirrorPortRangeRequest {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorPortRangeRequest`](crate::model::TrafficMirrorPortRangeRequest)
    pub fn builder() -> crate::model::traffic_mirror_port_range_request::Builder {
        crate::model::traffic_mirror_port_range_request::Builder::default()
    }
}

/// <p>Describes the Traffic Mirror filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorFilter {
    /// <p>The ID of the Traffic Mirror filter.</p>
    pub traffic_mirror_filter_id: std::option::Option<std::string::String>,
    /// <p>Information about the ingress rules that are associated with the Traffic Mirror filter.</p>
    pub ingress_filter_rules:
        std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
    /// <p>Information about the egress rules that are associated with the Traffic Mirror filter.</p>
    pub egress_filter_rules:
        std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
    /// <p>The network service traffic that is associated with the Traffic Mirror filter.</p>
    pub network_services:
        std::option::Option<std::vec::Vec<crate::model::TrafficMirrorNetworkService>>,
    /// <p>The description of the Traffic Mirror filter.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the Traffic Mirror filter.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TrafficMirrorFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorFilter");
        formatter.field("traffic_mirror_filter_id", &self.traffic_mirror_filter_id);
        formatter.field("ingress_filter_rules", &self.ingress_filter_rules);
        formatter.field("egress_filter_rules", &self.egress_filter_rules);
        formatter.field("network_services", &self.network_services);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrafficMirrorFilter`](crate::model::TrafficMirrorFilter)
pub mod traffic_mirror_filter {
    /// A builder for [`TrafficMirrorFilter`](crate::model::TrafficMirrorFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_mirror_filter_id: std::option::Option<std::string::String>,
        pub(crate) ingress_filter_rules:
            std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
        pub(crate) egress_filter_rules:
            std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
        pub(crate) network_services:
            std::option::Option<std::vec::Vec<crate::model::TrafficMirrorNetworkService>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_filter_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_filter_id = input;
            self
        }
        pub fn ingress_filter_rules(
            mut self,
            input: impl Into<crate::model::TrafficMirrorFilterRule>,
        ) -> Self {
            let mut v = self.ingress_filter_rules.unwrap_or_default();
            v.push(input.into());
            self.ingress_filter_rules = Some(v);
            self
        }
        pub fn set_ingress_filter_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
        ) -> Self {
            self.ingress_filter_rules = input;
            self
        }
        pub fn egress_filter_rules(
            mut self,
            input: impl Into<crate::model::TrafficMirrorFilterRule>,
        ) -> Self {
            let mut v = self.egress_filter_rules.unwrap_or_default();
            v.push(input.into());
            self.egress_filter_rules = Some(v);
            self
        }
        pub fn set_egress_filter_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRule>>,
        ) -> Self {
            self.egress_filter_rules = input;
            self
        }
        pub fn network_services(
            mut self,
            input: impl Into<crate::model::TrafficMirrorNetworkService>,
        ) -> Self {
            let mut v = self.network_services.unwrap_or_default();
            v.push(input.into());
            self.network_services = Some(v);
            self
        }
        pub fn set_network_services(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorNetworkService>>,
        ) -> Self {
            self.network_services = input;
            self
        }
        /// <p>The description of the Traffic Mirror filter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorFilter`](crate::model::TrafficMirrorFilter)
        pub fn build(self) -> crate::model::TrafficMirrorFilter {
            crate::model::TrafficMirrorFilter {
                traffic_mirror_filter_id: self.traffic_mirror_filter_id,
                ingress_filter_rules: self.ingress_filter_rules,
                egress_filter_rules: self.egress_filter_rules,
                network_services: self.network_services,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl TrafficMirrorFilter {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorFilter`](crate::model::TrafficMirrorFilter)
    pub fn builder() -> crate::model::traffic_mirror_filter::Builder {
        crate::model::traffic_mirror_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficMirrorNetworkService {
    AmazonDns,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficMirrorNetworkService {
    fn from(s: &str) -> Self {
        match s {
            "amazon-dns" => TrafficMirrorNetworkService::AmazonDns,
            other => TrafficMirrorNetworkService::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficMirrorNetworkService {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficMirrorNetworkService::from(s))
    }
}
impl TrafficMirrorNetworkService {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficMirrorNetworkService::AmazonDns => "amazon-dns",
            TrafficMirrorNetworkService::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["amazon-dns"]
    }
}
impl AsRef<str> for TrafficMirrorNetworkService {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OperationType {
    Add,
    Remove,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OperationType {
    fn from(s: &str) -> Self {
        match s {
            "add" => OperationType::Add,
            "remove" => OperationType::Remove,
            other => OperationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OperationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OperationType::from(s))
    }
}
impl OperationType {
    pub fn as_str(&self) -> &str {
        match self {
            OperationType::Add => "add",
            OperationType::Remove => "remove",
            OperationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["add", "remove"]
    }
}
impl AsRef<str> for OperationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes modifications to the list of create volume permissions for a volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVolumePermissionModifications {
    /// <p>Adds the specified Amazon Web Services account ID or group to the list.</p>
    pub add: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
    /// <p>Removes the specified Amazon Web Services account ID or group from the list.</p>
    pub remove: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
}
impl std::fmt::Debug for CreateVolumePermissionModifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVolumePermissionModifications");
        formatter.field("add", &self.add);
        formatter.field("remove", &self.remove);
        formatter.finish()
    }
}
/// See [`CreateVolumePermissionModifications`](crate::model::CreateVolumePermissionModifications)
pub mod create_volume_permission_modifications {
    /// A builder for [`CreateVolumePermissionModifications`](crate::model::CreateVolumePermissionModifications)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
        pub(crate) remove: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
    }
    impl Builder {
        pub fn add(mut self, input: impl Into<crate::model::CreateVolumePermission>) -> Self {
            let mut v = self.add.unwrap_or_default();
            v.push(input.into());
            self.add = Some(v);
            self
        }
        pub fn set_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
        ) -> Self {
            self.add = input;
            self
        }
        pub fn remove(mut self, input: impl Into<crate::model::CreateVolumePermission>) -> Self {
            let mut v = self.remove.unwrap_or_default();
            v.push(input.into());
            self.remove = Some(v);
            self
        }
        pub fn set_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateVolumePermission>>,
        ) -> Self {
            self.remove = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVolumePermissionModifications`](crate::model::CreateVolumePermissionModifications)
        pub fn build(self) -> crate::model::CreateVolumePermissionModifications {
            crate::model::CreateVolumePermissionModifications {
                add: self.add,
                remove: self.remove,
            }
        }
    }
}
impl CreateVolumePermissionModifications {
    /// Creates a new builder-style object to manufacture [`CreateVolumePermissionModifications`](crate::model::CreateVolumePermissionModifications)
    pub fn builder() -> crate::model::create_volume_permission_modifications::Builder {
        crate::model::create_volume_permission_modifications::Builder::default()
    }
}

/// <p>Describes the user or group to be added or removed from the list of create volume
/// permissions for a volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVolumePermission {
    /// <p>The group to be added or removed. The possible value is <code>all</code>.</p>
    pub group: std::option::Option<crate::model::PermissionGroup>,
    /// <p>The ID of the Amazon Web Services account to be added or removed.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateVolumePermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVolumePermission");
        formatter.field("group", &self.group);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}
/// See [`CreateVolumePermission`](crate::model::CreateVolumePermission)
pub mod create_volume_permission {
    /// A builder for [`CreateVolumePermission`](crate::model::CreateVolumePermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group: std::option::Option<crate::model::PermissionGroup>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The group to be added or removed. The possible value is <code>all</code>.</p>
        pub fn group(mut self, input: crate::model::PermissionGroup) -> Self {
            self.group = Some(input);
            self
        }
        pub fn set_group(
            mut self,
            input: std::option::Option<crate::model::PermissionGroup>,
        ) -> Self {
            self.group = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account to be added or removed.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVolumePermission`](crate::model::CreateVolumePermission)
        pub fn build(self) -> crate::model::CreateVolumePermission {
            crate::model::CreateVolumePermission {
                group: self.group,
                user_id: self.user_id,
            }
        }
    }
}
impl CreateVolumePermission {
    /// Creates a new builder-style object to manufacture [`CreateVolumePermission`](crate::model::CreateVolumePermission)
    pub fn builder() -> crate::model::create_volume_permission::Builder {
        crate::model::create_volume_permission::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionGroup {
    All,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PermissionGroup {
    fn from(s: &str) -> Self {
        match s {
            "all" => PermissionGroup::All,
            other => PermissionGroup::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PermissionGroup {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionGroup::from(s))
    }
}
impl PermissionGroup {
    pub fn as_str(&self) -> &str {
        match self {
            PermissionGroup::All => "all",
            PermissionGroup::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["all"]
    }
}
impl AsRef<str> for PermissionGroup {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an update to a security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRuleUpdate {
    /// <p>The ID of the security group rule.</p>
    pub security_group_rule_id: std::option::Option<std::string::String>,
    /// <p>Information about the security group rule.</p>
    pub security_group_rule: std::option::Option<crate::model::SecurityGroupRuleRequest>,
}
impl std::fmt::Debug for SecurityGroupRuleUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRuleUpdate");
        formatter.field("security_group_rule_id", &self.security_group_rule_id);
        formatter.field("security_group_rule", &self.security_group_rule);
        formatter.finish()
    }
}
/// See [`SecurityGroupRuleUpdate`](crate::model::SecurityGroupRuleUpdate)
pub mod security_group_rule_update {
    /// A builder for [`SecurityGroupRuleUpdate`](crate::model::SecurityGroupRuleUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_rule_id: std::option::Option<std::string::String>,
        pub(crate) security_group_rule: std::option::Option<crate::model::SecurityGroupRuleRequest>,
    }
    impl Builder {
        /// <p>The ID of the security group rule.</p>
        pub fn security_group_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_group_rule_id = Some(input.into());
            self
        }
        pub fn set_security_group_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_group_rule_id = input;
            self
        }
        /// <p>Information about the security group rule.</p>
        pub fn security_group_rule(
            mut self,
            input: crate::model::SecurityGroupRuleRequest,
        ) -> Self {
            self.security_group_rule = Some(input);
            self
        }
        pub fn set_security_group_rule(
            mut self,
            input: std::option::Option<crate::model::SecurityGroupRuleRequest>,
        ) -> Self {
            self.security_group_rule = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRuleUpdate`](crate::model::SecurityGroupRuleUpdate)
        pub fn build(self) -> crate::model::SecurityGroupRuleUpdate {
            crate::model::SecurityGroupRuleUpdate {
                security_group_rule_id: self.security_group_rule_id,
                security_group_rule: self.security_group_rule,
            }
        }
    }
}
impl SecurityGroupRuleUpdate {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRuleUpdate`](crate::model::SecurityGroupRuleUpdate)
    pub fn builder() -> crate::model::security_group_rule_update::Builder {
        crate::model::security_group_rule_update::Builder::default()
    }
}

/// <p>Describes a security group rule.</p>
/// <p>You must specify exactly one of the following parameters, based on the rule type:</p>
/// <ul>
/// <li>
/// <p>CidrIpv4</p>
/// </li>
/// <li>
/// <p>CidrIpv6</p>
/// </li>
/// <li>
/// <p>PrefixListId</p>
/// </li>
/// <li>
/// <p>ReferencedGroupId</p>
/// </li>
/// </ul>
/// <p>When you modify a rule, you cannot change the rule type. For example, if the rule  
/// uses an IPv4 address range, you must use <code>CidrIpv4</code> to specify a new IPv4
/// address range.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRuleRequest {
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
    /// <code>icmpv6</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p>
    /// <p>Use <code>-1</code> to specify all protocols.</p>
    pub ip_protocol: std::option::Option<std::string::String>,
    /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
    pub from_port: std::option::Option<i32>,
    /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
    pub to_port: std::option::Option<i32>,
    /// <p>The IPv4 CIDR range. To specify a single IPv4 address, use the /32 prefix length. </p>
    pub cidr_ipv4: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR range. To specify a single IPv6 address, use the /128 prefix length.</p>
    pub cidr_ipv6: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The ID of the security group that is referenced in the security group rule.</p>
    pub referenced_group_id: std::option::Option<std::string::String>,
    /// <p>The description of the security group rule.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityGroupRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRuleRequest");
        formatter.field("ip_protocol", &self.ip_protocol);
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.field("cidr_ipv4", &self.cidr_ipv4);
        formatter.field("cidr_ipv6", &self.cidr_ipv6);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("referenced_group_id", &self.referenced_group_id);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`SecurityGroupRuleRequest`](crate::model::SecurityGroupRuleRequest)
pub mod security_group_rule_request {
    /// A builder for [`SecurityGroupRuleRequest`](crate::model::SecurityGroupRuleRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_protocol: std::option::Option<std::string::String>,
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
        pub(crate) cidr_ipv4: std::option::Option<std::string::String>,
        pub(crate) cidr_ipv6: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) referenced_group_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
        /// <code>icmpv6</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p>
        /// <p>Use <code>-1</code> to specify all protocols.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_protocol = Some(input.into());
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_protocol = input;
            self
        }
        /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// <p>The IPv4 CIDR range. To specify a single IPv4 address, use the /32 prefix length. </p>
        pub fn cidr_ipv4(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv4 = Some(input.into());
            self
        }
        pub fn set_cidr_ipv4(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv4 = input;
            self
        }
        /// <p>The IPv6 CIDR range. To specify a single IPv6 address, use the /128 prefix length.</p>
        pub fn cidr_ipv6(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv6 = Some(input.into());
            self
        }
        pub fn set_cidr_ipv6(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv6 = input;
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The ID of the security group that is referenced in the security group rule.</p>
        pub fn referenced_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.referenced_group_id = Some(input.into());
            self
        }
        pub fn set_referenced_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.referenced_group_id = input;
            self
        }
        /// <p>The description of the security group rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRuleRequest`](crate::model::SecurityGroupRuleRequest)
        pub fn build(self) -> crate::model::SecurityGroupRuleRequest {
            crate::model::SecurityGroupRuleRequest {
                ip_protocol: self.ip_protocol,
                from_port: self.from_port,
                to_port: self.to_port,
                cidr_ipv4: self.cidr_ipv4,
                cidr_ipv6: self.cidr_ipv6,
                prefix_list_id: self.prefix_list_id,
                referenced_group_id: self.referenced_group_id,
                description: self.description,
            }
        }
    }
}
impl SecurityGroupRuleRequest {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRuleRequest`](crate::model::SecurityGroupRuleRequest)
    pub fn builder() -> crate::model::security_group_rule_request::Builder {
        crate::model::security_group_rule_request::Builder::default()
    }
}

/// <p>Describes the configuration settings for the modified Reserved Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesConfiguration {
    /// <p>The Availability Zone for the modified Reserved Instances.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of modified Reserved Instances.</p>
    /// <note>
    /// <p>This is a required field for a request.</p>
    /// </note>
    pub instance_count: std::option::Option<i32>,
    /// <p>The instance type for the modified Reserved Instances.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>Whether the Reserved Instance is applied to instances in a Region or instances in a specific Availability Zone.</p>
    pub scope: std::option::Option<crate::model::Scope>,
}
impl std::fmt::Debug for ReservedInstancesConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesConfiguration");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("platform", &self.platform);
        formatter.field("scope", &self.scope);
        formatter.finish()
    }
}
/// See [`ReservedInstancesConfiguration`](crate::model::ReservedInstancesConfiguration)
pub mod reserved_instances_configuration {
    /// A builder for [`ReservedInstancesConfiguration`](crate::model::ReservedInstancesConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
    }
    impl Builder {
        /// <p>The Availability Zone for the modified Reserved Instances.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of modified Reserved Instances.</p>
        /// <note>
        /// <p>This is a required field for a request.</p>
        /// </note>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The instance type for the modified Reserved Instances.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>Whether the Reserved Instance is applied to instances in a Region or instances in a specific Availability Zone.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesConfiguration`](crate::model::ReservedInstancesConfiguration)
        pub fn build(self) -> crate::model::ReservedInstancesConfiguration {
            crate::model::ReservedInstancesConfiguration {
                availability_zone: self.availability_zone,
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                platform: self.platform,
                scope: self.scope,
            }
        }
    }
}
impl ReservedInstancesConfiguration {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesConfiguration`](crate::model::ReservedInstancesConfiguration)
    pub fn builder() -> crate::model::reserved_instances_configuration::Builder {
        crate::model::reserved_instances_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Scope {
    AvailabilityZone,
    Regional,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Scope {
    fn from(s: &str) -> Self {
        match s {
            "Availability Zone" => Scope::AvailabilityZone,
            "Region" => Scope::Regional,
            other => Scope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Scope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Scope::from(s))
    }
}
impl Scope {
    pub fn as_str(&self) -> &str {
        match self {
            Scope::AvailabilityZone => "Availability Zone",
            Scope::Regional => "Region",
            Scope::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Availability Zone", "Region"]
    }
}
impl AsRef<str> for Scope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a value for a resource attribute that is a String.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeValue {
    /// <p>The attribute value. The value is case-sensitive.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AttributeValue`](crate::model::AttributeValue)
pub mod attribute_value {
    /// A builder for [`AttributeValue`](crate::model::AttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute value. The value is case-sensitive.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeValue`](crate::model::AttributeValue)
        pub fn build(self) -> crate::model::AttributeValue {
            crate::model::AttributeValue { value: self.value }
        }
    }
}
impl AttributeValue {
    /// Creates a new builder-style object to manufacture [`AttributeValue`](crate::model::AttributeValue)
    pub fn builder() -> crate::model::attribute_value::Builder {
        crate::model::attribute_value::Builder::default()
    }
}

/// <p>Describes an attachment change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfaceAttachmentChanges {
    /// <p>The ID of the network interface attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
}
impl std::fmt::Debug for NetworkInterfaceAttachmentChanges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfaceAttachmentChanges");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.finish()
    }
}
/// See [`NetworkInterfaceAttachmentChanges`](crate::model::NetworkInterfaceAttachmentChanges)
pub mod network_interface_attachment_changes {
    /// A builder for [`NetworkInterfaceAttachmentChanges`](crate::model::NetworkInterfaceAttachmentChanges)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the network interface attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfaceAttachmentChanges`](crate::model::NetworkInterfaceAttachmentChanges)
        pub fn build(self) -> crate::model::NetworkInterfaceAttachmentChanges {
            crate::model::NetworkInterfaceAttachmentChanges {
                attachment_id: self.attachment_id,
                delete_on_termination: self.delete_on_termination,
            }
        }
    }
}
impl NetworkInterfaceAttachmentChanges {
    /// Creates a new builder-style object to manufacture [`NetworkInterfaceAttachmentChanges`](crate::model::NetworkInterfaceAttachmentChanges)
    pub fn builder() -> crate::model::network_interface_attachment_changes::Builder {
        crate::model::network_interface_attachment_changes::Builder::default()
    }
}

/// <p>An entry for a prefix list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemovePrefixListEntry {
    /// <p>The CIDR block.</p>
    pub cidr: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemovePrefixListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemovePrefixListEntry");
        formatter.field("cidr", &self.cidr);
        formatter.finish()
    }
}
/// See [`RemovePrefixListEntry`](crate::model::RemovePrefixListEntry)
pub mod remove_prefix_list_entry {
    /// A builder for [`RemovePrefixListEntry`](crate::model::RemovePrefixListEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// Consumes the builder and constructs a [`RemovePrefixListEntry`](crate::model::RemovePrefixListEntry)
        pub fn build(self) -> crate::model::RemovePrefixListEntry {
            crate::model::RemovePrefixListEntry { cidr: self.cidr }
        }
    }
}
impl RemovePrefixListEntry {
    /// Creates a new builder-style object to manufacture [`RemovePrefixListEntry`](crate::model::RemovePrefixListEntry)
    pub fn builder() -> crate::model::remove_prefix_list_entry::Builder {
        crate::model::remove_prefix_list_entry::Builder::default()
    }
}

/// <p>An entry for a prefix list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddPrefixListEntry {
    /// <p>The CIDR block.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>A description for the entry.</p>
    /// <p>Constraints: Up to 255 characters in length.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddPrefixListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddPrefixListEntry");
        formatter.field("cidr", &self.cidr);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`AddPrefixListEntry`](crate::model::AddPrefixListEntry)
pub mod add_prefix_list_entry {
    /// A builder for [`AddPrefixListEntry`](crate::model::AddPrefixListEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>A description for the entry.</p>
        /// <p>Constraints: Up to 255 characters in length.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`AddPrefixListEntry`](crate::model::AddPrefixListEntry)
        pub fn build(self) -> crate::model::AddPrefixListEntry {
            crate::model::AddPrefixListEntry {
                cidr: self.cidr,
                description: self.description,
            }
        }
    }
}
impl AddPrefixListEntry {
    /// Creates a new builder-style object to manufacture [`AddPrefixListEntry`](crate::model::AddPrefixListEntry)
    pub fn builder() -> crate::model::add_prefix_list_entry::Builder {
        crate::model::add_prefix_list_entry::Builder::default()
    }
}

/// <p>Describes a launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplate {
    /// <p>The ID of the launch template.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The time launch template was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The principal that created the launch template. </p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The version number of the default version of the launch template.</p>
    pub default_version_number: std::option::Option<i64>,
    /// <p>The version number of the latest version of the launch template.</p>
    pub latest_version_number: std::option::Option<i64>,
    /// <p>The tags for the launch template.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LaunchTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplate");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("create_time", &self.create_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("default_version_number", &self.default_version_number);
        formatter.field("latest_version_number", &self.latest_version_number);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LaunchTemplate`](crate::model::LaunchTemplate)
pub mod launch_template {
    /// A builder for [`LaunchTemplate`](crate::model::LaunchTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) default_version_number: std::option::Option<i64>,
        pub(crate) latest_version_number: std::option::Option<i64>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the launch template.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The time launch template was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The principal that created the launch template. </p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The version number of the default version of the launch template.</p>
        pub fn default_version_number(mut self, input: i64) -> Self {
            self.default_version_number = Some(input);
            self
        }
        pub fn set_default_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.default_version_number = input;
            self
        }
        /// <p>The version number of the latest version of the launch template.</p>
        pub fn latest_version_number(mut self, input: i64) -> Self {
            self.latest_version_number = Some(input);
            self
        }
        pub fn set_latest_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.latest_version_number = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplate`](crate::model::LaunchTemplate)
        pub fn build(self) -> crate::model::LaunchTemplate {
            crate::model::LaunchTemplate {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                create_time: self.create_time,
                created_by: self.created_by,
                default_version_number: self.default_version_number,
                latest_version_number: self.latest_version_number,
                tags: self.tags,
            }
        }
    }
}
impl LaunchTemplate {
    /// Creates a new builder-style object to manufacture [`LaunchTemplate`](crate::model::LaunchTemplate)
    pub fn builder() -> crate::model::launch_template::Builder {
        crate::model::launch_template::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HostTenancy {
    Dedicated,
    Host,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HostTenancy {
    fn from(s: &str) -> Self {
        match s {
            "dedicated" => HostTenancy::Dedicated,
            "host" => HostTenancy::Host,
            other => HostTenancy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HostTenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HostTenancy::from(s))
    }
}
impl HostTenancy {
    pub fn as_str(&self) -> &str {
        match self {
            HostTenancy::Dedicated => "dedicated",
            HostTenancy::Host => "host",
            HostTenancy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["dedicated", "host"]
    }
}
impl AsRef<str> for HostTenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Affinity {
    Default,
    Host,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Affinity {
    fn from(s: &str) -> Self {
        match s {
            "default" => Affinity::Default,
            "host" => Affinity::Host,
            other => Affinity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Affinity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Affinity::from(s))
    }
}
impl Affinity {
    pub fn as_str(&self) -> &str {
        match self {
            Affinity::Default => "default",
            Affinity::Host => "host",
            Affinity::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["default", "host"]
    }
}
impl AsRef<str> for Affinity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The event window.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindow {
    /// <p>The ID of the event window.</p>
    pub instance_event_window_id: std::option::Option<std::string::String>,
    /// <p>One or more time ranges defined for the event window.</p>
    pub time_ranges: std::option::Option<std::vec::Vec<crate::model::InstanceEventWindowTimeRange>>,
    /// <p>The name of the event window.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The cron expression defined for the event window.</p>
    pub cron_expression: std::option::Option<std::string::String>,
    /// <p>One or more targets associated with the event window.</p>
    pub association_target: std::option::Option<crate::model::InstanceEventWindowAssociationTarget>,
    /// <p>The current state of the event window.</p>
    pub state: std::option::Option<crate::model::InstanceEventWindowState>,
    /// <p>The instance tags associated with the event window.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for InstanceEventWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindow");
        formatter.field("instance_event_window_id", &self.instance_event_window_id);
        formatter.field("time_ranges", &self.time_ranges);
        formatter.field("name", &self.name);
        formatter.field("cron_expression", &self.cron_expression);
        formatter.field("association_target", &self.association_target);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`InstanceEventWindow`](crate::model::InstanceEventWindow)
pub mod instance_event_window {
    /// A builder for [`InstanceEventWindow`](crate::model::InstanceEventWindow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_event_window_id: std::option::Option<std::string::String>,
        pub(crate) time_ranges:
            std::option::Option<std::vec::Vec<crate::model::InstanceEventWindowTimeRange>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) cron_expression: std::option::Option<std::string::String>,
        pub(crate) association_target:
            std::option::Option<crate::model::InstanceEventWindowAssociationTarget>,
        pub(crate) state: std::option::Option<crate::model::InstanceEventWindowState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the event window.</p>
        pub fn instance_event_window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_event_window_id = Some(input.into());
            self
        }
        pub fn set_instance_event_window_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_event_window_id = input;
            self
        }
        pub fn time_ranges(
            mut self,
            input: impl Into<crate::model::InstanceEventWindowTimeRange>,
        ) -> Self {
            let mut v = self.time_ranges.unwrap_or_default();
            v.push(input.into());
            self.time_ranges = Some(v);
            self
        }
        pub fn set_time_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceEventWindowTimeRange>>,
        ) -> Self {
            self.time_ranges = input;
            self
        }
        /// <p>The name of the event window.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The cron expression defined for the event window.</p>
        pub fn cron_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.cron_expression = Some(input.into());
            self
        }
        pub fn set_cron_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cron_expression = input;
            self
        }
        /// <p>One or more targets associated with the event window.</p>
        pub fn association_target(
            mut self,
            input: crate::model::InstanceEventWindowAssociationTarget,
        ) -> Self {
            self.association_target = Some(input);
            self
        }
        pub fn set_association_target(
            mut self,
            input: std::option::Option<crate::model::InstanceEventWindowAssociationTarget>,
        ) -> Self {
            self.association_target = input;
            self
        }
        /// <p>The current state of the event window.</p>
        pub fn state(mut self, input: crate::model::InstanceEventWindowState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::InstanceEventWindowState>,
        ) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindow`](crate::model::InstanceEventWindow)
        pub fn build(self) -> crate::model::InstanceEventWindow {
            crate::model::InstanceEventWindow {
                instance_event_window_id: self.instance_event_window_id,
                time_ranges: self.time_ranges,
                name: self.name,
                cron_expression: self.cron_expression,
                association_target: self.association_target,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl InstanceEventWindow {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindow`](crate::model::InstanceEventWindow)
    pub fn builder() -> crate::model::instance_event_window::Builder {
        crate::model::instance_event_window::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceEventWindowState {
    Active,
    Creating,
    Deleted,
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceEventWindowState {
    fn from(s: &str) -> Self {
        match s {
            "active" => InstanceEventWindowState::Active,
            "creating" => InstanceEventWindowState::Creating,
            "deleted" => InstanceEventWindowState::Deleted,
            "deleting" => InstanceEventWindowState::Deleting,
            other => InstanceEventWindowState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceEventWindowState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceEventWindowState::from(s))
    }
}
impl InstanceEventWindowState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceEventWindowState::Active => "active",
            InstanceEventWindowState::Creating => "creating",
            InstanceEventWindowState::Deleted => "deleted",
            InstanceEventWindowState::Deleting => "deleting",
            InstanceEventWindowState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "creating", "deleted", "deleting"]
    }
}
impl AsRef<str> for InstanceEventWindowState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>One or more targets associated with the event window.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowAssociationTarget {
    /// <p>The IDs of the instances associated with the event window.</p>
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance tags associated with the event window. Any instances associated with the tags
    /// will be associated with the event window.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The IDs of the Dedicated Hosts associated with the event window.</p>
    pub dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InstanceEventWindowAssociationTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowAssociationTarget");
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("tags", &self.tags);
        formatter.field("dedicated_host_ids", &self.dedicated_host_ids);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowAssociationTarget`](crate::model::InstanceEventWindowAssociationTarget)
pub mod instance_event_window_association_target {
    /// A builder for [`InstanceEventWindowAssociationTarget`](crate::model::InstanceEventWindowAssociationTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn dedicated_host_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dedicated_host_ids.unwrap_or_default();
            v.push(input.into());
            self.dedicated_host_ids = Some(v);
            self
        }
        pub fn set_dedicated_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dedicated_host_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowAssociationTarget`](crate::model::InstanceEventWindowAssociationTarget)
        pub fn build(self) -> crate::model::InstanceEventWindowAssociationTarget {
            crate::model::InstanceEventWindowAssociationTarget {
                instance_ids: self.instance_ids,
                tags: self.tags,
                dedicated_host_ids: self.dedicated_host_ids,
            }
        }
    }
}
impl InstanceEventWindowAssociationTarget {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowAssociationTarget`](crate::model::InstanceEventWindowAssociationTarget)
    pub fn builder() -> crate::model::instance_event_window_association_target::Builder {
        crate::model::instance_event_window_association_target::Builder::default()
    }
}

/// <p>The start day and time and the end day and time of the time range, in UTC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowTimeRange {
    /// <p>The day on which the time range begins.</p>
    pub start_week_day: std::option::Option<crate::model::WeekDay>,
    /// <p>The hour when the time range begins.</p>
    pub start_hour: std::option::Option<i32>,
    /// <p>The day on which the time range ends.</p>
    pub end_week_day: std::option::Option<crate::model::WeekDay>,
    /// <p>The hour when the time range ends.</p>
    pub end_hour: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceEventWindowTimeRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowTimeRange");
        formatter.field("start_week_day", &self.start_week_day);
        formatter.field("start_hour", &self.start_hour);
        formatter.field("end_week_day", &self.end_week_day);
        formatter.field("end_hour", &self.end_hour);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowTimeRange`](crate::model::InstanceEventWindowTimeRange)
pub mod instance_event_window_time_range {
    /// A builder for [`InstanceEventWindowTimeRange`](crate::model::InstanceEventWindowTimeRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_week_day: std::option::Option<crate::model::WeekDay>,
        pub(crate) start_hour: std::option::Option<i32>,
        pub(crate) end_week_day: std::option::Option<crate::model::WeekDay>,
        pub(crate) end_hour: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The day on which the time range begins.</p>
        pub fn start_week_day(mut self, input: crate::model::WeekDay) -> Self {
            self.start_week_day = Some(input);
            self
        }
        pub fn set_start_week_day(
            mut self,
            input: std::option::Option<crate::model::WeekDay>,
        ) -> Self {
            self.start_week_day = input;
            self
        }
        /// <p>The hour when the time range begins.</p>
        pub fn start_hour(mut self, input: i32) -> Self {
            self.start_hour = Some(input);
            self
        }
        pub fn set_start_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.start_hour = input;
            self
        }
        /// <p>The day on which the time range ends.</p>
        pub fn end_week_day(mut self, input: crate::model::WeekDay) -> Self {
            self.end_week_day = Some(input);
            self
        }
        pub fn set_end_week_day(
            mut self,
            input: std::option::Option<crate::model::WeekDay>,
        ) -> Self {
            self.end_week_day = input;
            self
        }
        /// <p>The hour when the time range ends.</p>
        pub fn end_hour(mut self, input: i32) -> Self {
            self.end_hour = Some(input);
            self
        }
        pub fn set_end_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.end_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowTimeRange`](crate::model::InstanceEventWindowTimeRange)
        pub fn build(self) -> crate::model::InstanceEventWindowTimeRange {
            crate::model::InstanceEventWindowTimeRange {
                start_week_day: self.start_week_day,
                start_hour: self.start_hour,
                end_week_day: self.end_week_day,
                end_hour: self.end_hour,
            }
        }
    }
}
impl InstanceEventWindowTimeRange {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowTimeRange`](crate::model::InstanceEventWindowTimeRange)
    pub fn builder() -> crate::model::instance_event_window_time_range::Builder {
        crate::model::instance_event_window_time_range::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WeekDay {
    Friday,
    Monday,
    Saturday,
    Sunday,
    Thursday,
    Tuesday,
    Wednesday,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WeekDay {
    fn from(s: &str) -> Self {
        match s {
            "friday" => WeekDay::Friday,
            "monday" => WeekDay::Monday,
            "saturday" => WeekDay::Saturday,
            "sunday" => WeekDay::Sunday,
            "thursday" => WeekDay::Thursday,
            "tuesday" => WeekDay::Tuesday,
            "wednesday" => WeekDay::Wednesday,
            other => WeekDay::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WeekDay {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WeekDay::from(s))
    }
}
impl WeekDay {
    pub fn as_str(&self) -> &str {
        match self {
            WeekDay::Friday => "friday",
            WeekDay::Monday => "monday",
            WeekDay::Saturday => "saturday",
            WeekDay::Sunday => "sunday",
            WeekDay::Thursday => "thursday",
            WeekDay::Tuesday => "tuesday",
            WeekDay::Wednesday => "wednesday",
            WeekDay::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "friday",
            "monday",
            "saturday",
            "sunday",
            "thursday",
            "tuesday",
            "wednesday",
        ]
    }
}
impl AsRef<str> for WeekDay {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The start day and time and the end day and time of the time range, in UTC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowTimeRangeRequest {
    /// <p>The day on which the time range begins.</p>
    pub start_week_day: std::option::Option<crate::model::WeekDay>,
    /// <p>The hour when the time range begins.</p>
    pub start_hour: std::option::Option<i32>,
    /// <p>The day on which the time range ends.</p>
    pub end_week_day: std::option::Option<crate::model::WeekDay>,
    /// <p>The hour when the time range ends.</p>
    pub end_hour: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceEventWindowTimeRangeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowTimeRangeRequest");
        formatter.field("start_week_day", &self.start_week_day);
        formatter.field("start_hour", &self.start_hour);
        formatter.field("end_week_day", &self.end_week_day);
        formatter.field("end_hour", &self.end_hour);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowTimeRangeRequest`](crate::model::InstanceEventWindowTimeRangeRequest)
pub mod instance_event_window_time_range_request {
    /// A builder for [`InstanceEventWindowTimeRangeRequest`](crate::model::InstanceEventWindowTimeRangeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_week_day: std::option::Option<crate::model::WeekDay>,
        pub(crate) start_hour: std::option::Option<i32>,
        pub(crate) end_week_day: std::option::Option<crate::model::WeekDay>,
        pub(crate) end_hour: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The day on which the time range begins.</p>
        pub fn start_week_day(mut self, input: crate::model::WeekDay) -> Self {
            self.start_week_day = Some(input);
            self
        }
        pub fn set_start_week_day(
            mut self,
            input: std::option::Option<crate::model::WeekDay>,
        ) -> Self {
            self.start_week_day = input;
            self
        }
        /// <p>The hour when the time range begins.</p>
        pub fn start_hour(mut self, input: i32) -> Self {
            self.start_hour = Some(input);
            self
        }
        pub fn set_start_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.start_hour = input;
            self
        }
        /// <p>The day on which the time range ends.</p>
        pub fn end_week_day(mut self, input: crate::model::WeekDay) -> Self {
            self.end_week_day = Some(input);
            self
        }
        pub fn set_end_week_day(
            mut self,
            input: std::option::Option<crate::model::WeekDay>,
        ) -> Self {
            self.end_week_day = input;
            self
        }
        /// <p>The hour when the time range ends.</p>
        pub fn end_hour(mut self, input: i32) -> Self {
            self.end_hour = Some(input);
            self
        }
        pub fn set_end_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.end_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowTimeRangeRequest`](crate::model::InstanceEventWindowTimeRangeRequest)
        pub fn build(self) -> crate::model::InstanceEventWindowTimeRangeRequest {
            crate::model::InstanceEventWindowTimeRangeRequest {
                start_week_day: self.start_week_day,
                start_hour: self.start_hour,
                end_week_day: self.end_week_day,
                end_hour: self.end_hour,
            }
        }
    }
}
impl InstanceEventWindowTimeRangeRequest {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowTimeRangeRequest`](crate::model::InstanceEventWindowTimeRangeRequest)
    pub fn builder() -> crate::model::instance_event_window_time_range_request::Builder {
        crate::model::instance_event_window_time_range_request::Builder::default()
    }
}

/// <p>Describes a scheduled event for an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStatusEvent {
    /// <p>The ID of the event.</p>
    pub instance_event_id: std::option::Option<std::string::String>,
    /// <p>The event code.</p>
    pub code: std::option::Option<crate::model::EventCode>,
    /// <p>A description of the event.</p>
    /// <p>After a scheduled event is completed, it can still be described for up to a week. If
    /// the event has been completed, this description starts with the following text:
    /// [Completed].</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The latest scheduled end time for the event.</p>
    pub not_after: std::option::Option<smithy_types::Instant>,
    /// <p>The earliest scheduled start time for the event.</p>
    pub not_before: std::option::Option<smithy_types::Instant>,
    /// <p>The deadline for starting the event.</p>
    pub not_before_deadline: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for InstanceStatusEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStatusEvent");
        formatter.field("instance_event_id", &self.instance_event_id);
        formatter.field("code", &self.code);
        formatter.field("description", &self.description);
        formatter.field("not_after", &self.not_after);
        formatter.field("not_before", &self.not_before);
        formatter.field("not_before_deadline", &self.not_before_deadline);
        formatter.finish()
    }
}
/// See [`InstanceStatusEvent`](crate::model::InstanceStatusEvent)
pub mod instance_status_event {
    /// A builder for [`InstanceStatusEvent`](crate::model::InstanceStatusEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_event_id: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<crate::model::EventCode>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) not_after: std::option::Option<smithy_types::Instant>,
        pub(crate) not_before: std::option::Option<smithy_types::Instant>,
        pub(crate) not_before_deadline: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the event.</p>
        pub fn instance_event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_event_id = Some(input.into());
            self
        }
        pub fn set_instance_event_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_event_id = input;
            self
        }
        /// <p>The event code.</p>
        pub fn code(mut self, input: crate::model::EventCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::EventCode>) -> Self {
            self.code = input;
            self
        }
        /// <p>A description of the event.</p>
        /// <p>After a scheduled event is completed, it can still be described for up to a week. If
        /// the event has been completed, this description starts with the following text:
        /// [Completed].</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The latest scheduled end time for the event.</p>
        pub fn not_after(mut self, input: smithy_types::Instant) -> Self {
            self.not_after = Some(input);
            self
        }
        pub fn set_not_after(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_after = input;
            self
        }
        /// <p>The earliest scheduled start time for the event.</p>
        pub fn not_before(mut self, input: smithy_types::Instant) -> Self {
            self.not_before = Some(input);
            self
        }
        pub fn set_not_before(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_before = input;
            self
        }
        /// <p>The deadline for starting the event.</p>
        pub fn not_before_deadline(mut self, input: smithy_types::Instant) -> Self {
            self.not_before_deadline = Some(input);
            self
        }
        pub fn set_not_before_deadline(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.not_before_deadline = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatusEvent`](crate::model::InstanceStatusEvent)
        pub fn build(self) -> crate::model::InstanceStatusEvent {
            crate::model::InstanceStatusEvent {
                instance_event_id: self.instance_event_id,
                code: self.code,
                description: self.description,
                not_after: self.not_after,
                not_before: self.not_before,
                not_before_deadline: self.not_before_deadline,
            }
        }
    }
}
impl InstanceStatusEvent {
    /// Creates a new builder-style object to manufacture [`InstanceStatusEvent`](crate::model::InstanceStatusEvent)
    pub fn builder() -> crate::model::instance_status_event::Builder {
        crate::model::instance_status_event::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventCode {
    InstanceReboot,
    InstanceRetirement,
    InstanceStop,
    SystemMaintenance,
    SystemReboot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EventCode {
    fn from(s: &str) -> Self {
        match s {
            "instance-reboot" => EventCode::InstanceReboot,
            "instance-retirement" => EventCode::InstanceRetirement,
            "instance-stop" => EventCode::InstanceStop,
            "system-maintenance" => EventCode::SystemMaintenance,
            "system-reboot" => EventCode::SystemReboot,
            other => EventCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EventCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventCode::from(s))
    }
}
impl EventCode {
    pub fn as_str(&self) -> &str {
        match self {
            EventCode::InstanceReboot => "instance-reboot",
            EventCode::InstanceRetirement => "instance-retirement",
            EventCode::InstanceStop => "instance-stop",
            EventCode::SystemMaintenance => "system-maintenance",
            EventCode::SystemReboot => "system-reboot",
            EventCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "instance-reboot",
            "instance-retirement",
            "instance-stop",
            "system-maintenance",
            "system-reboot",
        ]
    }
}
impl AsRef<str> for EventCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the burstable performance instance whose credit option for CPU usage was not
/// modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsuccessfulInstanceCreditSpecificationItem {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The applicable error for the burstable performance instance whose credit option for
    /// CPU usage was not modified.</p>
    pub error: std::option::Option<crate::model::UnsuccessfulInstanceCreditSpecificationItemError>,
}
impl std::fmt::Debug for UnsuccessfulInstanceCreditSpecificationItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsuccessfulInstanceCreditSpecificationItem");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`UnsuccessfulInstanceCreditSpecificationItem`](crate::model::UnsuccessfulInstanceCreditSpecificationItem)
pub mod unsuccessful_instance_credit_specification_item {
    /// A builder for [`UnsuccessfulInstanceCreditSpecificationItem`](crate::model::UnsuccessfulInstanceCreditSpecificationItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) error:
            std::option::Option<crate::model::UnsuccessfulInstanceCreditSpecificationItemError>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The applicable error for the burstable performance instance whose credit option for
        /// CPU usage was not modified.</p>
        pub fn error(
            mut self,
            input: crate::model::UnsuccessfulInstanceCreditSpecificationItemError,
        ) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<
                crate::model::UnsuccessfulInstanceCreditSpecificationItemError,
            >,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsuccessfulInstanceCreditSpecificationItem`](crate::model::UnsuccessfulInstanceCreditSpecificationItem)
        pub fn build(self) -> crate::model::UnsuccessfulInstanceCreditSpecificationItem {
            crate::model::UnsuccessfulInstanceCreditSpecificationItem {
                instance_id: self.instance_id,
                error: self.error,
            }
        }
    }
}
impl UnsuccessfulInstanceCreditSpecificationItem {
    /// Creates a new builder-style object to manufacture [`UnsuccessfulInstanceCreditSpecificationItem`](crate::model::UnsuccessfulInstanceCreditSpecificationItem)
    pub fn builder() -> crate::model::unsuccessful_instance_credit_specification_item::Builder {
        crate::model::unsuccessful_instance_credit_specification_item::Builder::default()
    }
}

/// <p>Information about the error for the burstable performance instance whose credit option
/// for CPU usage was not modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsuccessfulInstanceCreditSpecificationItemError {
    /// <p>The error code.</p>
    pub code: std::option::Option<crate::model::UnsuccessfulInstanceCreditSpecificationErrorCode>,
    /// <p>The applicable error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsuccessfulInstanceCreditSpecificationItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsuccessfulInstanceCreditSpecificationItemError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`UnsuccessfulInstanceCreditSpecificationItemError`](crate::model::UnsuccessfulInstanceCreditSpecificationItemError)
pub mod unsuccessful_instance_credit_specification_item_error {
    /// A builder for [`UnsuccessfulInstanceCreditSpecificationItemError`](crate::model::UnsuccessfulInstanceCreditSpecificationItemError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code:
            std::option::Option<crate::model::UnsuccessfulInstanceCreditSpecificationErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(
            mut self,
            input: crate::model::UnsuccessfulInstanceCreditSpecificationErrorCode,
        ) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<
                crate::model::UnsuccessfulInstanceCreditSpecificationErrorCode,
            >,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The applicable error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsuccessfulInstanceCreditSpecificationItemError`](crate::model::UnsuccessfulInstanceCreditSpecificationItemError)
        pub fn build(self) -> crate::model::UnsuccessfulInstanceCreditSpecificationItemError {
            crate::model::UnsuccessfulInstanceCreditSpecificationItemError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnsuccessfulInstanceCreditSpecificationItemError {
    /// Creates a new builder-style object to manufacture [`UnsuccessfulInstanceCreditSpecificationItemError`](crate::model::UnsuccessfulInstanceCreditSpecificationItemError)
    pub fn builder() -> crate::model::unsuccessful_instance_credit_specification_item_error::Builder
    {
        crate::model::unsuccessful_instance_credit_specification_item_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UnsuccessfulInstanceCreditSpecificationErrorCode {
    IncorrectInstanceState,
    InstanceCreditSpecificationNotSupported,
    InvalidInstanceId,
    InstanceNotFound,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UnsuccessfulInstanceCreditSpecificationErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "IncorrectInstanceState" => UnsuccessfulInstanceCreditSpecificationErrorCode::IncorrectInstanceState,
            "InstanceCreditSpecification.NotSupported" => UnsuccessfulInstanceCreditSpecificationErrorCode::InstanceCreditSpecificationNotSupported,
            "InvalidInstanceID.Malformed" => UnsuccessfulInstanceCreditSpecificationErrorCode::InvalidInstanceId,
            "InvalidInstanceID.NotFound" => UnsuccessfulInstanceCreditSpecificationErrorCode::InstanceNotFound,
            other => UnsuccessfulInstanceCreditSpecificationErrorCode::Unknown(other.to_owned())
        }
    }
}
impl std::str::FromStr for UnsuccessfulInstanceCreditSpecificationErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UnsuccessfulInstanceCreditSpecificationErrorCode::from(s))
    }
}
impl UnsuccessfulInstanceCreditSpecificationErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            UnsuccessfulInstanceCreditSpecificationErrorCode::IncorrectInstanceState => "IncorrectInstanceState",
            UnsuccessfulInstanceCreditSpecificationErrorCode::InstanceCreditSpecificationNotSupported => "InstanceCreditSpecification.NotSupported",
            UnsuccessfulInstanceCreditSpecificationErrorCode::InvalidInstanceId => "InvalidInstanceID.Malformed",
            UnsuccessfulInstanceCreditSpecificationErrorCode::InstanceNotFound => "InvalidInstanceID.NotFound",
            UnsuccessfulInstanceCreditSpecificationErrorCode::Unknown(s) => s.as_ref()
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "IncorrectInstanceState",
            "InstanceCreditSpecification.NotSupported",
            "InvalidInstanceID.Malformed",
            "InvalidInstanceID.NotFound",
        ]
    }
}
impl AsRef<str> for UnsuccessfulInstanceCreditSpecificationErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the burstable performance instance whose credit option for CPU usage was
/// successfully modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SuccessfulInstanceCreditSpecificationItem {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SuccessfulInstanceCreditSpecificationItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SuccessfulInstanceCreditSpecificationItem");
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}
/// See [`SuccessfulInstanceCreditSpecificationItem`](crate::model::SuccessfulInstanceCreditSpecificationItem)
pub mod successful_instance_credit_specification_item {
    /// A builder for [`SuccessfulInstanceCreditSpecificationItem`](crate::model::SuccessfulInstanceCreditSpecificationItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SuccessfulInstanceCreditSpecificationItem`](crate::model::SuccessfulInstanceCreditSpecificationItem)
        pub fn build(self) -> crate::model::SuccessfulInstanceCreditSpecificationItem {
            crate::model::SuccessfulInstanceCreditSpecificationItem {
                instance_id: self.instance_id,
            }
        }
    }
}
impl SuccessfulInstanceCreditSpecificationItem {
    /// Creates a new builder-style object to manufacture [`SuccessfulInstanceCreditSpecificationItem`](crate::model::SuccessfulInstanceCreditSpecificationItem)
    pub fn builder() -> crate::model::successful_instance_credit_specification_item::Builder {
        crate::model::successful_instance_credit_specification_item::Builder::default()
    }
}

/// <p>Describes the credit option for CPU usage of a burstable performance instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceCreditSpecificationRequest {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The credit option for CPU usage of the instance. Valid values are
    /// <code>standard</code> and <code>unlimited</code>.</p>
    /// <p>T3 instances with <code>host</code> tenancy do not support the <code>unlimited</code>
    /// CPU credit option.</p>
    pub cpu_credits: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceCreditSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceCreditSpecificationRequest");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("cpu_credits", &self.cpu_credits);
        formatter.finish()
    }
}
/// See [`InstanceCreditSpecificationRequest`](crate::model::InstanceCreditSpecificationRequest)
pub mod instance_credit_specification_request {
    /// A builder for [`InstanceCreditSpecificationRequest`](crate::model::InstanceCreditSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) cpu_credits: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The credit option for CPU usage of the instance. Valid values are
        /// <code>standard</code> and <code>unlimited</code>.</p>
        /// <p>T3 instances with <code>host</code> tenancy do not support the <code>unlimited</code>
        /// CPU credit option.</p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_credits = Some(input.into());
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu_credits = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCreditSpecificationRequest`](crate::model::InstanceCreditSpecificationRequest)
        pub fn build(self) -> crate::model::InstanceCreditSpecificationRequest {
            crate::model::InstanceCreditSpecificationRequest {
                instance_id: self.instance_id,
                cpu_credits: self.cpu_credits,
            }
        }
    }
}
impl InstanceCreditSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`InstanceCreditSpecificationRequest`](crate::model::InstanceCreditSpecificationRequest)
    pub fn builder() -> crate::model::instance_credit_specification_request::Builder {
        crate::model::instance_credit_specification_request::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlobAttributeValue {
    pub value: std::option::Option<smithy_types::Blob>,
}
impl std::fmt::Debug for BlobAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlobAttributeValue");
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`BlobAttributeValue`](crate::model::BlobAttributeValue)
pub mod blob_attribute_value {
    /// A builder for [`BlobAttributeValue`](crate::model::BlobAttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<smithy_types::Blob>,
    }
    impl Builder {
        pub fn value(mut self, input: smithy_types::Blob) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`BlobAttributeValue`](crate::model::BlobAttributeValue)
        pub fn build(self) -> crate::model::BlobAttributeValue {
            crate::model::BlobAttributeValue { value: self.value }
        }
    }
}
impl BlobAttributeValue {
    /// Creates a new builder-style object to manufacture [`BlobAttributeValue`](crate::model::BlobAttributeValue)
    pub fn builder() -> crate::model::blob_attribute_value::Builder {
        crate::model::blob_attribute_value::Builder::default()
    }
}

/// <p>Describes a block device mapping entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceBlockDeviceMappingSpecification {
    /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to automatically set up EBS volumes when the instance is
    /// launched.</p>
    pub ebs: std::option::Option<crate::model::EbsInstanceBlockDeviceSpecification>,
    /// <p>suppress the specified device included in the block device mapping.</p>
    pub no_device: std::option::Option<std::string::String>,
    /// <p>The virtual device name.</p>
    pub virtual_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceBlockDeviceMappingSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceBlockDeviceMappingSpecification");
        formatter.field("device_name", &self.device_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.finish()
    }
}
/// See [`InstanceBlockDeviceMappingSpecification`](crate::model::InstanceBlockDeviceMappingSpecification)
pub mod instance_block_device_mapping_specification {
    /// A builder for [`InstanceBlockDeviceMappingSpecification`](crate::model::InstanceBlockDeviceMappingSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::EbsInstanceBlockDeviceSpecification>,
        pub(crate) no_device: std::option::Option<std::string::String>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Parameters used to automatically set up EBS volumes when the instance is
        /// launched.</p>
        pub fn ebs(mut self, input: crate::model::EbsInstanceBlockDeviceSpecification) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(
            mut self,
            input: std::option::Option<crate::model::EbsInstanceBlockDeviceSpecification>,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// <p>suppress the specified device included in the block device mapping.</p>
        pub fn no_device(mut self, input: impl Into<std::string::String>) -> Self {
            self.no_device = Some(input.into());
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.no_device = input;
            self
        }
        /// <p>The virtual device name.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceBlockDeviceMappingSpecification`](crate::model::InstanceBlockDeviceMappingSpecification)
        pub fn build(self) -> crate::model::InstanceBlockDeviceMappingSpecification {
            crate::model::InstanceBlockDeviceMappingSpecification {
                device_name: self.device_name,
                ebs: self.ebs,
                no_device: self.no_device,
                virtual_name: self.virtual_name,
            }
        }
    }
}
impl InstanceBlockDeviceMappingSpecification {
    /// Creates a new builder-style object to manufacture [`InstanceBlockDeviceMappingSpecification`](crate::model::InstanceBlockDeviceMappingSpecification)
    pub fn builder() -> crate::model::instance_block_device_mapping_specification::Builder {
        crate::model::instance_block_device_mapping_specification::Builder::default()
    }
}

/// <p>Describes information used to set up an EBS volume specified in a block device
/// mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsInstanceBlockDeviceSpecification {
    /// <p>Indicates whether the volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The ID of the EBS volume.</p>
    pub volume_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EbsInstanceBlockDeviceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsInstanceBlockDeviceSpecification");
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("volume_id", &self.volume_id);
        formatter.finish()
    }
}
/// See [`EbsInstanceBlockDeviceSpecification`](crate::model::EbsInstanceBlockDeviceSpecification)
pub mod ebs_instance_block_device_specification {
    /// A builder for [`EbsInstanceBlockDeviceSpecification`](crate::model::EbsInstanceBlockDeviceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The ID of the EBS volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsInstanceBlockDeviceSpecification`](crate::model::EbsInstanceBlockDeviceSpecification)
        pub fn build(self) -> crate::model::EbsInstanceBlockDeviceSpecification {
            crate::model::EbsInstanceBlockDeviceSpecification {
                delete_on_termination: self.delete_on_termination,
                volume_id: self.volume_id,
            }
        }
    }
}
impl EbsInstanceBlockDeviceSpecification {
    /// Creates a new builder-style object to manufacture [`EbsInstanceBlockDeviceSpecification`](crate::model::EbsInstanceBlockDeviceSpecification)
    pub fn builder() -> crate::model::ebs_instance_block_device_specification::Builder {
        crate::model::ebs_instance_block_device_specification::Builder::default()
    }
}

/// <p>Describes a launch permission modification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchPermissionModifications {
    /// <p>The Amazon Web Services account ID to add to the list of launch permissions for the AMI.</p>
    pub add: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
    /// <p>The Amazon Web Services account ID to remove from the list of launch permissions for the AMI.</p>
    pub remove: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
}
impl std::fmt::Debug for LaunchPermissionModifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchPermissionModifications");
        formatter.field("add", &self.add);
        formatter.field("remove", &self.remove);
        formatter.finish()
    }
}
/// See [`LaunchPermissionModifications`](crate::model::LaunchPermissionModifications)
pub mod launch_permission_modifications {
    /// A builder for [`LaunchPermissionModifications`](crate::model::LaunchPermissionModifications)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
        pub(crate) remove: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
    }
    impl Builder {
        pub fn add(mut self, input: impl Into<crate::model::LaunchPermission>) -> Self {
            let mut v = self.add.unwrap_or_default();
            v.push(input.into());
            self.add = Some(v);
            self
        }
        pub fn set_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
        ) -> Self {
            self.add = input;
            self
        }
        pub fn remove(mut self, input: impl Into<crate::model::LaunchPermission>) -> Self {
            let mut v = self.remove.unwrap_or_default();
            v.push(input.into());
            self.remove = Some(v);
            self
        }
        pub fn set_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchPermission>>,
        ) -> Self {
            self.remove = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchPermissionModifications`](crate::model::LaunchPermissionModifications)
        pub fn build(self) -> crate::model::LaunchPermissionModifications {
            crate::model::LaunchPermissionModifications {
                add: self.add,
                remove: self.remove,
            }
        }
    }
}
impl LaunchPermissionModifications {
    /// Creates a new builder-style object to manufacture [`LaunchPermissionModifications`](crate::model::LaunchPermissionModifications)
    pub fn builder() -> crate::model::launch_permission_modifications::Builder {
        crate::model::launch_permission_modifications::Builder::default()
    }
}

/// <p>Describes a launch permission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchPermission {
    /// <p>The name of the group.</p>
    pub group: std::option::Option<crate::model::PermissionGroup>,
    /// <p>The Amazon Web Services account ID.</p>
    /// <p>Constraints: Up to 10 000 account IDs can be specified in a single request.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchPermission");
        formatter.field("group", &self.group);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}
/// See [`LaunchPermission`](crate::model::LaunchPermission)
pub mod launch_permission {
    /// A builder for [`LaunchPermission`](crate::model::LaunchPermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group: std::option::Option<crate::model::PermissionGroup>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group.</p>
        pub fn group(mut self, input: crate::model::PermissionGroup) -> Self {
            self.group = Some(input);
            self
        }
        pub fn set_group(
            mut self,
            input: std::option::Option<crate::model::PermissionGroup>,
        ) -> Self {
            self.group = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        /// <p>Constraints: Up to 10 000 account IDs can be specified in a single request.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchPermission`](crate::model::LaunchPermission)
        pub fn build(self) -> crate::model::LaunchPermission {
            crate::model::LaunchPermission {
                group: self.group,
                user_id: self.user_id,
            }
        }
    }
}
impl LaunchPermission {
    /// Creates a new builder-style object to manufacture [`LaunchPermission`](crate::model::LaunchPermission)
    pub fn builder() -> crate::model::launch_permission::Builder {
        crate::model::launch_permission::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HostRecovery {
    Off,
    On,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HostRecovery {
    fn from(s: &str) -> Self {
        match s {
            "off" => HostRecovery::Off,
            "on" => HostRecovery::On,
            other => HostRecovery::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HostRecovery {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HostRecovery::from(s))
    }
}
impl HostRecovery {
    pub fn as_str(&self) -> &str {
        match self {
            HostRecovery::Off => "off",
            HostRecovery::On => "on",
            HostRecovery::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["off", "on"]
    }
}
impl AsRef<str> for HostRecovery {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoPlacement {
    Off,
    On,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoPlacement {
    fn from(s: &str) -> Self {
        match s {
            "off" => AutoPlacement::Off,
            "on" => AutoPlacement::On,
            other => AutoPlacement::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoPlacement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoPlacement::from(s))
    }
}
impl AutoPlacement {
    pub fn as_str(&self) -> &str {
        match self {
            AutoPlacement::Off => "off",
            AutoPlacement::On => "on",
            AutoPlacement::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["off", "on"]
    }
}
impl AsRef<str> for AutoPlacement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Amazon FPGA image (AFI) attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaImageAttribute {
    /// <p>The ID of the AFI.</p>
    pub fpga_image_id: std::option::Option<std::string::String>,
    /// <p>The name of the AFI.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the AFI.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The load permissions.</p>
    pub load_permissions: std::option::Option<std::vec::Vec<crate::model::LoadPermission>>,
    /// <p>The product codes.</p>
    pub product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
}
impl std::fmt::Debug for FpgaImageAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaImageAttribute");
        formatter.field("fpga_image_id", &self.fpga_image_id);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("load_permissions", &self.load_permissions);
        formatter.field("product_codes", &self.product_codes);
        formatter.finish()
    }
}
/// See [`FpgaImageAttribute`](crate::model::FpgaImageAttribute)
pub mod fpga_image_attribute {
    /// A builder for [`FpgaImageAttribute`](crate::model::FpgaImageAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpga_image_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) load_permissions:
            std::option::Option<std::vec::Vec<crate::model::LoadPermission>>,
        pub(crate) product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
    }
    impl Builder {
        /// <p>The ID of the AFI.</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fpga_image_id = Some(input.into());
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fpga_image_id = input;
            self
        }
        /// <p>The name of the AFI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the AFI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn load_permissions(mut self, input: impl Into<crate::model::LoadPermission>) -> Self {
            let mut v = self.load_permissions.unwrap_or_default();
            v.push(input.into());
            self.load_permissions = Some(v);
            self
        }
        pub fn set_load_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadPermission>>,
        ) -> Self {
            self.load_permissions = input;
            self
        }
        pub fn product_codes(mut self, input: impl Into<crate::model::ProductCode>) -> Self {
            let mut v = self.product_codes.unwrap_or_default();
            v.push(input.into());
            self.product_codes = Some(v);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        ) -> Self {
            self.product_codes = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaImageAttribute`](crate::model::FpgaImageAttribute)
        pub fn build(self) -> crate::model::FpgaImageAttribute {
            crate::model::FpgaImageAttribute {
                fpga_image_id: self.fpga_image_id,
                name: self.name,
                description: self.description,
                load_permissions: self.load_permissions,
                product_codes: self.product_codes,
            }
        }
    }
}
impl FpgaImageAttribute {
    /// Creates a new builder-style object to manufacture [`FpgaImageAttribute`](crate::model::FpgaImageAttribute)
    pub fn builder() -> crate::model::fpga_image_attribute::Builder {
        crate::model::fpga_image_attribute::Builder::default()
    }
}

/// <p>Describes a load permission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadPermission {
    /// <p>The AWS account ID.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The name of the group.</p>
    pub group: std::option::Option<crate::model::PermissionGroup>,
}
impl std::fmt::Debug for LoadPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadPermission");
        formatter.field("user_id", &self.user_id);
        formatter.field("group", &self.group);
        formatter.finish()
    }
}
/// See [`LoadPermission`](crate::model::LoadPermission)
pub mod load_permission {
    /// A builder for [`LoadPermission`](crate::model::LoadPermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) group: std::option::Option<crate::model::PermissionGroup>,
    }
    impl Builder {
        /// <p>The AWS account ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The name of the group.</p>
        pub fn group(mut self, input: crate::model::PermissionGroup) -> Self {
            self.group = Some(input);
            self
        }
        pub fn set_group(
            mut self,
            input: std::option::Option<crate::model::PermissionGroup>,
        ) -> Self {
            self.group = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadPermission`](crate::model::LoadPermission)
        pub fn build(self) -> crate::model::LoadPermission {
            crate::model::LoadPermission {
                user_id: self.user_id,
                group: self.group,
            }
        }
    }
}
impl LoadPermission {
    /// Creates a new builder-style object to manufacture [`LoadPermission`](crate::model::LoadPermission)
    pub fn builder() -> crate::model::load_permission::Builder {
        crate::model::load_permission::Builder::default()
    }
}

/// <p>Describes modifications to the load permissions of an Amazon FPGA image (AFI).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadPermissionModifications {
    /// <p>The load permissions to add.</p>
    pub add: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
    /// <p>The load permissions to remove.</p>
    pub remove: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
}
impl std::fmt::Debug for LoadPermissionModifications {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadPermissionModifications");
        formatter.field("add", &self.add);
        formatter.field("remove", &self.remove);
        formatter.finish()
    }
}
/// See [`LoadPermissionModifications`](crate::model::LoadPermissionModifications)
pub mod load_permission_modifications {
    /// A builder for [`LoadPermissionModifications`](crate::model::LoadPermissionModifications)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
        pub(crate) remove: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
    }
    impl Builder {
        pub fn add(mut self, input: impl Into<crate::model::LoadPermissionRequest>) -> Self {
            let mut v = self.add.unwrap_or_default();
            v.push(input.into());
            self.add = Some(v);
            self
        }
        pub fn set_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
        ) -> Self {
            self.add = input;
            self
        }
        pub fn remove(mut self, input: impl Into<crate::model::LoadPermissionRequest>) -> Self {
            let mut v = self.remove.unwrap_or_default();
            v.push(input.into());
            self.remove = Some(v);
            self
        }
        pub fn set_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadPermissionRequest>>,
        ) -> Self {
            self.remove = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadPermissionModifications`](crate::model::LoadPermissionModifications)
        pub fn build(self) -> crate::model::LoadPermissionModifications {
            crate::model::LoadPermissionModifications {
                add: self.add,
                remove: self.remove,
            }
        }
    }
}
impl LoadPermissionModifications {
    /// Creates a new builder-style object to manufacture [`LoadPermissionModifications`](crate::model::LoadPermissionModifications)
    pub fn builder() -> crate::model::load_permission_modifications::Builder {
        crate::model::load_permission_modifications::Builder::default()
    }
}

/// <p>Describes a load permission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadPermissionRequest {
    /// <p>The name of the group.</p>
    pub group: std::option::Option<crate::model::PermissionGroup>,
    /// <p>The AWS account ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LoadPermissionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadPermissionRequest");
        formatter.field("group", &self.group);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}
/// See [`LoadPermissionRequest`](crate::model::LoadPermissionRequest)
pub mod load_permission_request {
    /// A builder for [`LoadPermissionRequest`](crate::model::LoadPermissionRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group: std::option::Option<crate::model::PermissionGroup>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the group.</p>
        pub fn group(mut self, input: crate::model::PermissionGroup) -> Self {
            self.group = Some(input);
            self
        }
        pub fn set_group(
            mut self,
            input: std::option::Option<crate::model::PermissionGroup>,
        ) -> Self {
            self.group = input;
            self
        }
        /// <p>The AWS account ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadPermissionRequest`](crate::model::LoadPermissionRequest)
        pub fn build(self) -> crate::model::LoadPermissionRequest {
            crate::model::LoadPermissionRequest {
                group: self.group,
                user_id: self.user_id,
            }
        }
    }
}
impl LoadPermissionRequest {
    /// Creates a new builder-style object to manufacture [`LoadPermissionRequest`](crate::model::LoadPermissionRequest)
    pub fn builder() -> crate::model::load_permission_request::Builder {
        crate::model::load_permission_request::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FpgaImageAttributeName {
    Description,
    LoadPermission,
    Name,
    ProductCodes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FpgaImageAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "description" => FpgaImageAttributeName::Description,
            "loadPermission" => FpgaImageAttributeName::LoadPermission,
            "name" => FpgaImageAttributeName::Name,
            "productCodes" => FpgaImageAttributeName::ProductCodes,
            other => FpgaImageAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FpgaImageAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FpgaImageAttributeName::from(s))
    }
}
impl FpgaImageAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            FpgaImageAttributeName::Description => "description",
            FpgaImageAttributeName::LoadPermission => "loadPermission",
            FpgaImageAttributeName::Name => "name",
            FpgaImageAttributeName::ProductCodes => "productCodes",
            FpgaImageAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["description", "loadPermission", "name", "productCodes"]
    }
}
impl AsRef<str> for FpgaImageAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The number of units to request. You can choose to set the target capacity as the number of
/// instances. Or you can set the target capacity to a performance characteristic that is important to your application workload,
/// such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can
/// specify a target capacity of 0 and add capacity later.</p>
/// <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance
/// <code>MaxTotalPrice</code> parameter, or both parameters to ensure that your fleet cost
/// does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances
/// in your request, EC2 Fleet will launch instances until it reaches the maximum amount that you're
/// willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops
/// launching instances even if it hasn’t met the target capacity. The
/// <code>MaxTotalPrice</code> parameters are located in <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_OnDemandOptionsRequest">OnDemandOptionsRequest</a>
/// and <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotOptionsRequest">SpotOptionsRequest</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetCapacitySpecificationRequest {
    /// <p>The number of units to request, filled using
    /// <code>DefaultTargetCapacityType</code>.</p>
    pub total_target_capacity: std::option::Option<i32>,
    /// <p>The number of On-Demand units to request.</p>
    pub on_demand_target_capacity: std::option::Option<i32>,
    /// <p>The number of Spot units to request.</p>
    pub spot_target_capacity: std::option::Option<i32>,
    /// <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or
    /// <code>On-Demand</code>.</p>
    pub default_target_capacity_type: std::option::Option<crate::model::DefaultTargetCapacityType>,
}
impl std::fmt::Debug for TargetCapacitySpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetCapacitySpecificationRequest");
        formatter.field("total_target_capacity", &self.total_target_capacity);
        formatter.field("on_demand_target_capacity", &self.on_demand_target_capacity);
        formatter.field("spot_target_capacity", &self.spot_target_capacity);
        formatter.field(
            "default_target_capacity_type",
            &self.default_target_capacity_type,
        );
        formatter.finish()
    }
}
/// See [`TargetCapacitySpecificationRequest`](crate::model::TargetCapacitySpecificationRequest)
pub mod target_capacity_specification_request {
    /// A builder for [`TargetCapacitySpecificationRequest`](crate::model::TargetCapacitySpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_target_capacity: std::option::Option<i32>,
        pub(crate) on_demand_target_capacity: std::option::Option<i32>,
        pub(crate) spot_target_capacity: std::option::Option<i32>,
        pub(crate) default_target_capacity_type:
            std::option::Option<crate::model::DefaultTargetCapacityType>,
    }
    impl Builder {
        /// <p>The number of units to request, filled using
        /// <code>DefaultTargetCapacityType</code>.</p>
        pub fn total_target_capacity(mut self, input: i32) -> Self {
            self.total_target_capacity = Some(input);
            self
        }
        pub fn set_total_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.total_target_capacity = input;
            self
        }
        /// <p>The number of On-Demand units to request.</p>
        pub fn on_demand_target_capacity(mut self, input: i32) -> Self {
            self.on_demand_target_capacity = Some(input);
            self
        }
        pub fn set_on_demand_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.on_demand_target_capacity = input;
            self
        }
        /// <p>The number of Spot units to request.</p>
        pub fn spot_target_capacity(mut self, input: i32) -> Self {
            self.spot_target_capacity = Some(input);
            self
        }
        pub fn set_spot_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.spot_target_capacity = input;
            self
        }
        /// <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or
        /// <code>On-Demand</code>.</p>
        pub fn default_target_capacity_type(
            mut self,
            input: crate::model::DefaultTargetCapacityType,
        ) -> Self {
            self.default_target_capacity_type = Some(input);
            self
        }
        pub fn set_default_target_capacity_type(
            mut self,
            input: std::option::Option<crate::model::DefaultTargetCapacityType>,
        ) -> Self {
            self.default_target_capacity_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetCapacitySpecificationRequest`](crate::model::TargetCapacitySpecificationRequest)
        pub fn build(self) -> crate::model::TargetCapacitySpecificationRequest {
            crate::model::TargetCapacitySpecificationRequest {
                total_target_capacity: self.total_target_capacity,
                on_demand_target_capacity: self.on_demand_target_capacity,
                spot_target_capacity: self.spot_target_capacity,
                default_target_capacity_type: self.default_target_capacity_type,
            }
        }
    }
}
impl TargetCapacitySpecificationRequest {
    /// Creates a new builder-style object to manufacture [`TargetCapacitySpecificationRequest`](crate::model::TargetCapacitySpecificationRequest)
    pub fn builder() -> crate::model::target_capacity_specification_request::Builder {
        crate::model::target_capacity_specification_request::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DefaultTargetCapacityType {
    OnDemand,
    Spot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DefaultTargetCapacityType {
    fn from(s: &str) -> Self {
        match s {
            "on-demand" => DefaultTargetCapacityType::OnDemand,
            "spot" => DefaultTargetCapacityType::Spot,
            other => DefaultTargetCapacityType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DefaultTargetCapacityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DefaultTargetCapacityType::from(s))
    }
}
impl DefaultTargetCapacityType {
    pub fn as_str(&self) -> &str {
        match self {
            DefaultTargetCapacityType::OnDemand => "on-demand",
            DefaultTargetCapacityType::Spot => "spot",
            DefaultTargetCapacityType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["on-demand", "spot"]
    }
}
impl AsRef<str> for DefaultTargetCapacityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a launch template and overrides.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateConfigRequest {
    /// <p>The launch template to use. You must specify either the launch template ID or launch
    /// template name in the request. </p>
    pub launch_template_specification:
        std::option::Option<crate::model::FleetLaunchTemplateSpecificationRequest>,
    /// <p>Any parameters that you specify override the same parameters in the launch
    /// template.</p>
    /// <p>For fleets of type <code>request</code> and <code>maintain</code>, a maximum of 300
    /// items is allowed across all launch templates.</p>
    pub overrides:
        std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateOverridesRequest>>,
}
impl std::fmt::Debug for FleetLaunchTemplateConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateConfigRequest");
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateConfigRequest`](crate::model::FleetLaunchTemplateConfigRequest)
pub mod fleet_launch_template_config_request {
    /// A builder for [`FleetLaunchTemplateConfigRequest`](crate::model::FleetLaunchTemplateConfigRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::FleetLaunchTemplateSpecificationRequest>,
        pub(crate) overrides:
            std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateOverridesRequest>>,
    }
    impl Builder {
        /// <p>The launch template to use. You must specify either the launch template ID or launch
        /// template name in the request. </p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::FleetLaunchTemplateSpecificationRequest,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::FleetLaunchTemplateSpecificationRequest>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        pub fn overrides(
            mut self,
            input: impl Into<crate::model::FleetLaunchTemplateOverridesRequest>,
        ) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input.into());
            self.overrides = Some(v);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FleetLaunchTemplateOverridesRequest>,
            >,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateConfigRequest`](crate::model::FleetLaunchTemplateConfigRequest)
        pub fn build(self) -> crate::model::FleetLaunchTemplateConfigRequest {
            crate::model::FleetLaunchTemplateConfigRequest {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl FleetLaunchTemplateConfigRequest {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateConfigRequest`](crate::model::FleetLaunchTemplateConfigRequest)
    pub fn builder() -> crate::model::fleet_launch_template_config_request::Builder {
        crate::model::fleet_launch_template_config_request::Builder::default()
    }
}

/// <p>Describes overrides for a launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateOverridesRequest {
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
    pub max_price: std::option::Option<std::string::String>,
    /// <p>The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, <code>subnet-1234abcdeexample1, subnet-0987cdef6example2</code>). A request of type <code>instant</code> can have only one subnet ID.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which to launch the instances.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of units provided by the specified instance type.</p>
    pub weighted_capacity: std::option::Option<f64>,
    /// <p>The priority for the launch template override. The highest priority is launched
    /// first.</p>
    /// <p>If the On-Demand <code>AllocationStrategy</code> is set to <code>prioritized</code>,
    /// EC2 Fleet uses priority to determine which launch template override to use first in fulfilling
    /// On-Demand capacity.</p>
    /// <p>If the Spot <code>AllocationStrategy</code> is set to
    /// <code>capacity-optimized-prioritized</code>, EC2 Fleet uses priority on a best-effort basis
    /// to determine which launch template override to use in fulfilling Spot capacity, but
    /// optimizes for capacity first.</p>
    /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
    /// higher the priority. If no number is set, the launch template override has the lowest
    /// priority. You can set the same priority for different launch template overrides.</p>
    pub priority: std::option::Option<f64>,
    /// <p>The location where the instance launched, if applicable.</p>
    pub placement: std::option::Option<crate::model::Placement>,
}
impl std::fmt::Debug for FleetLaunchTemplateOverridesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateOverridesRequest");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("max_price", &self.max_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("priority", &self.priority);
        formatter.field("placement", &self.placement);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateOverridesRequest`](crate::model::FleetLaunchTemplateOverridesRequest)
pub mod fleet_launch_template_overrides_request {
    /// A builder for [`FleetLaunchTemplateOverridesRequest`](crate::model::FleetLaunchTemplateOverridesRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) max_price: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<f64>,
        pub(crate) priority: std::option::Option<f64>,
        pub(crate) placement: std::option::Option<crate::model::Placement>,
    }
    impl Builder {
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
        pub fn max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_price = Some(input.into());
            self
        }
        pub fn set_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_price = input;
            self
        }
        /// <p>The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, <code>subnet-1234abcdeexample1, subnet-0987cdef6example2</code>). A request of type <code>instant</code> can have only one subnet ID.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Availability Zone in which to launch the instances.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of units provided by the specified instance type.</p>
        pub fn weighted_capacity(mut self, input: f64) -> Self {
            self.weighted_capacity = Some(input);
            self
        }
        pub fn set_weighted_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// <p>The priority for the launch template override. The highest priority is launched
        /// first.</p>
        /// <p>If the On-Demand <code>AllocationStrategy</code> is set to <code>prioritized</code>,
        /// EC2 Fleet uses priority to determine which launch template override to use first in fulfilling
        /// On-Demand capacity.</p>
        /// <p>If the Spot <code>AllocationStrategy</code> is set to
        /// <code>capacity-optimized-prioritized</code>, EC2 Fleet uses priority on a best-effort basis
        /// to determine which launch template override to use in fulfilling Spot capacity, but
        /// optimizes for capacity first.</p>
        /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
        /// higher the priority. If no number is set, the launch template override has the lowest
        /// priority. You can set the same priority for different launch template overrides.</p>
        pub fn priority(mut self, input: f64) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<f64>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The location where the instance launched, if applicable.</p>
        pub fn placement(mut self, input: crate::model::Placement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::Placement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateOverridesRequest`](crate::model::FleetLaunchTemplateOverridesRequest)
        pub fn build(self) -> crate::model::FleetLaunchTemplateOverridesRequest {
            crate::model::FleetLaunchTemplateOverridesRequest {
                instance_type: self.instance_type,
                max_price: self.max_price,
                subnet_id: self.subnet_id,
                availability_zone: self.availability_zone,
                weighted_capacity: self.weighted_capacity,
                priority: self.priority,
                placement: self.placement,
            }
        }
    }
}
impl FleetLaunchTemplateOverridesRequest {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateOverridesRequest`](crate::model::FleetLaunchTemplateOverridesRequest)
    pub fn builder() -> crate::model::fleet_launch_template_overrides_request::Builder {
        crate::model::fleet_launch_template_overrides_request::Builder::default()
    }
}

/// <p>Describes the Amazon EC2 launch template and the launch template version that can be used by
/// an EC2 Fleet to configure Amazon EC2 instances. For information about launch templates, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html">Launching
/// an instance from a launch template</a> in the
/// <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateSpecificationRequest {
    /// <p>The ID of the launch template. If you specify the template ID, you can't specify the template name.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template. If you specify the template name, you can't specify the template ID.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The launch template version number, <code>$Latest</code>, or <code>$Default</code>. You must specify a value, otherwise the request fails.</p>
    /// <p>If the value is <code>$Latest</code>, Amazon EC2 uses the latest version of the launch template.</p>
    /// <p>If the value is <code>$Default</code>, Amazon EC2 uses the default version of the launch template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FleetLaunchTemplateSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateSpecificationRequest");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateSpecificationRequest`](crate::model::FleetLaunchTemplateSpecificationRequest)
pub mod fleet_launch_template_specification_request {
    /// A builder for [`FleetLaunchTemplateSpecificationRequest`](crate::model::FleetLaunchTemplateSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the launch template. If you specify the template ID, you can't specify the template name.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template. If you specify the template name, you can't specify the template ID.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The launch template version number, <code>$Latest</code>, or <code>$Default</code>. You must specify a value, otherwise the request fails.</p>
        /// <p>If the value is <code>$Latest</code>, Amazon EC2 uses the latest version of the launch template.</p>
        /// <p>If the value is <code>$Default</code>, Amazon EC2 uses the default version of the launch template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateSpecificationRequest`](crate::model::FleetLaunchTemplateSpecificationRequest)
        pub fn build(self) -> crate::model::FleetLaunchTemplateSpecificationRequest {
            crate::model::FleetLaunchTemplateSpecificationRequest {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version: self.version,
            }
        }
    }
}
impl FleetLaunchTemplateSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateSpecificationRequest`](crate::model::FleetLaunchTemplateSpecificationRequest)
    pub fn builder() -> crate::model::fleet_launch_template_specification_request::Builder {
        crate::model::fleet_launch_template_specification_request::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetExcessCapacityTerminationPolicy {
    NoTermination,
    Termination,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetExcessCapacityTerminationPolicy {
    fn from(s: &str) -> Self {
        match s {
            "no-termination" => FleetExcessCapacityTerminationPolicy::NoTermination,
            "termination" => FleetExcessCapacityTerminationPolicy::Termination,
            other => FleetExcessCapacityTerminationPolicy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetExcessCapacityTerminationPolicy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetExcessCapacityTerminationPolicy::from(s))
    }
}
impl FleetExcessCapacityTerminationPolicy {
    pub fn as_str(&self) -> &str {
        match self {
            FleetExcessCapacityTerminationPolicy::NoTermination => "no-termination",
            FleetExcessCapacityTerminationPolicy::Termination => "termination",
            FleetExcessCapacityTerminationPolicy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["no-termination", "termination"]
    }
}
impl AsRef<str> for FleetExcessCapacityTerminationPolicy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the default credit option for CPU usage of a burstable performance instance family.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceFamilyCreditSpecification {
    /// <p>The instance family.</p>
    pub instance_family: std::option::Option<crate::model::UnlimitedSupportedInstanceFamily>,
    /// <p>The default credit option for CPU usage of the instance family. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
    pub cpu_credits: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceFamilyCreditSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceFamilyCreditSpecification");
        formatter.field("instance_family", &self.instance_family);
        formatter.field("cpu_credits", &self.cpu_credits);
        formatter.finish()
    }
}
/// See [`InstanceFamilyCreditSpecification`](crate::model::InstanceFamilyCreditSpecification)
pub mod instance_family_credit_specification {
    /// A builder for [`InstanceFamilyCreditSpecification`](crate::model::InstanceFamilyCreditSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_family:
            std::option::Option<crate::model::UnlimitedSupportedInstanceFamily>,
        pub(crate) cpu_credits: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The instance family.</p>
        pub fn instance_family(
            mut self,
            input: crate::model::UnlimitedSupportedInstanceFamily,
        ) -> Self {
            self.instance_family = Some(input);
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<crate::model::UnlimitedSupportedInstanceFamily>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The default credit option for CPU usage of the instance family. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_credits = Some(input.into());
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu_credits = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceFamilyCreditSpecification`](crate::model::InstanceFamilyCreditSpecification)
        pub fn build(self) -> crate::model::InstanceFamilyCreditSpecification {
            crate::model::InstanceFamilyCreditSpecification {
                instance_family: self.instance_family,
                cpu_credits: self.cpu_credits,
            }
        }
    }
}
impl InstanceFamilyCreditSpecification {
    /// Creates a new builder-style object to manufacture [`InstanceFamilyCreditSpecification`](crate::model::InstanceFamilyCreditSpecification)
    pub fn builder() -> crate::model::instance_family_credit_specification::Builder {
        crate::model::instance_family_credit_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UnlimitedSupportedInstanceFamily {
    T2,
    T3,
    T3a,
    T4g,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UnlimitedSupportedInstanceFamily {
    fn from(s: &str) -> Self {
        match s {
            "t2" => UnlimitedSupportedInstanceFamily::T2,
            "t3" => UnlimitedSupportedInstanceFamily::T3,
            "t3a" => UnlimitedSupportedInstanceFamily::T3a,
            "t4g" => UnlimitedSupportedInstanceFamily::T4g,
            other => UnlimitedSupportedInstanceFamily::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UnlimitedSupportedInstanceFamily {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UnlimitedSupportedInstanceFamily::from(s))
    }
}
impl UnlimitedSupportedInstanceFamily {
    pub fn as_str(&self) -> &str {
        match self {
            UnlimitedSupportedInstanceFamily::T2 => "t2",
            UnlimitedSupportedInstanceFamily::T3 => "t3",
            UnlimitedSupportedInstanceFamily::T3a => "t3a",
            UnlimitedSupportedInstanceFamily::T4g => "t4g",
            UnlimitedSupportedInstanceFamily::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["t2", "t3", "t3a", "t4g"]
    }
}
impl AsRef<str> for UnlimitedSupportedInstanceFamily {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The options for managing connection authorization for new client connections.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientConnectOptions {
    /// <p>Indicates whether client connect options are enabled. The default is <code>false</code> (not enabled).</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.</p>
    pub lambda_function_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientConnectOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientConnectOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("lambda_function_arn", &self.lambda_function_arn);
        formatter.finish()
    }
}
/// See [`ClientConnectOptions`](crate::model::ClientConnectOptions)
pub mod client_connect_options {
    /// A builder for [`ClientConnectOptions`](crate::model::ClientConnectOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) lambda_function_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether client connect options are enabled. The default is <code>false</code> (not enabled).</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.</p>
        pub fn lambda_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_function_arn = Some(input.into());
            self
        }
        pub fn set_lambda_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lambda_function_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientConnectOptions`](crate::model::ClientConnectOptions)
        pub fn build(self) -> crate::model::ClientConnectOptions {
            crate::model::ClientConnectOptions {
                enabled: self.enabled,
                lambda_function_arn: self.lambda_function_arn,
            }
        }
    }
}
impl ClientConnectOptions {
    /// Creates a new builder-style object to manufacture [`ClientConnectOptions`](crate::model::ClientConnectOptions)
    pub fn builder() -> crate::model::client_connect_options::Builder {
        crate::model::client_connect_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SelfServicePortal {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SelfServicePortal {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => SelfServicePortal::Disabled,
            "enabled" => SelfServicePortal::Enabled,
            other => SelfServicePortal::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SelfServicePortal {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SelfServicePortal::from(s))
    }
}
impl SelfServicePortal {
    pub fn as_str(&self) -> &str {
        match self {
            SelfServicePortal::Disabled => "disabled",
            SelfServicePortal::Enabled => "enabled",
            SelfServicePortal::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for SelfServicePortal {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the DNS server to be used.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsServersOptionsModifyStructure {
    /// <p>The IPv4 address range, in CIDR notation, of the DNS servers to be used. You can specify up to
    /// two DNS servers. Ensure that the DNS servers can be reached by the clients. The specified values
    /// overwrite the existing values.</p>
    pub custom_dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether DNS servers should be used. Specify <code>False</code> to delete the existing DNS
    /// servers.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for DnsServersOptionsModifyStructure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsServersOptionsModifyStructure");
        formatter.field("custom_dns_servers", &self.custom_dns_servers);
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`DnsServersOptionsModifyStructure`](crate::model::DnsServersOptionsModifyStructure)
pub mod dns_servers_options_modify_structure {
    /// A builder for [`DnsServersOptionsModifyStructure`](crate::model::DnsServersOptionsModifyStructure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        pub fn custom_dns_servers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.custom_dns_servers.unwrap_or_default();
            v.push(input.into());
            self.custom_dns_servers = Some(v);
            self
        }
        pub fn set_custom_dns_servers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.custom_dns_servers = input;
            self
        }
        /// <p>Indicates whether DNS servers should be used. Specify <code>False</code> to delete the existing DNS
        /// servers.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsServersOptionsModifyStructure`](crate::model::DnsServersOptionsModifyStructure)
        pub fn build(self) -> crate::model::DnsServersOptionsModifyStructure {
            crate::model::DnsServersOptionsModifyStructure {
                custom_dns_servers: self.custom_dns_servers,
                enabled: self.enabled,
            }
        }
    }
}
impl DnsServersOptionsModifyStructure {
    /// Creates a new builder-style object to manufacture [`DnsServersOptionsModifyStructure`](crate::model::DnsServersOptionsModifyStructure)
    pub fn builder() -> crate::model::dns_servers_options_modify_structure::Builder {
        crate::model::dns_servers_options_modify_structure::Builder::default()
    }
}

/// <p>Describes the client connection logging options for the Client VPN endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConnectionLogOptions {
    /// <p>Indicates whether connection logging is enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The name of the CloudWatch Logs log group. Required if connection logging is enabled.</p>
    pub cloudwatch_log_group: std::option::Option<std::string::String>,
    /// <p>The name of the CloudWatch Logs log stream to which the connection data is published.</p>
    pub cloudwatch_log_stream: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConnectionLogOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConnectionLogOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("cloudwatch_log_group", &self.cloudwatch_log_group);
        formatter.field("cloudwatch_log_stream", &self.cloudwatch_log_stream);
        formatter.finish()
    }
}
/// See [`ConnectionLogOptions`](crate::model::ConnectionLogOptions)
pub mod connection_log_options {
    /// A builder for [`ConnectionLogOptions`](crate::model::ConnectionLogOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) cloudwatch_log_group: std::option::Option<std::string::String>,
        pub(crate) cloudwatch_log_stream: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether connection logging is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The name of the CloudWatch Logs log group. Required if connection logging is enabled.</p>
        pub fn cloudwatch_log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloudwatch_log_group = Some(input.into());
            self
        }
        pub fn set_cloudwatch_log_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloudwatch_log_group = input;
            self
        }
        /// <p>The name of the CloudWatch Logs log stream to which the connection data is published.</p>
        pub fn cloudwatch_log_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloudwatch_log_stream = Some(input.into());
            self
        }
        pub fn set_cloudwatch_log_stream(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloudwatch_log_stream = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionLogOptions`](crate::model::ConnectionLogOptions)
        pub fn build(self) -> crate::model::ConnectionLogOptions {
            crate::model::ConnectionLogOptions {
                enabled: self.enabled,
                cloudwatch_log_group: self.cloudwatch_log_group,
                cloudwatch_log_stream: self.cloudwatch_log_stream,
            }
        }
    }
}
impl ConnectionLogOptions {
    /// Creates a new builder-style object to manufacture [`ConnectionLogOptions`](crate::model::ConnectionLogOptions)
    pub fn builder() -> crate::model::connection_log_options::Builder {
        crate::model::connection_log_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndDateType {
    Limited,
    Unlimited,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndDateType {
    fn from(s: &str) -> Self {
        match s {
            "limited" => EndDateType::Limited,
            "unlimited" => EndDateType::Unlimited,
            other => EndDateType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndDateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndDateType::from(s))
    }
}
impl EndDateType {
    pub fn as_str(&self) -> &str {
        match self {
            EndDateType::Limited => "limited",
            EndDateType::Unlimited => "unlimited",
            EndDateType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["limited", "unlimited"]
    }
}
impl AsRef<str> for EndDateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModifyAvailabilityZoneOptInStatus {
    NotOptedIn,
    OptedIn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModifyAvailabilityZoneOptInStatus {
    fn from(s: &str) -> Self {
        match s {
            "not-opted-in" => ModifyAvailabilityZoneOptInStatus::NotOptedIn,
            "opted-in" => ModifyAvailabilityZoneOptInStatus::OptedIn,
            other => ModifyAvailabilityZoneOptInStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModifyAvailabilityZoneOptInStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModifyAvailabilityZoneOptInStatus::from(s))
    }
}
impl ModifyAvailabilityZoneOptInStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ModifyAvailabilityZoneOptInStatus::NotOptedIn => "not-opted-in",
            ModifyAvailabilityZoneOptInStatus::OptedIn => "opted-in",
            ModifyAvailabilityZoneOptInStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["not-opted-in", "opted-in"]
    }
}
impl AsRef<str> for ModifyAvailabilityZoneOptInStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a conversion task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConversionTask {
    /// <p>The ID of the conversion task.</p>
    pub conversion_task_id: std::option::Option<std::string::String>,
    /// <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel
    /// the task.</p>
    pub expiration_time: std::option::Option<std::string::String>,
    /// <p>If the task is for importing an instance, this contains information about the import instance task.</p>
    pub import_instance: std::option::Option<crate::model::ImportInstanceTaskDetails>,
    /// <p>If the task is for importing a volume, this contains information about the import volume task.</p>
    pub import_volume: std::option::Option<crate::model::ImportVolumeTaskDetails>,
    /// <p>The state of the conversion task.</p>
    pub state: std::option::Option<crate::model::ConversionTaskState>,
    /// <p>The status message related to the conversion task.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ConversionTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConversionTask");
        formatter.field("conversion_task_id", &self.conversion_task_id);
        formatter.field("expiration_time", &self.expiration_time);
        formatter.field("import_instance", &self.import_instance);
        formatter.field("import_volume", &self.import_volume);
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ConversionTask`](crate::model::ConversionTask)
pub mod conversion_task {
    /// A builder for [`ConversionTask`](crate::model::ConversionTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conversion_task_id: std::option::Option<std::string::String>,
        pub(crate) expiration_time: std::option::Option<std::string::String>,
        pub(crate) import_instance: std::option::Option<crate::model::ImportInstanceTaskDetails>,
        pub(crate) import_volume: std::option::Option<crate::model::ImportVolumeTaskDetails>,
        pub(crate) state: std::option::Option<crate::model::ConversionTaskState>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the conversion task.</p>
        pub fn conversion_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conversion_task_id = Some(input.into());
            self
        }
        pub fn set_conversion_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conversion_task_id = input;
            self
        }
        /// <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel
        /// the task.</p>
        pub fn expiration_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiration_time = Some(input.into());
            self
        }
        pub fn set_expiration_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expiration_time = input;
            self
        }
        /// <p>If the task is for importing an instance, this contains information about the import instance task.</p>
        pub fn import_instance(mut self, input: crate::model::ImportInstanceTaskDetails) -> Self {
            self.import_instance = Some(input);
            self
        }
        pub fn set_import_instance(
            mut self,
            input: std::option::Option<crate::model::ImportInstanceTaskDetails>,
        ) -> Self {
            self.import_instance = input;
            self
        }
        /// <p>If the task is for importing a volume, this contains information about the import volume task.</p>
        pub fn import_volume(mut self, input: crate::model::ImportVolumeTaskDetails) -> Self {
            self.import_volume = Some(input);
            self
        }
        pub fn set_import_volume(
            mut self,
            input: std::option::Option<crate::model::ImportVolumeTaskDetails>,
        ) -> Self {
            self.import_volume = input;
            self
        }
        /// <p>The state of the conversion task.</p>
        pub fn state(mut self, input: crate::model::ConversionTaskState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ConversionTaskState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status message related to the conversion task.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ConversionTask`](crate::model::ConversionTask)
        pub fn build(self) -> crate::model::ConversionTask {
            crate::model::ConversionTask {
                conversion_task_id: self.conversion_task_id,
                expiration_time: self.expiration_time,
                import_instance: self.import_instance,
                import_volume: self.import_volume,
                state: self.state,
                status_message: self.status_message,
                tags: self.tags,
            }
        }
    }
}
impl ConversionTask {
    /// Creates a new builder-style object to manufacture [`ConversionTask`](crate::model::ConversionTask)
    pub fn builder() -> crate::model::conversion_task::Builder {
        crate::model::conversion_task::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConversionTaskState {
    Active,
    Cancelled,
    Cancelling,
    Completed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConversionTaskState {
    fn from(s: &str) -> Self {
        match s {
            "active" => ConversionTaskState::Active,
            "cancelled" => ConversionTaskState::Cancelled,
            "cancelling" => ConversionTaskState::Cancelling,
            "completed" => ConversionTaskState::Completed,
            other => ConversionTaskState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConversionTaskState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConversionTaskState::from(s))
    }
}
impl ConversionTaskState {
    pub fn as_str(&self) -> &str {
        match self {
            ConversionTaskState::Active => "active",
            ConversionTaskState::Cancelled => "cancelled",
            ConversionTaskState::Cancelling => "cancelling",
            ConversionTaskState::Completed => "completed",
            ConversionTaskState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "cancelling", "completed"]
    }
}
impl AsRef<str> for ConversionTaskState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an import volume task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportVolumeTaskDetails {
    /// <p>The Availability Zone where the resulting volume will reside.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of bytes converted so far.</p>
    pub bytes_converted: std::option::Option<i64>,
    /// <p>The description you provided when starting the import volume task.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The image.</p>
    pub image: std::option::Option<crate::model::DiskImageDescription>,
    /// <p>The volume.</p>
    pub volume: std::option::Option<crate::model::DiskImageVolumeDescription>,
}
impl std::fmt::Debug for ImportVolumeTaskDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportVolumeTaskDetails");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("bytes_converted", &self.bytes_converted);
        formatter.field("description", &self.description);
        formatter.field("image", &self.image);
        formatter.field("volume", &self.volume);
        formatter.finish()
    }
}
/// See [`ImportVolumeTaskDetails`](crate::model::ImportVolumeTaskDetails)
pub mod import_volume_task_details {
    /// A builder for [`ImportVolumeTaskDetails`](crate::model::ImportVolumeTaskDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) bytes_converted: std::option::Option<i64>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::DiskImageDescription>,
        pub(crate) volume: std::option::Option<crate::model::DiskImageVolumeDescription>,
    }
    impl Builder {
        /// <p>The Availability Zone where the resulting volume will reside.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of bytes converted so far.</p>
        pub fn bytes_converted(mut self, input: i64) -> Self {
            self.bytes_converted = Some(input);
            self
        }
        pub fn set_bytes_converted(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes_converted = input;
            self
        }
        /// <p>The description you provided when starting the import volume task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The image.</p>
        pub fn image(mut self, input: crate::model::DiskImageDescription) -> Self {
            self.image = Some(input);
            self
        }
        pub fn set_image(
            mut self,
            input: std::option::Option<crate::model::DiskImageDescription>,
        ) -> Self {
            self.image = input;
            self
        }
        /// <p>The volume.</p>
        pub fn volume(mut self, input: crate::model::DiskImageVolumeDescription) -> Self {
            self.volume = Some(input);
            self
        }
        pub fn set_volume(
            mut self,
            input: std::option::Option<crate::model::DiskImageVolumeDescription>,
        ) -> Self {
            self.volume = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportVolumeTaskDetails`](crate::model::ImportVolumeTaskDetails)
        pub fn build(self) -> crate::model::ImportVolumeTaskDetails {
            crate::model::ImportVolumeTaskDetails {
                availability_zone: self.availability_zone,
                bytes_converted: self.bytes_converted,
                description: self.description,
                image: self.image,
                volume: self.volume,
            }
        }
    }
}
impl ImportVolumeTaskDetails {
    /// Creates a new builder-style object to manufacture [`ImportVolumeTaskDetails`](crate::model::ImportVolumeTaskDetails)
    pub fn builder() -> crate::model::import_volume_task_details::Builder {
        crate::model::import_volume_task_details::Builder::default()
    }
}

/// <p>Describes a disk image volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskImageVolumeDescription {
    /// <p>The volume identifier.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiB.</p>
    pub size: std::option::Option<i64>,
}
impl std::fmt::Debug for DiskImageVolumeDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskImageVolumeDescription");
        formatter.field("id", &self.id);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`DiskImageVolumeDescription`](crate::model::DiskImageVolumeDescription)
pub mod disk_image_volume_description {
    /// A builder for [`DiskImageVolumeDescription`](crate::model::DiskImageVolumeDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The volume identifier.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The size of the volume, in GiB.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskImageVolumeDescription`](crate::model::DiskImageVolumeDescription)
        pub fn build(self) -> crate::model::DiskImageVolumeDescription {
            crate::model::DiskImageVolumeDescription {
                id: self.id,
                size: self.size,
            }
        }
    }
}
impl DiskImageVolumeDescription {
    /// Creates a new builder-style object to manufacture [`DiskImageVolumeDescription`](crate::model::DiskImageVolumeDescription)
    pub fn builder() -> crate::model::disk_image_volume_description::Builder {
        crate::model::disk_image_volume_description::Builder::default()
    }
}

/// <p>Describes a disk image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskImageDescription {
    /// <p>The checksum computed for the disk image.</p>
    pub checksum: std::option::Option<std::string::String>,
    /// <p>The disk image format.</p>
    pub format: std::option::Option<crate::model::DiskImageFormat>,
    /// <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for
    /// an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in
    /// the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    /// <p>For information about the import manifest referenced by this API action, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
    pub import_manifest_url: std::option::Option<std::string::String>,
    /// <p>The size of the disk image, in GiB.</p>
    pub size: std::option::Option<i64>,
}
impl std::fmt::Debug for DiskImageDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskImageDescription");
        formatter.field("checksum", &self.checksum);
        formatter.field("format", &self.format);
        formatter.field("import_manifest_url", &self.import_manifest_url);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`DiskImageDescription`](crate::model::DiskImageDescription)
pub mod disk_image_description {
    /// A builder for [`DiskImageDescription`](crate::model::DiskImageDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) checksum: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::DiskImageFormat>,
        pub(crate) import_manifest_url: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The checksum computed for the disk image.</p>
        pub fn checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.checksum = Some(input.into());
            self
        }
        pub fn set_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.checksum = input;
            self
        }
        /// <p>The disk image format.</p>
        pub fn format(mut self, input: crate::model::DiskImageFormat) -> Self {
            self.format = Some(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::DiskImageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for
        /// an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in
        /// the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
        /// <p>For information about the import manifest referenced by this API action, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
        pub fn import_manifest_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_manifest_url = Some(input.into());
            self
        }
        pub fn set_import_manifest_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.import_manifest_url = input;
            self
        }
        /// <p>The size of the disk image, in GiB.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskImageDescription`](crate::model::DiskImageDescription)
        pub fn build(self) -> crate::model::DiskImageDescription {
            crate::model::DiskImageDescription {
                checksum: self.checksum,
                format: self.format,
                import_manifest_url: self.import_manifest_url,
                size: self.size,
            }
        }
    }
}
impl DiskImageDescription {
    /// Creates a new builder-style object to manufacture [`DiskImageDescription`](crate::model::DiskImageDescription)
    pub fn builder() -> crate::model::disk_image_description::Builder {
        crate::model::disk_image_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DiskImageFormat {
    Raw,
    Vhd,
    Vmdk,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DiskImageFormat {
    fn from(s: &str) -> Self {
        match s {
            "RAW" => DiskImageFormat::Raw,
            "VHD" => DiskImageFormat::Vhd,
            "VMDK" => DiskImageFormat::Vmdk,
            other => DiskImageFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DiskImageFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DiskImageFormat::from(s))
    }
}
impl DiskImageFormat {
    pub fn as_str(&self) -> &str {
        match self {
            DiskImageFormat::Raw => "RAW",
            DiskImageFormat::Vhd => "VHD",
            DiskImageFormat::Vmdk => "VMDK",
            DiskImageFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["RAW", "VHD", "VMDK"]
    }
}
impl AsRef<str> for DiskImageFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an import instance task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportInstanceTaskDetails {
    /// <p>A description of the task.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance operating system.</p>
    pub platform: std::option::Option<crate::model::PlatformValues>,
    /// <p>The volumes.</p>
    pub volumes: std::option::Option<std::vec::Vec<crate::model::ImportInstanceVolumeDetailItem>>,
}
impl std::fmt::Debug for ImportInstanceTaskDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportInstanceTaskDetails");
        formatter.field("description", &self.description);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("platform", &self.platform);
        formatter.field("volumes", &self.volumes);
        formatter.finish()
    }
}
/// See [`ImportInstanceTaskDetails`](crate::model::ImportInstanceTaskDetails)
pub mod import_instance_task_details {
    /// A builder for [`ImportInstanceTaskDetails`](crate::model::ImportInstanceTaskDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::PlatformValues>,
        pub(crate) volumes:
            std::option::Option<std::vec::Vec<crate::model::ImportInstanceVolumeDetailItem>>,
    }
    impl Builder {
        /// <p>A description of the task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance operating system.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.platform = input;
            self
        }
        pub fn volumes(
            mut self,
            input: impl Into<crate::model::ImportInstanceVolumeDetailItem>,
        ) -> Self {
            let mut v = self.volumes.unwrap_or_default();
            v.push(input.into());
            self.volumes = Some(v);
            self
        }
        pub fn set_volumes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ImportInstanceVolumeDetailItem>>,
        ) -> Self {
            self.volumes = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportInstanceTaskDetails`](crate::model::ImportInstanceTaskDetails)
        pub fn build(self) -> crate::model::ImportInstanceTaskDetails {
            crate::model::ImportInstanceTaskDetails {
                description: self.description,
                instance_id: self.instance_id,
                platform: self.platform,
                volumes: self.volumes,
            }
        }
    }
}
impl ImportInstanceTaskDetails {
    /// Creates a new builder-style object to manufacture [`ImportInstanceTaskDetails`](crate::model::ImportInstanceTaskDetails)
    pub fn builder() -> crate::model::import_instance_task_details::Builder {
        crate::model::import_instance_task_details::Builder::default()
    }
}

/// <p>Describes an import volume task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportInstanceVolumeDetailItem {
    /// <p>The Availability Zone where the resulting instance will reside.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of bytes converted so far.</p>
    pub bytes_converted: std::option::Option<i64>,
    /// <p>A description of the task.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The image.</p>
    pub image: std::option::Option<crate::model::DiskImageDescription>,
    /// <p>The status of the import of this particular disk image.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The status information or errors related to the disk image.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The volume.</p>
    pub volume: std::option::Option<crate::model::DiskImageVolumeDescription>,
}
impl std::fmt::Debug for ImportInstanceVolumeDetailItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportInstanceVolumeDetailItem");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("bytes_converted", &self.bytes_converted);
        formatter.field("description", &self.description);
        formatter.field("image", &self.image);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("volume", &self.volume);
        formatter.finish()
    }
}
/// See [`ImportInstanceVolumeDetailItem`](crate::model::ImportInstanceVolumeDetailItem)
pub mod import_instance_volume_detail_item {
    /// A builder for [`ImportInstanceVolumeDetailItem`](crate::model::ImportInstanceVolumeDetailItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) bytes_converted: std::option::Option<i64>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::DiskImageDescription>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) volume: std::option::Option<crate::model::DiskImageVolumeDescription>,
    }
    impl Builder {
        /// <p>The Availability Zone where the resulting instance will reside.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of bytes converted so far.</p>
        pub fn bytes_converted(mut self, input: i64) -> Self {
            self.bytes_converted = Some(input);
            self
        }
        pub fn set_bytes_converted(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes_converted = input;
            self
        }
        /// <p>A description of the task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The image.</p>
        pub fn image(mut self, input: crate::model::DiskImageDescription) -> Self {
            self.image = Some(input);
            self
        }
        pub fn set_image(
            mut self,
            input: std::option::Option<crate::model::DiskImageDescription>,
        ) -> Self {
            self.image = input;
            self
        }
        /// <p>The status of the import of this particular disk image.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The status information or errors related to the disk image.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The volume.</p>
        pub fn volume(mut self, input: crate::model::DiskImageVolumeDescription) -> Self {
            self.volume = Some(input);
            self
        }
        pub fn set_volume(
            mut self,
            input: std::option::Option<crate::model::DiskImageVolumeDescription>,
        ) -> Self {
            self.volume = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportInstanceVolumeDetailItem`](crate::model::ImportInstanceVolumeDetailItem)
        pub fn build(self) -> crate::model::ImportInstanceVolumeDetailItem {
            crate::model::ImportInstanceVolumeDetailItem {
                availability_zone: self.availability_zone,
                bytes_converted: self.bytes_converted,
                description: self.description,
                image: self.image,
                status: self.status,
                status_message: self.status_message,
                volume: self.volume,
            }
        }
    }
}
impl ImportInstanceVolumeDetailItem {
    /// Creates a new builder-style object to manufacture [`ImportInstanceVolumeDetailItem`](crate::model::ImportInstanceVolumeDetailItem)
    pub fn builder() -> crate::model::import_instance_volume_detail_item::Builder {
        crate::model::import_instance_volume_detail_item::Builder::default()
    }
}

/// <p>Describes an EBS volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeDetail {
    /// <p>The size of the volume, in GiB.</p>
    pub size: std::option::Option<i64>,
}
impl std::fmt::Debug for VolumeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeDetail");
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`VolumeDetail`](crate::model::VolumeDetail)
pub mod volume_detail {
    /// A builder for [`VolumeDetail`](crate::model::VolumeDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The size of the volume, in GiB.</p>
        pub fn size(mut self, input: i64) -> Self {
            self.size = Some(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i64>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeDetail`](crate::model::VolumeDetail)
        pub fn build(self) -> crate::model::VolumeDetail {
            crate::model::VolumeDetail { size: self.size }
        }
    }
}
impl VolumeDetail {
    /// Creates a new builder-style object to manufacture [`VolumeDetail`](crate::model::VolumeDetail)
    pub fn builder() -> crate::model::volume_detail::Builder {
        crate::model::volume_detail::Builder::default()
    }
}

/// <p>Describes a disk image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskImageDetail {
    /// <p>The size of the disk image, in GiB.</p>
    pub bytes: std::option::Option<i64>,
    /// <p>The disk image format.</p>
    pub format: std::option::Option<crate::model::DiskImageFormat>,
    /// <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL.
    /// For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication
    /// Alternative" section of the <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer
    /// Guide</i>.</p>
    /// <p>For information about the import manifest referenced by this API action, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
    pub import_manifest_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DiskImageDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskImageDetail");
        formatter.field("bytes", &self.bytes);
        formatter.field("format", &self.format);
        formatter.field("import_manifest_url", &self.import_manifest_url);
        formatter.finish()
    }
}
/// See [`DiskImageDetail`](crate::model::DiskImageDetail)
pub mod disk_image_detail {
    /// A builder for [`DiskImageDetail`](crate::model::DiskImageDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bytes: std::option::Option<i64>,
        pub(crate) format: std::option::Option<crate::model::DiskImageFormat>,
        pub(crate) import_manifest_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The size of the disk image, in GiB.</p>
        pub fn bytes(mut self, input: i64) -> Self {
            self.bytes = Some(input);
            self
        }
        pub fn set_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes = input;
            self
        }
        /// <p>The disk image format.</p>
        pub fn format(mut self, input: crate::model::DiskImageFormat) -> Self {
            self.format = Some(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::DiskImageFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL.
        /// For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication
        /// Alternative" section of the <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer
        /// Guide</i>.</p>
        /// <p>For information about the import manifest referenced by this API action, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
        pub fn import_manifest_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_manifest_url = Some(input.into());
            self
        }
        pub fn set_import_manifest_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.import_manifest_url = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskImageDetail`](crate::model::DiskImageDetail)
        pub fn build(self) -> crate::model::DiskImageDetail {
            crate::model::DiskImageDetail {
                bytes: self.bytes,
                format: self.format,
                import_manifest_url: self.import_manifest_url,
            }
        }
    }
}
impl DiskImageDetail {
    /// Creates a new builder-style object to manufacture [`DiskImageDetail`](crate::model::DiskImageDetail)
    pub fn builder() -> crate::model::disk_image_detail::Builder {
        crate::model::disk_image_detail::Builder::default()
    }
}

/// <p>Details about the import snapshot task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotTaskDetail {
    /// <p>The description of the snapshot.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The size of the disk in the snapshot, in GiB.</p>
    pub disk_image_size: std::option::Option<f64>,
    /// <p>Indicates whether the snapshot is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The format of the disk image from which the snapshot is created.</p>
    pub format: std::option::Option<std::string::String>,
    /// <p>The identifier for the KMS key that was used to create the encrypted snapshot.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The percentage of completion for the import snapshot task.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>The snapshot ID of the disk being imported.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>A brief status for the import snapshot task.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>A detailed status message for the import snapshot task.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The URL of the disk image from which the snapshot is created.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket for the disk image.</p>
    pub user_bucket: std::option::Option<crate::model::UserBucketDetails>,
}
impl std::fmt::Debug for SnapshotTaskDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotTaskDetail");
        formatter.field("description", &self.description);
        formatter.field("disk_image_size", &self.disk_image_size);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("format", &self.format);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("progress", &self.progress);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("url", &self.url);
        formatter.field("user_bucket", &self.user_bucket);
        formatter.finish()
    }
}
/// See [`SnapshotTaskDetail`](crate::model::SnapshotTaskDetail)
pub mod snapshot_task_detail {
    /// A builder for [`SnapshotTaskDetail`](crate::model::SnapshotTaskDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) disk_image_size: std::option::Option<f64>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) user_bucket: std::option::Option<crate::model::UserBucketDetails>,
    }
    impl Builder {
        /// <p>The description of the snapshot.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The size of the disk in the snapshot, in GiB.</p>
        pub fn disk_image_size(mut self, input: f64) -> Self {
            self.disk_image_size = Some(input);
            self
        }
        pub fn set_disk_image_size(mut self, input: std::option::Option<f64>) -> Self {
            self.disk_image_size = input;
            self
        }
        /// <p>Indicates whether the snapshot is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The format of the disk image from which the snapshot is created.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The identifier for the KMS key that was used to create the encrypted snapshot.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The percentage of completion for the import snapshot task.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The snapshot ID of the disk being imported.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>A brief status for the import snapshot task.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status message for the import snapshot task.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The URL of the disk image from which the snapshot is created.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The Amazon S3 bucket for the disk image.</p>
        pub fn user_bucket(mut self, input: crate::model::UserBucketDetails) -> Self {
            self.user_bucket = Some(input);
            self
        }
        pub fn set_user_bucket(
            mut self,
            input: std::option::Option<crate::model::UserBucketDetails>,
        ) -> Self {
            self.user_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotTaskDetail`](crate::model::SnapshotTaskDetail)
        pub fn build(self) -> crate::model::SnapshotTaskDetail {
            crate::model::SnapshotTaskDetail {
                description: self.description,
                disk_image_size: self.disk_image_size,
                encrypted: self.encrypted,
                format: self.format,
                kms_key_id: self.kms_key_id,
                progress: self.progress,
                snapshot_id: self.snapshot_id,
                status: self.status,
                status_message: self.status_message,
                url: self.url,
                user_bucket: self.user_bucket,
            }
        }
    }
}
impl SnapshotTaskDetail {
    /// Creates a new builder-style object to manufacture [`SnapshotTaskDetail`](crate::model::SnapshotTaskDetail)
    pub fn builder() -> crate::model::snapshot_task_detail::Builder {
        crate::model::snapshot_task_detail::Builder::default()
    }
}

/// <p>Describes the Amazon S3 bucket for the disk image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserBucketDetails {
    /// <p>The Amazon S3 bucket from which the disk image was created.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The file name of the disk image.</p>
    pub s3_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserBucketDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserBucketDetails");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.finish()
    }
}
/// See [`UserBucketDetails`](crate::model::UserBucketDetails)
pub mod user_bucket_details {
    /// A builder for [`UserBucketDetails`](crate::model::UserBucketDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket from which the disk image was created.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The file name of the disk image.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`UserBucketDetails`](crate::model::UserBucketDetails)
        pub fn build(self) -> crate::model::UserBucketDetails {
            crate::model::UserBucketDetails {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
            }
        }
    }
}
impl UserBucketDetails {
    /// Creates a new builder-style object to manufacture [`UserBucketDetails`](crate::model::UserBucketDetails)
    pub fn builder() -> crate::model::user_bucket_details::Builder {
        crate::model::user_bucket_details::Builder::default()
    }
}

/// <p>The disk container object for the import snapshot request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotDiskContainer {
    /// <p>The description of the disk image being imported.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The format of the disk image being imported.</p>
    /// <p>Valid values: <code>VHD</code> | <code>VMDK</code> | <code>RAW</code>
    /// </p>
    pub format: std::option::Option<std::string::String>,
    /// <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon
    /// S3 URL (s3://..).</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket for the disk image.</p>
    pub user_bucket: std::option::Option<crate::model::UserBucket>,
}
impl std::fmt::Debug for SnapshotDiskContainer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotDiskContainer");
        formatter.field("description", &self.description);
        formatter.field("format", &self.format);
        formatter.field("url", &self.url);
        formatter.field("user_bucket", &self.user_bucket);
        formatter.finish()
    }
}
/// See [`SnapshotDiskContainer`](crate::model::SnapshotDiskContainer)
pub mod snapshot_disk_container {
    /// A builder for [`SnapshotDiskContainer`](crate::model::SnapshotDiskContainer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) user_bucket: std::option::Option<crate::model::UserBucket>,
    }
    impl Builder {
        /// <p>The description of the disk image being imported.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The format of the disk image being imported.</p>
        /// <p>Valid values: <code>VHD</code> | <code>VMDK</code> | <code>RAW</code>
        /// </p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon
        /// S3 URL (s3://..).</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The Amazon S3 bucket for the disk image.</p>
        pub fn user_bucket(mut self, input: crate::model::UserBucket) -> Self {
            self.user_bucket = Some(input);
            self
        }
        pub fn set_user_bucket(
            mut self,
            input: std::option::Option<crate::model::UserBucket>,
        ) -> Self {
            self.user_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotDiskContainer`](crate::model::SnapshotDiskContainer)
        pub fn build(self) -> crate::model::SnapshotDiskContainer {
            crate::model::SnapshotDiskContainer {
                description: self.description,
                format: self.format,
                url: self.url,
                user_bucket: self.user_bucket,
            }
        }
    }
}
impl SnapshotDiskContainer {
    /// Creates a new builder-style object to manufacture [`SnapshotDiskContainer`](crate::model::SnapshotDiskContainer)
    pub fn builder() -> crate::model::snapshot_disk_container::Builder {
        crate::model::snapshot_disk_container::Builder::default()
    }
}

/// <p>Describes the Amazon S3 bucket for the disk image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserBucket {
    /// <p>The name of the Amazon S3 bucket where the disk image is located.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The file name of the disk image.</p>
    pub s3_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserBucket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserBucket");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.finish()
    }
}
/// See [`UserBucket`](crate::model::UserBucket)
pub mod user_bucket {
    /// A builder for [`UserBucket`](crate::model::UserBucket)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket where the disk image is located.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The file name of the disk image.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`UserBucket`](crate::model::UserBucket)
        pub fn build(self) -> crate::model::UserBucket {
            crate::model::UserBucket {
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
            }
        }
    }
}
impl UserBucket {
    /// Creates a new builder-style object to manufacture [`UserBucket`](crate::model::UserBucket)
    pub fn builder() -> crate::model::user_bucket::Builder {
        crate::model::user_bucket::Builder::default()
    }
}

/// <p>Describes the client-specific data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientData {
    /// <p>A user-defined comment about the disk upload.</p>
    pub comment: std::option::Option<std::string::String>,
    /// <p>The time that the disk upload ends.</p>
    pub upload_end: std::option::Option<smithy_types::Instant>,
    /// <p>The size of the uploaded disk image, in GiB.</p>
    pub upload_size: std::option::Option<f64>,
    /// <p>The time that the disk upload starts.</p>
    pub upload_start: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ClientData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientData");
        formatter.field("comment", &self.comment);
        formatter.field("upload_end", &self.upload_end);
        formatter.field("upload_size", &self.upload_size);
        formatter.field("upload_start", &self.upload_start);
        formatter.finish()
    }
}
/// See [`ClientData`](crate::model::ClientData)
pub mod client_data {
    /// A builder for [`ClientData`](crate::model::ClientData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comment: std::option::Option<std::string::String>,
        pub(crate) upload_end: std::option::Option<smithy_types::Instant>,
        pub(crate) upload_size: std::option::Option<f64>,
        pub(crate) upload_start: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>A user-defined comment about the disk upload.</p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// <p>The time that the disk upload ends.</p>
        pub fn upload_end(mut self, input: smithy_types::Instant) -> Self {
            self.upload_end = Some(input);
            self
        }
        pub fn set_upload_end(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.upload_end = input;
            self
        }
        /// <p>The size of the uploaded disk image, in GiB.</p>
        pub fn upload_size(mut self, input: f64) -> Self {
            self.upload_size = Some(input);
            self
        }
        pub fn set_upload_size(mut self, input: std::option::Option<f64>) -> Self {
            self.upload_size = input;
            self
        }
        /// <p>The time that the disk upload starts.</p>
        pub fn upload_start(mut self, input: smithy_types::Instant) -> Self {
            self.upload_start = Some(input);
            self
        }
        pub fn set_upload_start(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.upload_start = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientData`](crate::model::ClientData)
        pub fn build(self) -> crate::model::ClientData {
            crate::model::ClientData {
                comment: self.comment,
                upload_end: self.upload_end,
                upload_size: self.upload_size,
                upload_start: self.upload_start,
            }
        }
    }
}
impl ClientData {
    /// Creates a new builder-style object to manufacture [`ClientData`](crate::model::ClientData)
    pub fn builder() -> crate::model::client_data::Builder {
        crate::model::client_data::Builder::default()
    }
}

/// <p>Describes the launch specification for VM import.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportInstanceLaunchSpecification {
    /// <p>Reserved.</p>
    pub additional_info: std::option::Option<std::string::String>,
    /// <p>The architecture of the instance.</p>
    pub architecture: std::option::Option<crate::model::ArchitectureValues>,
    /// <p>The security group IDs.</p>
    pub group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security group names.</p>
    pub group_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the
    /// operating system command for system shutdown).</p>
    pub instance_initiated_shutdown_behavior: std::option::Option<crate::model::ShutdownBehavior>,
    /// <p>The instance type. For more information about the instance types that you can import, see <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmie_prereqs.html#vmimport-instance-types">Instance Types</a> in the
    /// VM Import/Export User Guide.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>Indicates whether monitoring is enabled.</p>
    pub monitoring: std::option::Option<bool>,
    /// <p>The placement information for the instance.</p>
    pub placement: std::option::Option<crate::model::Placement>,
    /// <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Base64-encoded user data to make available to the instance.</p>
    pub user_data: std::option::Option<crate::model::UserData>,
}
impl std::fmt::Debug for ImportInstanceLaunchSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportInstanceLaunchSpecification");
        formatter.field("additional_info", &self.additional_info);
        formatter.field("architecture", &self.architecture);
        formatter.field("group_ids", &self.group_ids);
        formatter.field("group_names", &self.group_names);
        formatter.field(
            "instance_initiated_shutdown_behavior",
            &self.instance_initiated_shutdown_behavior,
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("placement", &self.placement);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ImportInstanceLaunchSpecification`](crate::model::ImportInstanceLaunchSpecification)
pub mod import_instance_launch_specification {
    /// A builder for [`ImportInstanceLaunchSpecification`](crate::model::ImportInstanceLaunchSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_info: std::option::Option<std::string::String>,
        pub(crate) architecture: std::option::Option<crate::model::ArchitectureValues>,
        pub(crate) group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_initiated_shutdown_behavior:
            std::option::Option<crate::model::ShutdownBehavior>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) monitoring: std::option::Option<bool>,
        pub(crate) placement: std::option::Option<crate::model::Placement>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<crate::model::UserData>,
    }
    impl Builder {
        /// <p>Reserved.</p>
        pub fn additional_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_info = Some(input.into());
            self
        }
        pub fn set_additional_info(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_info = input;
            self
        }
        /// <p>The architecture of the instance.</p>
        pub fn architecture(mut self, input: crate::model::ArchitectureValues) -> Self {
            self.architecture = Some(input);
            self
        }
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::ArchitectureValues>,
        ) -> Self {
            self.architecture = input;
            self
        }
        pub fn group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.group_ids.unwrap_or_default();
            v.push(input.into());
            self.group_ids = Some(v);
            self
        }
        pub fn set_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.group_ids = input;
            self
        }
        pub fn group_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.group_names.unwrap_or_default();
            v.push(input.into());
            self.group_names = Some(v);
            self
        }
        pub fn set_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.group_names = input;
            self
        }
        /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the
        /// operating system command for system shutdown).</p>
        pub fn instance_initiated_shutdown_behavior(
            mut self,
            input: crate::model::ShutdownBehavior,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = Some(input);
            self
        }
        pub fn set_instance_initiated_shutdown_behavior(
            mut self,
            input: std::option::Option<crate::model::ShutdownBehavior>,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = input;
            self
        }
        /// <p>The instance type. For more information about the instance types that you can import, see <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmie_prereqs.html#vmimport-instance-types">Instance Types</a> in the
        /// VM Import/Export User Guide.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Indicates whether monitoring is enabled.</p>
        pub fn monitoring(mut self, input: bool) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(mut self, input: std::option::Option<bool>) -> Self {
            self.monitoring = input;
            self
        }
        /// <p>The placement information for the instance.</p>
        pub fn placement(mut self, input: crate::model::Placement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::Placement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Base64-encoded user data to make available to the instance.</p>
        pub fn user_data(mut self, input: crate::model::UserData) -> Self {
            self.user_data = Some(input);
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<crate::model::UserData>) -> Self {
            self.user_data = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportInstanceLaunchSpecification`](crate::model::ImportInstanceLaunchSpecification)
        pub fn build(self) -> crate::model::ImportInstanceLaunchSpecification {
            crate::model::ImportInstanceLaunchSpecification {
                additional_info: self.additional_info,
                architecture: self.architecture,
                group_ids: self.group_ids,
                group_names: self.group_names,
                instance_initiated_shutdown_behavior: self.instance_initiated_shutdown_behavior,
                instance_type: self.instance_type,
                monitoring: self.monitoring,
                placement: self.placement,
                private_ip_address: self.private_ip_address,
                subnet_id: self.subnet_id,
                user_data: self.user_data,
            }
        }
    }
}
impl ImportInstanceLaunchSpecification {
    /// Creates a new builder-style object to manufacture [`ImportInstanceLaunchSpecification`](crate::model::ImportInstanceLaunchSpecification)
    pub fn builder() -> crate::model::import_instance_launch_specification::Builder {
        crate::model::import_instance_launch_specification::Builder::default()
    }
}

/// <p>Describes the user data for an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserData {
    /// <p>The user data. If you are using an Amazon Web Services SDK or command line tool, Base64-encoding is performed for you, and you
    /// can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
    pub data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserData");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`UserData`](crate::model::UserData)
pub mod user_data {
    /// A builder for [`UserData`](crate::model::UserData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user data. If you are using an Amazon Web Services SDK or command line tool, Base64-encoding is performed for you, and you
        /// can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`UserData`](crate::model::UserData)
        pub fn build(self) -> crate::model::UserData {
            crate::model::UserData { data: self.data }
        }
    }
}
impl UserData {
    /// Creates a new builder-style object to manufacture [`UserData`](crate::model::UserData)
    pub fn builder() -> crate::model::user_data::Builder {
        crate::model::user_data::Builder::default()
    }
}

/// <p>Describes a disk image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskImage {
    /// <p>A description of the disk image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about the disk image.</p>
    pub image: std::option::Option<crate::model::DiskImageDetail>,
    /// <p>Information about the volume.</p>
    pub volume: std::option::Option<crate::model::VolumeDetail>,
}
impl std::fmt::Debug for DiskImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskImage");
        formatter.field("description", &self.description);
        formatter.field("image", &self.image);
        formatter.field("volume", &self.volume);
        formatter.finish()
    }
}
/// See [`DiskImage`](crate::model::DiskImage)
pub mod disk_image {
    /// A builder for [`DiskImage`](crate::model::DiskImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<crate::model::DiskImageDetail>,
        pub(crate) volume: std::option::Option<crate::model::VolumeDetail>,
    }
    impl Builder {
        /// <p>A description of the disk image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Information about the disk image.</p>
        pub fn image(mut self, input: crate::model::DiskImageDetail) -> Self {
            self.image = Some(input);
            self
        }
        pub fn set_image(
            mut self,
            input: std::option::Option<crate::model::DiskImageDetail>,
        ) -> Self {
            self.image = input;
            self
        }
        /// <p>Information about the volume.</p>
        pub fn volume(mut self, input: crate::model::VolumeDetail) -> Self {
            self.volume = Some(input);
            self
        }
        pub fn set_volume(
            mut self,
            input: std::option::Option<crate::model::VolumeDetail>,
        ) -> Self {
            self.volume = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskImage`](crate::model::DiskImage)
        pub fn build(self) -> crate::model::DiskImage {
            crate::model::DiskImage {
                description: self.description,
                image: self.image,
                volume: self.volume,
            }
        }
    }
}
impl DiskImage {
    /// Creates a new builder-style object to manufacture [`DiskImage`](crate::model::DiskImage)
    pub fn builder() -> crate::model::disk_image::Builder {
        crate::model::disk_image::Builder::default()
    }
}

/// <p> The response information for license configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportImageLicenseConfigurationResponse {
    /// <p>The ARN of a license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportImageLicenseConfigurationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportImageLicenseConfigurationResponse");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`ImportImageLicenseConfigurationResponse`](crate::model::ImportImageLicenseConfigurationResponse)
pub mod import_image_license_configuration_response {
    /// A builder for [`ImportImageLicenseConfigurationResponse`](crate::model::ImportImageLicenseConfigurationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of a license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportImageLicenseConfigurationResponse`](crate::model::ImportImageLicenseConfigurationResponse)
        pub fn build(self) -> crate::model::ImportImageLicenseConfigurationResponse {
            crate::model::ImportImageLicenseConfigurationResponse {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl ImportImageLicenseConfigurationResponse {
    /// Creates a new builder-style object to manufacture [`ImportImageLicenseConfigurationResponse`](crate::model::ImportImageLicenseConfigurationResponse)
    pub fn builder() -> crate::model::import_image_license_configuration_response::Builder {
        crate::model::import_image_license_configuration_response::Builder::default()
    }
}

/// <p>Describes the snapshot created from the imported disk.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotDetail {
    /// <p>A description for the snapshot.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The block device mapping for the snapshot.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The size of the disk in the snapshot, in GiB.</p>
    pub disk_image_size: std::option::Option<f64>,
    /// <p>The format of the disk image from which the snapshot is created.</p>
    pub format: std::option::Option<std::string::String>,
    /// <p>The percentage of progress for the task.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>The snapshot ID of the disk being imported.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>A brief status of the snapshot creation.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>A detailed status message for the snapshot creation.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The URL used to access the disk image.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket for the disk image.</p>
    pub user_bucket: std::option::Option<crate::model::UserBucketDetails>,
}
impl std::fmt::Debug for SnapshotDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotDetail");
        formatter.field("description", &self.description);
        formatter.field("device_name", &self.device_name);
        formatter.field("disk_image_size", &self.disk_image_size);
        formatter.field("format", &self.format);
        formatter.field("progress", &self.progress);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("url", &self.url);
        formatter.field("user_bucket", &self.user_bucket);
        formatter.finish()
    }
}
/// See [`SnapshotDetail`](crate::model::SnapshotDetail)
pub mod snapshot_detail {
    /// A builder for [`SnapshotDetail`](crate::model::SnapshotDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) disk_image_size: std::option::Option<f64>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) user_bucket: std::option::Option<crate::model::UserBucketDetails>,
    }
    impl Builder {
        /// <p>A description for the snapshot.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The block device mapping for the snapshot.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The size of the disk in the snapshot, in GiB.</p>
        pub fn disk_image_size(mut self, input: f64) -> Self {
            self.disk_image_size = Some(input);
            self
        }
        pub fn set_disk_image_size(mut self, input: std::option::Option<f64>) -> Self {
            self.disk_image_size = input;
            self
        }
        /// <p>The format of the disk image from which the snapshot is created.</p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The percentage of progress for the task.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The snapshot ID of the disk being imported.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>A brief status of the snapshot creation.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A detailed status message for the snapshot creation.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The URL used to access the disk image.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The Amazon S3 bucket for the disk image.</p>
        pub fn user_bucket(mut self, input: crate::model::UserBucketDetails) -> Self {
            self.user_bucket = Some(input);
            self
        }
        pub fn set_user_bucket(
            mut self,
            input: std::option::Option<crate::model::UserBucketDetails>,
        ) -> Self {
            self.user_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotDetail`](crate::model::SnapshotDetail)
        pub fn build(self) -> crate::model::SnapshotDetail {
            crate::model::SnapshotDetail {
                description: self.description,
                device_name: self.device_name,
                disk_image_size: self.disk_image_size,
                format: self.format,
                progress: self.progress,
                snapshot_id: self.snapshot_id,
                status: self.status,
                status_message: self.status_message,
                url: self.url,
                user_bucket: self.user_bucket,
            }
        }
    }
}
impl SnapshotDetail {
    /// Creates a new builder-style object to manufacture [`SnapshotDetail`](crate::model::SnapshotDetail)
    pub fn builder() -> crate::model::snapshot_detail::Builder {
        crate::model::snapshot_detail::Builder::default()
    }
}

/// <p>The request information of license configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportImageLicenseConfigurationRequest {
    /// <p>The ARN of a license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportImageLicenseConfigurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportImageLicenseConfigurationRequest");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`ImportImageLicenseConfigurationRequest`](crate::model::ImportImageLicenseConfigurationRequest)
pub mod import_image_license_configuration_request {
    /// A builder for [`ImportImageLicenseConfigurationRequest`](crate::model::ImportImageLicenseConfigurationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of a license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportImageLicenseConfigurationRequest`](crate::model::ImportImageLicenseConfigurationRequest)
        pub fn build(self) -> crate::model::ImportImageLicenseConfigurationRequest {
            crate::model::ImportImageLicenseConfigurationRequest {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl ImportImageLicenseConfigurationRequest {
    /// Creates a new builder-style object to manufacture [`ImportImageLicenseConfigurationRequest`](crate::model::ImportImageLicenseConfigurationRequest)
    pub fn builder() -> crate::model::import_image_license_configuration_request::Builder {
        crate::model::import_image_license_configuration_request::Builder::default()
    }
}

/// <p>Describes the disk container object for an import image task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageDiskContainer {
    /// <p>The description of the disk image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The block device mapping for the disk.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The format of the disk image being imported.</p>
    /// <p>Valid values: <code>OVA</code> | <code>VHD</code> | <code>VHDX</code> | <code>VMDK</code> | <code>RAW</code>
    /// </p>
    pub format: std::option::Option<std::string::String>,
    /// <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an
    /// Amazon S3 URL (s3://..)</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The S3 bucket for the disk image.</p>
    pub user_bucket: std::option::Option<crate::model::UserBucket>,
}
impl std::fmt::Debug for ImageDiskContainer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageDiskContainer");
        formatter.field("description", &self.description);
        formatter.field("device_name", &self.device_name);
        formatter.field("format", &self.format);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("url", &self.url);
        formatter.field("user_bucket", &self.user_bucket);
        formatter.finish()
    }
}
/// See [`ImageDiskContainer`](crate::model::ImageDiskContainer)
pub mod image_disk_container {
    /// A builder for [`ImageDiskContainer`](crate::model::ImageDiskContainer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) user_bucket: std::option::Option<crate::model::UserBucket>,
    }
    impl Builder {
        /// <p>The description of the disk image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The block device mapping for the disk.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The format of the disk image being imported.</p>
        /// <p>Valid values: <code>OVA</code> | <code>VHD</code> | <code>VHDX</code> | <code>VMDK</code> | <code>RAW</code>
        /// </p>
        pub fn format(mut self, input: impl Into<std::string::String>) -> Self {
            self.format = Some(input.into());
            self
        }
        pub fn set_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.format = input;
            self
        }
        /// <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an
        /// Amazon S3 URL (s3://..)</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The S3 bucket for the disk image.</p>
        pub fn user_bucket(mut self, input: crate::model::UserBucket) -> Self {
            self.user_bucket = Some(input);
            self
        }
        pub fn set_user_bucket(
            mut self,
            input: std::option::Option<crate::model::UserBucket>,
        ) -> Self {
            self.user_bucket = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageDiskContainer`](crate::model::ImageDiskContainer)
        pub fn build(self) -> crate::model::ImageDiskContainer {
            crate::model::ImageDiskContainer {
                description: self.description,
                device_name: self.device_name,
                format: self.format,
                snapshot_id: self.snapshot_id,
                url: self.url,
                user_bucket: self.user_bucket,
            }
        }
    }
}
impl ImageDiskContainer {
    /// Creates a new builder-style object to manufacture [`ImageDiskContainer`](crate::model::ImageDiskContainer)
    pub fn builder() -> crate::model::image_disk_container::Builder {
        crate::model::image_disk_container::Builder::default()
    }
}

/// <p>Describes a route table propagation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRouteTablePropagation {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The state of the resource.</p>
    pub state: std::option::Option<crate::model::TransitGatewayPropagationState>,
}
impl std::fmt::Debug for TransitGatewayRouteTablePropagation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRouteTablePropagation");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayRouteTablePropagation`](crate::model::TransitGatewayRouteTablePropagation)
pub mod transit_gateway_route_table_propagation {
    /// A builder for [`TransitGatewayRouteTablePropagation`](crate::model::TransitGatewayRouteTablePropagation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayPropagationState>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The state of the resource.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayPropagationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayPropagationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRouteTablePropagation`](crate::model::TransitGatewayRouteTablePropagation)
        pub fn build(self) -> crate::model::TransitGatewayRouteTablePropagation {
            crate::model::TransitGatewayRouteTablePropagation {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayRouteTablePropagation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRouteTablePropagation`](crate::model::TransitGatewayRouteTablePropagation)
    pub fn builder() -> crate::model::transit_gateway_route_table_propagation::Builder {
        crate::model::transit_gateway_route_table_propagation::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayPropagationState {
    Disabled,
    Disabling,
    Enabled,
    Enabling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayPropagationState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => TransitGatewayPropagationState::Disabled,
            "disabling" => TransitGatewayPropagationState::Disabling,
            "enabled" => TransitGatewayPropagationState::Enabled,
            "enabling" => TransitGatewayPropagationState::Enabling,
            other => TransitGatewayPropagationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayPropagationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayPropagationState::from(s))
    }
}
impl TransitGatewayPropagationState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayPropagationState::Disabled => "disabled",
            TransitGatewayPropagationState::Disabling => "disabling",
            TransitGatewayPropagationState::Enabled => "enabled",
            TransitGatewayPropagationState::Enabling => "enabling",
            TransitGatewayPropagationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "disabling", "enabled", "enabling"]
    }
}
impl AsRef<str> for TransitGatewayPropagationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an association between a route table and a resource attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRouteTableAssociation {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAssociationState>,
}
impl std::fmt::Debug for TransitGatewayRouteTableAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRouteTableAssociation");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayRouteTableAssociation`](crate::model::TransitGatewayRouteTableAssociation)
pub mod transit_gateway_route_table_association {
    /// A builder for [`TransitGatewayRouteTableAssociation`](crate::model::TransitGatewayRouteTableAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAssociationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRouteTableAssociation`](crate::model::TransitGatewayRouteTableAssociation)
        pub fn build(self) -> crate::model::TransitGatewayRouteTableAssociation {
            crate::model::TransitGatewayRouteTableAssociation {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayRouteTableAssociation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRouteTableAssociation`](crate::model::TransitGatewayRouteTableAssociation)
    pub fn builder() -> crate::model::transit_gateway_route_table_association::Builder {
        crate::model::transit_gateway_route_table_association::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayAssociationState {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "associated" => TransitGatewayAssociationState::Associated,
            "associating" => TransitGatewayAssociationState::Associating,
            "disassociated" => TransitGatewayAssociationState::Disassociated,
            "disassociating" => TransitGatewayAssociationState::Disassociating,
            other => TransitGatewayAssociationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayAssociationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayAssociationState::from(s))
    }
}
impl TransitGatewayAssociationState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayAssociationState::Associated => "associated",
            TransitGatewayAssociationState::Associating => "associating",
            TransitGatewayAssociationState::Disassociated => "disassociated",
            TransitGatewayAssociationState::Disassociating => "disassociating",
            TransitGatewayAssociationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
        ]
    }
}
impl AsRef<str> for TransitGatewayAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the resources associated with the transit gateway multicast domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDomainAssociation {
    /// <p>The ID of the transit gateway attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource, for example a VPC attachment.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain association resource.</p>
    pub resource_owner_id: std::option::Option<std::string::String>,
    /// <p>The subnet associated with the transit gateway multicast domain.</p>
    pub subnet: std::option::Option<crate::model::SubnetAssociation>,
}
impl std::fmt::Debug for TransitGatewayMulticastDomainAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDomainAssociation");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_owner_id", &self.resource_owner_id);
        formatter.field("subnet", &self.subnet);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDomainAssociation`](crate::model::TransitGatewayMulticastDomainAssociation)
pub mod transit_gateway_multicast_domain_association {
    /// A builder for [`TransitGatewayMulticastDomainAssociation`](crate::model::TransitGatewayMulticastDomainAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) resource_owner_id: std::option::Option<std::string::String>,
        pub(crate) subnet: std::option::Option<crate::model::SubnetAssociation>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource, for example a VPC attachment.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain association resource.</p>
        pub fn resource_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner_id = Some(input.into());
            self
        }
        pub fn set_resource_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner_id = input;
            self
        }
        /// <p>The subnet associated with the transit gateway multicast domain.</p>
        pub fn subnet(mut self, input: crate::model::SubnetAssociation) -> Self {
            self.subnet = Some(input);
            self
        }
        pub fn set_subnet(
            mut self,
            input: std::option::Option<crate::model::SubnetAssociation>,
        ) -> Self {
            self.subnet = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDomainAssociation`](crate::model::TransitGatewayMulticastDomainAssociation)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDomainAssociation {
            crate::model::TransitGatewayMulticastDomainAssociation {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                resource_owner_id: self.resource_owner_id,
                subnet: self.subnet,
            }
        }
    }
}
impl TransitGatewayMulticastDomainAssociation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDomainAssociation`](crate::model::TransitGatewayMulticastDomainAssociation)
    pub fn builder() -> crate::model::transit_gateway_multicast_domain_association::Builder {
        crate::model::transit_gateway_multicast_domain_association::Builder::default()
    }
}

/// <p>Describes a propagation route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayAttachmentPropagation {
    /// <p>The ID of the propagation route table.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The state of the propagation route table.</p>
    pub state: std::option::Option<crate::model::TransitGatewayPropagationState>,
}
impl std::fmt::Debug for TransitGatewayAttachmentPropagation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayAttachmentPropagation");
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayAttachmentPropagation`](crate::model::TransitGatewayAttachmentPropagation)
pub mod transit_gateway_attachment_propagation {
    /// A builder for [`TransitGatewayAttachmentPropagation`](crate::model::TransitGatewayAttachmentPropagation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayPropagationState>,
    }
    impl Builder {
        /// <p>The ID of the propagation route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The state of the propagation route table.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayPropagationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayPropagationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayAttachmentPropagation`](crate::model::TransitGatewayAttachmentPropagation)
        pub fn build(self) -> crate::model::TransitGatewayAttachmentPropagation {
            crate::model::TransitGatewayAttachmentPropagation {
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayAttachmentPropagation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayAttachmentPropagation`](crate::model::TransitGatewayAttachmentPropagation)
    pub fn builder() -> crate::model::transit_gateway_attachment_propagation::Builder {
        crate::model::transit_gateway_attachment_propagation::Builder::default()
    }
}

/// <p>Describes a subnet CIDR reservation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetCidrReservation {
    /// <p>The ID of the subnet CIDR reservation.</p>
    pub subnet_cidr_reservation_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The CIDR that has been reserved.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The type of reservation. </p>
    pub reservation_type: std::option::Option<crate::model::SubnetCidrReservationType>,
    /// <p>The ID of the account that owns the subnet CIDR reservation. </p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The
    /// description
    /// assigned to the subnet CIDR
    /// reservation.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the subnet CIDR reservation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for SubnetCidrReservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetCidrReservation");
        formatter.field(
            "subnet_cidr_reservation_id",
            &self.subnet_cidr_reservation_id,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("cidr", &self.cidr);
        formatter.field("reservation_type", &self.reservation_type);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SubnetCidrReservation`](crate::model::SubnetCidrReservation)
pub mod subnet_cidr_reservation {
    /// A builder for [`SubnetCidrReservation`](crate::model::SubnetCidrReservation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_cidr_reservation_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) reservation_type: std::option::Option<crate::model::SubnetCidrReservationType>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the subnet CIDR reservation.</p>
        pub fn subnet_cidr_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_cidr_reservation_id = Some(input.into());
            self
        }
        pub fn set_subnet_cidr_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_cidr_reservation_id = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The CIDR that has been reserved.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>The type of reservation. </p>
        pub fn reservation_type(mut self, input: crate::model::SubnetCidrReservationType) -> Self {
            self.reservation_type = Some(input);
            self
        }
        pub fn set_reservation_type(
            mut self,
            input: std::option::Option<crate::model::SubnetCidrReservationType>,
        ) -> Self {
            self.reservation_type = input;
            self
        }
        /// <p>The ID of the account that owns the subnet CIDR reservation. </p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The
        /// description
        /// assigned to the subnet CIDR
        /// reservation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetCidrReservation`](crate::model::SubnetCidrReservation)
        pub fn build(self) -> crate::model::SubnetCidrReservation {
            crate::model::SubnetCidrReservation {
                subnet_cidr_reservation_id: self.subnet_cidr_reservation_id,
                subnet_id: self.subnet_id,
                cidr: self.cidr,
                reservation_type: self.reservation_type,
                owner_id: self.owner_id,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl SubnetCidrReservation {
    /// Creates a new builder-style object to manufacture [`SubnetCidrReservation`](crate::model::SubnetCidrReservation)
    pub fn builder() -> crate::model::subnet_cidr_reservation::Builder {
        crate::model::subnet_cidr_reservation::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubnetCidrReservationType {
    Explicit,
    Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubnetCidrReservationType {
    fn from(s: &str) -> Self {
        match s {
            "explicit" => SubnetCidrReservationType::Explicit,
            "prefix" => SubnetCidrReservationType::Prefix,
            other => SubnetCidrReservationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubnetCidrReservationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubnetCidrReservationType::from(s))
    }
}
impl SubnetCidrReservationType {
    pub fn as_str(&self) -> &str {
        match self {
            SubnetCidrReservationType::Explicit => "explicit",
            SubnetCidrReservationType::Prefix => "prefix",
            SubnetCidrReservationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["explicit", "prefix"]
    }
}
impl AsRef<str> for SubnetCidrReservationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The total value of the new Convertible Reserved Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetReservationValue {
    /// <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of
    /// the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
    pub reservation_value: std::option::Option<crate::model::ReservationValue>,
    /// <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
    pub target_configuration: std::option::Option<crate::model::TargetConfiguration>,
}
impl std::fmt::Debug for TargetReservationValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetReservationValue");
        formatter.field("reservation_value", &self.reservation_value);
        formatter.field("target_configuration", &self.target_configuration);
        formatter.finish()
    }
}
/// See [`TargetReservationValue`](crate::model::TargetReservationValue)
pub mod target_reservation_value {
    /// A builder for [`TargetReservationValue`](crate::model::TargetReservationValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reservation_value: std::option::Option<crate::model::ReservationValue>,
        pub(crate) target_configuration: std::option::Option<crate::model::TargetConfiguration>,
    }
    impl Builder {
        /// <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of
        /// the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
        pub fn reservation_value(mut self, input: crate::model::ReservationValue) -> Self {
            self.reservation_value = Some(input);
            self
        }
        pub fn set_reservation_value(
            mut self,
            input: std::option::Option<crate::model::ReservationValue>,
        ) -> Self {
            self.reservation_value = input;
            self
        }
        /// <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
        pub fn target_configuration(mut self, input: crate::model::TargetConfiguration) -> Self {
            self.target_configuration = Some(input);
            self
        }
        pub fn set_target_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetConfiguration>,
        ) -> Self {
            self.target_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetReservationValue`](crate::model::TargetReservationValue)
        pub fn build(self) -> crate::model::TargetReservationValue {
            crate::model::TargetReservationValue {
                reservation_value: self.reservation_value,
                target_configuration: self.target_configuration,
            }
        }
    }
}
impl TargetReservationValue {
    /// Creates a new builder-style object to manufacture [`TargetReservationValue`](crate::model::TargetReservationValue)
    pub fn builder() -> crate::model::target_reservation_value::Builder {
        crate::model::target_reservation_value::Builder::default()
    }
}

/// <p>Information about the Convertible Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetConfiguration {
    /// <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is
    /// reserved and cannot be specified in a request</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The ID of the Convertible Reserved Instance offering.</p>
    pub offering_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetConfiguration");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("offering_id", &self.offering_id);
        formatter.finish()
    }
}
/// See [`TargetConfiguration`](crate::model::TargetConfiguration)
pub mod target_configuration {
    /// A builder for [`TargetConfiguration`](crate::model::TargetConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) offering_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is
        /// reserved and cannot be specified in a request</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The ID of the Convertible Reserved Instance offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_id = Some(input.into());
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetConfiguration`](crate::model::TargetConfiguration)
        pub fn build(self) -> crate::model::TargetConfiguration {
            crate::model::TargetConfiguration {
                instance_count: self.instance_count,
                offering_id: self.offering_id,
            }
        }
    }
}
impl TargetConfiguration {
    /// Creates a new builder-style object to manufacture [`TargetConfiguration`](crate::model::TargetConfiguration)
    pub fn builder() -> crate::model::target_configuration::Builder {
        crate::model::target_configuration::Builder::default()
    }
}

/// <p>The cost associated with the Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationValue {
    /// <p>The hourly rate of the reservation.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
    pub remaining_total_value: std::option::Option<std::string::String>,
    /// <p>The remaining upfront cost of the reservation.</p>
    pub remaining_upfront_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservationValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationValue");
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("remaining_total_value", &self.remaining_total_value);
        formatter.field("remaining_upfront_value", &self.remaining_upfront_value);
        formatter.finish()
    }
}
/// See [`ReservationValue`](crate::model::ReservationValue)
pub mod reservation_value {
    /// A builder for [`ReservationValue`](crate::model::ReservationValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) remaining_total_value: std::option::Option<std::string::String>,
        pub(crate) remaining_upfront_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The hourly rate of the reservation.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
        pub fn remaining_total_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.remaining_total_value = Some(input.into());
            self
        }
        pub fn set_remaining_total_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remaining_total_value = input;
            self
        }
        /// <p>The remaining upfront cost of the reservation.</p>
        pub fn remaining_upfront_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.remaining_upfront_value = Some(input.into());
            self
        }
        pub fn set_remaining_upfront_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remaining_upfront_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationValue`](crate::model::ReservationValue)
        pub fn build(self) -> crate::model::ReservationValue {
            crate::model::ReservationValue {
                hourly_price: self.hourly_price,
                remaining_total_value: self.remaining_total_value,
                remaining_upfront_value: self.remaining_upfront_value,
            }
        }
    }
}
impl ReservationValue {
    /// Creates a new builder-style object to manufacture [`ReservationValue`](crate::model::ReservationValue)
    pub fn builder() -> crate::model::reservation_value::Builder {
        crate::model::reservation_value::Builder::default()
    }
}

/// <p>The total value of the Convertible Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstanceReservationValue {
    /// <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
    pub reservation_value: std::option::Option<crate::model::ReservationValue>,
    /// <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
    pub reserved_instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedInstanceReservationValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstanceReservationValue");
        formatter.field("reservation_value", &self.reservation_value);
        formatter.field("reserved_instance_id", &self.reserved_instance_id);
        formatter.finish()
    }
}
/// See [`ReservedInstanceReservationValue`](crate::model::ReservedInstanceReservationValue)
pub mod reserved_instance_reservation_value {
    /// A builder for [`ReservedInstanceReservationValue`](crate::model::ReservedInstanceReservationValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reservation_value: std::option::Option<crate::model::ReservationValue>,
        pub(crate) reserved_instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
        pub fn reservation_value(mut self, input: crate::model::ReservationValue) -> Self {
            self.reservation_value = Some(input);
            self
        }
        pub fn set_reservation_value(
            mut self,
            input: std::option::Option<crate::model::ReservationValue>,
        ) -> Self {
            self.reservation_value = input;
            self
        }
        /// <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
        pub fn reserved_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instance_id = Some(input.into());
            self
        }
        pub fn set_reserved_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstanceReservationValue`](crate::model::ReservedInstanceReservationValue)
        pub fn build(self) -> crate::model::ReservedInstanceReservationValue {
            crate::model::ReservedInstanceReservationValue {
                reservation_value: self.reservation_value,
                reserved_instance_id: self.reserved_instance_id,
            }
        }
    }
}
impl ReservedInstanceReservationValue {
    /// Creates a new builder-style object to manufacture [`ReservedInstanceReservationValue`](crate::model::ReservedInstanceReservationValue)
    pub fn builder() -> crate::model::reserved_instance_reservation_value::Builder {
        crate::model::reserved_instance_reservation_value::Builder::default()
    }
}

/// <p>Details about the target configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetConfigurationRequest {
    /// <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot
    /// be specified in a request</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The Convertible Reserved Instance offering ID.</p>
    pub offering_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetConfigurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetConfigurationRequest");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("offering_id", &self.offering_id);
        formatter.finish()
    }
}
/// See [`TargetConfigurationRequest`](crate::model::TargetConfigurationRequest)
pub mod target_configuration_request {
    /// A builder for [`TargetConfigurationRequest`](crate::model::TargetConfigurationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) offering_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot
        /// be specified in a request</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The Convertible Reserved Instance offering ID.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_id = Some(input.into());
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetConfigurationRequest`](crate::model::TargetConfigurationRequest)
        pub fn build(self) -> crate::model::TargetConfigurationRequest {
            crate::model::TargetConfigurationRequest {
                instance_count: self.instance_count,
                offering_id: self.offering_id,
            }
        }
    }
}
impl TargetConfigurationRequest {
    /// Creates a new builder-style object to manufacture [`TargetConfigurationRequest`](crate::model::TargetConfigurationRequest)
    pub fn builder() -> crate::model::target_configuration_request::Builder {
        crate::model::target_configuration_request::Builder::default()
    }
}

/// <p>Describes a prefix list entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrefixListEntry {
    /// <p>The CIDR block.</p>
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrefixListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrefixListEntry");
        formatter.field("cidr", &self.cidr);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`PrefixListEntry`](crate::model::PrefixListEntry)
pub mod prefix_list_entry {
    /// A builder for [`PrefixListEntry`](crate::model::PrefixListEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefixListEntry`](crate::model::PrefixListEntry)
        pub fn build(self) -> crate::model::PrefixListEntry {
            crate::model::PrefixListEntry {
                cidr: self.cidr,
                description: self.description,
            }
        }
    }
}
impl PrefixListEntry {
    /// Creates a new builder-style object to manufacture [`PrefixListEntry`](crate::model::PrefixListEntry)
    pub fn builder() -> crate::model::prefix_list_entry::Builder {
        crate::model::prefix_list_entry::Builder::default()
    }
}

/// <p>Describes the resource with which a prefix list is associated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrefixListAssociation {
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The owner of the resource.</p>
    pub resource_owner: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrefixListAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrefixListAssociation");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_owner", &self.resource_owner);
        formatter.finish()
    }
}
/// See [`PrefixListAssociation`](crate::model::PrefixListAssociation)
pub mod prefix_list_association {
    /// A builder for [`PrefixListAssociation`](crate::model::PrefixListAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The owner of the resource.</p>
        pub fn resource_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner = Some(input.into());
            self
        }
        pub fn set_resource_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefixListAssociation`](crate::model::PrefixListAssociation)
        pub fn build(self) -> crate::model::PrefixListAssociation {
            crate::model::PrefixListAssociation {
                resource_id: self.resource_id,
                resource_owner: self.resource_owner,
            }
        }
    }
}
impl PrefixListAssociation {
    /// Creates a new builder-style object to manufacture [`PrefixListAssociation`](crate::model::PrefixListAssociation)
    pub fn builder() -> crate::model::prefix_list_association::Builder {
        crate::model::prefix_list_association::Builder::default()
    }
}

/// <p>The information for a launch template. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResponseLaunchTemplateData {
    /// <p>The ID of the kernel, if applicable.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. </p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile:
        std::option::Option<crate::model::LaunchTemplateIamInstanceProfileSpecification>,
    /// <p>The block device mappings.</p>
    pub block_device_mappings:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMapping>>,
    /// <p>The network interfaces.</p>
    pub network_interfaces: std::option::Option<
        std::vec::Vec<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification>,
    >,
    /// <p>The ID of the AMI that was used to launch the instance.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The monitoring for the instance.</p>
    pub monitoring: std::option::Option<crate::model::LaunchTemplatesMonitoring>,
    /// <p>The placement of the instance.</p>
    pub placement: std::option::Option<crate::model::LaunchTemplatePlacement>,
    /// <p>The ID of the RAM disk, if applicable.</p>
    pub ram_disk_id: std::option::Option<std::string::String>,
    /// <p>If set to <code>true</code>, indicates that the instance cannot be terminated using
    /// the Amazon EC2 console, command line tool, or API.</p>
    pub disable_api_termination: std::option::Option<bool>,
    /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from
    /// the instance (using the operating system command for system shutdown).</p>
    pub instance_initiated_shutdown_behavior: std::option::Option<crate::model::ShutdownBehavior>,
    /// <p>The user data for the instance. </p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The tags.</p>
    pub tag_specifications:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateTagSpecification>>,
    /// <p>The elastic GPU specification.</p>
    pub elastic_gpu_specifications:
        std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecificationResponse>>,
    /// <p>
    /// The elastic inference accelerator for the instance.
    /// </p>
    pub elastic_inference_accelerators: std::option::Option<
        std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAcceleratorResponse>,
    >,
    /// <p>The security group IDs.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The security group names.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The market (purchasing) option for the instances.</p>
    pub instance_market_options:
        std::option::Option<crate::model::LaunchTemplateInstanceMarketOptions>,
    /// <p>The credit option for CPU usage of the instance.</p>
    pub credit_specification: std::option::Option<crate::model::CreditSpecification>,
    /// <p>The CPU options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU options</a> in the <i>Amazon Elastic Compute Cloud User
    /// Guide</i>.</p>
    pub cpu_options: std::option::Option<crate::model::LaunchTemplateCpuOptions>,
    /// <p>Information about the Capacity Reservation targeting option.</p>
    pub capacity_reservation_specification:
        std::option::Option<crate::model::LaunchTemplateCapacityReservationSpecificationResponse>,
    /// <p>The license configurations.</p>
    pub license_specifications:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateLicenseConfiguration>>,
    /// <p>Indicates whether an instance is configured for hibernation. For more information, see
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate
    /// your instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub hibernation_options: std::option::Option<crate::model::LaunchTemplateHibernationOptions>,
    /// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub metadata_options: std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptions>,
    /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
    pub enclave_options: std::option::Option<crate::model::LaunchTemplateEnclaveOptions>,
}
impl std::fmt::Debug for ResponseLaunchTemplateData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResponseLaunchTemplateData");
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("placement", &self.placement);
        formatter.field("ram_disk_id", &self.ram_disk_id);
        formatter.field("disable_api_termination", &self.disable_api_termination);
        formatter.field(
            "instance_initiated_shutdown_behavior",
            &self.instance_initiated_shutdown_behavior,
        );
        formatter.field("user_data", &self.user_data);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.field(
            "elastic_gpu_specifications",
            &self.elastic_gpu_specifications,
        );
        formatter.field(
            "elastic_inference_accelerators",
            &self.elastic_inference_accelerators,
        );
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("instance_market_options", &self.instance_market_options);
        formatter.field("credit_specification", &self.credit_specification);
        formatter.field("cpu_options", &self.cpu_options);
        formatter.field(
            "capacity_reservation_specification",
            &self.capacity_reservation_specification,
        );
        formatter.field("license_specifications", &self.license_specifications);
        formatter.field("hibernation_options", &self.hibernation_options);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.field("enclave_options", &self.enclave_options);
        formatter.finish()
    }
}
/// See [`ResponseLaunchTemplateData`](crate::model::ResponseLaunchTemplateData)
pub mod response_launch_template_data {
    /// A builder for [`ResponseLaunchTemplateData`](crate::model::ResponseLaunchTemplateData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::LaunchTemplateIamInstanceProfileSpecification>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMapping>>,
        pub(crate) network_interfaces: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification>,
        >,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::LaunchTemplatesMonitoring>,
        pub(crate) placement: std::option::Option<crate::model::LaunchTemplatePlacement>,
        pub(crate) ram_disk_id: std::option::Option<std::string::String>,
        pub(crate) disable_api_termination: std::option::Option<bool>,
        pub(crate) instance_initiated_shutdown_behavior:
            std::option::Option<crate::model::ShutdownBehavior>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) tag_specifications:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateTagSpecification>>,
        pub(crate) elastic_gpu_specifications:
            std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecificationResponse>>,
        pub(crate) elastic_inference_accelerators: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAcceleratorResponse>,
        >,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_market_options:
            std::option::Option<crate::model::LaunchTemplateInstanceMarketOptions>,
        pub(crate) credit_specification: std::option::Option<crate::model::CreditSpecification>,
        pub(crate) cpu_options: std::option::Option<crate::model::LaunchTemplateCpuOptions>,
        pub(crate) capacity_reservation_specification: std::option::Option<
            crate::model::LaunchTemplateCapacityReservationSpecificationResponse,
        >,
        pub(crate) license_specifications:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateLicenseConfiguration>>,
        pub(crate) hibernation_options:
            std::option::Option<crate::model::LaunchTemplateHibernationOptions>,
        pub(crate) metadata_options:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptions>,
        pub(crate) enclave_options: std::option::Option<crate::model::LaunchTemplateEnclaveOptions>,
    }
    impl Builder {
        /// <p>The ID of the kernel, if applicable.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::LaunchTemplateIamInstanceProfileSpecification,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateIamInstanceProfileSpecification>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::LaunchTemplateBlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMapping>,
            >,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification>,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The ID of the AMI that was used to launch the instance.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The monitoring for the instance.</p>
        pub fn monitoring(mut self, input: crate::model::LaunchTemplatesMonitoring) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplatesMonitoring>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        /// <p>The placement of the instance.</p>
        pub fn placement(mut self, input: crate::model::LaunchTemplatePlacement) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplatePlacement>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk, if applicable.</p>
        pub fn ram_disk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ram_disk_id = Some(input.into());
            self
        }
        pub fn set_ram_disk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ram_disk_id = input;
            self
        }
        /// <p>If set to <code>true</code>, indicates that the instance cannot be terminated using
        /// the Amazon EC2 console, command line tool, or API.</p>
        pub fn disable_api_termination(mut self, input: bool) -> Self {
            self.disable_api_termination = Some(input);
            self
        }
        pub fn set_disable_api_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_api_termination = input;
            self
        }
        /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from
        /// the instance (using the operating system command for system shutdown).</p>
        pub fn instance_initiated_shutdown_behavior(
            mut self,
            input: crate::model::ShutdownBehavior,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = Some(input);
            self
        }
        pub fn set_instance_initiated_shutdown_behavior(
            mut self,
            input: std::option::Option<crate::model::ShutdownBehavior>,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = input;
            self
        }
        /// <p>The user data for the instance. </p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        pub fn tag_specifications(
            mut self,
            input: impl Into<crate::model::LaunchTemplateTagSpecification>,
        ) -> Self {
            let mut v = self.tag_specifications.unwrap_or_default();
            v.push(input.into());
            self.tag_specifications = Some(v);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateTagSpecification>>,
        ) -> Self {
            self.tag_specifications = input;
            self
        }
        pub fn elastic_gpu_specifications(
            mut self,
            input: impl Into<crate::model::ElasticGpuSpecificationResponse>,
        ) -> Self {
            let mut v = self.elastic_gpu_specifications.unwrap_or_default();
            v.push(input.into());
            self.elastic_gpu_specifications = Some(v);
            self
        }
        pub fn set_elastic_gpu_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ElasticGpuSpecificationResponse>,
            >,
        ) -> Self {
            self.elastic_gpu_specifications = input;
            self
        }
        pub fn elastic_inference_accelerators(
            mut self,
            input: impl Into<crate::model::LaunchTemplateElasticInferenceAcceleratorResponse>,
        ) -> Self {
            let mut v = self.elastic_inference_accelerators.unwrap_or_default();
            v.push(input.into());
            self.elastic_inference_accelerators = Some(v);
            self
        }
        pub fn set_elastic_inference_accelerators(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAcceleratorResponse>,
            >,
        ) -> Self {
            self.elastic_inference_accelerators = input;
            self
        }
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The market (purchasing) option for the instances.</p>
        pub fn instance_market_options(
            mut self,
            input: crate::model::LaunchTemplateInstanceMarketOptions,
        ) -> Self {
            self.instance_market_options = Some(input);
            self
        }
        pub fn set_instance_market_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMarketOptions>,
        ) -> Self {
            self.instance_market_options = input;
            self
        }
        /// <p>The credit option for CPU usage of the instance.</p>
        pub fn credit_specification(mut self, input: crate::model::CreditSpecification) -> Self {
            self.credit_specification = Some(input);
            self
        }
        pub fn set_credit_specification(
            mut self,
            input: std::option::Option<crate::model::CreditSpecification>,
        ) -> Self {
            self.credit_specification = input;
            self
        }
        /// <p>The CPU options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU options</a> in the <i>Amazon Elastic Compute Cloud User
        /// Guide</i>.</p>
        pub fn cpu_options(mut self, input: crate::model::LaunchTemplateCpuOptions) -> Self {
            self.cpu_options = Some(input);
            self
        }
        pub fn set_cpu_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateCpuOptions>,
        ) -> Self {
            self.cpu_options = input;
            self
        }
        /// <p>Information about the Capacity Reservation targeting option.</p>
        pub fn capacity_reservation_specification(
            mut self,
            input: crate::model::LaunchTemplateCapacityReservationSpecificationResponse,
        ) -> Self {
            self.capacity_reservation_specification = Some(input);
            self
        }
        pub fn set_capacity_reservation_specification(
            mut self,
            input: std::option::Option<
                crate::model::LaunchTemplateCapacityReservationSpecificationResponse,
            >,
        ) -> Self {
            self.capacity_reservation_specification = input;
            self
        }
        pub fn license_specifications(
            mut self,
            input: impl Into<crate::model::LaunchTemplateLicenseConfiguration>,
        ) -> Self {
            let mut v = self.license_specifications.unwrap_or_default();
            v.push(input.into());
            self.license_specifications = Some(v);
            self
        }
        pub fn set_license_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateLicenseConfiguration>,
            >,
        ) -> Self {
            self.license_specifications = input;
            self
        }
        /// <p>Indicates whether an instance is configured for hibernation. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate
        /// your instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn hibernation_options(
            mut self,
            input: crate::model::LaunchTemplateHibernationOptions,
        ) -> Self {
            self.hibernation_options = Some(input);
            self
        }
        pub fn set_hibernation_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateHibernationOptions>,
        ) -> Self {
            self.hibernation_options = input;
            self
        }
        /// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn metadata_options(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataOptions,
        ) -> Self {
            self.metadata_options = Some(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptions>,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
        pub fn enclave_options(
            mut self,
            input: crate::model::LaunchTemplateEnclaveOptions,
        ) -> Self {
            self.enclave_options = Some(input);
            self
        }
        pub fn set_enclave_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateEnclaveOptions>,
        ) -> Self {
            self.enclave_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ResponseLaunchTemplateData`](crate::model::ResponseLaunchTemplateData)
        pub fn build(self) -> crate::model::ResponseLaunchTemplateData {
            crate::model::ResponseLaunchTemplateData {
                kernel_id: self.kernel_id,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                block_device_mappings: self.block_device_mappings,
                network_interfaces: self.network_interfaces,
                image_id: self.image_id,
                instance_type: self.instance_type,
                key_name: self.key_name,
                monitoring: self.monitoring,
                placement: self.placement,
                ram_disk_id: self.ram_disk_id,
                disable_api_termination: self.disable_api_termination,
                instance_initiated_shutdown_behavior: self.instance_initiated_shutdown_behavior,
                user_data: self.user_data,
                tag_specifications: self.tag_specifications,
                elastic_gpu_specifications: self.elastic_gpu_specifications,
                elastic_inference_accelerators: self.elastic_inference_accelerators,
                security_group_ids: self.security_group_ids,
                security_groups: self.security_groups,
                instance_market_options: self.instance_market_options,
                credit_specification: self.credit_specification,
                cpu_options: self.cpu_options,
                capacity_reservation_specification: self.capacity_reservation_specification,
                license_specifications: self.license_specifications,
                hibernation_options: self.hibernation_options,
                metadata_options: self.metadata_options,
                enclave_options: self.enclave_options,
            }
        }
    }
}
impl ResponseLaunchTemplateData {
    /// Creates a new builder-style object to manufacture [`ResponseLaunchTemplateData`](crate::model::ResponseLaunchTemplateData)
    pub fn builder() -> crate::model::response_launch_template_data::Builder {
        crate::model::response_launch_template_data::Builder::default()
    }
}

/// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateEnclaveOptions {
    /// <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves;
    /// otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplateEnclaveOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateEnclaveOptions");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`LaunchTemplateEnclaveOptions`](crate::model::LaunchTemplateEnclaveOptions)
pub mod launch_template_enclave_options {
    /// A builder for [`LaunchTemplateEnclaveOptions`](crate::model::LaunchTemplateEnclaveOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves;
        /// otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateEnclaveOptions`](crate::model::LaunchTemplateEnclaveOptions)
        pub fn build(self) -> crate::model::LaunchTemplateEnclaveOptions {
            crate::model::LaunchTemplateEnclaveOptions {
                enabled: self.enabled,
            }
        }
    }
}
impl LaunchTemplateEnclaveOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateEnclaveOptions`](crate::model::LaunchTemplateEnclaveOptions)
    pub fn builder() -> crate::model::launch_template_enclave_options::Builder {
        crate::model::launch_template_enclave_options::Builder::default()
    }
}

/// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance Metadata and User Data</a> in the
/// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceMetadataOptions {
    /// <p>The state of the metadata option changes.</p>
    /// <p>
    /// <code>pending</code> - The metadata options are being updated and the instance is not ready to process metadata traffic with the new selection.</p>
    /// <p>
    /// <code>applied</code> - The metadata options have been successfully applied on the instance.</p>
    pub state: std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsState>,
    /// <p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p>
    /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p>
    /// <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>
    pub http_tokens: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
    /// <p>Default: 1</p>
    /// <p>Possible values: Integers from 1 to 64</p>
    pub http_put_response_hop_limit: std::option::Option<i32>,
    /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p>
    /// <note>
    /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.
    /// </p>
    /// </note>
    pub http_endpoint:
        std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
    /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
    /// <p>Default: <code>disabled</code>
    /// </p>
    pub http_protocol_ipv6:
        std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
}
impl std::fmt::Debug for LaunchTemplateInstanceMetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateInstanceMetadataOptions");
        formatter.field("state", &self.state);
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field("http_protocol_ipv6", &self.http_protocol_ipv6);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceMetadataOptions`](crate::model::LaunchTemplateInstanceMetadataOptions)
pub mod launch_template_instance_metadata_options {
    /// A builder for [`LaunchTemplateInstanceMetadataOptions`](crate::model::LaunchTemplateInstanceMetadataOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsState>,
        pub(crate) http_tokens: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_endpoint:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
        pub(crate) http_protocol_ipv6:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
    }
    impl Builder {
        /// <p>The state of the metadata option changes.</p>
        /// <p>
        /// <code>pending</code> - The metadata options are being updated and the instance is not ready to process metadata traffic with the new selection.</p>
        /// <p>
        /// <code>applied</code> - The metadata options have been successfully applied on the instance.</p>
        pub fn state(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataOptionsState,
        ) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>
        pub fn http_tokens(mut self, input: crate::model::LaunchTemplateHttpTokensState) -> Self {
            self.http_tokens = Some(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
        ) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
        /// <p>Default: 1</p>
        /// <p>Possible values: Integers from 1 to 64</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.
        /// </p>
        /// </note>
        pub fn http_endpoint(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataEndpointState,
        ) -> Self {
            self.http_endpoint = Some(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
        /// <p>Default: <code>disabled</code>
        /// </p>
        pub fn http_protocol_ipv6(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataProtocolIpv6,
        ) -> Self {
            self.http_protocol_ipv6 = Some(input);
            self
        }
        pub fn set_http_protocol_ipv6(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
        ) -> Self {
            self.http_protocol_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceMetadataOptions`](crate::model::LaunchTemplateInstanceMetadataOptions)
        pub fn build(self) -> crate::model::LaunchTemplateInstanceMetadataOptions {
            crate::model::LaunchTemplateInstanceMetadataOptions {
                state: self.state,
                http_tokens: self.http_tokens,
                http_put_response_hop_limit: self.http_put_response_hop_limit,
                http_endpoint: self.http_endpoint,
                http_protocol_ipv6: self.http_protocol_ipv6,
            }
        }
    }
}
impl LaunchTemplateInstanceMetadataOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceMetadataOptions`](crate::model::LaunchTemplateInstanceMetadataOptions)
    pub fn builder() -> crate::model::launch_template_instance_metadata_options::Builder {
        crate::model::launch_template_instance_metadata_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchTemplateInstanceMetadataProtocolIpv6 {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchTemplateInstanceMetadataProtocolIpv6 {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => LaunchTemplateInstanceMetadataProtocolIpv6::Disabled,
            "enabled" => LaunchTemplateInstanceMetadataProtocolIpv6::Enabled,
            other => LaunchTemplateInstanceMetadataProtocolIpv6::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchTemplateInstanceMetadataProtocolIpv6 {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchTemplateInstanceMetadataProtocolIpv6::from(s))
    }
}
impl LaunchTemplateInstanceMetadataProtocolIpv6 {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchTemplateInstanceMetadataProtocolIpv6::Disabled => "disabled",
            LaunchTemplateInstanceMetadataProtocolIpv6::Enabled => "enabled",
            LaunchTemplateInstanceMetadataProtocolIpv6::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for LaunchTemplateInstanceMetadataProtocolIpv6 {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchTemplateInstanceMetadataEndpointState {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchTemplateInstanceMetadataEndpointState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => LaunchTemplateInstanceMetadataEndpointState::Disabled,
            "enabled" => LaunchTemplateInstanceMetadataEndpointState::Enabled,
            other => LaunchTemplateInstanceMetadataEndpointState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchTemplateInstanceMetadataEndpointState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchTemplateInstanceMetadataEndpointState::from(s))
    }
}
impl LaunchTemplateInstanceMetadataEndpointState {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchTemplateInstanceMetadataEndpointState::Disabled => "disabled",
            LaunchTemplateInstanceMetadataEndpointState::Enabled => "enabled",
            LaunchTemplateInstanceMetadataEndpointState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for LaunchTemplateInstanceMetadataEndpointState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchTemplateHttpTokensState {
    Optional,
    Required,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchTemplateHttpTokensState {
    fn from(s: &str) -> Self {
        match s {
            "optional" => LaunchTemplateHttpTokensState::Optional,
            "required" => LaunchTemplateHttpTokensState::Required,
            other => LaunchTemplateHttpTokensState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchTemplateHttpTokensState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchTemplateHttpTokensState::from(s))
    }
}
impl LaunchTemplateHttpTokensState {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchTemplateHttpTokensState::Optional => "optional",
            LaunchTemplateHttpTokensState::Required => "required",
            LaunchTemplateHttpTokensState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["optional", "required"]
    }
}
impl AsRef<str> for LaunchTemplateHttpTokensState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchTemplateInstanceMetadataOptionsState {
    Applied,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchTemplateInstanceMetadataOptionsState {
    fn from(s: &str) -> Self {
        match s {
            "applied" => LaunchTemplateInstanceMetadataOptionsState::Applied,
            "pending" => LaunchTemplateInstanceMetadataOptionsState::Pending,
            other => LaunchTemplateInstanceMetadataOptionsState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchTemplateInstanceMetadataOptionsState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchTemplateInstanceMetadataOptionsState::from(s))
    }
}
impl LaunchTemplateInstanceMetadataOptionsState {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchTemplateInstanceMetadataOptionsState::Applied => "applied",
            LaunchTemplateInstanceMetadataOptionsState::Pending => "pending",
            LaunchTemplateInstanceMetadataOptionsState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["applied", "pending"]
    }
}
impl AsRef<str> for LaunchTemplateInstanceMetadataOptionsState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Indicates whether an instance is configured for hibernation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateHibernationOptions {
    /// <p>If this parameter is set to <code>true</code>, the instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>
    pub configured: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplateHibernationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateHibernationOptions");
        formatter.field("configured", &self.configured);
        formatter.finish()
    }
}
/// See [`LaunchTemplateHibernationOptions`](crate::model::LaunchTemplateHibernationOptions)
pub mod launch_template_hibernation_options {
    /// A builder for [`LaunchTemplateHibernationOptions`](crate::model::LaunchTemplateHibernationOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If this parameter is set to <code>true</code>, the instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>
        pub fn configured(mut self, input: bool) -> Self {
            self.configured = Some(input);
            self
        }
        pub fn set_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.configured = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateHibernationOptions`](crate::model::LaunchTemplateHibernationOptions)
        pub fn build(self) -> crate::model::LaunchTemplateHibernationOptions {
            crate::model::LaunchTemplateHibernationOptions {
                configured: self.configured,
            }
        }
    }
}
impl LaunchTemplateHibernationOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateHibernationOptions`](crate::model::LaunchTemplateHibernationOptions)
    pub fn builder() -> crate::model::launch_template_hibernation_options::Builder {
        crate::model::launch_template_hibernation_options::Builder::default()
    }
}

/// <p>Describes a license configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateLicenseConfiguration {
    /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateLicenseConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateLicenseConfiguration");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`LaunchTemplateLicenseConfiguration`](crate::model::LaunchTemplateLicenseConfiguration)
pub mod launch_template_license_configuration {
    /// A builder for [`LaunchTemplateLicenseConfiguration`](crate::model::LaunchTemplateLicenseConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateLicenseConfiguration`](crate::model::LaunchTemplateLicenseConfiguration)
        pub fn build(self) -> crate::model::LaunchTemplateLicenseConfiguration {
            crate::model::LaunchTemplateLicenseConfiguration {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl LaunchTemplateLicenseConfiguration {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateLicenseConfiguration`](crate::model::LaunchTemplateLicenseConfiguration)
    pub fn builder() -> crate::model::launch_template_license_configuration::Builder {
        crate::model::launch_template_license_configuration::Builder::default()
    }
}

/// <p>Information about the Capacity Reservation targeting option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateCapacityReservationSpecificationResponse {
    /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
    /// (instance type, platform, Availability Zone).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance
    /// runs in On-Demand capacity.</p>
    /// </li>
    /// </ul>
    pub capacity_reservation_preference:
        std::option::Option<crate::model::CapacityReservationPreference>,
    /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
    pub capacity_reservation_target:
        std::option::Option<crate::model::CapacityReservationTargetResponse>,
}
impl std::fmt::Debug for LaunchTemplateCapacityReservationSpecificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("LaunchTemplateCapacityReservationSpecificationResponse");
        formatter.field(
            "capacity_reservation_preference",
            &self.capacity_reservation_preference,
        );
        formatter.field(
            "capacity_reservation_target",
            &self.capacity_reservation_target,
        );
        formatter.finish()
    }
}
/// See [`LaunchTemplateCapacityReservationSpecificationResponse`](crate::model::LaunchTemplateCapacityReservationSpecificationResponse)
pub mod launch_template_capacity_reservation_specification_response {
    /// A builder for [`LaunchTemplateCapacityReservationSpecificationResponse`](crate::model::LaunchTemplateCapacityReservationSpecificationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_preference:
            std::option::Option<crate::model::CapacityReservationPreference>,
        pub(crate) capacity_reservation_target:
            std::option::Option<crate::model::CapacityReservationTargetResponse>,
    }
    impl Builder {
        /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
        /// (instance type, platform, Availability Zone).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance
        /// runs in On-Demand capacity.</p>
        /// </li>
        /// </ul>
        pub fn capacity_reservation_preference(
            mut self,
            input: crate::model::CapacityReservationPreference,
        ) -> Self {
            self.capacity_reservation_preference = Some(input);
            self
        }
        pub fn set_capacity_reservation_preference(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationPreference>,
        ) -> Self {
            self.capacity_reservation_preference = input;
            self
        }
        /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
        pub fn capacity_reservation_target(
            mut self,
            input: crate::model::CapacityReservationTargetResponse,
        ) -> Self {
            self.capacity_reservation_target = Some(input);
            self
        }
        pub fn set_capacity_reservation_target(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTargetResponse>,
        ) -> Self {
            self.capacity_reservation_target = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateCapacityReservationSpecificationResponse`](crate::model::LaunchTemplateCapacityReservationSpecificationResponse)
        pub fn build(self) -> crate::model::LaunchTemplateCapacityReservationSpecificationResponse {
            crate::model::LaunchTemplateCapacityReservationSpecificationResponse {
                capacity_reservation_preference: self.capacity_reservation_preference,
                capacity_reservation_target: self.capacity_reservation_target,
            }
        }
    }
}
impl LaunchTemplateCapacityReservationSpecificationResponse {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateCapacityReservationSpecificationResponse`](crate::model::LaunchTemplateCapacityReservationSpecificationResponse)
    pub fn builder(
    ) -> crate::model::launch_template_capacity_reservation_specification_response::Builder {
        crate::model::launch_template_capacity_reservation_specification_response::Builder::default(
        )
    }
}

/// <p>The CPU options for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateCpuOptions {
    /// <p>The number of CPU cores for the instance.</p>
    pub core_count: std::option::Option<i32>,
    /// <p>The number of threads per CPU core.</p>
    pub threads_per_core: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateCpuOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateCpuOptions");
        formatter.field("core_count", &self.core_count);
        formatter.field("threads_per_core", &self.threads_per_core);
        formatter.finish()
    }
}
/// See [`LaunchTemplateCpuOptions`](crate::model::LaunchTemplateCpuOptions)
pub mod launch_template_cpu_options {
    /// A builder for [`LaunchTemplateCpuOptions`](crate::model::LaunchTemplateCpuOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_count: std::option::Option<i32>,
        pub(crate) threads_per_core: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of CPU cores for the instance.</p>
        pub fn core_count(mut self, input: i32) -> Self {
            self.core_count = Some(input);
            self
        }
        pub fn set_core_count(mut self, input: std::option::Option<i32>) -> Self {
            self.core_count = input;
            self
        }
        /// <p>The number of threads per CPU core.</p>
        pub fn threads_per_core(mut self, input: i32) -> Self {
            self.threads_per_core = Some(input);
            self
        }
        pub fn set_threads_per_core(mut self, input: std::option::Option<i32>) -> Self {
            self.threads_per_core = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateCpuOptions`](crate::model::LaunchTemplateCpuOptions)
        pub fn build(self) -> crate::model::LaunchTemplateCpuOptions {
            crate::model::LaunchTemplateCpuOptions {
                core_count: self.core_count,
                threads_per_core: self.threads_per_core,
            }
        }
    }
}
impl LaunchTemplateCpuOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateCpuOptions`](crate::model::LaunchTemplateCpuOptions)
    pub fn builder() -> crate::model::launch_template_cpu_options::Builder {
        crate::model::launch_template_cpu_options::Builder::default()
    }
}

/// <p>Describes the credit option for CPU usage of a T2, T3, or T3a instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreditSpecification {
    /// <p>The credit option for CPU usage of a T2, T3, or T3a instance. Valid values are
    /// <code>standard</code> and <code>unlimited</code>.</p>
    pub cpu_credits: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreditSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreditSpecification");
        formatter.field("cpu_credits", &self.cpu_credits);
        formatter.finish()
    }
}
/// See [`CreditSpecification`](crate::model::CreditSpecification)
pub mod credit_specification {
    /// A builder for [`CreditSpecification`](crate::model::CreditSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu_credits: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The credit option for CPU usage of a T2, T3, or T3a instance. Valid values are
        /// <code>standard</code> and <code>unlimited</code>.</p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_credits = Some(input.into());
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu_credits = input;
            self
        }
        /// Consumes the builder and constructs a [`CreditSpecification`](crate::model::CreditSpecification)
        pub fn build(self) -> crate::model::CreditSpecification {
            crate::model::CreditSpecification {
                cpu_credits: self.cpu_credits,
            }
        }
    }
}
impl CreditSpecification {
    /// Creates a new builder-style object to manufacture [`CreditSpecification`](crate::model::CreditSpecification)
    pub fn builder() -> crate::model::credit_specification::Builder {
        crate::model::credit_specification::Builder::default()
    }
}

/// <p>The market (purchasing) option for the instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceMarketOptions {
    /// <p>The market type.</p>
    pub market_type: std::option::Option<crate::model::MarketType>,
    /// <p>The options for Spot Instances.</p>
    pub spot_options: std::option::Option<crate::model::LaunchTemplateSpotMarketOptions>,
}
impl std::fmt::Debug for LaunchTemplateInstanceMarketOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateInstanceMarketOptions");
        formatter.field("market_type", &self.market_type);
        formatter.field("spot_options", &self.spot_options);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceMarketOptions`](crate::model::LaunchTemplateInstanceMarketOptions)
pub mod launch_template_instance_market_options {
    /// A builder for [`LaunchTemplateInstanceMarketOptions`](crate::model::LaunchTemplateInstanceMarketOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) market_type: std::option::Option<crate::model::MarketType>,
        pub(crate) spot_options: std::option::Option<crate::model::LaunchTemplateSpotMarketOptions>,
    }
    impl Builder {
        /// <p>The market type.</p>
        pub fn market_type(mut self, input: crate::model::MarketType) -> Self {
            self.market_type = Some(input);
            self
        }
        pub fn set_market_type(
            mut self,
            input: std::option::Option<crate::model::MarketType>,
        ) -> Self {
            self.market_type = input;
            self
        }
        /// <p>The options for Spot Instances.</p>
        pub fn spot_options(
            mut self,
            input: crate::model::LaunchTemplateSpotMarketOptions,
        ) -> Self {
            self.spot_options = Some(input);
            self
        }
        pub fn set_spot_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpotMarketOptions>,
        ) -> Self {
            self.spot_options = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceMarketOptions`](crate::model::LaunchTemplateInstanceMarketOptions)
        pub fn build(self) -> crate::model::LaunchTemplateInstanceMarketOptions {
            crate::model::LaunchTemplateInstanceMarketOptions {
                market_type: self.market_type,
                spot_options: self.spot_options,
            }
        }
    }
}
impl LaunchTemplateInstanceMarketOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceMarketOptions`](crate::model::LaunchTemplateInstanceMarketOptions)
    pub fn builder() -> crate::model::launch_template_instance_market_options::Builder {
        crate::model::launch_template_instance_market_options::Builder::default()
    }
}

/// <p>The options for Spot Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateSpotMarketOptions {
    /// <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
    pub max_price: std::option::Option<std::string::String>,
    /// <p>The Spot Instance request type.</p>
    pub spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
    /// <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
    pub block_duration_minutes: std::option::Option<i32>,
    /// <p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>The behavior when a Spot Instance is interrupted.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::InstanceInterruptionBehavior>,
}
impl std::fmt::Debug for LaunchTemplateSpotMarketOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateSpotMarketOptions");
        formatter.field("max_price", &self.max_price);
        formatter.field("spot_instance_type", &self.spot_instance_type);
        formatter.field("block_duration_minutes", &self.block_duration_minutes);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.finish()
    }
}
/// See [`LaunchTemplateSpotMarketOptions`](crate::model::LaunchTemplateSpotMarketOptions)
pub mod launch_template_spot_market_options {
    /// A builder for [`LaunchTemplateSpotMarketOptions`](crate::model::LaunchTemplateSpotMarketOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_price: std::option::Option<std::string::String>,
        pub(crate) spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
        pub(crate) block_duration_minutes: std::option::Option<i32>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::InstanceInterruptionBehavior>,
    }
    impl Builder {
        /// <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
        pub fn max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_price = Some(input.into());
            self
        }
        pub fn set_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_price = input;
            self
        }
        /// <p>The Spot Instance request type.</p>
        pub fn spot_instance_type(mut self, input: crate::model::SpotInstanceType) -> Self {
            self.spot_instance_type = Some(input);
            self
        }
        pub fn set_spot_instance_type(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceType>,
        ) -> Self {
            self.spot_instance_type = input;
            self
        }
        /// <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
        pub fn block_duration_minutes(mut self, input: i32) -> Self {
            self.block_duration_minutes = Some(input);
            self
        }
        pub fn set_block_duration_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.block_duration_minutes = input;
            self
        }
        /// <p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateSpotMarketOptions`](crate::model::LaunchTemplateSpotMarketOptions)
        pub fn build(self) -> crate::model::LaunchTemplateSpotMarketOptions {
            crate::model::LaunchTemplateSpotMarketOptions {
                max_price: self.max_price,
                spot_instance_type: self.spot_instance_type,
                block_duration_minutes: self.block_duration_minutes,
                valid_until: self.valid_until,
                instance_interruption_behavior: self.instance_interruption_behavior,
            }
        }
    }
}
impl LaunchTemplateSpotMarketOptions {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateSpotMarketOptions`](crate::model::LaunchTemplateSpotMarketOptions)
    pub fn builder() -> crate::model::launch_template_spot_market_options::Builder {
        crate::model::launch_template_spot_market_options::Builder::default()
    }
}

/// <p>
/// Describes an elastic inference accelerator.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateElasticInferenceAcceleratorResponse {
    /// <p>
    /// The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
    /// </p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>
    /// The number of elastic inference accelerators to attach to the instance.
    /// </p>
    /// <p>Default: 1</p>
    pub count: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateElasticInferenceAcceleratorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateElasticInferenceAcceleratorResponse");
        formatter.field("r#type", &self.r#type);
        formatter.field("count", &self.count);
        formatter.finish()
    }
}
/// See [`LaunchTemplateElasticInferenceAcceleratorResponse`](crate::model::LaunchTemplateElasticInferenceAcceleratorResponse)
pub mod launch_template_elastic_inference_accelerator_response {
    /// A builder for [`LaunchTemplateElasticInferenceAcceleratorResponse`](crate::model::LaunchTemplateElasticInferenceAcceleratorResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>
        /// The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
        /// </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>
        /// The number of elastic inference accelerators to attach to the instance.
        /// </p>
        /// <p>Default: 1</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateElasticInferenceAcceleratorResponse`](crate::model::LaunchTemplateElasticInferenceAcceleratorResponse)
        pub fn build(self) -> crate::model::LaunchTemplateElasticInferenceAcceleratorResponse {
            crate::model::LaunchTemplateElasticInferenceAcceleratorResponse {
                r#type: self.r#type,
                count: self.count,
            }
        }
    }
}
impl LaunchTemplateElasticInferenceAcceleratorResponse {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateElasticInferenceAcceleratorResponse`](crate::model::LaunchTemplateElasticInferenceAcceleratorResponse)
    pub fn builder() -> crate::model::launch_template_elastic_inference_accelerator_response::Builder
    {
        crate::model::launch_template_elastic_inference_accelerator_response::Builder::default()
    }
}

/// <p>Describes an elastic GPU.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticGpuSpecificationResponse {
    /// <p>The elastic GPU type.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ElasticGpuSpecificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticGpuSpecificationResponse");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ElasticGpuSpecificationResponse`](crate::model::ElasticGpuSpecificationResponse)
pub mod elastic_gpu_specification_response {
    /// A builder for [`ElasticGpuSpecificationResponse`](crate::model::ElasticGpuSpecificationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The elastic GPU type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticGpuSpecificationResponse`](crate::model::ElasticGpuSpecificationResponse)
        pub fn build(self) -> crate::model::ElasticGpuSpecificationResponse {
            crate::model::ElasticGpuSpecificationResponse {
                r#type: self.r#type,
            }
        }
    }
}
impl ElasticGpuSpecificationResponse {
    /// Creates a new builder-style object to manufacture [`ElasticGpuSpecificationResponse`](crate::model::ElasticGpuSpecificationResponse)
    pub fn builder() -> crate::model::elastic_gpu_specification_response::Builder {
        crate::model::elastic_gpu_specification_response::Builder::default()
    }
}

/// <p>The tag specification for the launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateTagSpecification {
    /// <p>The type of resource.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The tags for the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LaunchTemplateTagSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateTagSpecification");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LaunchTemplateTagSpecification`](crate::model::LaunchTemplateTagSpecification)
pub mod launch_template_tag_specification {
    /// A builder for [`LaunchTemplateTagSpecification`](crate::model::LaunchTemplateTagSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateTagSpecification`](crate::model::LaunchTemplateTagSpecification)
        pub fn build(self) -> crate::model::LaunchTemplateTagSpecification {
            crate::model::LaunchTemplateTagSpecification {
                resource_type: self.resource_type,
                tags: self.tags,
            }
        }
    }
}
impl LaunchTemplateTagSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateTagSpecification`](crate::model::LaunchTemplateTagSpecification)
    pub fn builder() -> crate::model::launch_template_tag_specification::Builder {
        crate::model::launch_template_tag_specification::Builder::default()
    }
}

/// <p>Describes the placement of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplatePlacement {
    /// <p>The Availability Zone of the instance.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The affinity setting for the instance on the Dedicated Host.</p>
    pub affinity: std::option::Option<std::string::String>,
    /// <p>The name of the placement group for the instance.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Dedicated Host for the instance.</p>
    pub host_id: std::option::Option<std::string::String>,
    /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. </p>
    pub tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>Reserved for future use.</p>
    pub spread_domain: std::option::Option<std::string::String>,
    /// <p>The ARN of the host resource group in which to launch the instances.
    /// </p>
    pub host_resource_group_arn: std::option::Option<std::string::String>,
    /// <p>The number of the partition the instance should launch in. Valid only if the placement group strategy is set to <code>partition</code>.</p>
    pub partition_number: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplatePlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplatePlacement");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("affinity", &self.affinity);
        formatter.field("group_name", &self.group_name);
        formatter.field("host_id", &self.host_id);
        formatter.field("tenancy", &self.tenancy);
        formatter.field("spread_domain", &self.spread_domain);
        formatter.field("host_resource_group_arn", &self.host_resource_group_arn);
        formatter.field("partition_number", &self.partition_number);
        formatter.finish()
    }
}
/// See [`LaunchTemplatePlacement`](crate::model::LaunchTemplatePlacement)
pub mod launch_template_placement {
    /// A builder for [`LaunchTemplatePlacement`](crate::model::LaunchTemplatePlacement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) affinity: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) host_id: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) spread_domain: std::option::Option<std::string::String>,
        pub(crate) host_resource_group_arn: std::option::Option<std::string::String>,
        pub(crate) partition_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Availability Zone of the instance.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The affinity setting for the instance on the Dedicated Host.</p>
        pub fn affinity(mut self, input: impl Into<std::string::String>) -> Self {
            self.affinity = Some(input.into());
            self
        }
        pub fn set_affinity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.affinity = input;
            self
        }
        /// <p>The name of the placement group for the instance.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the Dedicated Host for the instance.</p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_id = Some(input.into());
            self
        }
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_id = input;
            self
        }
        /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. </p>
        pub fn tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        pub fn set_tenancy(mut self, input: std::option::Option<crate::model::Tenancy>) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn spread_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.spread_domain = Some(input.into());
            self
        }
        pub fn set_spread_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spread_domain = input;
            self
        }
        /// <p>The ARN of the host resource group in which to launch the instances.
        /// </p>
        pub fn host_resource_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_resource_group_arn = Some(input.into());
            self
        }
        pub fn set_host_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_resource_group_arn = input;
            self
        }
        /// <p>The number of the partition the instance should launch in. Valid only if the placement group strategy is set to <code>partition</code>.</p>
        pub fn partition_number(mut self, input: i32) -> Self {
            self.partition_number = Some(input);
            self
        }
        pub fn set_partition_number(mut self, input: std::option::Option<i32>) -> Self {
            self.partition_number = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplatePlacement`](crate::model::LaunchTemplatePlacement)
        pub fn build(self) -> crate::model::LaunchTemplatePlacement {
            crate::model::LaunchTemplatePlacement {
                availability_zone: self.availability_zone,
                affinity: self.affinity,
                group_name: self.group_name,
                host_id: self.host_id,
                tenancy: self.tenancy,
                spread_domain: self.spread_domain,
                host_resource_group_arn: self.host_resource_group_arn,
                partition_number: self.partition_number,
            }
        }
    }
}
impl LaunchTemplatePlacement {
    /// Creates a new builder-style object to manufacture [`LaunchTemplatePlacement`](crate::model::LaunchTemplatePlacement)
    pub fn builder() -> crate::model::launch_template_placement::Builder {
        crate::model::launch_template_placement::Builder::default()
    }
}

/// <p>Describes the monitoring for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplatesMonitoring {
    /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
    /// enabled.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplatesMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplatesMonitoring");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`LaunchTemplatesMonitoring`](crate::model::LaunchTemplatesMonitoring)
pub mod launch_templates_monitoring {
    /// A builder for [`LaunchTemplatesMonitoring`](crate::model::LaunchTemplatesMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is
        /// enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplatesMonitoring`](crate::model::LaunchTemplatesMonitoring)
        pub fn build(self) -> crate::model::LaunchTemplatesMonitoring {
            crate::model::LaunchTemplatesMonitoring {
                enabled: self.enabled,
            }
        }
    }
}
impl LaunchTemplatesMonitoring {
    /// Creates a new builder-style object to manufacture [`LaunchTemplatesMonitoring`](crate::model::LaunchTemplatesMonitoring)
    pub fn builder() -> crate::model::launch_templates_monitoring::Builder {
        crate::model::launch_templates_monitoring::Builder::default()
    }
}

/// <p>Describes a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceNetworkInterfaceSpecification {
    /// <p>Indicates whether to associate a Carrier IP address with eth0 for a new network interface.</p>
    /// <p>Use this option when you launch an instance in a Wavelength Zone and want to associate
    /// a Carrier IP address with the network interface. For more information about Carrier IP
    /// addresses, see <a href="https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip">Carrier IP addresses</a> in the <i>Wavelength Developer
    /// Guide</i>.</p>
    pub associate_carrier_ip_address: std::option::Option<bool>,
    /// <p>Indicates whether to associate a public IPv4 address with eth0 for a new network interface.</p>
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>A description for the network interface.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The device index for the network interface attachment.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The IDs of one or more security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of network interface.</p>
    pub interface_type: std::option::Option<std::string::String>,
    /// <p>The number of IPv6 addresses for the network interface.</p>
    pub ipv6_address_count: std::option::Option<i32>,
    /// <p>The IPv6 addresses for the network interface.</p>
    pub ipv6_addresses: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The primary private IPv4 address of the network interface.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>One or more private IPv4 addresses.</p>
    pub private_ip_addresses:
        std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
    /// <p>The number of secondary private IPv4 addresses for the network interface.</p>
    pub secondary_private_ip_address_count: std::option::Option<i32>,
    /// <p>The ID of the subnet for the network interface.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The index of the network card.</p>
    pub network_card_index: std::option::Option<i32>,
    /// <p>One or more IPv4 prefixes assigned to the network interface.</p>
    pub ipv4_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationResponse>>,
    /// <p>The number of IPv4 prefixes that Amazon Web Services automatically assigned to the
    /// network interface.</p>
    pub ipv4_prefix_count: std::option::Option<i32>,
    /// <p>One or more IPv6 prefixes assigned to the network interface.</p>
    pub ipv6_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationResponse>>,
    /// <p>The number of IPv6 prefixes that Amazon Web Services automatically assigned to the network
    /// interface.</p>
    pub ipv6_prefix_count: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateInstanceNetworkInterfaceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateInstanceNetworkInterfaceSpecification");
        formatter.field(
            "associate_carrier_ip_address",
            &self.associate_carrier_ip_address,
        );
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("description", &self.description);
        formatter.field("device_index", &self.device_index);
        formatter.field("groups", &self.groups);
        formatter.field("interface_type", &self.interface_type);
        formatter.field("ipv6_address_count", &self.ipv6_address_count);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field(
            "secondary_private_ip_address_count",
            &self.secondary_private_ip_address_count,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("network_card_index", &self.network_card_index);
        formatter.field("ipv4_prefixes", &self.ipv4_prefixes);
        formatter.field("ipv4_prefix_count", &self.ipv4_prefix_count);
        formatter.field("ipv6_prefixes", &self.ipv6_prefixes);
        formatter.field("ipv6_prefix_count", &self.ipv6_prefix_count);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceNetworkInterfaceSpecification`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification)
pub mod launch_template_instance_network_interface_specification {
    /// A builder for [`LaunchTemplateInstanceNetworkInterfaceSpecification`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associate_carrier_ip_address: std::option::Option<bool>,
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) interface_type: std::option::Option<std::string::String>,
        pub(crate) ipv6_address_count: std::option::Option<i32>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        pub(crate) secondary_private_ip_address_count: std::option::Option<i32>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) network_card_index: std::option::Option<i32>,
        pub(crate) ipv4_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationResponse>>,
        pub(crate) ipv4_prefix_count: std::option::Option<i32>,
        pub(crate) ipv6_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationResponse>>,
        pub(crate) ipv6_prefix_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether to associate a Carrier IP address with eth0 for a new network interface.</p>
        /// <p>Use this option when you launch an instance in a Wavelength Zone and want to associate
        /// a Carrier IP address with the network interface. For more information about Carrier IP
        /// addresses, see <a href="https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip">Carrier IP addresses</a> in the <i>Wavelength Developer
        /// Guide</i>.</p>
        pub fn associate_carrier_ip_address(mut self, input: bool) -> Self {
            self.associate_carrier_ip_address = Some(input);
            self
        }
        pub fn set_associate_carrier_ip_address(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.associate_carrier_ip_address = input;
            self
        }
        /// <p>Indicates whether to associate a public IPv4 address with eth0 for a new network interface.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>A description for the network interface.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The device index for the network interface attachment.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The type of network interface.</p>
        pub fn interface_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_type = Some(input.into());
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interface_type = input;
            self
        }
        /// <p>The number of IPv6 addresses for the network interface.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.ipv6_address_count = Some(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_address_count = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::InstanceIpv6Address>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The primary private IPv4 address of the network interface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_addresses(
            mut self,
            input: impl Into<crate::model::PrivateIpAddressSpecification>,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.private_ip_addresses = Some(v);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>The number of secondary private IPv4 addresses for the network interface.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.secondary_private_ip_address_count = Some(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.secondary_private_ip_address_count = input;
            self
        }
        /// <p>The ID of the subnet for the network interface.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The index of the network card.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        pub fn ipv4_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv4PrefixSpecificationResponse>,
        ) -> Self {
            let mut v = self.ipv4_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv4_prefixes = Some(v);
            self
        }
        pub fn set_ipv4_prefixes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Ipv4PrefixSpecificationResponse>,
            >,
        ) -> Self {
            self.ipv4_prefixes = input;
            self
        }
        /// <p>The number of IPv4 prefixes that Amazon Web Services automatically assigned to the
        /// network interface.</p>
        pub fn ipv4_prefix_count(mut self, input: i32) -> Self {
            self.ipv4_prefix_count = Some(input);
            self
        }
        pub fn set_ipv4_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv4_prefix_count = input;
            self
        }
        pub fn ipv6_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv6PrefixSpecificationResponse>,
        ) -> Self {
            let mut v = self.ipv6_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv6_prefixes = Some(v);
            self
        }
        pub fn set_ipv6_prefixes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Ipv6PrefixSpecificationResponse>,
            >,
        ) -> Self {
            self.ipv6_prefixes = input;
            self
        }
        /// <p>The number of IPv6 prefixes that Amazon Web Services automatically assigned to the network
        /// interface.</p>
        pub fn ipv6_prefix_count(mut self, input: i32) -> Self {
            self.ipv6_prefix_count = Some(input);
            self
        }
        pub fn set_ipv6_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_prefix_count = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceNetworkInterfaceSpecification`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification)
        pub fn build(self) -> crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification {
            crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification {
                associate_carrier_ip_address: self.associate_carrier_ip_address,
                associate_public_ip_address: self.associate_public_ip_address,
                delete_on_termination: self.delete_on_termination,
                description: self.description,
                device_index: self.device_index,
                groups: self.groups,
                interface_type: self.interface_type,
                ipv6_address_count: self.ipv6_address_count,
                ipv6_addresses: self.ipv6_addresses,
                network_interface_id: self.network_interface_id,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                secondary_private_ip_address_count: self.secondary_private_ip_address_count,
                subnet_id: self.subnet_id,
                network_card_index: self.network_card_index,
                ipv4_prefixes: self.ipv4_prefixes,
                ipv4_prefix_count: self.ipv4_prefix_count,
                ipv6_prefixes: self.ipv6_prefixes,
                ipv6_prefix_count: self.ipv6_prefix_count,
            }
        }
    }
}
impl LaunchTemplateInstanceNetworkInterfaceSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceNetworkInterfaceSpecification`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecification)
    pub fn builder(
    ) -> crate::model::launch_template_instance_network_interface_specification::Builder {
        crate::model::launch_template_instance_network_interface_specification::Builder::default()
    }
}

/// <p>Information about the IPv6 delegated prefixes assigned
/// to a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6PrefixSpecificationResponse {
    /// <p>One or more IPv6 delegated prefixes assigned to the network interface.</p>
    pub ipv6_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6PrefixSpecificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6PrefixSpecificationResponse");
        formatter.field("ipv6_prefix", &self.ipv6_prefix);
        formatter.finish()
    }
}
/// See [`Ipv6PrefixSpecificationResponse`](crate::model::Ipv6PrefixSpecificationResponse)
pub mod ipv6_prefix_specification_response {
    /// A builder for [`Ipv6PrefixSpecificationResponse`](crate::model::Ipv6PrefixSpecificationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One or more IPv6 delegated prefixes assigned to the network interface.</p>
        pub fn ipv6_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_prefix = Some(input.into());
            self
        }
        pub fn set_ipv6_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6PrefixSpecificationResponse`](crate::model::Ipv6PrefixSpecificationResponse)
        pub fn build(self) -> crate::model::Ipv6PrefixSpecificationResponse {
            crate::model::Ipv6PrefixSpecificationResponse {
                ipv6_prefix: self.ipv6_prefix,
            }
        }
    }
}
impl Ipv6PrefixSpecificationResponse {
    /// Creates a new builder-style object to manufacture [`Ipv6PrefixSpecificationResponse`](crate::model::Ipv6PrefixSpecificationResponse)
    pub fn builder() -> crate::model::ipv6_prefix_specification_response::Builder {
        crate::model::ipv6_prefix_specification_response::Builder::default()
    }
}

/// <p>Information about the IPv4 delegated prefixes assigned
/// to a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv4PrefixSpecificationResponse {
    /// <p>One or more IPv4 delegated prefixes assigned to the network interface.</p>
    pub ipv4_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv4PrefixSpecificationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv4PrefixSpecificationResponse");
        formatter.field("ipv4_prefix", &self.ipv4_prefix);
        formatter.finish()
    }
}
/// See [`Ipv4PrefixSpecificationResponse`](crate::model::Ipv4PrefixSpecificationResponse)
pub mod ipv4_prefix_specification_response {
    /// A builder for [`Ipv4PrefixSpecificationResponse`](crate::model::Ipv4PrefixSpecificationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv4_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One or more IPv4 delegated prefixes assigned to the network interface.</p>
        pub fn ipv4_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_prefix = Some(input.into());
            self
        }
        pub fn set_ipv4_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv4PrefixSpecificationResponse`](crate::model::Ipv4PrefixSpecificationResponse)
        pub fn build(self) -> crate::model::Ipv4PrefixSpecificationResponse {
            crate::model::Ipv4PrefixSpecificationResponse {
                ipv4_prefix: self.ipv4_prefix,
            }
        }
    }
}
impl Ipv4PrefixSpecificationResponse {
    /// Creates a new builder-style object to manufacture [`Ipv4PrefixSpecificationResponse`](crate::model::Ipv4PrefixSpecificationResponse)
    pub fn builder() -> crate::model::ipv4_prefix_specification_response::Builder {
        crate::model::ipv4_prefix_specification_response::Builder::default()
    }
}

/// <p>Describes a block device mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateBlockDeviceMapping {
    /// <p>The device name.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The virtual device name (ephemeralN).</p>
    pub virtual_name: std::option::Option<std::string::String>,
    /// <p>Information about the block device for an EBS volume.</p>
    pub ebs: std::option::Option<crate::model::LaunchTemplateEbsBlockDevice>,
    /// <p>To omit the device from the block device mapping, specify an empty string.</p>
    pub no_device: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateBlockDeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateBlockDeviceMapping");
        formatter.field("device_name", &self.device_name);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.finish()
    }
}
/// See [`LaunchTemplateBlockDeviceMapping`](crate::model::LaunchTemplateBlockDeviceMapping)
pub mod launch_template_block_device_mapping {
    /// A builder for [`LaunchTemplateBlockDeviceMapping`](crate::model::LaunchTemplateBlockDeviceMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::LaunchTemplateEbsBlockDevice>,
        pub(crate) no_device: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The virtual device name (ephemeralN).</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// <p>Information about the block device for an EBS volume.</p>
        pub fn ebs(mut self, input: crate::model::LaunchTemplateEbsBlockDevice) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateEbsBlockDevice>,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// <p>To omit the device from the block device mapping, specify an empty string.</p>
        pub fn no_device(mut self, input: impl Into<std::string::String>) -> Self {
            self.no_device = Some(input.into());
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.no_device = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateBlockDeviceMapping`](crate::model::LaunchTemplateBlockDeviceMapping)
        pub fn build(self) -> crate::model::LaunchTemplateBlockDeviceMapping {
            crate::model::LaunchTemplateBlockDeviceMapping {
                device_name: self.device_name,
                virtual_name: self.virtual_name,
                ebs: self.ebs,
                no_device: self.no_device,
            }
        }
    }
}
impl LaunchTemplateBlockDeviceMapping {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateBlockDeviceMapping`](crate::model::LaunchTemplateBlockDeviceMapping)
    pub fn builder() -> crate::model::launch_template_block_device_mapping::Builder {
        crate::model::launch_template_block_device_mapping::Builder::default()
    }
}

/// <p>Describes a block device for an EBS volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateEbsBlockDevice {
    /// <p>Indicates whether the EBS volume is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The number of I/O operations per second (IOPS) that the volume supports. </p>
    pub iops: std::option::Option<i32>,
    /// <p>The ARN of the Key Management Service (KMS) CMK used for encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiB.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>The volume type.</p>
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>The throughput that the volume supports, in MiB/s.</p>
    pub throughput: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateEbsBlockDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateEbsBlockDevice");
        formatter.field("encrypted", &self.encrypted);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("iops", &self.iops);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("throughput", &self.throughput);
        formatter.finish()
    }
}
/// See [`LaunchTemplateEbsBlockDevice`](crate::model::LaunchTemplateEbsBlockDevice)
pub mod launch_template_ebs_block_device {
    /// A builder for [`LaunchTemplateEbsBlockDevice`](crate::model::LaunchTemplateEbsBlockDevice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether the EBS volume is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The number of I/O operations per second (IOPS) that the volume supports. </p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The ARN of the Key Management Service (KMS) CMK used for encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The size of the volume, in GiB.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>The throughput that the volume supports, in MiB/s.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateEbsBlockDevice`](crate::model::LaunchTemplateEbsBlockDevice)
        pub fn build(self) -> crate::model::LaunchTemplateEbsBlockDevice {
            crate::model::LaunchTemplateEbsBlockDevice {
                encrypted: self.encrypted,
                delete_on_termination: self.delete_on_termination,
                iops: self.iops,
                kms_key_id: self.kms_key_id,
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size,
                volume_type: self.volume_type,
                throughput: self.throughput,
            }
        }
    }
}
impl LaunchTemplateEbsBlockDevice {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateEbsBlockDevice`](crate::model::LaunchTemplateEbsBlockDevice)
    pub fn builder() -> crate::model::launch_template_ebs_block_device::Builder {
        crate::model::launch_template_ebs_block_device::Builder::default()
    }
}

/// <p>Describes an IAM instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateIamInstanceProfileSpecification {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the instance profile.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateIamInstanceProfileSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateIamInstanceProfileSpecification");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`LaunchTemplateIamInstanceProfileSpecification`](crate::model::LaunchTemplateIamInstanceProfileSpecification)
pub mod launch_template_iam_instance_profile_specification {
    /// A builder for [`LaunchTemplateIamInstanceProfileSpecification`](crate::model::LaunchTemplateIamInstanceProfileSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the instance profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateIamInstanceProfileSpecification`](crate::model::LaunchTemplateIamInstanceProfileSpecification)
        pub fn build(self) -> crate::model::LaunchTemplateIamInstanceProfileSpecification {
            crate::model::LaunchTemplateIamInstanceProfileSpecification {
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl LaunchTemplateIamInstanceProfileSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateIamInstanceProfileSpecification`](crate::model::LaunchTemplateIamInstanceProfileSpecification)
    pub fn builder() -> crate::model::launch_template_iam_instance_profile_specification::Builder {
        crate::model::launch_template_iam_instance_profile_specification::Builder::default()
    }
}

/// <p>Describes a resource group to which a Capacity Reservation has been added.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationGroup {
    /// <p>The ARN of the resource group.</p>
    pub group_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the resource group.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CapacityReservationGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationGroup");
        formatter.field("group_arn", &self.group_arn);
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`CapacityReservationGroup`](crate::model::CapacityReservationGroup)
pub mod capacity_reservation_group {
    /// A builder for [`CapacityReservationGroup`](crate::model::CapacityReservationGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource group.</p>
        pub fn group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_arn = Some(input.into());
            self
        }
        pub fn set_group_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_arn = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the resource group.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationGroup`](crate::model::CapacityReservationGroup)
        pub fn build(self) -> crate::model::CapacityReservationGroup {
            crate::model::CapacityReservationGroup {
                group_arn: self.group_arn,
                owner_id: self.owner_id,
            }
        }
    }
}
impl CapacityReservationGroup {
    /// Creates a new builder-style object to manufacture [`CapacityReservationGroup`](crate::model::CapacityReservationGroup)
    pub fn builder() -> crate::model::capacity_reservation_group::Builder {
        crate::model::capacity_reservation_group::Builder::default()
    }
}

/// <p>Describes service integrations with VPC Flow logs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegrateServices {
    /// <p>Information about the integration with Amazon Athena.</p>
    pub athena_integrations: std::option::Option<std::vec::Vec<crate::model::AthenaIntegration>>,
}
impl std::fmt::Debug for IntegrateServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegrateServices");
        formatter.field("athena_integrations", &self.athena_integrations);
        formatter.finish()
    }
}
/// See [`IntegrateServices`](crate::model::IntegrateServices)
pub mod integrate_services {
    /// A builder for [`IntegrateServices`](crate::model::IntegrateServices)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) athena_integrations:
            std::option::Option<std::vec::Vec<crate::model::AthenaIntegration>>,
    }
    impl Builder {
        pub fn athena_integrations(
            mut self,
            input: impl Into<crate::model::AthenaIntegration>,
        ) -> Self {
            let mut v = self.athena_integrations.unwrap_or_default();
            v.push(input.into());
            self.athena_integrations = Some(v);
            self
        }
        pub fn set_athena_integrations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AthenaIntegration>>,
        ) -> Self {
            self.athena_integrations = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegrateServices`](crate::model::IntegrateServices)
        pub fn build(self) -> crate::model::IntegrateServices {
            crate::model::IntegrateServices {
                athena_integrations: self.athena_integrations,
            }
        }
    }
}
impl IntegrateServices {
    /// Creates a new builder-style object to manufacture [`IntegrateServices`](crate::model::IntegrateServices)
    pub fn builder() -> crate::model::integrate_services::Builder {
        crate::model::integrate_services::Builder::default()
    }
}

/// <p>Describes integration options for Amazon Athena.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AthenaIntegration {
    /// <p>The location in Amazon S3 to store the generated CloudFormation template.</p>
    pub integration_result_s3_destination_arn: std::option::Option<std::string::String>,
    /// <p>The schedule for adding new partitions to the table.</p>
    pub partition_load_frequency: std::option::Option<crate::model::PartitionLoadFrequency>,
    /// <p>The start date for the partition.</p>
    pub partition_start_date: std::option::Option<smithy_types::Instant>,
    /// <p>The end date for the partition.</p>
    pub partition_end_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for AthenaIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AthenaIntegration");
        formatter.field(
            "integration_result_s3_destination_arn",
            &self.integration_result_s3_destination_arn,
        );
        formatter.field("partition_load_frequency", &self.partition_load_frequency);
        formatter.field("partition_start_date", &self.partition_start_date);
        formatter.field("partition_end_date", &self.partition_end_date);
        formatter.finish()
    }
}
/// See [`AthenaIntegration`](crate::model::AthenaIntegration)
pub mod athena_integration {
    /// A builder for [`AthenaIntegration`](crate::model::AthenaIntegration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integration_result_s3_destination_arn: std::option::Option<std::string::String>,
        pub(crate) partition_load_frequency:
            std::option::Option<crate::model::PartitionLoadFrequency>,
        pub(crate) partition_start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) partition_end_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The location in Amazon S3 to store the generated CloudFormation template.</p>
        pub fn integration_result_s3_destination_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.integration_result_s3_destination_arn = Some(input.into());
            self
        }
        pub fn set_integration_result_s3_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.integration_result_s3_destination_arn = input;
            self
        }
        /// <p>The schedule for adding new partitions to the table.</p>
        pub fn partition_load_frequency(
            mut self,
            input: crate::model::PartitionLoadFrequency,
        ) -> Self {
            self.partition_load_frequency = Some(input);
            self
        }
        pub fn set_partition_load_frequency(
            mut self,
            input: std::option::Option<crate::model::PartitionLoadFrequency>,
        ) -> Self {
            self.partition_load_frequency = input;
            self
        }
        /// <p>The start date for the partition.</p>
        pub fn partition_start_date(mut self, input: smithy_types::Instant) -> Self {
            self.partition_start_date = Some(input);
            self
        }
        pub fn set_partition_start_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.partition_start_date = input;
            self
        }
        /// <p>The end date for the partition.</p>
        pub fn partition_end_date(mut self, input: smithy_types::Instant) -> Self {
            self.partition_end_date = Some(input);
            self
        }
        pub fn set_partition_end_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.partition_end_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaIntegration`](crate::model::AthenaIntegration)
        pub fn build(self) -> crate::model::AthenaIntegration {
            crate::model::AthenaIntegration {
                integration_result_s3_destination_arn: self.integration_result_s3_destination_arn,
                partition_load_frequency: self.partition_load_frequency,
                partition_start_date: self.partition_start_date,
                partition_end_date: self.partition_end_date,
            }
        }
    }
}
impl AthenaIntegration {
    /// Creates a new builder-style object to manufacture [`AthenaIntegration`](crate::model::AthenaIntegration)
    pub fn builder() -> crate::model::athena_integration::Builder {
        crate::model::athena_integration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartitionLoadFrequency {
    Daily,
    Monthly,
    None,
    Weekly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PartitionLoadFrequency {
    fn from(s: &str) -> Self {
        match s {
            "daily" => PartitionLoadFrequency::Daily,
            "monthly" => PartitionLoadFrequency::Monthly,
            "none" => PartitionLoadFrequency::None,
            "weekly" => PartitionLoadFrequency::Weekly,
            other => PartitionLoadFrequency::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PartitionLoadFrequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartitionLoadFrequency::from(s))
    }
}
impl PartitionLoadFrequency {
    pub fn as_str(&self) -> &str {
        match self {
            PartitionLoadFrequency::Daily => "daily",
            PartitionLoadFrequency::Monthly => "monthly",
            PartitionLoadFrequency::None => "none",
            PartitionLoadFrequency::Weekly => "weekly",
            PartitionLoadFrequency::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["daily", "monthly", "none", "weekly"]
    }
}
impl AsRef<str> for PartitionLoadFrequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes address usage for a customer-owned address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoipAddressUsage {
    /// <p>The allocation ID of the address.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The AWS account ID.</p>
    pub aws_account_id: std::option::Option<std::string::String>,
    /// <p>The AWS service.</p>
    pub aws_service: std::option::Option<std::string::String>,
    /// <p>The customer-owned IP address.</p>
    pub co_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CoipAddressUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoipAddressUsage");
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("aws_account_id", &self.aws_account_id);
        formatter.field("aws_service", &self.aws_service);
        formatter.field("co_ip", &self.co_ip);
        formatter.finish()
    }
}
/// See [`CoipAddressUsage`](crate::model::CoipAddressUsage)
pub mod coip_address_usage {
    /// A builder for [`CoipAddressUsage`](crate::model::CoipAddressUsage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
        pub(crate) aws_service: std::option::Option<std::string::String>,
        pub(crate) co_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The allocation ID of the address.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The AWS account ID.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// <p>The AWS service.</p>
        pub fn aws_service(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_service = Some(input.into());
            self
        }
        pub fn set_aws_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_service = input;
            self
        }
        /// <p>The customer-owned IP address.</p>
        pub fn co_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.co_ip = Some(input.into());
            self
        }
        pub fn set_co_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.co_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`CoipAddressUsage`](crate::model::CoipAddressUsage)
        pub fn build(self) -> crate::model::CoipAddressUsage {
            crate::model::CoipAddressUsage {
                allocation_id: self.allocation_id,
                aws_account_id: self.aws_account_id,
                aws_service: self.aws_service,
                co_ip: self.co_ip,
            }
        }
    }
}
impl CoipAddressUsage {
    /// Creates a new builder-style object to manufacture [`CoipAddressUsage`](crate::model::CoipAddressUsage)
    pub fn builder() -> crate::model::coip_address_usage::Builder {
        crate::model::coip_address_usage::Builder::default()
    }
}

/// <p>Information about the Capacity Reservation usage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceUsage {
    /// <p>The ID of the Amazon Web Services account that is making use of the Capacity Reservation.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The number of instances the Amazon Web Services account currently has in the Capacity Reservation.</p>
    pub used_instance_count: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceUsage");
        formatter.field("account_id", &self.account_id);
        formatter.field("used_instance_count", &self.used_instance_count);
        formatter.finish()
    }
}
/// See [`InstanceUsage`](crate::model::InstanceUsage)
pub mod instance_usage {
    /// A builder for [`InstanceUsage`](crate::model::InstanceUsage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) used_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the Amazon Web Services account that is making use of the Capacity Reservation.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The number of instances the Amazon Web Services account currently has in the Capacity Reservation.</p>
        pub fn used_instance_count(mut self, input: i32) -> Self {
            self.used_instance_count = Some(input);
            self
        }
        pub fn set_used_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.used_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceUsage`](crate::model::InstanceUsage)
        pub fn build(self) -> crate::model::InstanceUsage {
            crate::model::InstanceUsage {
                account_id: self.account_id,
                used_instance_count: self.used_instance_count,
            }
        }
    }
}
impl InstanceUsage {
    /// Creates a new builder-style object to manufacture [`InstanceUsage`](crate::model::InstanceUsage)
    pub fn builder() -> crate::model::instance_usage::Builder {
        crate::model::instance_usage::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacityReservationState {
    Active,
    Cancelled,
    Expired,
    Failed,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacityReservationState {
    fn from(s: &str) -> Self {
        match s {
            "active" => CapacityReservationState::Active,
            "cancelled" => CapacityReservationState::Cancelled,
            "expired" => CapacityReservationState::Expired,
            "failed" => CapacityReservationState::Failed,
            "pending" => CapacityReservationState::Pending,
            other => CapacityReservationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacityReservationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacityReservationState::from(s))
    }
}
impl CapacityReservationState {
    pub fn as_str(&self) -> &str {
        match self {
            CapacityReservationState::Active => "active",
            CapacityReservationState::Cancelled => "cancelled",
            CapacityReservationState::Expired => "expired",
            CapacityReservationState::Failed => "failed",
            CapacityReservationState::Pending => "pending",
            CapacityReservationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "expired", "failed", "pending"]
    }
}
impl AsRef<str> for CapacityReservationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IPv6 CIDR block association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6CidrAssociation {
    /// <p>The IPv6 CIDR block.</p>
    pub ipv6_cidr: std::option::Option<std::string::String>,
    /// <p>The resource that's associated with the IPv6 CIDR block.</p>
    pub associated_resource: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6CidrAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6CidrAssociation");
        formatter.field("ipv6_cidr", &self.ipv6_cidr);
        formatter.field("associated_resource", &self.associated_resource);
        formatter.finish()
    }
}
/// See [`Ipv6CidrAssociation`](crate::model::Ipv6CidrAssociation)
pub mod ipv6_cidr_association {
    /// A builder for [`Ipv6CidrAssociation`](crate::model::Ipv6CidrAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_cidr: std::option::Option<std::string::String>,
        pub(crate) associated_resource: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 CIDR block.</p>
        pub fn ipv6_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr = Some(input.into());
            self
        }
        pub fn set_ipv6_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_cidr = input;
            self
        }
        /// <p>The resource that's associated with the IPv6 CIDR block.</p>
        pub fn associated_resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_resource = Some(input.into());
            self
        }
        pub fn set_associated_resource(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6CidrAssociation`](crate::model::Ipv6CidrAssociation)
        pub fn build(self) -> crate::model::Ipv6CidrAssociation {
            crate::model::Ipv6CidrAssociation {
                ipv6_cidr: self.ipv6_cidr,
                associated_resource: self.associated_resource,
            }
        }
    }
}
impl Ipv6CidrAssociation {
    /// Creates a new builder-style object to manufacture [`Ipv6CidrAssociation`](crate::model::Ipv6CidrAssociation)
    pub fn builder() -> crate::model::ipv6_cidr_association::Builder {
        crate::model::ipv6_cidr_association::Builder::default()
    }
}

/// <p>Information about the associated IAM roles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatedRole {
    /// <p>The ARN of the associated IAM role.</p>
    pub associated_role_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon S3 bucket in which the Amazon S3 object is stored.</p>
    pub certificate_s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The key of the Amazon S3 object ey where the certificate, certificate chain, and encrypted private key bundle
    /// is stored. The object key is formated as follows:  <code>role_arn</code>/<code>certificate_arn</code>.
    /// </p>
    pub certificate_s3_object_key: std::option::Option<std::string::String>,
    /// <p>The ID of the KMS customer master key (CMK) used to encrypt the private key.</p>
    pub encryption_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociatedRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatedRole");
        formatter.field("associated_role_arn", &self.associated_role_arn);
        formatter.field(
            "certificate_s3_bucket_name",
            &self.certificate_s3_bucket_name,
        );
        formatter.field("certificate_s3_object_key", &self.certificate_s3_object_key);
        formatter.field("encryption_kms_key_id", &self.encryption_kms_key_id);
        formatter.finish()
    }
}
/// See [`AssociatedRole`](crate::model::AssociatedRole)
pub mod associated_role {
    /// A builder for [`AssociatedRole`](crate::model::AssociatedRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associated_role_arn: std::option::Option<std::string::String>,
        pub(crate) certificate_s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) certificate_s3_object_key: std::option::Option<std::string::String>,
        pub(crate) encryption_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the associated IAM role.</p>
        pub fn associated_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_role_arn = Some(input.into());
            self
        }
        pub fn set_associated_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_role_arn = input;
            self
        }
        /// <p>The name of the Amazon S3 bucket in which the Amazon S3 object is stored.</p>
        pub fn certificate_s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_s3_bucket_name = Some(input.into());
            self
        }
        pub fn set_certificate_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_s3_bucket_name = input;
            self
        }
        /// <p>The key of the Amazon S3 object ey where the certificate, certificate chain, and encrypted private key bundle
        /// is stored. The object key is formated as follows:  <code>role_arn</code>/<code>certificate_arn</code>.
        /// </p>
        pub fn certificate_s3_object_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_s3_object_key = Some(input.into());
            self
        }
        pub fn set_certificate_s3_object_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_s3_object_key = input;
            self
        }
        /// <p>The ID of the KMS customer master key (CMK) used to encrypt the private key.</p>
        pub fn encryption_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_kms_key_id = Some(input.into());
            self
        }
        pub fn set_encryption_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatedRole`](crate::model::AssociatedRole)
        pub fn build(self) -> crate::model::AssociatedRole {
            crate::model::AssociatedRole {
                associated_role_arn: self.associated_role_arn,
                certificate_s3_bucket_name: self.certificate_s3_bucket_name,
                certificate_s3_object_key: self.certificate_s3_object_key,
                encryption_kms_key_id: self.encryption_kms_key_id,
            }
        }
    }
}
impl AssociatedRole {
    /// Creates a new builder-style object to manufacture [`AssociatedRole`](crate::model::AssociatedRole)
    pub fn builder() -> crate::model::associated_role::Builder {
        crate::model::associated_role::Builder::default()
    }
}

/// <p>Describes the destination for an export image task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskS3Location {
    /// <p>The destination Amazon S3 bucket.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The prefix (logical hierarchy) in the bucket.</p>
    pub s3_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskS3Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskS3Location");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_prefix", &self.s3_prefix);
        formatter.finish()
    }
}
/// See [`ExportTaskS3Location`](crate::model::ExportTaskS3Location)
pub mod export_task_s3_location {
    /// A builder for [`ExportTaskS3Location`](crate::model::ExportTaskS3Location)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination Amazon S3 bucket.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The prefix (logical hierarchy) in the bucket.</p>
        pub fn s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(input.into());
            self
        }
        pub fn set_s3_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskS3Location`](crate::model::ExportTaskS3Location)
        pub fn build(self) -> crate::model::ExportTaskS3Location {
            crate::model::ExportTaskS3Location {
                s3_bucket: self.s3_bucket,
                s3_prefix: self.s3_prefix,
            }
        }
    }
}
impl ExportTaskS3Location {
    /// Creates a new builder-style object to manufacture [`ExportTaskS3Location`](crate::model::ExportTaskS3Location)
    pub fn builder() -> crate::model::export_task_s3_location::Builder {
        crate::model::export_task_s3_location::Builder::default()
    }
}

/// <p>Describes the destination for an export image task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskS3LocationRequest {
    /// <p>The destination Amazon S3 bucket.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The prefix (logical hierarchy) in the bucket.</p>
    pub s3_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskS3LocationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskS3LocationRequest");
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_prefix", &self.s3_prefix);
        formatter.finish()
    }
}
/// See [`ExportTaskS3LocationRequest`](crate::model::ExportTaskS3LocationRequest)
pub mod export_task_s3_location_request {
    /// A builder for [`ExportTaskS3LocationRequest`](crate::model::ExportTaskS3LocationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination Amazon S3 bucket.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The prefix (logical hierarchy) in the bucket.</p>
        pub fn s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(input.into());
            self
        }
        pub fn set_s3_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskS3LocationRequest`](crate::model::ExportTaskS3LocationRequest)
        pub fn build(self) -> crate::model::ExportTaskS3LocationRequest {
            crate::model::ExportTaskS3LocationRequest {
                s3_bucket: self.s3_bucket,
                s3_prefix: self.s3_prefix,
            }
        }
    }
}
impl ExportTaskS3LocationRequest {
    /// Creates a new builder-style object to manufacture [`ExportTaskS3LocationRequest`](crate::model::ExportTaskS3LocationRequest)
    pub fn builder() -> crate::model::export_task_s3_location_request::Builder {
        crate::model::export_task_s3_location_request::Builder::default()
    }
}

/// <p>Describes the state of a client certificate revocation list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientCertificateRevocationListStatus {
    /// <p>The state of the client certificate revocation list.</p>
    pub code: std::option::Option<crate::model::ClientCertificateRevocationListStatusCode>,
    /// <p>A message about the status of the client certificate revocation list, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientCertificateRevocationListStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientCertificateRevocationListStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientCertificateRevocationListStatus`](crate::model::ClientCertificateRevocationListStatus)
pub mod client_certificate_revocation_list_status {
    /// A builder for [`ClientCertificateRevocationListStatus`](crate::model::ClientCertificateRevocationListStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code:
            std::option::Option<crate::model::ClientCertificateRevocationListStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the client certificate revocation list.</p>
        pub fn code(
            mut self,
            input: crate::model::ClientCertificateRevocationListStatusCode,
        ) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientCertificateRevocationListStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the client certificate revocation list, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientCertificateRevocationListStatus`](crate::model::ClientCertificateRevocationListStatus)
        pub fn build(self) -> crate::model::ClientCertificateRevocationListStatus {
            crate::model::ClientCertificateRevocationListStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientCertificateRevocationListStatus {
    /// Creates a new builder-style object to manufacture [`ClientCertificateRevocationListStatus`](crate::model::ClientCertificateRevocationListStatus)
    pub fn builder() -> crate::model::client_certificate_revocation_list_status::Builder {
        crate::model::client_certificate_revocation_list_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientCertificateRevocationListStatusCode {
    Active,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientCertificateRevocationListStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => ClientCertificateRevocationListStatusCode::Active,
            "pending" => ClientCertificateRevocationListStatusCode::Pending,
            other => ClientCertificateRevocationListStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientCertificateRevocationListStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientCertificateRevocationListStatusCode::from(s))
    }
}
impl ClientCertificateRevocationListStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientCertificateRevocationListStatusCode::Active => "active",
            ClientCertificateRevocationListStatusCode::Pending => "pending",
            ClientCertificateRevocationListStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "pending"]
    }
}
impl AsRef<str> for ClientCertificateRevocationListStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes route propagation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayPropagation {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The ID of the transit gateway route table.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The state.</p>
    pub state: std::option::Option<crate::model::TransitGatewayPropagationState>,
}
impl std::fmt::Debug for TransitGatewayPropagation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayPropagation");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayPropagation`](crate::model::TransitGatewayPropagation)
pub mod transit_gateway_propagation {
    /// A builder for [`TransitGatewayPropagation`](crate::model::TransitGatewayPropagation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayPropagationState>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The state.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayPropagationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayPropagationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayPropagation`](crate::model::TransitGatewayPropagation)
        pub fn build(self) -> crate::model::TransitGatewayPropagation {
            crate::model::TransitGatewayPropagation {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayPropagation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayPropagation`](crate::model::TransitGatewayPropagation)
    pub fn builder() -> crate::model::transit_gateway_propagation::Builder {
        crate::model::transit_gateway_propagation::Builder::default()
    }
}

/// <p>Contains information about the errors that occurred when enabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableFastSnapshotRestoreErrorItem {
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The errors.</p>
    pub fast_snapshot_restore_state_errors:
        std::option::Option<std::vec::Vec<crate::model::EnableFastSnapshotRestoreStateErrorItem>>,
}
impl std::fmt::Debug for EnableFastSnapshotRestoreErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableFastSnapshotRestoreErrorItem");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field(
            "fast_snapshot_restore_state_errors",
            &self.fast_snapshot_restore_state_errors,
        );
        formatter.finish()
    }
}
/// See [`EnableFastSnapshotRestoreErrorItem`](crate::model::EnableFastSnapshotRestoreErrorItem)
pub mod enable_fast_snapshot_restore_error_item {
    /// A builder for [`EnableFastSnapshotRestoreErrorItem`](crate::model::EnableFastSnapshotRestoreErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) fast_snapshot_restore_state_errors: std::option::Option<
            std::vec::Vec<crate::model::EnableFastSnapshotRestoreStateErrorItem>,
        >,
    }
    impl Builder {
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        pub fn fast_snapshot_restore_state_errors(
            mut self,
            input: impl Into<crate::model::EnableFastSnapshotRestoreStateErrorItem>,
        ) -> Self {
            let mut v = self.fast_snapshot_restore_state_errors.unwrap_or_default();
            v.push(input.into());
            self.fast_snapshot_restore_state_errors = Some(v);
            self
        }
        pub fn set_fast_snapshot_restore_state_errors(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::EnableFastSnapshotRestoreStateErrorItem>,
            >,
        ) -> Self {
            self.fast_snapshot_restore_state_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableFastSnapshotRestoreErrorItem`](crate::model::EnableFastSnapshotRestoreErrorItem)
        pub fn build(self) -> crate::model::EnableFastSnapshotRestoreErrorItem {
            crate::model::EnableFastSnapshotRestoreErrorItem {
                snapshot_id: self.snapshot_id,
                fast_snapshot_restore_state_errors: self.fast_snapshot_restore_state_errors,
            }
        }
    }
}
impl EnableFastSnapshotRestoreErrorItem {
    /// Creates a new builder-style object to manufacture [`EnableFastSnapshotRestoreErrorItem`](crate::model::EnableFastSnapshotRestoreErrorItem)
    pub fn builder() -> crate::model::enable_fast_snapshot_restore_error_item::Builder {
        crate::model::enable_fast_snapshot_restore_error_item::Builder::default()
    }
}

/// <p>Contains information about an error that occurred when enabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableFastSnapshotRestoreStateErrorItem {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The error.</p>
    pub error: std::option::Option<crate::model::EnableFastSnapshotRestoreStateError>,
}
impl std::fmt::Debug for EnableFastSnapshotRestoreStateErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableFastSnapshotRestoreStateErrorItem");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`EnableFastSnapshotRestoreStateErrorItem`](crate::model::EnableFastSnapshotRestoreStateErrorItem)
pub mod enable_fast_snapshot_restore_state_error_item {
    /// A builder for [`EnableFastSnapshotRestoreStateErrorItem`](crate::model::EnableFastSnapshotRestoreStateErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::EnableFastSnapshotRestoreStateError>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The error.</p>
        pub fn error(mut self, input: crate::model::EnableFastSnapshotRestoreStateError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::EnableFastSnapshotRestoreStateError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableFastSnapshotRestoreStateErrorItem`](crate::model::EnableFastSnapshotRestoreStateErrorItem)
        pub fn build(self) -> crate::model::EnableFastSnapshotRestoreStateErrorItem {
            crate::model::EnableFastSnapshotRestoreStateErrorItem {
                availability_zone: self.availability_zone,
                error: self.error,
            }
        }
    }
}
impl EnableFastSnapshotRestoreStateErrorItem {
    /// Creates a new builder-style object to manufacture [`EnableFastSnapshotRestoreStateErrorItem`](crate::model::EnableFastSnapshotRestoreStateErrorItem)
    pub fn builder() -> crate::model::enable_fast_snapshot_restore_state_error_item::Builder {
        crate::model::enable_fast_snapshot_restore_state_error_item::Builder::default()
    }
}

/// <p>Describes an error that occurred when enabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableFastSnapshotRestoreStateError {
    /// <p>The error code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EnableFastSnapshotRestoreStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableFastSnapshotRestoreStateError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`EnableFastSnapshotRestoreStateError`](crate::model::EnableFastSnapshotRestoreStateError)
pub mod enable_fast_snapshot_restore_state_error {
    /// A builder for [`EnableFastSnapshotRestoreStateError`](crate::model::EnableFastSnapshotRestoreStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableFastSnapshotRestoreStateError`](crate::model::EnableFastSnapshotRestoreStateError)
        pub fn build(self) -> crate::model::EnableFastSnapshotRestoreStateError {
            crate::model::EnableFastSnapshotRestoreStateError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl EnableFastSnapshotRestoreStateError {
    /// Creates a new builder-style object to manufacture [`EnableFastSnapshotRestoreStateError`](crate::model::EnableFastSnapshotRestoreStateError)
    pub fn builder() -> crate::model::enable_fast_snapshot_restore_state_error::Builder {
        crate::model::enable_fast_snapshot_restore_state_error::Builder::default()
    }
}

/// <p>Describes fast snapshot restores that were successfully enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableFastSnapshotRestoreSuccessItem {
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The state of fast snapshot restores.</p>
    pub state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
    /// <p>The reason for the state transition. The possible values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
    /// <code>disabling</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
    /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
    /// </li>
    /// </ul>
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
    pub owner_alias: std::option::Option<std::string::String>,
    /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
    pub enabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
    pub optimizing_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
    pub enabled_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
    pub disabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
    pub disabled_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for EnableFastSnapshotRestoreSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableFastSnapshotRestoreSuccessItem");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.field("enabling_time", &self.enabling_time);
        formatter.field("optimizing_time", &self.optimizing_time);
        formatter.field("enabled_time", &self.enabled_time);
        formatter.field("disabling_time", &self.disabling_time);
        formatter.field("disabled_time", &self.disabled_time);
        formatter.finish()
    }
}
/// See [`EnableFastSnapshotRestoreSuccessItem`](crate::model::EnableFastSnapshotRestoreSuccessItem)
pub mod enable_fast_snapshot_restore_success_item {
    /// A builder for [`EnableFastSnapshotRestoreSuccessItem`](crate::model::EnableFastSnapshotRestoreSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        pub(crate) state_transition_reason: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
        pub(crate) enabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) optimizing_time: std::option::Option<smithy_types::Instant>,
        pub(crate) enabled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabled_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The state of fast snapshot restores.</p>
        pub fn state(mut self, input: crate::model::FastSnapshotRestoreStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the state transition. The possible values are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
        /// <code>disabling</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
        /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
        /// </li>
        /// </ul>
        pub fn state_transition_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_transition_reason = Some(input.into());
            self
        }
        pub fn set_state_transition_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_transition_reason = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
        pub fn enabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabling_time = Some(input);
            self
        }
        pub fn set_enabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
        pub fn optimizing_time(mut self, input: smithy_types::Instant) -> Self {
            self.optimizing_time = Some(input);
            self
        }
        pub fn set_optimizing_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.optimizing_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
        pub fn enabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabled_time = Some(input);
            self
        }
        pub fn set_enabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabled_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
        pub fn disabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabling_time = Some(input);
            self
        }
        pub fn set_disabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
        pub fn disabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabled_time = Some(input);
            self
        }
        pub fn set_disabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabled_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableFastSnapshotRestoreSuccessItem`](crate::model::EnableFastSnapshotRestoreSuccessItem)
        pub fn build(self) -> crate::model::EnableFastSnapshotRestoreSuccessItem {
            crate::model::EnableFastSnapshotRestoreSuccessItem {
                snapshot_id: self.snapshot_id,
                availability_zone: self.availability_zone,
                state: self.state,
                state_transition_reason: self.state_transition_reason,
                owner_id: self.owner_id,
                owner_alias: self.owner_alias,
                enabling_time: self.enabling_time,
                optimizing_time: self.optimizing_time,
                enabled_time: self.enabled_time,
                disabling_time: self.disabling_time,
                disabled_time: self.disabled_time,
            }
        }
    }
}
impl EnableFastSnapshotRestoreSuccessItem {
    /// Creates a new builder-style object to manufacture [`EnableFastSnapshotRestoreSuccessItem`](crate::model::EnableFastSnapshotRestoreSuccessItem)
    pub fn builder() -> crate::model::enable_fast_snapshot_restore_success_item::Builder {
        crate::model::enable_fast_snapshot_restore_success_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FastSnapshotRestoreStateCode {
    Disabled,
    Disabling,
    Enabled,
    Enabling,
    Optimizing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FastSnapshotRestoreStateCode {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => FastSnapshotRestoreStateCode::Disabled,
            "disabling" => FastSnapshotRestoreStateCode::Disabling,
            "enabled" => FastSnapshotRestoreStateCode::Enabled,
            "enabling" => FastSnapshotRestoreStateCode::Enabling,
            "optimizing" => FastSnapshotRestoreStateCode::Optimizing,
            other => FastSnapshotRestoreStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FastSnapshotRestoreStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FastSnapshotRestoreStateCode::from(s))
    }
}
impl FastSnapshotRestoreStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            FastSnapshotRestoreStateCode::Disabled => "disabled",
            FastSnapshotRestoreStateCode::Disabling => "disabling",
            FastSnapshotRestoreStateCode::Enabled => "enabled",
            FastSnapshotRestoreStateCode::Enabling => "enabling",
            FastSnapshotRestoreStateCode::Optimizing => "optimizing",
            FastSnapshotRestoreStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "disabling", "enabled", "enabling", "optimizing"]
    }
}
impl AsRef<str> for FastSnapshotRestoreStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IPv4 CIDR block associated with a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcCidrBlockAssociation {
    /// <p>The association ID for the IPv4 CIDR block.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 CIDR block.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the state of the CIDR block.</p>
    pub cidr_block_state: std::option::Option<crate::model::VpcCidrBlockState>,
}
impl std::fmt::Debug for VpcCidrBlockAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcCidrBlockAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("cidr_block_state", &self.cidr_block_state);
        formatter.finish()
    }
}
/// See [`VpcCidrBlockAssociation`](crate::model::VpcCidrBlockAssociation)
pub mod vpc_cidr_block_association {
    /// A builder for [`VpcCidrBlockAssociation`](crate::model::VpcCidrBlockAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) cidr_block_state: std::option::Option<crate::model::VpcCidrBlockState>,
    }
    impl Builder {
        /// <p>The association ID for the IPv4 CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The IPv4 CIDR block.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Information about the state of the CIDR block.</p>
        pub fn cidr_block_state(mut self, input: crate::model::VpcCidrBlockState) -> Self {
            self.cidr_block_state = Some(input);
            self
        }
        pub fn set_cidr_block_state(
            mut self,
            input: std::option::Option<crate::model::VpcCidrBlockState>,
        ) -> Self {
            self.cidr_block_state = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcCidrBlockAssociation`](crate::model::VpcCidrBlockAssociation)
        pub fn build(self) -> crate::model::VpcCidrBlockAssociation {
            crate::model::VpcCidrBlockAssociation {
                association_id: self.association_id,
                cidr_block: self.cidr_block,
                cidr_block_state: self.cidr_block_state,
            }
        }
    }
}
impl VpcCidrBlockAssociation {
    /// Creates a new builder-style object to manufacture [`VpcCidrBlockAssociation`](crate::model::VpcCidrBlockAssociation)
    pub fn builder() -> crate::model::vpc_cidr_block_association::Builder {
        crate::model::vpc_cidr_block_association::Builder::default()
    }
}

/// <p>Describes the state of a CIDR block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcCidrBlockState {
    /// <p>The state of the CIDR block.</p>
    pub state: std::option::Option<crate::model::VpcCidrBlockStateCode>,
    /// <p>A message about the status of the CIDR block, if applicable.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcCidrBlockState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcCidrBlockState");
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`VpcCidrBlockState`](crate::model::VpcCidrBlockState)
pub mod vpc_cidr_block_state {
    /// A builder for [`VpcCidrBlockState`](crate::model::VpcCidrBlockState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::VpcCidrBlockStateCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the CIDR block.</p>
        pub fn state(mut self, input: crate::model::VpcCidrBlockStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VpcCidrBlockStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>A message about the status of the CIDR block, if applicable.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcCidrBlockState`](crate::model::VpcCidrBlockState)
        pub fn build(self) -> crate::model::VpcCidrBlockState {
            crate::model::VpcCidrBlockState {
                state: self.state,
                status_message: self.status_message,
            }
        }
    }
}
impl VpcCidrBlockState {
    /// Creates a new builder-style object to manufacture [`VpcCidrBlockState`](crate::model::VpcCidrBlockState)
    pub fn builder() -> crate::model::vpc_cidr_block_state::Builder {
        crate::model::vpc_cidr_block_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcCidrBlockStateCode {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    Failed,
    Failing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcCidrBlockStateCode {
    fn from(s: &str) -> Self {
        match s {
            "associated" => VpcCidrBlockStateCode::Associated,
            "associating" => VpcCidrBlockStateCode::Associating,
            "disassociated" => VpcCidrBlockStateCode::Disassociated,
            "disassociating" => VpcCidrBlockStateCode::Disassociating,
            "failed" => VpcCidrBlockStateCode::Failed,
            "failing" => VpcCidrBlockStateCode::Failing,
            other => VpcCidrBlockStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcCidrBlockStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcCidrBlockStateCode::from(s))
    }
}
impl VpcCidrBlockStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            VpcCidrBlockStateCode::Associated => "associated",
            VpcCidrBlockStateCode::Associating => "associating",
            VpcCidrBlockStateCode::Disassociated => "disassociated",
            VpcCidrBlockStateCode::Disassociating => "disassociating",
            VpcCidrBlockStateCode::Failed => "failed",
            VpcCidrBlockStateCode::Failing => "failing",
            VpcCidrBlockStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
            "failed",
            "failing",
        ]
    }
}
impl AsRef<str> for VpcCidrBlockStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IPv6 CIDR block associated with a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcIpv6CidrBlockAssociation {
    /// <p>The association ID for the IPv6 CIDR block.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR block.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the state of the CIDR block.</p>
    pub ipv6_cidr_block_state: std::option::Option<crate::model::VpcCidrBlockState>,
    /// <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from
    /// which AWS advertises IP addresses, for example, <code>us-east-1-wl1-bos-wlz-1</code>.</p>
    pub network_border_group: std::option::Option<std::string::String>,
    /// <p>The ID of the IPv6 address pool from which the IPv6 CIDR block is allocated.</p>
    pub ipv6_pool: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcIpv6CidrBlockAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcIpv6CidrBlockAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.field("ipv6_cidr_block_state", &self.ipv6_cidr_block_state);
        formatter.field("network_border_group", &self.network_border_group);
        formatter.field("ipv6_pool", &self.ipv6_pool);
        formatter.finish()
    }
}
/// See [`VpcIpv6CidrBlockAssociation`](crate::model::VpcIpv6CidrBlockAssociation)
pub mod vpc_ipv6_cidr_block_association {
    /// A builder for [`VpcIpv6CidrBlockAssociation`](crate::model::VpcIpv6CidrBlockAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block_state: std::option::Option<crate::model::VpcCidrBlockState>,
        pub(crate) network_border_group: std::option::Option<std::string::String>,
        pub(crate) ipv6_pool: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association ID for the IPv6 CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The IPv6 CIDR block.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// <p>Information about the state of the CIDR block.</p>
        pub fn ipv6_cidr_block_state(mut self, input: crate::model::VpcCidrBlockState) -> Self {
            self.ipv6_cidr_block_state = Some(input);
            self
        }
        pub fn set_ipv6_cidr_block_state(
            mut self,
            input: std::option::Option<crate::model::VpcCidrBlockState>,
        ) -> Self {
            self.ipv6_cidr_block_state = input;
            self
        }
        /// <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from
        /// which AWS advertises IP addresses, for example, <code>us-east-1-wl1-bos-wlz-1</code>.</p>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_border_group = Some(input.into());
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_border_group = input;
            self
        }
        /// <p>The ID of the IPv6 address pool from which the IPv6 CIDR block is allocated.</p>
        pub fn ipv6_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_pool = Some(input.into());
            self
        }
        pub fn set_ipv6_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_pool = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcIpv6CidrBlockAssociation`](crate::model::VpcIpv6CidrBlockAssociation)
        pub fn build(self) -> crate::model::VpcIpv6CidrBlockAssociation {
            crate::model::VpcIpv6CidrBlockAssociation {
                association_id: self.association_id,
                ipv6_cidr_block: self.ipv6_cidr_block,
                ipv6_cidr_block_state: self.ipv6_cidr_block_state,
                network_border_group: self.network_border_group,
                ipv6_pool: self.ipv6_pool,
            }
        }
    }
}
impl VpcIpv6CidrBlockAssociation {
    /// Creates a new builder-style object to manufacture [`VpcIpv6CidrBlockAssociation`](crate::model::VpcIpv6CidrBlockAssociation)
    pub fn builder() -> crate::model::vpc_ipv6_cidr_block_association::Builder {
        crate::model::vpc_ipv6_cidr_block_association::Builder::default()
    }
}

/// <p>Describes an association between a resource attachment and a transit gateway route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayAssociation {
    /// <p>The ID of the transit gateway route table.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAssociationState>,
}
impl std::fmt::Debug for TransitGatewayAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayAssociation");
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayAssociation`](crate::model::TransitGatewayAssociation)
pub mod transit_gateway_association {
    /// A builder for [`TransitGatewayAssociation`](crate::model::TransitGatewayAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAssociationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayAssociation`](crate::model::TransitGatewayAssociation)
        pub fn build(self) -> crate::model::TransitGatewayAssociation {
            crate::model::TransitGatewayAssociation {
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayAssociation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayAssociation`](crate::model::TransitGatewayAssociation)
    pub fn builder() -> crate::model::transit_gateway_association::Builder {
        crate::model::transit_gateway_association::Builder::default()
    }
}

/// <p>Describes an IPv6 CIDR block associated with a subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetIpv6CidrBlockAssociation {
    /// <p>The association ID for the CIDR block.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR block.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the state of the CIDR block.</p>
    pub ipv6_cidr_block_state: std::option::Option<crate::model::SubnetCidrBlockState>,
}
impl std::fmt::Debug for SubnetIpv6CidrBlockAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetIpv6CidrBlockAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.field("ipv6_cidr_block_state", &self.ipv6_cidr_block_state);
        formatter.finish()
    }
}
/// See [`SubnetIpv6CidrBlockAssociation`](crate::model::SubnetIpv6CidrBlockAssociation)
pub mod subnet_ipv6_cidr_block_association {
    /// A builder for [`SubnetIpv6CidrBlockAssociation`](crate::model::SubnetIpv6CidrBlockAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block_state: std::option::Option<crate::model::SubnetCidrBlockState>,
    }
    impl Builder {
        /// <p>The association ID for the CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The IPv6 CIDR block.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// <p>Information about the state of the CIDR block.</p>
        pub fn ipv6_cidr_block_state(mut self, input: crate::model::SubnetCidrBlockState) -> Self {
            self.ipv6_cidr_block_state = Some(input);
            self
        }
        pub fn set_ipv6_cidr_block_state(
            mut self,
            input: std::option::Option<crate::model::SubnetCidrBlockState>,
        ) -> Self {
            self.ipv6_cidr_block_state = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetIpv6CidrBlockAssociation`](crate::model::SubnetIpv6CidrBlockAssociation)
        pub fn build(self) -> crate::model::SubnetIpv6CidrBlockAssociation {
            crate::model::SubnetIpv6CidrBlockAssociation {
                association_id: self.association_id,
                ipv6_cidr_block: self.ipv6_cidr_block,
                ipv6_cidr_block_state: self.ipv6_cidr_block_state,
            }
        }
    }
}
impl SubnetIpv6CidrBlockAssociation {
    /// Creates a new builder-style object to manufacture [`SubnetIpv6CidrBlockAssociation`](crate::model::SubnetIpv6CidrBlockAssociation)
    pub fn builder() -> crate::model::subnet_ipv6_cidr_block_association::Builder {
        crate::model::subnet_ipv6_cidr_block_association::Builder::default()
    }
}

/// <p>Describes the state of a CIDR block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetCidrBlockState {
    /// <p>The state of a CIDR block.</p>
    pub state: std::option::Option<crate::model::SubnetCidrBlockStateCode>,
    /// <p>A message about the status of the CIDR block, if applicable.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetCidrBlockState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetCidrBlockState");
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`SubnetCidrBlockState`](crate::model::SubnetCidrBlockState)
pub mod subnet_cidr_block_state {
    /// A builder for [`SubnetCidrBlockState`](crate::model::SubnetCidrBlockState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::SubnetCidrBlockStateCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of a CIDR block.</p>
        pub fn state(mut self, input: crate::model::SubnetCidrBlockStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::SubnetCidrBlockStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>A message about the status of the CIDR block, if applicable.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetCidrBlockState`](crate::model::SubnetCidrBlockState)
        pub fn build(self) -> crate::model::SubnetCidrBlockState {
            crate::model::SubnetCidrBlockState {
                state: self.state,
                status_message: self.status_message,
            }
        }
    }
}
impl SubnetCidrBlockState {
    /// Creates a new builder-style object to manufacture [`SubnetCidrBlockState`](crate::model::SubnetCidrBlockState)
    pub fn builder() -> crate::model::subnet_cidr_block_state::Builder {
        crate::model::subnet_cidr_block_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubnetCidrBlockStateCode {
    Associated,
    Associating,
    Disassociated,
    Disassociating,
    Failed,
    Failing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubnetCidrBlockStateCode {
    fn from(s: &str) -> Self {
        match s {
            "associated" => SubnetCidrBlockStateCode::Associated,
            "associating" => SubnetCidrBlockStateCode::Associating,
            "disassociated" => SubnetCidrBlockStateCode::Disassociated,
            "disassociating" => SubnetCidrBlockStateCode::Disassociating,
            "failed" => SubnetCidrBlockStateCode::Failed,
            "failing" => SubnetCidrBlockStateCode::Failing,
            other => SubnetCidrBlockStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubnetCidrBlockStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubnetCidrBlockStateCode::from(s))
    }
}
impl SubnetCidrBlockStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            SubnetCidrBlockStateCode::Associated => "associated",
            SubnetCidrBlockStateCode::Associating => "associating",
            SubnetCidrBlockStateCode::Disassociated => "disassociated",
            SubnetCidrBlockStateCode::Disassociating => "disassociating",
            SubnetCidrBlockStateCode::Failed => "failed",
            SubnetCidrBlockStateCode::Failing => "failing",
            SubnetCidrBlockStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "disassociated",
            "disassociating",
            "failed",
            "failing",
        ]
    }
}
impl AsRef<str> for SubnetCidrBlockStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The targets to disassociate from the specified event window.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowDisassociationRequest {
    /// <p>The IDs of the instances to disassociate from the event window.</p>
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance tags to disassociate from the event window. Any instances associated with
    /// the tags will be disassociated from the event window.</p>
    pub instance_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The IDs of the Dedicated Hosts to disassociate from the event window.</p>
    pub dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InstanceEventWindowDisassociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowDisassociationRequest");
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("instance_tags", &self.instance_tags);
        formatter.field("dedicated_host_ids", &self.dedicated_host_ids);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowDisassociationRequest`](crate::model::InstanceEventWindowDisassociationRequest)
pub mod instance_event_window_disassociation_request {
    /// A builder for [`InstanceEventWindowDisassociationRequest`](crate::model::InstanceEventWindowDisassociationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        pub fn instance_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.instance_tags.unwrap_or_default();
            v.push(input.into());
            self.instance_tags = Some(v);
            self
        }
        pub fn set_instance_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.instance_tags = input;
            self
        }
        pub fn dedicated_host_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dedicated_host_ids.unwrap_or_default();
            v.push(input.into());
            self.dedicated_host_ids = Some(v);
            self
        }
        pub fn set_dedicated_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dedicated_host_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowDisassociationRequest`](crate::model::InstanceEventWindowDisassociationRequest)
        pub fn build(self) -> crate::model::InstanceEventWindowDisassociationRequest {
            crate::model::InstanceEventWindowDisassociationRequest {
                instance_ids: self.instance_ids,
                instance_tags: self.instance_tags,
                dedicated_host_ids: self.dedicated_host_ids,
            }
        }
    }
}
impl InstanceEventWindowDisassociationRequest {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowDisassociationRequest`](crate::model::InstanceEventWindowDisassociationRequest)
    pub fn builder() -> crate::model::instance_event_window_disassociation_request::Builder {
        crate::model::instance_event_window_disassociation_request::Builder::default()
    }
}

/// <p>Describes the state of a target network association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationStatus {
    /// <p>The state of the target network association.</p>
    pub code: std::option::Option<crate::model::AssociationStatusCode>,
    /// <p>A message about the status of the target network association, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AssociationStatus`](crate::model::AssociationStatus)
pub mod association_status {
    /// A builder for [`AssociationStatus`](crate::model::AssociationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::AssociationStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the target network association.</p>
        pub fn code(mut self, input: crate::model::AssociationStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::AssociationStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the target network association, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationStatus`](crate::model::AssociationStatus)
        pub fn build(self) -> crate::model::AssociationStatus {
            crate::model::AssociationStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl AssociationStatus {
    /// Creates a new builder-style object to manufacture [`AssociationStatus`](crate::model::AssociationStatus)
    pub fn builder() -> crate::model::association_status::Builder {
        crate::model::association_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationStatusCode {
    Associated,
    Associating,
    AssociationFailed,
    Disassociated,
    Disassociating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "associated" => AssociationStatusCode::Associated,
            "associating" => AssociationStatusCode::Associating,
            "association-failed" => AssociationStatusCode::AssociationFailed,
            "disassociated" => AssociationStatusCode::Disassociated,
            "disassociating" => AssociationStatusCode::Disassociating,
            other => AssociationStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociationStatusCode::from(s))
    }
}
impl AssociationStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationStatusCode::Associated => "associated",
            AssociationStatusCode::Associating => "associating",
            AssociationStatusCode::AssociationFailed => "association-failed",
            AssociationStatusCode::Disassociated => "disassociated",
            AssociationStatusCode::Disassociating => "disassociating",
            AssociationStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "associated",
            "associating",
            "association-failed",
            "disassociated",
            "disassociating",
        ]
    }
}
impl AsRef<str> for AssociationStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about the errors that occurred when disabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableFastSnapshotRestoreErrorItem {
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The errors.</p>
    pub fast_snapshot_restore_state_errors:
        std::option::Option<std::vec::Vec<crate::model::DisableFastSnapshotRestoreStateErrorItem>>,
}
impl std::fmt::Debug for DisableFastSnapshotRestoreErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableFastSnapshotRestoreErrorItem");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field(
            "fast_snapshot_restore_state_errors",
            &self.fast_snapshot_restore_state_errors,
        );
        formatter.finish()
    }
}
/// See [`DisableFastSnapshotRestoreErrorItem`](crate::model::DisableFastSnapshotRestoreErrorItem)
pub mod disable_fast_snapshot_restore_error_item {
    /// A builder for [`DisableFastSnapshotRestoreErrorItem`](crate::model::DisableFastSnapshotRestoreErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) fast_snapshot_restore_state_errors: std::option::Option<
            std::vec::Vec<crate::model::DisableFastSnapshotRestoreStateErrorItem>,
        >,
    }
    impl Builder {
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        pub fn fast_snapshot_restore_state_errors(
            mut self,
            input: impl Into<crate::model::DisableFastSnapshotRestoreStateErrorItem>,
        ) -> Self {
            let mut v = self.fast_snapshot_restore_state_errors.unwrap_or_default();
            v.push(input.into());
            self.fast_snapshot_restore_state_errors = Some(v);
            self
        }
        pub fn set_fast_snapshot_restore_state_errors(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DisableFastSnapshotRestoreStateErrorItem>,
            >,
        ) -> Self {
            self.fast_snapshot_restore_state_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableFastSnapshotRestoreErrorItem`](crate::model::DisableFastSnapshotRestoreErrorItem)
        pub fn build(self) -> crate::model::DisableFastSnapshotRestoreErrorItem {
            crate::model::DisableFastSnapshotRestoreErrorItem {
                snapshot_id: self.snapshot_id,
                fast_snapshot_restore_state_errors: self.fast_snapshot_restore_state_errors,
            }
        }
    }
}
impl DisableFastSnapshotRestoreErrorItem {
    /// Creates a new builder-style object to manufacture [`DisableFastSnapshotRestoreErrorItem`](crate::model::DisableFastSnapshotRestoreErrorItem)
    pub fn builder() -> crate::model::disable_fast_snapshot_restore_error_item::Builder {
        crate::model::disable_fast_snapshot_restore_error_item::Builder::default()
    }
}

/// <p>Contains information about an error that occurred when disabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableFastSnapshotRestoreStateErrorItem {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The error.</p>
    pub error: std::option::Option<crate::model::DisableFastSnapshotRestoreStateError>,
}
impl std::fmt::Debug for DisableFastSnapshotRestoreStateErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableFastSnapshotRestoreStateErrorItem");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
/// See [`DisableFastSnapshotRestoreStateErrorItem`](crate::model::DisableFastSnapshotRestoreStateErrorItem)
pub mod disable_fast_snapshot_restore_state_error_item {
    /// A builder for [`DisableFastSnapshotRestoreStateErrorItem`](crate::model::DisableFastSnapshotRestoreStateErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::DisableFastSnapshotRestoreStateError>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The error.</p>
        pub fn error(mut self, input: crate::model::DisableFastSnapshotRestoreStateError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::DisableFastSnapshotRestoreStateError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableFastSnapshotRestoreStateErrorItem`](crate::model::DisableFastSnapshotRestoreStateErrorItem)
        pub fn build(self) -> crate::model::DisableFastSnapshotRestoreStateErrorItem {
            crate::model::DisableFastSnapshotRestoreStateErrorItem {
                availability_zone: self.availability_zone,
                error: self.error,
            }
        }
    }
}
impl DisableFastSnapshotRestoreStateErrorItem {
    /// Creates a new builder-style object to manufacture [`DisableFastSnapshotRestoreStateErrorItem`](crate::model::DisableFastSnapshotRestoreStateErrorItem)
    pub fn builder() -> crate::model::disable_fast_snapshot_restore_state_error_item::Builder {
        crate::model::disable_fast_snapshot_restore_state_error_item::Builder::default()
    }
}

/// <p>Describes an error that occurred when disabling fast snapshot restores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableFastSnapshotRestoreStateError {
    /// <p>The error code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisableFastSnapshotRestoreStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableFastSnapshotRestoreStateError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DisableFastSnapshotRestoreStateError`](crate::model::DisableFastSnapshotRestoreStateError)
pub mod disable_fast_snapshot_restore_state_error {
    /// A builder for [`DisableFastSnapshotRestoreStateError`](crate::model::DisableFastSnapshotRestoreStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableFastSnapshotRestoreStateError`](crate::model::DisableFastSnapshotRestoreStateError)
        pub fn build(self) -> crate::model::DisableFastSnapshotRestoreStateError {
            crate::model::DisableFastSnapshotRestoreStateError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl DisableFastSnapshotRestoreStateError {
    /// Creates a new builder-style object to manufacture [`DisableFastSnapshotRestoreStateError`](crate::model::DisableFastSnapshotRestoreStateError)
    pub fn builder() -> crate::model::disable_fast_snapshot_restore_state_error::Builder {
        crate::model::disable_fast_snapshot_restore_state_error::Builder::default()
    }
}

/// <p>Describes fast snapshot restores that were successfully disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableFastSnapshotRestoreSuccessItem {
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The state of fast snapshot restores for the snapshot.</p>
    pub state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
    /// <p>The reason for the state transition. The possible values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
    /// <code>disabling</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
    /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
    /// </li>
    /// </ul>
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
    pub owner_alias: std::option::Option<std::string::String>,
    /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
    pub enabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
    pub optimizing_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
    pub enabled_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
    pub disabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
    pub disabled_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DisableFastSnapshotRestoreSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableFastSnapshotRestoreSuccessItem");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.field("enabling_time", &self.enabling_time);
        formatter.field("optimizing_time", &self.optimizing_time);
        formatter.field("enabled_time", &self.enabled_time);
        formatter.field("disabling_time", &self.disabling_time);
        formatter.field("disabled_time", &self.disabled_time);
        formatter.finish()
    }
}
/// See [`DisableFastSnapshotRestoreSuccessItem`](crate::model::DisableFastSnapshotRestoreSuccessItem)
pub mod disable_fast_snapshot_restore_success_item {
    /// A builder for [`DisableFastSnapshotRestoreSuccessItem`](crate::model::DisableFastSnapshotRestoreSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        pub(crate) state_transition_reason: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
        pub(crate) enabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) optimizing_time: std::option::Option<smithy_types::Instant>,
        pub(crate) enabled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabled_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The state of fast snapshot restores for the snapshot.</p>
        pub fn state(mut self, input: crate::model::FastSnapshotRestoreStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the state transition. The possible values are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
        /// <code>disabling</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
        /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
        /// </li>
        /// </ul>
        pub fn state_transition_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_transition_reason = Some(input.into());
            self
        }
        pub fn set_state_transition_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_transition_reason = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
        pub fn enabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabling_time = Some(input);
            self
        }
        pub fn set_enabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
        pub fn optimizing_time(mut self, input: smithy_types::Instant) -> Self {
            self.optimizing_time = Some(input);
            self
        }
        pub fn set_optimizing_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.optimizing_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
        pub fn enabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabled_time = Some(input);
            self
        }
        pub fn set_enabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabled_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
        pub fn disabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabling_time = Some(input);
            self
        }
        pub fn set_disabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
        pub fn disabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabled_time = Some(input);
            self
        }
        pub fn set_disabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabled_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableFastSnapshotRestoreSuccessItem`](crate::model::DisableFastSnapshotRestoreSuccessItem)
        pub fn build(self) -> crate::model::DisableFastSnapshotRestoreSuccessItem {
            crate::model::DisableFastSnapshotRestoreSuccessItem {
                snapshot_id: self.snapshot_id,
                availability_zone: self.availability_zone,
                state: self.state,
                state_transition_reason: self.state_transition_reason,
                owner_id: self.owner_id,
                owner_alias: self.owner_alias,
                enabling_time: self.enabling_time,
                optimizing_time: self.optimizing_time,
                enabled_time: self.enabled_time,
                disabling_time: self.disabling_time,
                disabled_time: self.disabled_time,
            }
        }
    }
}
impl DisableFastSnapshotRestoreSuccessItem {
    /// Creates a new builder-style object to manufacture [`DisableFastSnapshotRestoreSuccessItem`](crate::model::DisableFastSnapshotRestoreSuccessItem)
    pub fn builder() -> crate::model::disable_fast_snapshot_restore_success_item::Builder {
        crate::model::disable_fast_snapshot_restore_success_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeAttachmentState {
    Attached,
    Attaching,
    Busy,
    Detached,
    Detaching,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeAttachmentState {
    fn from(s: &str) -> Self {
        match s {
            "attached" => VolumeAttachmentState::Attached,
            "attaching" => VolumeAttachmentState::Attaching,
            "busy" => VolumeAttachmentState::Busy,
            "detached" => VolumeAttachmentState::Detached,
            "detaching" => VolumeAttachmentState::Detaching,
            other => VolumeAttachmentState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeAttachmentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeAttachmentState::from(s))
    }
}
impl VolumeAttachmentState {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeAttachmentState::Attached => "attached",
            VolumeAttachmentState::Attaching => "attaching",
            VolumeAttachmentState::Busy => "busy",
            VolumeAttachmentState::Detached => "detached",
            VolumeAttachmentState::Detaching => "detaching",
            VolumeAttachmentState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["attached", "attaching", "busy", "detached", "detaching"]
    }
}
impl AsRef<str> for VolumeAttachmentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a virtual private gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnGateway {
    /// <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The current state of the virtual private gateway.</p>
    pub state: std::option::Option<crate::model::VpnState>,
    /// <p>The type of VPN connection the virtual private gateway supports.</p>
    pub r#type: std::option::Option<crate::model::GatewayType>,
    /// <p>Any VPCs attached to the virtual private gateway.</p>
    pub vpc_attachments: std::option::Option<std::vec::Vec<crate::model::VpcAttachment>>,
    /// <p>The ID of the virtual private gateway.</p>
    pub vpn_gateway_id: std::option::Option<std::string::String>,
    /// <p>The private Autonomous System Number (ASN) for the Amazon side of a BGP session.</p>
    pub amazon_side_asn: std::option::Option<i64>,
    /// <p>Any tags assigned to the virtual private gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for VpnGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnGateway");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("state", &self.state);
        formatter.field("r#type", &self.r#type);
        formatter.field("vpc_attachments", &self.vpc_attachments);
        formatter.field("vpn_gateway_id", &self.vpn_gateway_id);
        formatter.field("amazon_side_asn", &self.amazon_side_asn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`VpnGateway`](crate::model::VpnGateway)
pub mod vpn_gateway {
    /// A builder for [`VpnGateway`](crate::model::VpnGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VpnState>,
        pub(crate) r#type: std::option::Option<crate::model::GatewayType>,
        pub(crate) vpc_attachments: std::option::Option<std::vec::Vec<crate::model::VpcAttachment>>,
        pub(crate) vpn_gateway_id: std::option::Option<std::string::String>,
        pub(crate) amazon_side_asn: std::option::Option<i64>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The current state of the virtual private gateway.</p>
        pub fn state(mut self, input: crate::model::VpnState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::VpnState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The type of VPN connection the virtual private gateway supports.</p>
        pub fn r#type(mut self, input: crate::model::GatewayType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::GatewayType>) -> Self {
            self.r#type = input;
            self
        }
        pub fn vpc_attachments(mut self, input: impl Into<crate::model::VpcAttachment>) -> Self {
            let mut v = self.vpc_attachments.unwrap_or_default();
            v.push(input.into());
            self.vpc_attachments = Some(v);
            self
        }
        pub fn set_vpc_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcAttachment>>,
        ) -> Self {
            self.vpc_attachments = input;
            self
        }
        /// <p>The ID of the virtual private gateway.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_gateway_id = Some(input.into());
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_gateway_id = input;
            self
        }
        /// <p>The private Autonomous System Number (ASN) for the Amazon side of a BGP session.</p>
        pub fn amazon_side_asn(mut self, input: i64) -> Self {
            self.amazon_side_asn = Some(input);
            self
        }
        pub fn set_amazon_side_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.amazon_side_asn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnGateway`](crate::model::VpnGateway)
        pub fn build(self) -> crate::model::VpnGateway {
            crate::model::VpnGateway {
                availability_zone: self.availability_zone,
                state: self.state,
                r#type: self.r#type,
                vpc_attachments: self.vpc_attachments,
                vpn_gateway_id: self.vpn_gateway_id,
                amazon_side_asn: self.amazon_side_asn,
                tags: self.tags,
            }
        }
    }
}
impl VpnGateway {
    /// Creates a new builder-style object to manufacture [`VpnGateway`](crate::model::VpnGateway)
    pub fn builder() -> crate::model::vpn_gateway::Builder {
        crate::model::vpn_gateway::Builder::default()
    }
}

/// <p>Describes an attachment between a virtual private gateway and a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcAttachment {
    /// <p>The current state of the attachment.</p>
    pub state: std::option::Option<crate::model::AttachmentStatus>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcAttachment");
        formatter.field("state", &self.state);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`VpcAttachment`](crate::model::VpcAttachment)
pub mod vpc_attachment {
    /// A builder for [`VpcAttachment`](crate::model::VpcAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AttachmentStatus>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of the attachment.</p>
        pub fn state(mut self, input: crate::model::AttachmentStatus) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AttachmentStatus>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcAttachment`](crate::model::VpcAttachment)
        pub fn build(self) -> crate::model::VpcAttachment {
            crate::model::VpcAttachment {
                state: self.state,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl VpcAttachment {
    /// Creates a new builder-style object to manufacture [`VpcAttachment`](crate::model::VpcAttachment)
    pub fn builder() -> crate::model::vpc_attachment::Builder {
        crate::model::vpc_attachment::Builder::default()
    }
}

/// <p>Describes a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Vpc {
    /// <p>The primary IPv4 CIDR block for the VPC.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>The ID of the set of DHCP options you've associated with the VPC.</p>
    pub dhcp_options_id: std::option::Option<std::string::String>,
    /// <p>The current state of the VPC.</p>
    pub state: std::option::Option<crate::model::VpcState>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The allowed tenancy of instances launched into the VPC.</p>
    pub instance_tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
    pub ipv6_cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::VpcIpv6CidrBlockAssociation>>,
    /// <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
    pub cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::VpcCidrBlockAssociation>>,
    /// <p>Indicates whether the VPC is the default VPC.</p>
    pub is_default: std::option::Option<bool>,
    /// <p>Any tags assigned to the VPC.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Vpc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Vpc");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("dhcp_options_id", &self.dhcp_options_id);
        formatter.field("state", &self.state);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("instance_tenancy", &self.instance_tenancy);
        formatter.field(
            "ipv6_cidr_block_association_set",
            &self.ipv6_cidr_block_association_set,
        );
        formatter.field(
            "cidr_block_association_set",
            &self.cidr_block_association_set,
        );
        formatter.field("is_default", &self.is_default);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Vpc`](crate::model::Vpc)
pub mod vpc {
    /// A builder for [`Vpc`](crate::model::Vpc)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) dhcp_options_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VpcState>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) instance_tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) ipv6_cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::VpcIpv6CidrBlockAssociation>>,
        pub(crate) cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::VpcCidrBlockAssociation>>,
        pub(crate) is_default: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The primary IPv4 CIDR block for the VPC.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>The ID of the set of DHCP options you've associated with the VPC.</p>
        pub fn dhcp_options_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dhcp_options_id = Some(input.into());
            self
        }
        pub fn set_dhcp_options_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dhcp_options_id = input;
            self
        }
        /// <p>The current state of the VPC.</p>
        pub fn state(mut self, input: crate::model::VpcState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::VpcState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The allowed tenancy of instances launched into the VPC.</p>
        pub fn instance_tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.instance_tenancy = Some(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::Tenancy>,
        ) -> Self {
            self.instance_tenancy = input;
            self
        }
        pub fn ipv6_cidr_block_association_set(
            mut self,
            input: impl Into<crate::model::VpcIpv6CidrBlockAssociation>,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_association_set.unwrap_or_default();
            v.push(input.into());
            self.ipv6_cidr_block_association_set = Some(v);
            self
        }
        pub fn set_ipv6_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcIpv6CidrBlockAssociation>>,
        ) -> Self {
            self.ipv6_cidr_block_association_set = input;
            self
        }
        pub fn cidr_block_association_set(
            mut self,
            input: impl Into<crate::model::VpcCidrBlockAssociation>,
        ) -> Self {
            let mut v = self.cidr_block_association_set.unwrap_or_default();
            v.push(input.into());
            self.cidr_block_association_set = Some(v);
            self
        }
        pub fn set_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcCidrBlockAssociation>>,
        ) -> Self {
            self.cidr_block_association_set = input;
            self
        }
        /// <p>Indicates whether the VPC is the default VPC.</p>
        pub fn is_default(mut self, input: bool) -> Self {
            self.is_default = Some(input);
            self
        }
        pub fn set_is_default(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Vpc`](crate::model::Vpc)
        pub fn build(self) -> crate::model::Vpc {
            crate::model::Vpc {
                cidr_block: self.cidr_block,
                dhcp_options_id: self.dhcp_options_id,
                state: self.state,
                vpc_id: self.vpc_id,
                owner_id: self.owner_id,
                instance_tenancy: self.instance_tenancy,
                ipv6_cidr_block_association_set: self.ipv6_cidr_block_association_set,
                cidr_block_association_set: self.cidr_block_association_set,
                is_default: self.is_default,
                tags: self.tags,
            }
        }
    }
}
impl Vpc {
    /// Creates a new builder-style object to manufacture [`Vpc`](crate::model::Vpc)
    pub fn builder() -> crate::model::vpc::Builder {
        crate::model::vpc::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcState {
    Available,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcState {
    fn from(s: &str) -> Self {
        match s {
            "available" => VpcState::Available,
            "pending" => VpcState::Pending,
            other => VpcState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcState::from(s))
    }
}
impl VpcState {
    pub fn as_str(&self) -> &str {
        match self {
            VpcState::Available => "available",
            VpcState::Pending => "pending",
            VpcState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "pending"]
    }
}
impl AsRef<str> for VpcState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a VPC peering connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcPeeringConnection {
    /// <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
    pub accepter_vpc_info: std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
    /// <p>The time that an unaccepted VPC peering connection will expire.</p>
    pub expiration_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
    pub requester_vpc_info: std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
    /// <p>The status of the VPC peering connection.</p>
    pub status: std::option::Option<crate::model::VpcPeeringConnectionStateReason>,
    /// <p>Any tags assigned to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC peering connection.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcPeeringConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcPeeringConnection");
        formatter.field("accepter_vpc_info", &self.accepter_vpc_info);
        formatter.field("expiration_time", &self.expiration_time);
        formatter.field("requester_vpc_info", &self.requester_vpc_info);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`VpcPeeringConnection`](crate::model::VpcPeeringConnection)
pub mod vpc_peering_connection {
    /// A builder for [`VpcPeeringConnection`](crate::model::VpcPeeringConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepter_vpc_info:
            std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
        pub(crate) expiration_time: std::option::Option<smithy_types::Instant>,
        pub(crate) requester_vpc_info:
            std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
        pub(crate) status: std::option::Option<crate::model::VpcPeeringConnectionStateReason>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
        pub fn accepter_vpc_info(
            mut self,
            input: crate::model::VpcPeeringConnectionVpcInfo,
        ) -> Self {
            self.accepter_vpc_info = Some(input);
            self
        }
        pub fn set_accepter_vpc_info(
            mut self,
            input: std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
        ) -> Self {
            self.accepter_vpc_info = input;
            self
        }
        /// <p>The time that an unaccepted VPC peering connection will expire.</p>
        pub fn expiration_time(mut self, input: smithy_types::Instant) -> Self {
            self.expiration_time = Some(input);
            self
        }
        pub fn set_expiration_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.expiration_time = input;
            self
        }
        /// <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
        pub fn requester_vpc_info(
            mut self,
            input: crate::model::VpcPeeringConnectionVpcInfo,
        ) -> Self {
            self.requester_vpc_info = Some(input);
            self
        }
        pub fn set_requester_vpc_info(
            mut self,
            input: std::option::Option<crate::model::VpcPeeringConnectionVpcInfo>,
        ) -> Self {
            self.requester_vpc_info = input;
            self
        }
        /// <p>The status of the VPC peering connection.</p>
        pub fn status(mut self, input: crate::model::VpcPeeringConnectionStateReason) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VpcPeeringConnectionStateReason>,
        ) -> Self {
            self.status = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcPeeringConnection`](crate::model::VpcPeeringConnection)
        pub fn build(self) -> crate::model::VpcPeeringConnection {
            crate::model::VpcPeeringConnection {
                accepter_vpc_info: self.accepter_vpc_info,
                expiration_time: self.expiration_time,
                requester_vpc_info: self.requester_vpc_info,
                status: self.status,
                tags: self.tags,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl VpcPeeringConnection {
    /// Creates a new builder-style object to manufacture [`VpcPeeringConnection`](crate::model::VpcPeeringConnection)
    pub fn builder() -> crate::model::vpc_peering_connection::Builder {
        crate::model::vpc_peering_connection::Builder::default()
    }
}

/// <p>Describes the status of a VPC peering connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcPeeringConnectionStateReason {
    /// <p>The status of the VPC peering connection.</p>
    pub code: std::option::Option<crate::model::VpcPeeringConnectionStateReasonCode>,
    /// <p>A message that provides more information about the status, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcPeeringConnectionStateReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcPeeringConnectionStateReason");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`VpcPeeringConnectionStateReason`](crate::model::VpcPeeringConnectionStateReason)
pub mod vpc_peering_connection_state_reason {
    /// A builder for [`VpcPeeringConnectionStateReason`](crate::model::VpcPeeringConnectionStateReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::VpcPeeringConnectionStateReasonCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the VPC peering connection.</p>
        pub fn code(mut self, input: crate::model::VpcPeeringConnectionStateReasonCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::VpcPeeringConnectionStateReasonCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message that provides more information about the status, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcPeeringConnectionStateReason`](crate::model::VpcPeeringConnectionStateReason)
        pub fn build(self) -> crate::model::VpcPeeringConnectionStateReason {
            crate::model::VpcPeeringConnectionStateReason {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl VpcPeeringConnectionStateReason {
    /// Creates a new builder-style object to manufacture [`VpcPeeringConnectionStateReason`](crate::model::VpcPeeringConnectionStateReason)
    pub fn builder() -> crate::model::vpc_peering_connection_state_reason::Builder {
        crate::model::vpc_peering_connection_state_reason::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcPeeringConnectionStateReasonCode {
    Active,
    Deleted,
    Deleting,
    Expired,
    Failed,
    InitiatingRequest,
    PendingAcceptance,
    Provisioning,
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcPeeringConnectionStateReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => VpcPeeringConnectionStateReasonCode::Active,
            "deleted" => VpcPeeringConnectionStateReasonCode::Deleted,
            "deleting" => VpcPeeringConnectionStateReasonCode::Deleting,
            "expired" => VpcPeeringConnectionStateReasonCode::Expired,
            "failed" => VpcPeeringConnectionStateReasonCode::Failed,
            "initiating-request" => VpcPeeringConnectionStateReasonCode::InitiatingRequest,
            "pending-acceptance" => VpcPeeringConnectionStateReasonCode::PendingAcceptance,
            "provisioning" => VpcPeeringConnectionStateReasonCode::Provisioning,
            "rejected" => VpcPeeringConnectionStateReasonCode::Rejected,
            other => VpcPeeringConnectionStateReasonCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcPeeringConnectionStateReasonCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcPeeringConnectionStateReasonCode::from(s))
    }
}
impl VpcPeeringConnectionStateReasonCode {
    pub fn as_str(&self) -> &str {
        match self {
            VpcPeeringConnectionStateReasonCode::Active => "active",
            VpcPeeringConnectionStateReasonCode::Deleted => "deleted",
            VpcPeeringConnectionStateReasonCode::Deleting => "deleting",
            VpcPeeringConnectionStateReasonCode::Expired => "expired",
            VpcPeeringConnectionStateReasonCode::Failed => "failed",
            VpcPeeringConnectionStateReasonCode::InitiatingRequest => "initiating-request",
            VpcPeeringConnectionStateReasonCode::PendingAcceptance => "pending-acceptance",
            VpcPeeringConnectionStateReasonCode::Provisioning => "provisioning",
            VpcPeeringConnectionStateReasonCode::Rejected => "rejected",
            VpcPeeringConnectionStateReasonCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "active",
            "deleted",
            "deleting",
            "expired",
            "failed",
            "initiating-request",
            "pending-acceptance",
            "provisioning",
            "rejected",
        ]
    }
}
impl AsRef<str> for VpcPeeringConnectionStateReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a VPC in a VPC peering connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcPeeringConnectionVpcInfo {
    /// <p>The IPv4 CIDR block for the VPC.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR block for the VPC.</p>
    pub ipv6_cidr_block_set: std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlock>>,
    /// <p>Information about the IPv4 CIDR blocks for the VPC.</p>
    pub cidr_block_set: std::option::Option<std::vec::Vec<crate::model::CidrBlock>>,
    /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
    pub peering_options: std::option::Option<crate::model::VpcPeeringConnectionOptionsDescription>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The Region in which the VPC is located.</p>
    pub region: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcPeeringConnectionVpcInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcPeeringConnectionVpcInfo");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("ipv6_cidr_block_set", &self.ipv6_cidr_block_set);
        formatter.field("cidr_block_set", &self.cidr_block_set);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("peering_options", &self.peering_options);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("region", &self.region);
        formatter.finish()
    }
}
/// See [`VpcPeeringConnectionVpcInfo`](crate::model::VpcPeeringConnectionVpcInfo)
pub mod vpc_peering_connection_vpc_info {
    /// A builder for [`VpcPeeringConnectionVpcInfo`](crate::model::VpcPeeringConnectionVpcInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) ipv6_cidr_block_set:
            std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlock>>,
        pub(crate) cidr_block_set: std::option::Option<std::vec::Vec<crate::model::CidrBlock>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) peering_options:
            std::option::Option<crate::model::VpcPeeringConnectionOptionsDescription>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR block for the VPC.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        pub fn ipv6_cidr_block_set(
            mut self,
            input: impl Into<crate::model::Ipv6CidrBlock>,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_set.unwrap_or_default();
            v.push(input.into());
            self.ipv6_cidr_block_set = Some(v);
            self
        }
        pub fn set_ipv6_cidr_block_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6CidrBlock>>,
        ) -> Self {
            self.ipv6_cidr_block_set = input;
            self
        }
        pub fn cidr_block_set(mut self, input: impl Into<crate::model::CidrBlock>) -> Self {
            let mut v = self.cidr_block_set.unwrap_or_default();
            v.push(input.into());
            self.cidr_block_set = Some(v);
            self
        }
        pub fn set_cidr_block_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CidrBlock>>,
        ) -> Self {
            self.cidr_block_set = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the VPC.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
        pub fn peering_options(
            mut self,
            input: crate::model::VpcPeeringConnectionOptionsDescription,
        ) -> Self {
            self.peering_options = Some(input);
            self
        }
        pub fn set_peering_options(
            mut self,
            input: std::option::Option<crate::model::VpcPeeringConnectionOptionsDescription>,
        ) -> Self {
            self.peering_options = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The Region in which the VPC is located.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcPeeringConnectionVpcInfo`](crate::model::VpcPeeringConnectionVpcInfo)
        pub fn build(self) -> crate::model::VpcPeeringConnectionVpcInfo {
            crate::model::VpcPeeringConnectionVpcInfo {
                cidr_block: self.cidr_block,
                ipv6_cidr_block_set: self.ipv6_cidr_block_set,
                cidr_block_set: self.cidr_block_set,
                owner_id: self.owner_id,
                peering_options: self.peering_options,
                vpc_id: self.vpc_id,
                region: self.region,
            }
        }
    }
}
impl VpcPeeringConnectionVpcInfo {
    /// Creates a new builder-style object to manufacture [`VpcPeeringConnectionVpcInfo`](crate::model::VpcPeeringConnectionVpcInfo)
    pub fn builder() -> crate::model::vpc_peering_connection_vpc_info::Builder {
        crate::model::vpc_peering_connection_vpc_info::Builder::default()
    }
}

/// <p>Describes the VPC peering connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcPeeringConnectionOptionsDescription {
    /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
    pub allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
    /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
    pub allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
    /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
    pub allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
}
impl std::fmt::Debug for VpcPeeringConnectionOptionsDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcPeeringConnectionOptionsDescription");
        formatter.field(
            "allow_dns_resolution_from_remote_vpc",
            &self.allow_dns_resolution_from_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_classic_link_to_remote_vpc",
            &self.allow_egress_from_local_classic_link_to_remote_vpc,
        );
        formatter.field(
            "allow_egress_from_local_vpc_to_remote_classic_link",
            &self.allow_egress_from_local_vpc_to_remote_classic_link,
        );
        formatter.finish()
    }
}
/// See [`VpcPeeringConnectionOptionsDescription`](crate::model::VpcPeeringConnectionOptionsDescription)
pub mod vpc_peering_connection_options_description {
    /// A builder for [`VpcPeeringConnectionOptionsDescription`](crate::model::VpcPeeringConnectionOptionsDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allow_dns_resolution_from_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_classic_link_to_remote_vpc: std::option::Option<bool>,
        pub(crate) allow_egress_from_local_vpc_to_remote_classic_link: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
        pub fn allow_dns_resolution_from_remote_vpc(mut self, input: bool) -> Self {
            self.allow_dns_resolution_from_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_dns_resolution_from_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_dns_resolution_from_remote_vpc = input;
            self
        }
        /// <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
        pub fn allow_egress_from_local_classic_link_to_remote_vpc(mut self, input: bool) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_classic_link_to_remote_vpc(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_classic_link_to_remote_vpc = input;
            self
        }
        /// <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
        pub fn allow_egress_from_local_vpc_to_remote_classic_link(mut self, input: bool) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = Some(input);
            self
        }
        pub fn set_allow_egress_from_local_vpc_to_remote_classic_link(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_egress_from_local_vpc_to_remote_classic_link = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcPeeringConnectionOptionsDescription`](crate::model::VpcPeeringConnectionOptionsDescription)
        pub fn build(self) -> crate::model::VpcPeeringConnectionOptionsDescription {
            crate::model::VpcPeeringConnectionOptionsDescription {
                allow_dns_resolution_from_remote_vpc: self.allow_dns_resolution_from_remote_vpc,
                allow_egress_from_local_classic_link_to_remote_vpc: self
                    .allow_egress_from_local_classic_link_to_remote_vpc,
                allow_egress_from_local_vpc_to_remote_classic_link: self
                    .allow_egress_from_local_vpc_to_remote_classic_link,
            }
        }
    }
}
impl VpcPeeringConnectionOptionsDescription {
    /// Creates a new builder-style object to manufacture [`VpcPeeringConnectionOptionsDescription`](crate::model::VpcPeeringConnectionOptionsDescription)
    pub fn builder() -> crate::model::vpc_peering_connection_options_description::Builder {
        crate::model::vpc_peering_connection_options_description::Builder::default()
    }
}

/// <p>Describes an IPv4 CIDR block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CidrBlock {
    /// <p>The IPv4 CIDR block.</p>
    pub cidr_block: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CidrBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CidrBlock");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.finish()
    }
}
/// See [`CidrBlock`](crate::model::CidrBlock)
pub mod cidr_block {
    /// A builder for [`CidrBlock`](crate::model::CidrBlock)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR block.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// Consumes the builder and constructs a [`CidrBlock`](crate::model::CidrBlock)
        pub fn build(self) -> crate::model::CidrBlock {
            crate::model::CidrBlock {
                cidr_block: self.cidr_block,
            }
        }
    }
}
impl CidrBlock {
    /// Creates a new builder-style object to manufacture [`CidrBlock`](crate::model::CidrBlock)
    pub fn builder() -> crate::model::cidr_block::Builder {
        crate::model::cidr_block::Builder::default()
    }
}

/// <p>Describes an IPv6 CIDR block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6CidrBlock {
    /// <p>The IPv6 CIDR block.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6CidrBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6CidrBlock");
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.finish()
    }
}
/// See [`Ipv6CidrBlock`](crate::model::Ipv6CidrBlock)
pub mod ipv6_cidr_block {
    /// A builder for [`Ipv6CidrBlock`](crate::model::Ipv6CidrBlock)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 CIDR block.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6CidrBlock`](crate::model::Ipv6CidrBlock)
        pub fn build(self) -> crate::model::Ipv6CidrBlock {
            crate::model::Ipv6CidrBlock {
                ipv6_cidr_block: self.ipv6_cidr_block,
            }
        }
    }
}
impl Ipv6CidrBlock {
    /// Creates a new builder-style object to manufacture [`Ipv6CidrBlock`](crate::model::Ipv6CidrBlock)
    pub fn builder() -> crate::model::ipv6_cidr_block::Builder {
        crate::model::ipv6_cidr_block::Builder::default()
    }
}

/// <p>Describes a VPC endpoint service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceDetail {
    /// <p>The Amazon Resource Name (ARN) of the service.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The ID of the endpoint service.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The type of service.</p>
    pub service_type: std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
    /// <p>The Availability Zones in which the service is available.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The AWS account ID of the service owner.</p>
    pub owner: std::option::Option<std::string::String>,
    /// <p>The DNS names for the service.</p>
    pub base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The private DNS name for the service.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The private DNS names assigned to the VPC endpoint service. </p>
    pub private_dns_names: std::option::Option<std::vec::Vec<crate::model::PrivateDnsDetails>>,
    /// <p>Indicates whether the service supports endpoint policies.</p>
    pub vpc_endpoint_policy_supported: std::option::Option<bool>,
    /// <p>Indicates whether VPC endpoint connection requests to the service must be accepted by the service owner.</p>
    pub acceptance_required: std::option::Option<bool>,
    /// <p>Indicates whether the service manages its VPC endpoints. Management of the service VPC
    /// endpoints using the VPC endpoint API is restricted.</p>
    pub manages_vpc_endpoints: std::option::Option<bool>,
    /// <p>Any tags assigned to the service.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The verification state of the VPC endpoint service.</p>
    /// <p>Consumers of the endpoint service cannot use the private name when the state is not <code>verified</code>.</p>
    pub private_dns_name_verification_state: std::option::Option<crate::model::DnsNameState>,
}
impl std::fmt::Debug for ServiceDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceDetail");
        formatter.field("service_name", &self.service_name);
        formatter.field("service_id", &self.service_id);
        formatter.field("service_type", &self.service_type);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("owner", &self.owner);
        formatter.field("base_endpoint_dns_names", &self.base_endpoint_dns_names);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_dns_names", &self.private_dns_names);
        formatter.field(
            "vpc_endpoint_policy_supported",
            &self.vpc_endpoint_policy_supported,
        );
        formatter.field("acceptance_required", &self.acceptance_required);
        formatter.field("manages_vpc_endpoints", &self.manages_vpc_endpoints);
        formatter.field("tags", &self.tags);
        formatter.field(
            "private_dns_name_verification_state",
            &self.private_dns_name_verification_state,
        );
        formatter.finish()
    }
}
/// See [`ServiceDetail`](crate::model::ServiceDetail)
pub mod service_detail {
    /// A builder for [`ServiceDetail`](crate::model::ServiceDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) service_type:
            std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_dns_names:
            std::option::Option<std::vec::Vec<crate::model::PrivateDnsDetails>>,
        pub(crate) vpc_endpoint_policy_supported: std::option::Option<bool>,
        pub(crate) acceptance_required: std::option::Option<bool>,
        pub(crate) manages_vpc_endpoints: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) private_dns_name_verification_state:
            std::option::Option<crate::model::DnsNameState>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the service.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The ID of the endpoint service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        pub fn service_type(mut self, input: impl Into<crate::model::ServiceTypeDetail>) -> Self {
            let mut v = self.service_type.unwrap_or_default();
            v.push(input.into());
            self.service_type = Some(v);
            self
        }
        pub fn set_service_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
        ) -> Self {
            self.service_type = input;
            self
        }
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>The AWS account ID of the service owner.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        pub fn base_endpoint_dns_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.base_endpoint_dns_names.unwrap_or_default();
            v.push(input.into());
            self.base_endpoint_dns_names = Some(v);
            self
        }
        pub fn set_base_endpoint_dns_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.base_endpoint_dns_names = input;
            self
        }
        /// <p>The private DNS name for the service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        pub fn private_dns_names(
            mut self,
            input: impl Into<crate::model::PrivateDnsDetails>,
        ) -> Self {
            let mut v = self.private_dns_names.unwrap_or_default();
            v.push(input.into());
            self.private_dns_names = Some(v);
            self
        }
        pub fn set_private_dns_names(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateDnsDetails>>,
        ) -> Self {
            self.private_dns_names = input;
            self
        }
        /// <p>Indicates whether the service supports endpoint policies.</p>
        pub fn vpc_endpoint_policy_supported(mut self, input: bool) -> Self {
            self.vpc_endpoint_policy_supported = Some(input);
            self
        }
        pub fn set_vpc_endpoint_policy_supported(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.vpc_endpoint_policy_supported = input;
            self
        }
        /// <p>Indicates whether VPC endpoint connection requests to the service must be accepted by the service owner.</p>
        pub fn acceptance_required(mut self, input: bool) -> Self {
            self.acceptance_required = Some(input);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.acceptance_required = input;
            self
        }
        /// <p>Indicates whether the service manages its VPC endpoints. Management of the service VPC
        /// endpoints using the VPC endpoint API is restricted.</p>
        pub fn manages_vpc_endpoints(mut self, input: bool) -> Self {
            self.manages_vpc_endpoints = Some(input);
            self
        }
        pub fn set_manages_vpc_endpoints(mut self, input: std::option::Option<bool>) -> Self {
            self.manages_vpc_endpoints = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The verification state of the VPC endpoint service.</p>
        /// <p>Consumers of the endpoint service cannot use the private name when the state is not <code>verified</code>.</p>
        pub fn private_dns_name_verification_state(
            mut self,
            input: crate::model::DnsNameState,
        ) -> Self {
            self.private_dns_name_verification_state = Some(input);
            self
        }
        pub fn set_private_dns_name_verification_state(
            mut self,
            input: std::option::Option<crate::model::DnsNameState>,
        ) -> Self {
            self.private_dns_name_verification_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceDetail`](crate::model::ServiceDetail)
        pub fn build(self) -> crate::model::ServiceDetail {
            crate::model::ServiceDetail {
                service_name: self.service_name,
                service_id: self.service_id,
                service_type: self.service_type,
                availability_zones: self.availability_zones,
                owner: self.owner,
                base_endpoint_dns_names: self.base_endpoint_dns_names,
                private_dns_name: self.private_dns_name,
                private_dns_names: self.private_dns_names,
                vpc_endpoint_policy_supported: self.vpc_endpoint_policy_supported,
                acceptance_required: self.acceptance_required,
                manages_vpc_endpoints: self.manages_vpc_endpoints,
                tags: self.tags,
                private_dns_name_verification_state: self.private_dns_name_verification_state,
            }
        }
    }
}
impl ServiceDetail {
    /// Creates a new builder-style object to manufacture [`ServiceDetail`](crate::model::ServiceDetail)
    pub fn builder() -> crate::model::service_detail::Builder {
        crate::model::service_detail::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DnsNameState {
    Failed,
    PendingVerification,
    Verified,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DnsNameState {
    fn from(s: &str) -> Self {
        match s {
            "failed" => DnsNameState::Failed,
            "pendingVerification" => DnsNameState::PendingVerification,
            "verified" => DnsNameState::Verified,
            other => DnsNameState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DnsNameState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DnsNameState::from(s))
    }
}
impl DnsNameState {
    pub fn as_str(&self) -> &str {
        match self {
            DnsNameState::Failed => "failed",
            DnsNameState::PendingVerification => "pendingVerification",
            DnsNameState::Verified => "verified",
            DnsNameState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["failed", "pendingVerification", "verified"]
    }
}
impl AsRef<str> for DnsNameState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the Private DNS name for interface endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrivateDnsDetails {
    /// <p>The private DNS name assigned to the VPC endpoint service.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrivateDnsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrivateDnsDetails");
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.finish()
    }
}
/// See [`PrivateDnsDetails`](crate::model::PrivateDnsDetails)
pub mod private_dns_details {
    /// A builder for [`PrivateDnsDetails`](crate::model::PrivateDnsDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The private DNS name assigned to the VPC endpoint service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PrivateDnsDetails`](crate::model::PrivateDnsDetails)
        pub fn build(self) -> crate::model::PrivateDnsDetails {
            crate::model::PrivateDnsDetails {
                private_dns_name: self.private_dns_name,
            }
        }
    }
}
impl PrivateDnsDetails {
    /// Creates a new builder-style object to manufacture [`PrivateDnsDetails`](crate::model::PrivateDnsDetails)
    pub fn builder() -> crate::model::private_dns_details::Builder {
        crate::model::private_dns_details::Builder::default()
    }
}

/// <p>Describes the type of service for a VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceTypeDetail {
    /// <p>The type of service.</p>
    pub service_type: std::option::Option<crate::model::ServiceType>,
}
impl std::fmt::Debug for ServiceTypeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceTypeDetail");
        formatter.field("service_type", &self.service_type);
        formatter.finish()
    }
}
/// See [`ServiceTypeDetail`](crate::model::ServiceTypeDetail)
pub mod service_type_detail {
    /// A builder for [`ServiceTypeDetail`](crate::model::ServiceTypeDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_type: std::option::Option<crate::model::ServiceType>,
    }
    impl Builder {
        /// <p>The type of service.</p>
        pub fn service_type(mut self, input: crate::model::ServiceType) -> Self {
            self.service_type = Some(input);
            self
        }
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::ServiceType>,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceTypeDetail`](crate::model::ServiceTypeDetail)
        pub fn build(self) -> crate::model::ServiceTypeDetail {
            crate::model::ServiceTypeDetail {
                service_type: self.service_type,
            }
        }
    }
}
impl ServiceTypeDetail {
    /// Creates a new builder-style object to manufacture [`ServiceTypeDetail`](crate::model::ServiceTypeDetail)
    pub fn builder() -> crate::model::service_type_detail::Builder {
        crate::model::service_type_detail::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceType {
    Gateway,
    GatewayLoadBalancer,
    Interface,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ServiceType {
    fn from(s: &str) -> Self {
        match s {
            "Gateway" => ServiceType::Gateway,
            "GatewayLoadBalancer" => ServiceType::GatewayLoadBalancer,
            "Interface" => ServiceType::Interface,
            other => ServiceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ServiceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceType::from(s))
    }
}
impl ServiceType {
    pub fn as_str(&self) -> &str {
        match self {
            ServiceType::Gateway => "Gateway",
            ServiceType::GatewayLoadBalancer => "GatewayLoadBalancer",
            ServiceType::Interface => "Interface",
            ServiceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Gateway", "GatewayLoadBalancer", "Interface"]
    }
}
impl AsRef<str> for ServiceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AllowedPrincipal {
    /// <p>The type of principal.</p>
    pub principal_type: std::option::Option<crate::model::PrincipalType>,
    /// <p>The Amazon Resource Name (ARN) of the principal.</p>
    pub principal: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AllowedPrincipal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AllowedPrincipal");
        formatter.field("principal_type", &self.principal_type);
        formatter.field("principal", &self.principal);
        formatter.finish()
    }
}
/// See [`AllowedPrincipal`](crate::model::AllowedPrincipal)
pub mod allowed_principal {
    /// A builder for [`AllowedPrincipal`](crate::model::AllowedPrincipal)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal_type: std::option::Option<crate::model::PrincipalType>,
        pub(crate) principal: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of principal.</p>
        pub fn principal_type(mut self, input: crate::model::PrincipalType) -> Self {
            self.principal_type = Some(input);
            self
        }
        pub fn set_principal_type(
            mut self,
            input: std::option::Option<crate::model::PrincipalType>,
        ) -> Self {
            self.principal_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the principal.</p>
        pub fn principal(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal = Some(input.into());
            self
        }
        pub fn set_principal(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal = input;
            self
        }
        /// Consumes the builder and constructs a [`AllowedPrincipal`](crate::model::AllowedPrincipal)
        pub fn build(self) -> crate::model::AllowedPrincipal {
            crate::model::AllowedPrincipal {
                principal_type: self.principal_type,
                principal: self.principal,
            }
        }
    }
}
impl AllowedPrincipal {
    /// Creates a new builder-style object to manufacture [`AllowedPrincipal`](crate::model::AllowedPrincipal)
    pub fn builder() -> crate::model::allowed_principal::Builder {
        crate::model::allowed_principal::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalType {
    Account,
    All,
    OrganizationUnit,
    Role,
    Service,
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PrincipalType {
    fn from(s: &str) -> Self {
        match s {
            "Account" => PrincipalType::Account,
            "All" => PrincipalType::All,
            "OrganizationUnit" => PrincipalType::OrganizationUnit,
            "Role" => PrincipalType::Role,
            "Service" => PrincipalType::Service,
            "User" => PrincipalType::User,
            other => PrincipalType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PrincipalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalType::from(s))
    }
}
impl PrincipalType {
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalType::Account => "Account",
            PrincipalType::All => "All",
            PrincipalType::OrganizationUnit => "OrganizationUnit",
            PrincipalType::Role => "Role",
            PrincipalType::Service => "Service",
            PrincipalType::User => "User",
            PrincipalType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Account",
            "All",
            "OrganizationUnit",
            "Role",
            "Service",
            "User",
        ]
    }
}
impl AsRef<str> for PrincipalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a service configuration for a VPC endpoint service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceConfiguration {
    /// <p>The type of service.</p>
    pub service_type: std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
    /// <p>The ID of the service.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The name of the service.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The service state.</p>
    pub service_state: std::option::Option<crate::model::ServiceState>,
    /// <p>The Availability Zones in which the service is available.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether requests from other AWS accounts to create an endpoint to the service must first be accepted.</p>
    pub acceptance_required: std::option::Option<bool>,
    /// <p>Indicates whether the service manages its VPC endpoints. Management of the service VPC
    /// endpoints using the VPC endpoint API is restricted.</p>
    pub manages_vpc_endpoints: std::option::Option<bool>,
    /// <p>The Amazon Resource Names (ARNs) of the Network Load Balancers for the service.</p>
    pub network_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Names (ARNs) of the Gateway Load Balancers for the service.</p>
    pub gateway_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The DNS names for the service.</p>
    pub base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The private DNS name for the service.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>Information about the endpoint service private DNS name configuration.</p>
    pub private_dns_name_configuration:
        std::option::Option<crate::model::PrivateDnsNameConfiguration>,
    /// <p>Any tags assigned to the service.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ServiceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceConfiguration");
        formatter.field("service_type", &self.service_type);
        formatter.field("service_id", &self.service_id);
        formatter.field("service_name", &self.service_name);
        formatter.field("service_state", &self.service_state);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("acceptance_required", &self.acceptance_required);
        formatter.field("manages_vpc_endpoints", &self.manages_vpc_endpoints);
        formatter.field(
            "network_load_balancer_arns",
            &self.network_load_balancer_arns,
        );
        formatter.field(
            "gateway_load_balancer_arns",
            &self.gateway_load_balancer_arns,
        );
        formatter.field("base_endpoint_dns_names", &self.base_endpoint_dns_names);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field(
            "private_dns_name_configuration",
            &self.private_dns_name_configuration,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ServiceConfiguration`](crate::model::ServiceConfiguration)
pub mod service_configuration {
    /// A builder for [`ServiceConfiguration`](crate::model::ServiceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_type:
            std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) service_state: std::option::Option<crate::model::ServiceState>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) acceptance_required: std::option::Option<bool>,
        pub(crate) manages_vpc_endpoints: std::option::Option<bool>,
        pub(crate) network_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) gateway_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) base_endpoint_dns_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_dns_name_configuration:
            std::option::Option<crate::model::PrivateDnsNameConfiguration>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        pub fn service_type(mut self, input: impl Into<crate::model::ServiceTypeDetail>) -> Self {
            let mut v = self.service_type.unwrap_or_default();
            v.push(input.into());
            self.service_type = Some(v);
            self
        }
        pub fn set_service_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceTypeDetail>>,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// <p>The ID of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The name of the service.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The service state.</p>
        pub fn service_state(mut self, input: crate::model::ServiceState) -> Self {
            self.service_state = Some(input);
            self
        }
        pub fn set_service_state(
            mut self,
            input: std::option::Option<crate::model::ServiceState>,
        ) -> Self {
            self.service_state = input;
            self
        }
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// <p>Indicates whether requests from other AWS accounts to create an endpoint to the service must first be accepted.</p>
        pub fn acceptance_required(mut self, input: bool) -> Self {
            self.acceptance_required = Some(input);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.acceptance_required = input;
            self
        }
        /// <p>Indicates whether the service manages its VPC endpoints. Management of the service VPC
        /// endpoints using the VPC endpoint API is restricted.</p>
        pub fn manages_vpc_endpoints(mut self, input: bool) -> Self {
            self.manages_vpc_endpoints = Some(input);
            self
        }
        pub fn set_manages_vpc_endpoints(mut self, input: std::option::Option<bool>) -> Self {
            self.manages_vpc_endpoints = input;
            self
        }
        pub fn network_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.network_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.network_load_balancer_arns = Some(v);
            self
        }
        pub fn set_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_load_balancer_arns = input;
            self
        }
        pub fn gateway_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.gateway_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.gateway_load_balancer_arns = Some(v);
            self
        }
        pub fn set_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.gateway_load_balancer_arns = input;
            self
        }
        pub fn base_endpoint_dns_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.base_endpoint_dns_names.unwrap_or_default();
            v.push(input.into());
            self.base_endpoint_dns_names = Some(v);
            self
        }
        pub fn set_base_endpoint_dns_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.base_endpoint_dns_names = input;
            self
        }
        /// <p>The private DNS name for the service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>Information about the endpoint service private DNS name configuration.</p>
        pub fn private_dns_name_configuration(
            mut self,
            input: crate::model::PrivateDnsNameConfiguration,
        ) -> Self {
            self.private_dns_name_configuration = Some(input);
            self
        }
        pub fn set_private_dns_name_configuration(
            mut self,
            input: std::option::Option<crate::model::PrivateDnsNameConfiguration>,
        ) -> Self {
            self.private_dns_name_configuration = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceConfiguration`](crate::model::ServiceConfiguration)
        pub fn build(self) -> crate::model::ServiceConfiguration {
            crate::model::ServiceConfiguration {
                service_type: self.service_type,
                service_id: self.service_id,
                service_name: self.service_name,
                service_state: self.service_state,
                availability_zones: self.availability_zones,
                acceptance_required: self.acceptance_required,
                manages_vpc_endpoints: self.manages_vpc_endpoints,
                network_load_balancer_arns: self.network_load_balancer_arns,
                gateway_load_balancer_arns: self.gateway_load_balancer_arns,
                base_endpoint_dns_names: self.base_endpoint_dns_names,
                private_dns_name: self.private_dns_name,
                private_dns_name_configuration: self.private_dns_name_configuration,
                tags: self.tags,
            }
        }
    }
}
impl ServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`ServiceConfiguration`](crate::model::ServiceConfiguration)
    pub fn builder() -> crate::model::service_configuration::Builder {
        crate::model::service_configuration::Builder::default()
    }
}

/// <p>Information about the private DNS name for the service endpoint. For more information
/// about these parameters, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/ndpoint-services-dns-validation.html">VPC Endpoint Service
/// Private DNS Name Verification</a> in the
/// <i>Amazon Virtual Private Cloud User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrivateDnsNameConfiguration {
    /// <p>The verification state of the VPC endpoint service.</p>
    /// <p>>Consumers
    /// of the endpoint service can use the private name only when the state is
    /// <code>verified</code>.</p>
    pub state: std::option::Option<crate::model::DnsNameState>,
    /// <p>The endpoint service verification type, for example TXT.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The value the service provider adds to the private DNS name domain record before verification.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The name of the record subdomain the service provider needs to create. The service provider adds the <code>value</code> text to the <code>name</code>.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrivateDnsNameConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrivateDnsNameConfiguration");
        formatter.field("state", &self.state);
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`PrivateDnsNameConfiguration`](crate::model::PrivateDnsNameConfiguration)
pub mod private_dns_name_configuration {
    /// A builder for [`PrivateDnsNameConfiguration`](crate::model::PrivateDnsNameConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::DnsNameState>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The verification state of the VPC endpoint service.</p>
        /// <p>>Consumers
        /// of the endpoint service can use the private name only when the state is
        /// <code>verified</code>.</p>
        pub fn state(mut self, input: crate::model::DnsNameState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::DnsNameState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The endpoint service verification type, for example TXT.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The value the service provider adds to the private DNS name domain record before verification.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The name of the record subdomain the service provider needs to create. The service provider adds the <code>value</code> text to the <code>name</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`PrivateDnsNameConfiguration`](crate::model::PrivateDnsNameConfiguration)
        pub fn build(self) -> crate::model::PrivateDnsNameConfiguration {
            crate::model::PrivateDnsNameConfiguration {
                state: self.state,
                r#type: self.r#type,
                value: self.value,
                name: self.name,
            }
        }
    }
}
impl PrivateDnsNameConfiguration {
    /// Creates a new builder-style object to manufacture [`PrivateDnsNameConfiguration`](crate::model::PrivateDnsNameConfiguration)
    pub fn builder() -> crate::model::private_dns_name_configuration::Builder {
        crate::model::private_dns_name_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceState {
    Available,
    Deleted,
    Deleting,
    Failed,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ServiceState {
    fn from(s: &str) -> Self {
        match s {
            "Available" => ServiceState::Available,
            "Deleted" => ServiceState::Deleted,
            "Deleting" => ServiceState::Deleting,
            "Failed" => ServiceState::Failed,
            "Pending" => ServiceState::Pending,
            other => ServiceState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ServiceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceState::from(s))
    }
}
impl ServiceState {
    pub fn as_str(&self) -> &str {
        match self {
            ServiceState::Available => "Available",
            ServiceState::Deleted => "Deleted",
            ServiceState::Deleting => "Deleting",
            ServiceState::Failed => "Failed",
            ServiceState::Pending => "Pending",
            ServiceState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Available", "Deleted", "Deleting", "Failed", "Pending"]
    }
}
impl AsRef<str> for ServiceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcEndpoint {
    /// <p>The ID of the VPC endpoint.</p>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The type of endpoint.</p>
    pub vpc_endpoint_type: std::option::Option<crate::model::VpcEndpointType>,
    /// <p>The ID of the VPC to which the endpoint is associated.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The name of the service to which the endpoint is associated.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The state of the VPC endpoint.</p>
    pub state: std::option::Option<crate::model::State>,
    /// <p>The policy document associated with the endpoint, if applicable.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>(Gateway endpoint) One or more route tables associated with the endpoint.</p>
    pub route_table_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>(Interface endpoint) One or more subnets in which the endpoint is located.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>(Interface endpoint) Information about the security groups that are associated with
    /// the network interface.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::SecurityGroupIdentifier>>,
    /// <p>(Interface endpoint) Indicates whether the VPC is associated with a private hosted zone.</p>
    pub private_dns_enabled: std::option::Option<bool>,
    /// <p>Indicates whether the VPC endpoint is being managed by its service.</p>
    pub requester_managed: std::option::Option<bool>,
    /// <p>(Interface endpoint) One or more network interfaces for the endpoint.</p>
    pub network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>(Interface endpoint) The DNS entries for the endpoint.</p>
    pub dns_entries: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
    /// <p>The date and time that the VPC endpoint was created.</p>
    pub creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Any tags assigned to the VPC endpoint.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the AWS account that owns the VPC endpoint.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The last error that occurred for VPC endpoint.</p>
    pub last_error: std::option::Option<crate::model::LastError>,
}
impl std::fmt::Debug for VpcEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcEndpoint");
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field("vpc_endpoint_type", &self.vpc_endpoint_type);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("service_name", &self.service_name);
        formatter.field("state", &self.state);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("route_table_ids", &self.route_table_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("groups", &self.groups);
        formatter.field("private_dns_enabled", &self.private_dns_enabled);
        formatter.field("requester_managed", &self.requester_managed);
        formatter.field("network_interface_ids", &self.network_interface_ids);
        formatter.field("dns_entries", &self.dns_entries);
        formatter.field("creation_timestamp", &self.creation_timestamp);
        formatter.field("tags", &self.tags);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("last_error", &self.last_error);
        formatter.finish()
    }
}
/// See [`VpcEndpoint`](crate::model::VpcEndpoint)
pub mod vpc_endpoint {
    /// A builder for [`VpcEndpoint`](crate::model::VpcEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_type: std::option::Option<crate::model::VpcEndpointType>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) route_table_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) groups:
            std::option::Option<std::vec::Vec<crate::model::SecurityGroupIdentifier>>,
        pub(crate) private_dns_enabled: std::option::Option<bool>,
        pub(crate) requester_managed: std::option::Option<bool>,
        pub(crate) network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) dns_entries: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
        pub(crate) creation_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) last_error: std::option::Option<crate::model::LastError>,
    }
    impl Builder {
        /// <p>The ID of the VPC endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The type of endpoint.</p>
        pub fn vpc_endpoint_type(mut self, input: crate::model::VpcEndpointType) -> Self {
            self.vpc_endpoint_type = Some(input);
            self
        }
        pub fn set_vpc_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::VpcEndpointType>,
        ) -> Self {
            self.vpc_endpoint_type = input;
            self
        }
        /// <p>The ID of the VPC to which the endpoint is associated.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The name of the service to which the endpoint is associated.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The state of the VPC endpoint.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// <p>The policy document associated with the endpoint, if applicable.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        pub fn route_table_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.route_table_ids.unwrap_or_default();
            v.push(input.into());
            self.route_table_ids = Some(v);
            self
        }
        pub fn set_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.route_table_ids = input;
            self
        }
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::SecurityGroupIdentifier>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecurityGroupIdentifier>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>(Interface endpoint) Indicates whether the VPC is associated with a private hosted zone.</p>
        pub fn private_dns_enabled(mut self, input: bool) -> Self {
            self.private_dns_enabled = Some(input);
            self
        }
        pub fn set_private_dns_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.private_dns_enabled = input;
            self
        }
        /// <p>Indicates whether the VPC endpoint is being managed by its service.</p>
        pub fn requester_managed(mut self, input: bool) -> Self {
            self.requester_managed = Some(input);
            self
        }
        pub fn set_requester_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_managed = input;
            self
        }
        pub fn network_interface_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.network_interface_ids = Some(v);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_interface_ids = input;
            self
        }
        pub fn dns_entries(mut self, input: impl Into<crate::model::DnsEntry>) -> Self {
            let mut v = self.dns_entries.unwrap_or_default();
            v.push(input.into());
            self.dns_entries = Some(v);
            self
        }
        pub fn set_dns_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
        ) -> Self {
            self.dns_entries = input;
            self
        }
        /// <p>The date and time that the VPC endpoint was created.</p>
        pub fn creation_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the AWS account that owns the VPC endpoint.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The last error that occurred for VPC endpoint.</p>
        pub fn last_error(mut self, input: crate::model::LastError) -> Self {
            self.last_error = Some(input);
            self
        }
        pub fn set_last_error(
            mut self,
            input: std::option::Option<crate::model::LastError>,
        ) -> Self {
            self.last_error = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpoint`](crate::model::VpcEndpoint)
        pub fn build(self) -> crate::model::VpcEndpoint {
            crate::model::VpcEndpoint {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_endpoint_type: self.vpc_endpoint_type,
                vpc_id: self.vpc_id,
                service_name: self.service_name,
                state: self.state,
                policy_document: self.policy_document,
                route_table_ids: self.route_table_ids,
                subnet_ids: self.subnet_ids,
                groups: self.groups,
                private_dns_enabled: self.private_dns_enabled,
                requester_managed: self.requester_managed,
                network_interface_ids: self.network_interface_ids,
                dns_entries: self.dns_entries,
                creation_timestamp: self.creation_timestamp,
                tags: self.tags,
                owner_id: self.owner_id,
                last_error: self.last_error,
            }
        }
    }
}
impl VpcEndpoint {
    /// Creates a new builder-style object to manufacture [`VpcEndpoint`](crate::model::VpcEndpoint)
    pub fn builder() -> crate::model::vpc_endpoint::Builder {
        crate::model::vpc_endpoint::Builder::default()
    }
}

/// <p>The last error that occurred for a VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LastError {
    /// <p>The error message for the VPC endpoint error.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The error code for the VPC endpoint error.</p>
    pub code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LastError");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
/// See [`LastError`](crate::model::LastError)
pub mod last_error {
    /// A builder for [`LastError`](crate::model::LastError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error message for the VPC endpoint error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The error code for the VPC endpoint error.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`LastError`](crate::model::LastError)
        pub fn build(self) -> crate::model::LastError {
            crate::model::LastError {
                message: self.message,
                code: self.code,
            }
        }
    }
}
impl LastError {
    /// Creates a new builder-style object to manufacture [`LastError`](crate::model::LastError)
    pub fn builder() -> crate::model::last_error::Builder {
        crate::model::last_error::Builder::default()
    }
}

/// <p>Describes a DNS entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DnsEntry {
    /// <p>The DNS name.</p>
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The ID of the private hosted zone.</p>
    pub hosted_zone_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DnsEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DnsEntry");
        formatter.field("dns_name", &self.dns_name);
        formatter.field("hosted_zone_id", &self.hosted_zone_id);
        formatter.finish()
    }
}
/// See [`DnsEntry`](crate::model::DnsEntry)
pub mod dns_entry {
    /// A builder for [`DnsEntry`](crate::model::DnsEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dns_name: std::option::Option<std::string::String>,
        pub(crate) hosted_zone_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The DNS name.</p>
        pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_name = Some(input.into());
            self
        }
        pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_name = input;
            self
        }
        /// <p>The ID of the private hosted zone.</p>
        pub fn hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hosted_zone_id = Some(input.into());
            self
        }
        pub fn set_hosted_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hosted_zone_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsEntry`](crate::model::DnsEntry)
        pub fn build(self) -> crate::model::DnsEntry {
            crate::model::DnsEntry {
                dns_name: self.dns_name,
                hosted_zone_id: self.hosted_zone_id,
            }
        }
    }
}
impl DnsEntry {
    /// Creates a new builder-style object to manufacture [`DnsEntry`](crate::model::DnsEntry)
    pub fn builder() -> crate::model::dns_entry::Builder {
        crate::model::dns_entry::Builder::default()
    }
}

/// <p>Describes a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupIdentifier {
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityGroupIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupIdentifier");
        formatter.field("group_id", &self.group_id);
        formatter.field("group_name", &self.group_name);
        formatter.finish()
    }
}
/// See [`SecurityGroupIdentifier`](crate::model::SecurityGroupIdentifier)
pub mod security_group_identifier {
    /// A builder for [`SecurityGroupIdentifier`](crate::model::SecurityGroupIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupIdentifier`](crate::model::SecurityGroupIdentifier)
        pub fn build(self) -> crate::model::SecurityGroupIdentifier {
            crate::model::SecurityGroupIdentifier {
                group_id: self.group_id,
                group_name: self.group_name,
            }
        }
    }
}
impl SecurityGroupIdentifier {
    /// Creates a new builder-style object to manufacture [`SecurityGroupIdentifier`](crate::model::SecurityGroupIdentifier)
    pub fn builder() -> crate::model::security_group_identifier::Builder {
        crate::model::security_group_identifier::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    Available,
    Deleted,
    Deleting,
    Expired,
    Failed,
    Pending,
    PendingAcceptance,
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "Available" => State::Available,
            "Deleted" => State::Deleted,
            "Deleting" => State::Deleting,
            "Expired" => State::Expired,
            "Failed" => State::Failed,
            "Pending" => State::Pending,
            "PendingAcceptance" => State::PendingAcceptance,
            "Rejected" => State::Rejected,
            other => State::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    pub fn as_str(&self) -> &str {
        match self {
            State::Available => "Available",
            State::Deleted => "Deleted",
            State::Deleting => "Deleting",
            State::Expired => "Expired",
            State::Failed => "Failed",
            State::Pending => "Pending",
            State::PendingAcceptance => "PendingAcceptance",
            State::Rejected => "Rejected",
            State::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Available",
            "Deleted",
            "Deleting",
            "Expired",
            "Failed",
            "Pending",
            "PendingAcceptance",
            "Rejected",
        ]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcEndpointType {
    Gateway,
    GatewayLoadBalancer,
    Interface,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcEndpointType {
    fn from(s: &str) -> Self {
        match s {
            "Gateway" => VpcEndpointType::Gateway,
            "GatewayLoadBalancer" => VpcEndpointType::GatewayLoadBalancer,
            "Interface" => VpcEndpointType::Interface,
            other => VpcEndpointType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcEndpointType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcEndpointType::from(s))
    }
}
impl VpcEndpointType {
    pub fn as_str(&self) -> &str {
        match self {
            VpcEndpointType::Gateway => "Gateway",
            VpcEndpointType::GatewayLoadBalancer => "GatewayLoadBalancer",
            VpcEndpointType::Interface => "Interface",
            VpcEndpointType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Gateway", "GatewayLoadBalancer", "Interface"]
    }
}
impl AsRef<str> for VpcEndpointType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a VPC endpoint connection to a service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcEndpointConnection {
    /// <p>The ID of the service to which the endpoint is connected.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC endpoint.</p>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The AWS account ID of the owner of the VPC endpoint.</p>
    pub vpc_endpoint_owner: std::option::Option<std::string::String>,
    /// <p>The state of the VPC endpoint.</p>
    pub vpc_endpoint_state: std::option::Option<crate::model::State>,
    /// <p>The date and time that the VPC endpoint was created.</p>
    pub creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The DNS entries for the VPC endpoint.</p>
    pub dns_entries: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
    /// <p>The Amazon Resource Names (ARNs) of the network load balancers for the service.</p>
    pub network_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Names (ARNs) of the Gateway Load Balancers for the service.</p>
    pub gateway_load_balancer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for VpcEndpointConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcEndpointConnection");
        formatter.field("service_id", &self.service_id);
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field("vpc_endpoint_owner", &self.vpc_endpoint_owner);
        formatter.field("vpc_endpoint_state", &self.vpc_endpoint_state);
        formatter.field("creation_timestamp", &self.creation_timestamp);
        formatter.field("dns_entries", &self.dns_entries);
        formatter.field(
            "network_load_balancer_arns",
            &self.network_load_balancer_arns,
        );
        formatter.field(
            "gateway_load_balancer_arns",
            &self.gateway_load_balancer_arns,
        );
        formatter.finish()
    }
}
/// See [`VpcEndpointConnection`](crate::model::VpcEndpointConnection)
pub mod vpc_endpoint_connection {
    /// A builder for [`VpcEndpointConnection`](crate::model::VpcEndpointConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_owner: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_state: std::option::Option<crate::model::State>,
        pub(crate) creation_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) dns_entries: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
        pub(crate) network_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) gateway_load_balancer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the service to which the endpoint is connected.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The ID of the VPC endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The AWS account ID of the owner of the VPC endpoint.</p>
        pub fn vpc_endpoint_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_owner = Some(input.into());
            self
        }
        pub fn set_vpc_endpoint_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_owner = input;
            self
        }
        /// <p>The state of the VPC endpoint.</p>
        pub fn vpc_endpoint_state(mut self, input: crate::model::State) -> Self {
            self.vpc_endpoint_state = Some(input);
            self
        }
        pub fn set_vpc_endpoint_state(
            mut self,
            input: std::option::Option<crate::model::State>,
        ) -> Self {
            self.vpc_endpoint_state = input;
            self
        }
        /// <p>The date and time that the VPC endpoint was created.</p>
        pub fn creation_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        pub fn set_creation_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_timestamp = input;
            self
        }
        pub fn dns_entries(mut self, input: impl Into<crate::model::DnsEntry>) -> Self {
            let mut v = self.dns_entries.unwrap_or_default();
            v.push(input.into());
            self.dns_entries = Some(v);
            self
        }
        pub fn set_dns_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DnsEntry>>,
        ) -> Self {
            self.dns_entries = input;
            self
        }
        pub fn network_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.network_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.network_load_balancer_arns = Some(v);
            self
        }
        pub fn set_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_load_balancer_arns = input;
            self
        }
        pub fn gateway_load_balancer_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.gateway_load_balancer_arns.unwrap_or_default();
            v.push(input.into());
            self.gateway_load_balancer_arns = Some(v);
            self
        }
        pub fn set_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.gateway_load_balancer_arns = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpointConnection`](crate::model::VpcEndpointConnection)
        pub fn build(self) -> crate::model::VpcEndpointConnection {
            crate::model::VpcEndpointConnection {
                service_id: self.service_id,
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_endpoint_owner: self.vpc_endpoint_owner,
                vpc_endpoint_state: self.vpc_endpoint_state,
                creation_timestamp: self.creation_timestamp,
                dns_entries: self.dns_entries,
                network_load_balancer_arns: self.network_load_balancer_arns,
                gateway_load_balancer_arns: self.gateway_load_balancer_arns,
            }
        }
    }
}
impl VpcEndpointConnection {
    /// Creates a new builder-style object to manufacture [`VpcEndpointConnection`](crate::model::VpcEndpointConnection)
    pub fn builder() -> crate::model::vpc_endpoint_connection::Builder {
        crate::model::vpc_endpoint_connection::Builder::default()
    }
}

/// <p>Describes a connection notification for a VPC endpoint or VPC endpoint
/// service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConnectionNotification {
    /// <p>The ID of the notification.</p>
    pub connection_notification_id: std::option::Option<std::string::String>,
    /// <p>The ID of the endpoint service.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC endpoint.</p>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The type of notification.</p>
    pub connection_notification_type: std::option::Option<crate::model::ConnectionNotificationType>,
    /// <p>The ARN of the SNS topic for the notification.</p>
    pub connection_notification_arn: std::option::Option<std::string::String>,
    /// <p>The events for the notification. Valid values are <code>Accept</code>,
    /// <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>
    pub connection_events: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The state of the notification.</p>
    pub connection_notification_state:
        std::option::Option<crate::model::ConnectionNotificationState>,
}
impl std::fmt::Debug for ConnectionNotification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConnectionNotification");
        formatter.field(
            "connection_notification_id",
            &self.connection_notification_id,
        );
        formatter.field("service_id", &self.service_id);
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field(
            "connection_notification_type",
            &self.connection_notification_type,
        );
        formatter.field(
            "connection_notification_arn",
            &self.connection_notification_arn,
        );
        formatter.field("connection_events", &self.connection_events);
        formatter.field(
            "connection_notification_state",
            &self.connection_notification_state,
        );
        formatter.finish()
    }
}
/// See [`ConnectionNotification`](crate::model::ConnectionNotification)
pub mod connection_notification {
    /// A builder for [`ConnectionNotification`](crate::model::ConnectionNotification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_notification_id: std::option::Option<std::string::String>,
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) connection_notification_type:
            std::option::Option<crate::model::ConnectionNotificationType>,
        pub(crate) connection_notification_arn: std::option::Option<std::string::String>,
        pub(crate) connection_events: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) connection_notification_state:
            std::option::Option<crate::model::ConnectionNotificationState>,
    }
    impl Builder {
        /// <p>The ID of the notification.</p>
        pub fn connection_notification_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_notification_id = Some(input.into());
            self
        }
        pub fn set_connection_notification_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_notification_id = input;
            self
        }
        /// <p>The ID of the endpoint service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The ID of the VPC endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The type of notification.</p>
        pub fn connection_notification_type(
            mut self,
            input: crate::model::ConnectionNotificationType,
        ) -> Self {
            self.connection_notification_type = Some(input);
            self
        }
        pub fn set_connection_notification_type(
            mut self,
            input: std::option::Option<crate::model::ConnectionNotificationType>,
        ) -> Self {
            self.connection_notification_type = input;
            self
        }
        /// <p>The ARN of the SNS topic for the notification.</p>
        pub fn connection_notification_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.connection_notification_arn = Some(input.into());
            self
        }
        pub fn set_connection_notification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_notification_arn = input;
            self
        }
        pub fn connection_events(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connection_events.unwrap_or_default();
            v.push(input.into());
            self.connection_events = Some(v);
            self
        }
        pub fn set_connection_events(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connection_events = input;
            self
        }
        /// <p>The state of the notification.</p>
        pub fn connection_notification_state(
            mut self,
            input: crate::model::ConnectionNotificationState,
        ) -> Self {
            self.connection_notification_state = Some(input);
            self
        }
        pub fn set_connection_notification_state(
            mut self,
            input: std::option::Option<crate::model::ConnectionNotificationState>,
        ) -> Self {
            self.connection_notification_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionNotification`](crate::model::ConnectionNotification)
        pub fn build(self) -> crate::model::ConnectionNotification {
            crate::model::ConnectionNotification {
                connection_notification_id: self.connection_notification_id,
                service_id: self.service_id,
                vpc_endpoint_id: self.vpc_endpoint_id,
                connection_notification_type: self.connection_notification_type,
                connection_notification_arn: self.connection_notification_arn,
                connection_events: self.connection_events,
                connection_notification_state: self.connection_notification_state,
            }
        }
    }
}
impl ConnectionNotification {
    /// Creates a new builder-style object to manufacture [`ConnectionNotification`](crate::model::ConnectionNotification)
    pub fn builder() -> crate::model::connection_notification::Builder {
        crate::model::connection_notification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionNotificationState {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConnectionNotificationState {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ConnectionNotificationState::Disabled,
            "Enabled" => ConnectionNotificationState::Enabled,
            other => ConnectionNotificationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConnectionNotificationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionNotificationState::from(s))
    }
}
impl ConnectionNotificationState {
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionNotificationState::Disabled => "Disabled",
            ConnectionNotificationState::Enabled => "Enabled",
            ConnectionNotificationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ConnectionNotificationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionNotificationType {
    Topic,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConnectionNotificationType {
    fn from(s: &str) -> Self {
        match s {
            "Topic" => ConnectionNotificationType::Topic,
            other => ConnectionNotificationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConnectionNotificationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionNotificationType::from(s))
    }
}
impl ConnectionNotificationType {
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionNotificationType::Topic => "Topic",
            ConnectionNotificationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Topic"]
    }
}
impl AsRef<str> for ConnectionNotificationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the ClassicLink DNS support status of a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassicLinkDnsSupport {
    /// <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
    pub classic_link_dns_supported: std::option::Option<bool>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClassicLinkDnsSupport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassicLinkDnsSupport");
        formatter.field(
            "classic_link_dns_supported",
            &self.classic_link_dns_supported,
        );
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`ClassicLinkDnsSupport`](crate::model::ClassicLinkDnsSupport)
pub mod classic_link_dns_support {
    /// A builder for [`ClassicLinkDnsSupport`](crate::model::ClassicLinkDnsSupport)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classic_link_dns_supported: std::option::Option<bool>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
        pub fn classic_link_dns_supported(mut self, input: bool) -> Self {
            self.classic_link_dns_supported = Some(input);
            self
        }
        pub fn set_classic_link_dns_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.classic_link_dns_supported = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassicLinkDnsSupport`](crate::model::ClassicLinkDnsSupport)
        pub fn build(self) -> crate::model::ClassicLinkDnsSupport {
            crate::model::ClassicLinkDnsSupport {
                classic_link_dns_supported: self.classic_link_dns_supported,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl ClassicLinkDnsSupport {
    /// Creates a new builder-style object to manufacture [`ClassicLinkDnsSupport`](crate::model::ClassicLinkDnsSupport)
    pub fn builder() -> crate::model::classic_link_dns_support::Builder {
        crate::model::classic_link_dns_support::Builder::default()
    }
}

/// <p>Describes whether a VPC is enabled for ClassicLink.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcClassicLink {
    /// <p>Indicates whether the VPC is enabled for ClassicLink.</p>
    pub classic_link_enabled: std::option::Option<bool>,
    /// <p>Any tags assigned to the VPC.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcClassicLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcClassicLink");
        formatter.field("classic_link_enabled", &self.classic_link_enabled);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`VpcClassicLink`](crate::model::VpcClassicLink)
pub mod vpc_classic_link {
    /// A builder for [`VpcClassicLink`](crate::model::VpcClassicLink)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classic_link_enabled: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether the VPC is enabled for ClassicLink.</p>
        pub fn classic_link_enabled(mut self, input: bool) -> Self {
            self.classic_link_enabled = Some(input);
            self
        }
        pub fn set_classic_link_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.classic_link_enabled = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcClassicLink`](crate::model::VpcClassicLink)
        pub fn build(self) -> crate::model::VpcClassicLink {
            crate::model::VpcClassicLink {
                classic_link_enabled: self.classic_link_enabled,
                tags: self.tags,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl VpcClassicLink {
    /// Creates a new builder-style object to manufacture [`VpcClassicLink`](crate::model::VpcClassicLink)
    pub fn builder() -> crate::model::vpc_classic_link::Builder {
        crate::model::vpc_classic_link::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpcAttributeName {
    EnableDnsHostnames,
    EnableDnsSupport,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpcAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "enableDnsHostnames" => VpcAttributeName::EnableDnsHostnames,
            "enableDnsSupport" => VpcAttributeName::EnableDnsSupport,
            other => VpcAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpcAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpcAttributeName::from(s))
    }
}
impl VpcAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            VpcAttributeName::EnableDnsHostnames => "enableDnsHostnames",
            VpcAttributeName::EnableDnsSupport => "enableDnsSupport",
            VpcAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["enableDnsHostnames", "enableDnsSupport"]
    }
}
impl AsRef<str> for VpcAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the volume status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusItem {
    /// <p>The details of the operation.</p>
    pub actions: std::option::Option<std::vec::Vec<crate::model::VolumeStatusAction>>,
    /// <p>The Availability Zone of the volume.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>A list of events associated with the volume.</p>
    pub events: std::option::Option<std::vec::Vec<crate::model::VolumeStatusEvent>>,
    /// <p>The volume ID.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>The volume status.</p>
    pub volume_status: std::option::Option<crate::model::VolumeStatusInfo>,
    /// <p>Information about the instances to which the volume is attached.</p>
    pub attachment_statuses:
        std::option::Option<std::vec::Vec<crate::model::VolumeStatusAttachmentStatus>>,
}
impl std::fmt::Debug for VolumeStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusItem");
        formatter.field("actions", &self.actions);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("events", &self.events);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("volume_status", &self.volume_status);
        formatter.field("attachment_statuses", &self.attachment_statuses);
        formatter.finish()
    }
}
/// See [`VolumeStatusItem`](crate::model::VolumeStatusItem)
pub mod volume_status_item {
    /// A builder for [`VolumeStatusItem`](crate::model::VolumeStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) actions: std::option::Option<std::vec::Vec<crate::model::VolumeStatusAction>>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::VolumeStatusEvent>>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) volume_status: std::option::Option<crate::model::VolumeStatusInfo>,
        pub(crate) attachment_statuses:
            std::option::Option<std::vec::Vec<crate::model::VolumeStatusAttachmentStatus>>,
    }
    impl Builder {
        pub fn actions(mut self, input: impl Into<crate::model::VolumeStatusAction>) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input.into());
            self.actions = Some(v);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeStatusAction>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// <p>The Availability Zone of the volume.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        pub fn events(mut self, input: impl Into<crate::model::VolumeStatusEvent>) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input.into());
            self.events = Some(v);
            self
        }
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeStatusEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The volume ID.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>The volume status.</p>
        pub fn volume_status(mut self, input: crate::model::VolumeStatusInfo) -> Self {
            self.volume_status = Some(input);
            self
        }
        pub fn set_volume_status(
            mut self,
            input: std::option::Option<crate::model::VolumeStatusInfo>,
        ) -> Self {
            self.volume_status = input;
            self
        }
        pub fn attachment_statuses(
            mut self,
            input: impl Into<crate::model::VolumeStatusAttachmentStatus>,
        ) -> Self {
            let mut v = self.attachment_statuses.unwrap_or_default();
            v.push(input.into());
            self.attachment_statuses = Some(v);
            self
        }
        pub fn set_attachment_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeStatusAttachmentStatus>>,
        ) -> Self {
            self.attachment_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusItem`](crate::model::VolumeStatusItem)
        pub fn build(self) -> crate::model::VolumeStatusItem {
            crate::model::VolumeStatusItem {
                actions: self.actions,
                availability_zone: self.availability_zone,
                outpost_arn: self.outpost_arn,
                events: self.events,
                volume_id: self.volume_id,
                volume_status: self.volume_status,
                attachment_statuses: self.attachment_statuses,
            }
        }
    }
}
impl VolumeStatusItem {
    /// Creates a new builder-style object to manufacture [`VolumeStatusItem`](crate::model::VolumeStatusItem)
    pub fn builder() -> crate::model::volume_status_item::Builder {
        crate::model::volume_status_item::Builder::default()
    }
}

/// <p>Information about the instances to which the volume is attached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusAttachmentStatus {
    /// <p>The maximum IOPS supported by the attached instance.</p>
    pub io_performance: std::option::Option<std::string::String>,
    /// <p>The ID of the attached instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VolumeStatusAttachmentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusAttachmentStatus");
        formatter.field("io_performance", &self.io_performance);
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}
/// See [`VolumeStatusAttachmentStatus`](crate::model::VolumeStatusAttachmentStatus)
pub mod volume_status_attachment_status {
    /// A builder for [`VolumeStatusAttachmentStatus`](crate::model::VolumeStatusAttachmentStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) io_performance: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum IOPS supported by the attached instance.</p>
        pub fn io_performance(mut self, input: impl Into<std::string::String>) -> Self {
            self.io_performance = Some(input.into());
            self
        }
        pub fn set_io_performance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.io_performance = input;
            self
        }
        /// <p>The ID of the attached instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusAttachmentStatus`](crate::model::VolumeStatusAttachmentStatus)
        pub fn build(self) -> crate::model::VolumeStatusAttachmentStatus {
            crate::model::VolumeStatusAttachmentStatus {
                io_performance: self.io_performance,
                instance_id: self.instance_id,
            }
        }
    }
}
impl VolumeStatusAttachmentStatus {
    /// Creates a new builder-style object to manufacture [`VolumeStatusAttachmentStatus`](crate::model::VolumeStatusAttachmentStatus)
    pub fn builder() -> crate::model::volume_status_attachment_status::Builder {
        crate::model::volume_status_attachment_status::Builder::default()
    }
}

/// <p>Describes the status of a volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusInfo {
    /// <p>The details of the volume status.</p>
    pub details: std::option::Option<std::vec::Vec<crate::model::VolumeStatusDetails>>,
    /// <p>The status of the volume.</p>
    pub status: std::option::Option<crate::model::VolumeStatusInfoStatus>,
}
impl std::fmt::Debug for VolumeStatusInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusInfo");
        formatter.field("details", &self.details);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VolumeStatusInfo`](crate::model::VolumeStatusInfo)
pub mod volume_status_info {
    /// A builder for [`VolumeStatusInfo`](crate::model::VolumeStatusInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) details: std::option::Option<std::vec::Vec<crate::model::VolumeStatusDetails>>,
        pub(crate) status: std::option::Option<crate::model::VolumeStatusInfoStatus>,
    }
    impl Builder {
        pub fn details(mut self, input: impl Into<crate::model::VolumeStatusDetails>) -> Self {
            let mut v = self.details.unwrap_or_default();
            v.push(input.into());
            self.details = Some(v);
            self
        }
        pub fn set_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeStatusDetails>>,
        ) -> Self {
            self.details = input;
            self
        }
        /// <p>The status of the volume.</p>
        pub fn status(mut self, input: crate::model::VolumeStatusInfoStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VolumeStatusInfoStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusInfo`](crate::model::VolumeStatusInfo)
        pub fn build(self) -> crate::model::VolumeStatusInfo {
            crate::model::VolumeStatusInfo {
                details: self.details,
                status: self.status,
            }
        }
    }
}
impl VolumeStatusInfo {
    /// Creates a new builder-style object to manufacture [`VolumeStatusInfo`](crate::model::VolumeStatusInfo)
    pub fn builder() -> crate::model::volume_status_info::Builder {
        crate::model::volume_status_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeStatusInfoStatus {
    Impaired,
    InsufficientData,
    Ok,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeStatusInfoStatus {
    fn from(s: &str) -> Self {
        match s {
            "impaired" => VolumeStatusInfoStatus::Impaired,
            "insufficient-data" => VolumeStatusInfoStatus::InsufficientData,
            "ok" => VolumeStatusInfoStatus::Ok,
            other => VolumeStatusInfoStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeStatusInfoStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeStatusInfoStatus::from(s))
    }
}
impl VolumeStatusInfoStatus {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeStatusInfoStatus::Impaired => "impaired",
            VolumeStatusInfoStatus::InsufficientData => "insufficient-data",
            VolumeStatusInfoStatus::Ok => "ok",
            VolumeStatusInfoStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["impaired", "insufficient-data", "ok"]
    }
}
impl AsRef<str> for VolumeStatusInfoStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a volume status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusDetails {
    /// <p>The name of the volume status.</p>
    pub name: std::option::Option<crate::model::VolumeStatusName>,
    /// <p>The intended status of the volume status.</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VolumeStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusDetails");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VolumeStatusDetails`](crate::model::VolumeStatusDetails)
pub mod volume_status_details {
    /// A builder for [`VolumeStatusDetails`](crate::model::VolumeStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::VolumeStatusName>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the volume status.</p>
        pub fn name(mut self, input: crate::model::VolumeStatusName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::VolumeStatusName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The intended status of the volume status.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusDetails`](crate::model::VolumeStatusDetails)
        pub fn build(self) -> crate::model::VolumeStatusDetails {
            crate::model::VolumeStatusDetails {
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl VolumeStatusDetails {
    /// Creates a new builder-style object to manufacture [`VolumeStatusDetails`](crate::model::VolumeStatusDetails)
    pub fn builder() -> crate::model::volume_status_details::Builder {
        crate::model::volume_status_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeStatusName {
    IoEnabled,
    IoPerformance,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeStatusName {
    fn from(s: &str) -> Self {
        match s {
            "io-enabled" => VolumeStatusName::IoEnabled,
            "io-performance" => VolumeStatusName::IoPerformance,
            other => VolumeStatusName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeStatusName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeStatusName::from(s))
    }
}
impl VolumeStatusName {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeStatusName::IoEnabled => "io-enabled",
            VolumeStatusName::IoPerformance => "io-performance",
            VolumeStatusName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["io-enabled", "io-performance"]
    }
}
impl AsRef<str> for VolumeStatusName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a volume status event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusEvent {
    /// <p>A description of the event.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of this event.</p>
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The type of this event.</p>
    pub event_type: std::option::Option<std::string::String>,
    /// <p>The latest end time of the event.</p>
    pub not_after: std::option::Option<smithy_types::Instant>,
    /// <p>The earliest start time of the event.</p>
    pub not_before: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the instance associated with the event.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VolumeStatusEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusEvent");
        formatter.field("description", &self.description);
        formatter.field("event_id", &self.event_id);
        formatter.field("event_type", &self.event_type);
        formatter.field("not_after", &self.not_after);
        formatter.field("not_before", &self.not_before);
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}
/// See [`VolumeStatusEvent`](crate::model::VolumeStatusEvent)
pub mod volume_status_event {
    /// A builder for [`VolumeStatusEvent`](crate::model::VolumeStatusEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_type: std::option::Option<std::string::String>,
        pub(crate) not_after: std::option::Option<smithy_types::Instant>,
        pub(crate) not_before: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description of the event.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of this event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The type of this event.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type = Some(input.into());
            self
        }
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_type = input;
            self
        }
        /// <p>The latest end time of the event.</p>
        pub fn not_after(mut self, input: smithy_types::Instant) -> Self {
            self.not_after = Some(input);
            self
        }
        pub fn set_not_after(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_after = input;
            self
        }
        /// <p>The earliest start time of the event.</p>
        pub fn not_before(mut self, input: smithy_types::Instant) -> Self {
            self.not_before = Some(input);
            self
        }
        pub fn set_not_before(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_before = input;
            self
        }
        /// <p>The ID of the instance associated with the event.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusEvent`](crate::model::VolumeStatusEvent)
        pub fn build(self) -> crate::model::VolumeStatusEvent {
            crate::model::VolumeStatusEvent {
                description: self.description,
                event_id: self.event_id,
                event_type: self.event_type,
                not_after: self.not_after,
                not_before: self.not_before,
                instance_id: self.instance_id,
            }
        }
    }
}
impl VolumeStatusEvent {
    /// Creates a new builder-style object to manufacture [`VolumeStatusEvent`](crate::model::VolumeStatusEvent)
    pub fn builder() -> crate::model::volume_status_event::Builder {
        crate::model::volume_status_event::Builder::default()
    }
}

/// <p>Describes a volume status operation code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeStatusAction {
    /// <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A description of the operation.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the event associated with this operation.</p>
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The event type associated with this operation.</p>
    pub event_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VolumeStatusAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeStatusAction");
        formatter.field("code", &self.code);
        formatter.field("description", &self.description);
        formatter.field("event_id", &self.event_id);
        formatter.field("event_type", &self.event_type);
        formatter.finish()
    }
}
/// See [`VolumeStatusAction`](crate::model::VolumeStatusAction)
pub mod volume_status_action {
    /// A builder for [`VolumeStatusAction`](crate::model::VolumeStatusAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A description of the operation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the event associated with this operation.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The event type associated with this operation.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type = Some(input.into());
            self
        }
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeStatusAction`](crate::model::VolumeStatusAction)
        pub fn build(self) -> crate::model::VolumeStatusAction {
            crate::model::VolumeStatusAction {
                code: self.code,
                description: self.description,
                event_id: self.event_id,
                event_type: self.event_type,
            }
        }
    }
}
impl VolumeStatusAction {
    /// Creates a new builder-style object to manufacture [`VolumeStatusAction`](crate::model::VolumeStatusAction)
    pub fn builder() -> crate::model::volume_status_action::Builder {
        crate::model::volume_status_action::Builder::default()
    }
}

/// <p>Describes a volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Volume {
    /// <p>Information about the volume attachments.</p>
    pub attachments: std::option::Option<std::vec::Vec<crate::model::VolumeAttachment>>,
    /// <p>The Availability Zone for the volume.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The time stamp when volume creation was initiated.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates whether the volume is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the
    /// volume encryption key for the volume.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiBs.</p>
    pub size: std::option::Option<i32>,
    /// <p>The snapshot from which the volume was created, if applicable.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The volume state.</p>
    pub state: std::option::Option<crate::model::VolumeState>,
    /// <p>The ID of the volume.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this represents
    /// the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline
    /// performance of the volume and the rate at which the volume accumulates I/O credits for bursting.</p>
    pub iops: std::option::Option<i32>,
    /// <p>Any tags assigned to the volume.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The volume type.</p>
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>Indicates whether the volume was created using fast snapshot restore.</p>
    pub fast_restored: std::option::Option<bool>,
    /// <p>Indicates whether Amazon EBS Multi-Attach is enabled.</p>
    pub multi_attach_enabled: std::option::Option<bool>,
    /// <p>The throughput that the volume supports, in MiB/s.</p>
    pub throughput: std::option::Option<i32>,
}
impl std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Volume");
        formatter.field("attachments", &self.attachments);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("create_time", &self.create_time);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("size", &self.size);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("state", &self.state);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("iops", &self.iops);
        formatter.field("tags", &self.tags);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("fast_restored", &self.fast_restored);
        formatter.field("multi_attach_enabled", &self.multi_attach_enabled);
        formatter.field("throughput", &self.throughput);
        formatter.finish()
    }
}
/// See [`Volume`](crate::model::Volume)
pub mod volume {
    /// A builder for [`Volume`](crate::model::Volume)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachments: std::option::Option<std::vec::Vec<crate::model::VolumeAttachment>>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i32>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VolumeState>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) fast_restored: std::option::Option<bool>,
        pub(crate) multi_attach_enabled: std::option::Option<bool>,
        pub(crate) throughput: std::option::Option<i32>,
    }
    impl Builder {
        pub fn attachments(mut self, input: impl Into<crate::model::VolumeAttachment>) -> Self {
            let mut v = self.attachments.unwrap_or_default();
            v.push(input.into());
            self.attachments = Some(v);
            self
        }
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VolumeAttachment>>,
        ) -> Self {
            self.attachments = input;
            self
        }
        /// <p>The Availability Zone for the volume.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The time stamp when volume creation was initiated.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>Indicates whether the volume is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the
        /// volume encryption key for the volume.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The size of the volume, in GiBs.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// <p>The snapshot from which the volume was created, if applicable.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The volume state.</p>
        pub fn state(mut self, input: crate::model::VolumeState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::VolumeState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this represents
        /// the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline
        /// performance of the volume and the rate at which the volume accumulates I/O credits for bursting.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The volume type.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Indicates whether the volume was created using fast snapshot restore.</p>
        pub fn fast_restored(mut self, input: bool) -> Self {
            self.fast_restored = Some(input);
            self
        }
        pub fn set_fast_restored(mut self, input: std::option::Option<bool>) -> Self {
            self.fast_restored = input;
            self
        }
        /// <p>Indicates whether Amazon EBS Multi-Attach is enabled.</p>
        pub fn multi_attach_enabled(mut self, input: bool) -> Self {
            self.multi_attach_enabled = Some(input);
            self
        }
        pub fn set_multi_attach_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.multi_attach_enabled = input;
            self
        }
        /// <p>The throughput that the volume supports, in MiB/s.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`Volume`](crate::model::Volume)
        pub fn build(self) -> crate::model::Volume {
            crate::model::Volume {
                attachments: self.attachments,
                availability_zone: self.availability_zone,
                create_time: self.create_time,
                encrypted: self.encrypted,
                kms_key_id: self.kms_key_id,
                outpost_arn: self.outpost_arn,
                size: self.size,
                snapshot_id: self.snapshot_id,
                state: self.state,
                volume_id: self.volume_id,
                iops: self.iops,
                tags: self.tags,
                volume_type: self.volume_type,
                fast_restored: self.fast_restored,
                multi_attach_enabled: self.multi_attach_enabled,
                throughput: self.throughput,
            }
        }
    }
}
impl Volume {
    /// Creates a new builder-style object to manufacture [`Volume`](crate::model::Volume)
    pub fn builder() -> crate::model::volume::Builder {
        crate::model::volume::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeState {
    Available,
    Creating,
    Deleted,
    Deleting,
    Error,
    InUse,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeState {
    fn from(s: &str) -> Self {
        match s {
            "available" => VolumeState::Available,
            "creating" => VolumeState::Creating,
            "deleted" => VolumeState::Deleted,
            "deleting" => VolumeState::Deleting,
            "error" => VolumeState::Error,
            "in-use" => VolumeState::InUse,
            other => VolumeState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeState::from(s))
    }
}
impl VolumeState {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeState::Available => "available",
            VolumeState::Creating => "creating",
            VolumeState::Deleted => "deleted",
            VolumeState::Deleting => "deleting",
            VolumeState::Error => "error",
            VolumeState::InUse => "in-use",
            VolumeState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "available",
            "creating",
            "deleted",
            "deleting",
            "error",
            "in-use",
        ]
    }
}
impl AsRef<str> for VolumeState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes volume attachment details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VolumeAttachment {
    /// <p>The time stamp when the attachment initiated.</p>
    pub attach_time: std::option::Option<smithy_types::Instant>,
    /// <p>The device name.</p>
    pub device: std::option::Option<std::string::String>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The attachment state of the volume.</p>
    pub state: std::option::Option<crate::model::VolumeAttachmentState>,
    /// <p>The ID of the volume.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
}
impl std::fmt::Debug for VolumeAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VolumeAttachment");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("device", &self.device);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("state", &self.state);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.finish()
    }
}
/// See [`VolumeAttachment`](crate::model::VolumeAttachment)
pub mod volume_attachment {
    /// A builder for [`VolumeAttachment`](crate::model::VolumeAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<smithy_types::Instant>,
        pub(crate) device: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::VolumeAttachmentState>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The time stamp when the attachment initiated.</p>
        pub fn attach_time(mut self, input: smithy_types::Instant) -> Self {
            self.attach_time = Some(input);
            self
        }
        pub fn set_attach_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>The device name.</p>
        pub fn device(mut self, input: impl Into<std::string::String>) -> Self {
            self.device = Some(input.into());
            self
        }
        pub fn set_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The attachment state of the volume.</p>
        pub fn state(mut self, input: crate::model::VolumeAttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::VolumeAttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeAttachment`](crate::model::VolumeAttachment)
        pub fn build(self) -> crate::model::VolumeAttachment {
            crate::model::VolumeAttachment {
                attach_time: self.attach_time,
                device: self.device,
                instance_id: self.instance_id,
                state: self.state,
                volume_id: self.volume_id,
                delete_on_termination: self.delete_on_termination,
            }
        }
    }
}
impl VolumeAttachment {
    /// Creates a new builder-style object to manufacture [`VolumeAttachment`](crate::model::VolumeAttachment)
    pub fn builder() -> crate::model::volume_attachment::Builder {
        crate::model::volume_attachment::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeAttributeName {
    AutoEnableIo,
    ProductCodes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VolumeAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "autoEnableIO" => VolumeAttributeName::AutoEnableIo,
            "productCodes" => VolumeAttributeName::ProductCodes,
            other => VolumeAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VolumeAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeAttributeName::from(s))
    }
}
impl VolumeAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            VolumeAttributeName::AutoEnableIo => "autoEnableIO",
            VolumeAttributeName::ProductCodes => "productCodes",
            VolumeAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["autoEnableIO", "productCodes"]
    }
}
impl AsRef<str> for VolumeAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <note>
/// <p>Currently available in <b>limited preview only</b>.
/// If you are interested in using this feature, contact your account manager.</p>
/// </note>
/// <p>Information about an association between a branch network interface with a trunk network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrunkInterfaceAssociation {
    /// <p>The ID of the association.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the branch network interface.</p>
    pub branch_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of the trunk network interface.</p>
    pub trunk_interface_id: std::option::Option<std::string::String>,
    /// <p>The interface protocol. Valid values are <code>VLAN</code> and <code>GRE</code>.</p>
    pub interface_protocol: std::option::Option<crate::model::InterfaceProtocolType>,
    /// <p>The ID of the VLAN when you use the VLAN protocol.</p>
    pub vlan_id: std::option::Option<i32>,
    /// <p>The application key when you use the GRE protocol.</p>
    pub gre_key: std::option::Option<i32>,
    /// <p>The tags for the trunk interface association.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TrunkInterfaceAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrunkInterfaceAssociation");
        formatter.field("association_id", &self.association_id);
        formatter.field("branch_interface_id", &self.branch_interface_id);
        formatter.field("trunk_interface_id", &self.trunk_interface_id);
        formatter.field("interface_protocol", &self.interface_protocol);
        formatter.field("vlan_id", &self.vlan_id);
        formatter.field("gre_key", &self.gre_key);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrunkInterfaceAssociation`](crate::model::TrunkInterfaceAssociation)
pub mod trunk_interface_association {
    /// A builder for [`TrunkInterfaceAssociation`](crate::model::TrunkInterfaceAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) branch_interface_id: std::option::Option<std::string::String>,
        pub(crate) trunk_interface_id: std::option::Option<std::string::String>,
        pub(crate) interface_protocol: std::option::Option<crate::model::InterfaceProtocolType>,
        pub(crate) vlan_id: std::option::Option<i32>,
        pub(crate) gre_key: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The ID of the branch network interface.</p>
        pub fn branch_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch_interface_id = Some(input.into());
            self
        }
        pub fn set_branch_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.branch_interface_id = input;
            self
        }
        /// <p>The ID of the trunk network interface.</p>
        pub fn trunk_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trunk_interface_id = Some(input.into());
            self
        }
        pub fn set_trunk_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trunk_interface_id = input;
            self
        }
        /// <p>The interface protocol. Valid values are <code>VLAN</code> and <code>GRE</code>.</p>
        pub fn interface_protocol(mut self, input: crate::model::InterfaceProtocolType) -> Self {
            self.interface_protocol = Some(input);
            self
        }
        pub fn set_interface_protocol(
            mut self,
            input: std::option::Option<crate::model::InterfaceProtocolType>,
        ) -> Self {
            self.interface_protocol = input;
            self
        }
        /// <p>The ID of the VLAN when you use the VLAN protocol.</p>
        pub fn vlan_id(mut self, input: i32) -> Self {
            self.vlan_id = Some(input);
            self
        }
        pub fn set_vlan_id(mut self, input: std::option::Option<i32>) -> Self {
            self.vlan_id = input;
            self
        }
        /// <p>The application key when you use the GRE protocol.</p>
        pub fn gre_key(mut self, input: i32) -> Self {
            self.gre_key = Some(input);
            self
        }
        pub fn set_gre_key(mut self, input: std::option::Option<i32>) -> Self {
            self.gre_key = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrunkInterfaceAssociation`](crate::model::TrunkInterfaceAssociation)
        pub fn build(self) -> crate::model::TrunkInterfaceAssociation {
            crate::model::TrunkInterfaceAssociation {
                association_id: self.association_id,
                branch_interface_id: self.branch_interface_id,
                trunk_interface_id: self.trunk_interface_id,
                interface_protocol: self.interface_protocol,
                vlan_id: self.vlan_id,
                gre_key: self.gre_key,
                tags: self.tags,
            }
        }
    }
}
impl TrunkInterfaceAssociation {
    /// Creates a new builder-style object to manufacture [`TrunkInterfaceAssociation`](crate::model::TrunkInterfaceAssociation)
    pub fn builder() -> crate::model::trunk_interface_association::Builder {
        crate::model::trunk_interface_association::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InterfaceProtocolType {
    Gre,
    Vlan,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InterfaceProtocolType {
    fn from(s: &str) -> Self {
        match s {
            "GRE" => InterfaceProtocolType::Gre,
            "VLAN" => InterfaceProtocolType::Vlan,
            other => InterfaceProtocolType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InterfaceProtocolType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InterfaceProtocolType::from(s))
    }
}
impl InterfaceProtocolType {
    pub fn as_str(&self) -> &str {
        match self {
            InterfaceProtocolType::Gre => "GRE",
            InterfaceProtocolType::Vlan => "VLAN",
            InterfaceProtocolType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["GRE", "VLAN"]
    }
}
impl AsRef<str> for InterfaceProtocolType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a transit gateway route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRouteTable {
    /// <p>The ID of the transit gateway route table.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The state of the transit gateway route table.</p>
    pub state: std::option::Option<crate::model::TransitGatewayRouteTableState>,
    /// <p>Indicates whether this is the default association route table for the transit gateway.</p>
    pub default_association_route_table: std::option::Option<bool>,
    /// <p>Indicates whether this is the default propagation route table for the transit gateway.</p>
    pub default_propagation_route_table: std::option::Option<bool>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Any tags assigned to the route table.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayRouteTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRouteTable");
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("state", &self.state);
        formatter.field(
            "default_association_route_table",
            &self.default_association_route_table,
        );
        formatter.field(
            "default_propagation_route_table",
            &self.default_propagation_route_table,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayRouteTable`](crate::model::TransitGatewayRouteTable)
pub mod transit_gateway_route_table {
    /// A builder for [`TransitGatewayRouteTable`](crate::model::TransitGatewayRouteTable)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayRouteTableState>,
        pub(crate) default_association_route_table: std::option::Option<bool>,
        pub(crate) default_propagation_route_table: std::option::Option<bool>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The state of the transit gateway route table.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayRouteTableState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayRouteTableState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates whether this is the default association route table for the transit gateway.</p>
        pub fn default_association_route_table(mut self, input: bool) -> Self {
            self.default_association_route_table = Some(input);
            self
        }
        pub fn set_default_association_route_table(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.default_association_route_table = input;
            self
        }
        /// <p>Indicates whether this is the default propagation route table for the transit gateway.</p>
        pub fn default_propagation_route_table(mut self, input: bool) -> Self {
            self.default_propagation_route_table = Some(input);
            self
        }
        pub fn set_default_propagation_route_table(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.default_propagation_route_table = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRouteTable`](crate::model::TransitGatewayRouteTable)
        pub fn build(self) -> crate::model::TransitGatewayRouteTable {
            crate::model::TransitGatewayRouteTable {
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                transit_gateway_id: self.transit_gateway_id,
                state: self.state,
                default_association_route_table: self.default_association_route_table,
                default_propagation_route_table: self.default_propagation_route_table,
                creation_time: self.creation_time,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayRouteTable {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRouteTable`](crate::model::TransitGatewayRouteTable)
    pub fn builder() -> crate::model::transit_gateway_route_table::Builder {
        crate::model::transit_gateway_route_table::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayRouteTableState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayRouteTableState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayRouteTableState::Available,
            "deleted" => TransitGatewayRouteTableState::Deleted,
            "deleting" => TransitGatewayRouteTableState::Deleting,
            "pending" => TransitGatewayRouteTableState::Pending,
            other => TransitGatewayRouteTableState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayRouteTableState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayRouteTableState::from(s))
    }
}
impl TransitGatewayRouteTableState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayRouteTableState::Available => "available",
            TransitGatewayRouteTableState::Deleted => "deleted",
            TransitGatewayRouteTableState::Deleting => "deleting",
            TransitGatewayRouteTableState::Pending => "pending",
            TransitGatewayRouteTableState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for TransitGatewayRouteTableState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the transit gateway multicast domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDomain {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_arn: std::option::Option<std::string::String>,
    /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The options for the transit gateway multicast domain.</p>
    pub options: std::option::Option<crate::model::TransitGatewayMulticastDomainOptions>,
    /// <p>The state of the transit gateway multicast domain.</p>
    pub state: std::option::Option<crate::model::TransitGatewayMulticastDomainState>,
    /// <p>The time the transit gateway multicast domain was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The tags for the transit gateway multicast domain.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayMulticastDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDomain");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field(
            "transit_gateway_multicast_domain_arn",
            &self.transit_gateway_multicast_domain_arn,
        );
        formatter.field("owner_id", &self.owner_id);
        formatter.field("options", &self.options);
        formatter.field("state", &self.state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDomain`](crate::model::TransitGatewayMulticastDomain)
pub mod transit_gateway_multicast_domain {
    /// A builder for [`TransitGatewayMulticastDomain`](crate::model::TransitGatewayMulticastDomain)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_multicast_domain_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<crate::model::TransitGatewayMulticastDomainOptions>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayMulticastDomainState>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_arn = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_arn = input;
            self
        }
        /// <p> The ID of the Amazon Web Services account that owns the transit gateway multicast domain.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The options for the transit gateway multicast domain.</p>
        pub fn options(
            mut self,
            input: crate::model::TransitGatewayMulticastDomainOptions,
        ) -> Self {
            self.options = Some(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayMulticastDomainOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// <p>The state of the transit gateway multicast domain.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayMulticastDomainState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayMulticastDomainState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time the transit gateway multicast domain was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDomain`](crate::model::TransitGatewayMulticastDomain)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDomain {
            crate::model::TransitGatewayMulticastDomain {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                transit_gateway_id: self.transit_gateway_id,
                transit_gateway_multicast_domain_arn: self.transit_gateway_multicast_domain_arn,
                owner_id: self.owner_id,
                options: self.options,
                state: self.state,
                creation_time: self.creation_time,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayMulticastDomain {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDomain`](crate::model::TransitGatewayMulticastDomain)
    pub fn builder() -> crate::model::transit_gateway_multicast_domain::Builder {
        crate::model::transit_gateway_multicast_domain::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayMulticastDomainState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayMulticastDomainState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayMulticastDomainState::Available,
            "deleted" => TransitGatewayMulticastDomainState::Deleted,
            "deleting" => TransitGatewayMulticastDomainState::Deleting,
            "pending" => TransitGatewayMulticastDomainState::Pending,
            other => TransitGatewayMulticastDomainState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayMulticastDomainState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayMulticastDomainState::from(s))
    }
}
impl TransitGatewayMulticastDomainState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayMulticastDomainState::Available => "available",
            TransitGatewayMulticastDomainState::Deleted => "deleted",
            TransitGatewayMulticastDomainState::Deleting => "deleting",
            TransitGatewayMulticastDomainState::Pending => "pending",
            TransitGatewayMulticastDomainState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for TransitGatewayMulticastDomainState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the options for a transit gateway multicast domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDomainOptions {
    /// <p>Indicates whether Internet Group Management Protocol (IGMP) version 2 is turned on for the transit gateway multicast domain.</p>
    pub igmpv2_support: std::option::Option<crate::model::Igmpv2SupportValue>,
    /// <p>Indicates whether support for statically configuring transit gateway multicast group sources is turned on.</p>
    pub static_sources_support: std::option::Option<crate::model::StaticSourcesSupportValue>,
    /// <p>Indicates whether to automatically cross-account subnet associations that are associated with the transit gateway multicast domain.</p>
    pub auto_accept_shared_associations:
        std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
}
impl std::fmt::Debug for TransitGatewayMulticastDomainOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDomainOptions");
        formatter.field("igmpv2_support", &self.igmpv2_support);
        formatter.field("static_sources_support", &self.static_sources_support);
        formatter.field(
            "auto_accept_shared_associations",
            &self.auto_accept_shared_associations,
        );
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDomainOptions`](crate::model::TransitGatewayMulticastDomainOptions)
pub mod transit_gateway_multicast_domain_options {
    /// A builder for [`TransitGatewayMulticastDomainOptions`](crate::model::TransitGatewayMulticastDomainOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) igmpv2_support: std::option::Option<crate::model::Igmpv2SupportValue>,
        pub(crate) static_sources_support:
            std::option::Option<crate::model::StaticSourcesSupportValue>,
        pub(crate) auto_accept_shared_associations:
            std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
    }
    impl Builder {
        /// <p>Indicates whether Internet Group Management Protocol (IGMP) version 2 is turned on for the transit gateway multicast domain.</p>
        pub fn igmpv2_support(mut self, input: crate::model::Igmpv2SupportValue) -> Self {
            self.igmpv2_support = Some(input);
            self
        }
        pub fn set_igmpv2_support(
            mut self,
            input: std::option::Option<crate::model::Igmpv2SupportValue>,
        ) -> Self {
            self.igmpv2_support = input;
            self
        }
        /// <p>Indicates whether support for statically configuring transit gateway multicast group sources is turned on.</p>
        pub fn static_sources_support(
            mut self,
            input: crate::model::StaticSourcesSupportValue,
        ) -> Self {
            self.static_sources_support = Some(input);
            self
        }
        pub fn set_static_sources_support(
            mut self,
            input: std::option::Option<crate::model::StaticSourcesSupportValue>,
        ) -> Self {
            self.static_sources_support = input;
            self
        }
        /// <p>Indicates whether to automatically cross-account subnet associations that are associated with the transit gateway multicast domain.</p>
        pub fn auto_accept_shared_associations(
            mut self,
            input: crate::model::AutoAcceptSharedAssociationsValue,
        ) -> Self {
            self.auto_accept_shared_associations = Some(input);
            self
        }
        pub fn set_auto_accept_shared_associations(
            mut self,
            input: std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
        ) -> Self {
            self.auto_accept_shared_associations = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDomainOptions`](crate::model::TransitGatewayMulticastDomainOptions)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDomainOptions {
            crate::model::TransitGatewayMulticastDomainOptions {
                igmpv2_support: self.igmpv2_support,
                static_sources_support: self.static_sources_support,
                auto_accept_shared_associations: self.auto_accept_shared_associations,
            }
        }
    }
}
impl TransitGatewayMulticastDomainOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDomainOptions`](crate::model::TransitGatewayMulticastDomainOptions)
    pub fn builder() -> crate::model::transit_gateway_multicast_domain_options::Builder {
        crate::model::transit_gateway_multicast_domain_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoAcceptSharedAssociationsValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoAcceptSharedAssociationsValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => AutoAcceptSharedAssociationsValue::Disable,
            "enable" => AutoAcceptSharedAssociationsValue::Enable,
            other => AutoAcceptSharedAssociationsValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoAcceptSharedAssociationsValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoAcceptSharedAssociationsValue::from(s))
    }
}
impl AutoAcceptSharedAssociationsValue {
    pub fn as_str(&self) -> &str {
        match self {
            AutoAcceptSharedAssociationsValue::Disable => "disable",
            AutoAcceptSharedAssociationsValue::Enable => "enable",
            AutoAcceptSharedAssociationsValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for AutoAcceptSharedAssociationsValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StaticSourcesSupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StaticSourcesSupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => StaticSourcesSupportValue::Disable,
            "enable" => StaticSourcesSupportValue::Enable,
            other => StaticSourcesSupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StaticSourcesSupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StaticSourcesSupportValue::from(s))
    }
}
impl StaticSourcesSupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            StaticSourcesSupportValue::Disable => "disable",
            StaticSourcesSupportValue::Enable => "enable",
            StaticSourcesSupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for StaticSourcesSupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Igmpv2SupportValue {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Igmpv2SupportValue {
    fn from(s: &str) -> Self {
        match s {
            "disable" => Igmpv2SupportValue::Disable,
            "enable" => Igmpv2SupportValue::Enable,
            other => Igmpv2SupportValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Igmpv2SupportValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Igmpv2SupportValue::from(s))
    }
}
impl Igmpv2SupportValue {
    pub fn as_str(&self) -> &str {
        match self {
            Igmpv2SupportValue::Disable => "disable",
            Igmpv2SupportValue::Enable => "enable",
            Igmpv2SupportValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disable", "enable"]
    }
}
impl AsRef<str> for Igmpv2SupportValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a transit gateway Connect attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayConnect {
    /// <p>The ID of the Connect attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment from which the Connect attachment was created.</p>
    pub transport_transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The state of the attachment.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Connect attachment options.</p>
    pub options: std::option::Option<crate::model::TransitGatewayConnectOptions>,
    /// <p>The tags for the attachment.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayConnect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayConnect");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field(
            "transport_transit_gateway_attachment_id",
            &self.transport_transit_gateway_attachment_id,
        );
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("state", &self.state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("options", &self.options);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayConnect`](crate::model::TransitGatewayConnect)
pub mod transit_gateway_connect {
    /// A builder for [`TransitGatewayConnect`](crate::model::TransitGatewayConnect)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) transport_transit_gateway_attachment_id:
            std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) options: std::option::Option<crate::model::TransitGatewayConnectOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the Connect attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the attachment from which the Connect attachment was created.</p>
        pub fn transport_transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transport_transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transport_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transport_transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The Connect attachment options.</p>
        pub fn options(mut self, input: crate::model::TransitGatewayConnectOptions) -> Self {
            self.options = Some(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayConnectOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnect`](crate::model::TransitGatewayConnect)
        pub fn build(self) -> crate::model::TransitGatewayConnect {
            crate::model::TransitGatewayConnect {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                transport_transit_gateway_attachment_id: self
                    .transport_transit_gateway_attachment_id,
                transit_gateway_id: self.transit_gateway_id,
                state: self.state,
                creation_time: self.creation_time,
                options: self.options,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayConnect {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnect`](crate::model::TransitGatewayConnect)
    pub fn builder() -> crate::model::transit_gateway_connect::Builder {
        crate::model::transit_gateway_connect::Builder::default()
    }
}

/// <p>Describes the Connect attachment options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayConnectOptions {
    /// <p>The tunnel protocol.</p>
    pub protocol: std::option::Option<crate::model::ProtocolValue>,
}
impl std::fmt::Debug for TransitGatewayConnectOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayConnectOptions");
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`TransitGatewayConnectOptions`](crate::model::TransitGatewayConnectOptions)
pub mod transit_gateway_connect_options {
    /// A builder for [`TransitGatewayConnectOptions`](crate::model::TransitGatewayConnectOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ProtocolValue>,
    }
    impl Builder {
        /// <p>The tunnel protocol.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolValue) -> Self {
            self.protocol = Some(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolValue>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnectOptions`](crate::model::TransitGatewayConnectOptions)
        pub fn build(self) -> crate::model::TransitGatewayConnectOptions {
            crate::model::TransitGatewayConnectOptions {
                protocol: self.protocol,
            }
        }
    }
}
impl TransitGatewayConnectOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnectOptions`](crate::model::TransitGatewayConnectOptions)
    pub fn builder() -> crate::model::transit_gateway_connect_options::Builder {
        crate::model::transit_gateway_connect_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProtocolValue {
    Gre,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProtocolValue {
    fn from(s: &str) -> Self {
        match s {
            "gre" => ProtocolValue::Gre,
            other => ProtocolValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProtocolValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProtocolValue::from(s))
    }
}
impl ProtocolValue {
    pub fn as_str(&self) -> &str {
        match self {
            ProtocolValue::Gre => "gre",
            ProtocolValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["gre"]
    }
}
impl AsRef<str> for ProtocolValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a transit gateway Connect peer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayConnectPeer {
    /// <p>The ID of the Connect attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer.</p>
    pub transit_gateway_connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The state of the Connect peer.</p>
    pub state: std::option::Option<crate::model::TransitGatewayConnectPeerState>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Connect peer details.</p>
    pub connect_peer_configuration:
        std::option::Option<crate::model::TransitGatewayConnectPeerConfiguration>,
    /// <p>The tags for the Connect peer.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayConnectPeer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayConnectPeer");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field(
            "transit_gateway_connect_peer_id",
            &self.transit_gateway_connect_peer_id,
        );
        formatter.field("state", &self.state);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "connect_peer_configuration",
            &self.connect_peer_configuration,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayConnectPeer`](crate::model::TransitGatewayConnectPeer)
pub mod transit_gateway_connect_peer {
    /// A builder for [`TransitGatewayConnectPeer`](crate::model::TransitGatewayConnectPeer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayConnectPeerState>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) connect_peer_configuration:
            std::option::Option<crate::model::TransitGatewayConnectPeerConfiguration>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the Connect attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn transit_gateway_connect_peer_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_id = input;
            self
        }
        /// <p>The state of the Connect peer.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayConnectPeerState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayConnectPeerState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The Connect peer details.</p>
        pub fn connect_peer_configuration(
            mut self,
            input: crate::model::TransitGatewayConnectPeerConfiguration,
        ) -> Self {
            self.connect_peer_configuration = Some(input);
            self
        }
        pub fn set_connect_peer_configuration(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayConnectPeerConfiguration>,
        ) -> Self {
            self.connect_peer_configuration = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnectPeer`](crate::model::TransitGatewayConnectPeer)
        pub fn build(self) -> crate::model::TransitGatewayConnectPeer {
            crate::model::TransitGatewayConnectPeer {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                transit_gateway_connect_peer_id: self.transit_gateway_connect_peer_id,
                state: self.state,
                creation_time: self.creation_time,
                connect_peer_configuration: self.connect_peer_configuration,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayConnectPeer {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnectPeer`](crate::model::TransitGatewayConnectPeer)
    pub fn builder() -> crate::model::transit_gateway_connect_peer::Builder {
        crate::model::transit_gateway_connect_peer::Builder::default()
    }
}

/// <p>Describes the Connect peer details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayConnectPeerConfiguration {
    /// <p>The Connect peer IP address on the transit gateway side of the tunnel.</p>
    pub transit_gateway_address: std::option::Option<std::string::String>,
    /// <p>The Connect peer IP address on the appliance side of the tunnel.</p>
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The range of interior BGP peer IP addresses.</p>
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tunnel protocol.</p>
    pub protocol: std::option::Option<crate::model::ProtocolValue>,
    /// <p>The BGP configuration details.</p>
    pub bgp_configurations:
        std::option::Option<std::vec::Vec<crate::model::TransitGatewayAttachmentBgpConfiguration>>,
}
impl std::fmt::Debug for TransitGatewayConnectPeerConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayConnectPeerConfiguration");
        formatter.field("transit_gateway_address", &self.transit_gateway_address);
        formatter.field("peer_address", &self.peer_address);
        formatter.field("inside_cidr_blocks", &self.inside_cidr_blocks);
        formatter.field("protocol", &self.protocol);
        formatter.field("bgp_configurations", &self.bgp_configurations);
        formatter.finish()
    }
}
/// See [`TransitGatewayConnectPeerConfiguration`](crate::model::TransitGatewayConnectPeerConfiguration)
pub mod transit_gateway_connect_peer_configuration {
    /// A builder for [`TransitGatewayConnectPeerConfiguration`](crate::model::TransitGatewayConnectPeerConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) protocol: std::option::Option<crate::model::ProtocolValue>,
        pub(crate) bgp_configurations: std::option::Option<
            std::vec::Vec<crate::model::TransitGatewayAttachmentBgpConfiguration>,
        >,
    }
    impl Builder {
        /// <p>The Connect peer IP address on the transit gateway side of the tunnel.</p>
        pub fn transit_gateway_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_address = Some(input.into());
            self
        }
        pub fn set_transit_gateway_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_address = input;
            self
        }
        /// <p>The Connect peer IP address on the appliance side of the tunnel.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input;
            self
        }
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.inside_cidr_blocks = Some(v);
            self
        }
        pub fn set_inside_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inside_cidr_blocks = input;
            self
        }
        /// <p>The tunnel protocol.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolValue) -> Self {
            self.protocol = Some(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolValue>,
        ) -> Self {
            self.protocol = input;
            self
        }
        pub fn bgp_configurations(
            mut self,
            input: impl Into<crate::model::TransitGatewayAttachmentBgpConfiguration>,
        ) -> Self {
            let mut v = self.bgp_configurations.unwrap_or_default();
            v.push(input.into());
            self.bgp_configurations = Some(v);
            self
        }
        pub fn set_bgp_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::TransitGatewayAttachmentBgpConfiguration>,
            >,
        ) -> Self {
            self.bgp_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnectPeerConfiguration`](crate::model::TransitGatewayConnectPeerConfiguration)
        pub fn build(self) -> crate::model::TransitGatewayConnectPeerConfiguration {
            crate::model::TransitGatewayConnectPeerConfiguration {
                transit_gateway_address: self.transit_gateway_address,
                peer_address: self.peer_address,
                inside_cidr_blocks: self.inside_cidr_blocks,
                protocol: self.protocol,
                bgp_configurations: self.bgp_configurations,
            }
        }
    }
}
impl TransitGatewayConnectPeerConfiguration {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnectPeerConfiguration`](crate::model::TransitGatewayConnectPeerConfiguration)
    pub fn builder() -> crate::model::transit_gateway_connect_peer_configuration::Builder {
        crate::model::transit_gateway_connect_peer_configuration::Builder::default()
    }
}

/// <p>The BGP configuration information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayAttachmentBgpConfiguration {
    /// <p>The transit gateway Autonomous System Number (ASN).</p>
    pub transit_gateway_asn: std::option::Option<i64>,
    /// <p>The peer Autonomous System Number (ASN).</p>
    pub peer_asn: std::option::Option<i64>,
    /// <p>The interior BGP peer IP address for the transit gateway.</p>
    pub transit_gateway_address: std::option::Option<std::string::String>,
    /// <p>The interior BGP peer IP address for the appliance.</p>
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The BGP status.</p>
    pub bgp_status: std::option::Option<crate::model::BgpStatus>,
}
impl std::fmt::Debug for TransitGatewayAttachmentBgpConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayAttachmentBgpConfiguration");
        formatter.field("transit_gateway_asn", &self.transit_gateway_asn);
        formatter.field("peer_asn", &self.peer_asn);
        formatter.field("transit_gateway_address", &self.transit_gateway_address);
        formatter.field("peer_address", &self.peer_address);
        formatter.field("bgp_status", &self.bgp_status);
        formatter.finish()
    }
}
/// See [`TransitGatewayAttachmentBgpConfiguration`](crate::model::TransitGatewayAttachmentBgpConfiguration)
pub mod transit_gateway_attachment_bgp_configuration {
    /// A builder for [`TransitGatewayAttachmentBgpConfiguration`](crate::model::TransitGatewayAttachmentBgpConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_asn: std::option::Option<i64>,
        pub(crate) peer_asn: std::option::Option<i64>,
        pub(crate) transit_gateway_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) bgp_status: std::option::Option<crate::model::BgpStatus>,
    }
    impl Builder {
        /// <p>The transit gateway Autonomous System Number (ASN).</p>
        pub fn transit_gateway_asn(mut self, input: i64) -> Self {
            self.transit_gateway_asn = Some(input);
            self
        }
        pub fn set_transit_gateway_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.transit_gateway_asn = input;
            self
        }
        /// <p>The peer Autonomous System Number (ASN).</p>
        pub fn peer_asn(mut self, input: i64) -> Self {
            self.peer_asn = Some(input);
            self
        }
        pub fn set_peer_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.peer_asn = input;
            self
        }
        /// <p>The interior BGP peer IP address for the transit gateway.</p>
        pub fn transit_gateway_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_address = Some(input.into());
            self
        }
        pub fn set_transit_gateway_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_address = input;
            self
        }
        /// <p>The interior BGP peer IP address for the appliance.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input;
            self
        }
        /// <p>The BGP status.</p>
        pub fn bgp_status(mut self, input: crate::model::BgpStatus) -> Self {
            self.bgp_status = Some(input);
            self
        }
        pub fn set_bgp_status(
            mut self,
            input: std::option::Option<crate::model::BgpStatus>,
        ) -> Self {
            self.bgp_status = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayAttachmentBgpConfiguration`](crate::model::TransitGatewayAttachmentBgpConfiguration)
        pub fn build(self) -> crate::model::TransitGatewayAttachmentBgpConfiguration {
            crate::model::TransitGatewayAttachmentBgpConfiguration {
                transit_gateway_asn: self.transit_gateway_asn,
                peer_asn: self.peer_asn,
                transit_gateway_address: self.transit_gateway_address,
                peer_address: self.peer_address,
                bgp_status: self.bgp_status,
            }
        }
    }
}
impl TransitGatewayAttachmentBgpConfiguration {
    /// Creates a new builder-style object to manufacture [`TransitGatewayAttachmentBgpConfiguration`](crate::model::TransitGatewayAttachmentBgpConfiguration)
    pub fn builder() -> crate::model::transit_gateway_attachment_bgp_configuration::Builder {
        crate::model::transit_gateway_attachment_bgp_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BgpStatus {
    Down,
    Up,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BgpStatus {
    fn from(s: &str) -> Self {
        match s {
            "down" => BgpStatus::Down,
            "up" => BgpStatus::Up,
            other => BgpStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BgpStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BgpStatus::from(s))
    }
}
impl BgpStatus {
    pub fn as_str(&self) -> &str {
        match self {
            BgpStatus::Down => "down",
            BgpStatus::Up => "up",
            BgpStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["down", "up"]
    }
}
impl AsRef<str> for BgpStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransitGatewayConnectPeerState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransitGatewayConnectPeerState {
    fn from(s: &str) -> Self {
        match s {
            "available" => TransitGatewayConnectPeerState::Available,
            "deleted" => TransitGatewayConnectPeerState::Deleted,
            "deleting" => TransitGatewayConnectPeerState::Deleting,
            "pending" => TransitGatewayConnectPeerState::Pending,
            other => TransitGatewayConnectPeerState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransitGatewayConnectPeerState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransitGatewayConnectPeerState::from(s))
    }
}
impl TransitGatewayConnectPeerState {
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayConnectPeerState::Available => "available",
            TransitGatewayConnectPeerState::Deleted => "deleted",
            TransitGatewayConnectPeerState::Deleting => "deleting",
            TransitGatewayConnectPeerState::Pending => "pending",
            TransitGatewayConnectPeerState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for TransitGatewayConnectPeerState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an attachment between a resource and a transit gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayAttachment {
    /// <p>The ID of the attachment.</p>
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
    pub transit_gateway_owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the resource.</p>
    pub resource_owner_id: std::option::Option<std::string::String>,
    /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
    pub resource_type: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The attachment state. Note that the <code>initiating</code> state has been deprecated.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
    /// <p>The association.</p>
    pub association: std::option::Option<crate::model::TransitGatewayAttachmentAssociation>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The tags for the attachment.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransitGatewayAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayAttachment");
        formatter.field(
            "transit_gateway_attachment_id",
            &self.transit_gateway_attachment_id,
        );
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("transit_gateway_owner_id", &self.transit_gateway_owner_id);
        formatter.field("resource_owner_id", &self.resource_owner_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("state", &self.state);
        formatter.field("association", &self.association);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransitGatewayAttachment`](crate::model::TransitGatewayAttachment)
pub mod transit_gateway_attachment {
    /// A builder for [`TransitGatewayAttachment`](crate::model::TransitGatewayAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_owner_id: std::option::Option<std::string::String>,
        pub(crate) resource_owner_id: std::option::Option<std::string::String>,
        pub(crate) resource_type:
            std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        pub(crate) association:
            std::option::Option<crate::model::TransitGatewayAttachmentAssociation>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_attachment_id = input;
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the transit gateway.</p>
        pub fn transit_gateway_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_owner_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_owner_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the resource.</p>
        pub fn resource_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner_id = Some(input.into());
            self
        }
        pub fn set_resource_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner_id = input;
            self
        }
        /// <p>The resource type. Note that the <code>tgw-peering</code> resource type has been deprecated.</p>
        pub fn resource_type(
            mut self,
            input: crate::model::TransitGatewayAttachmentResourceType,
        ) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The attachment state. Note that the <code>initiating</code> state has been deprecated.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The association.</p>
        pub fn association(
            mut self,
            input: crate::model::TransitGatewayAttachmentAssociation,
        ) -> Self {
            self.association = Some(input);
            self
        }
        pub fn set_association(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAttachmentAssociation>,
        ) -> Self {
            self.association = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayAttachment`](crate::model::TransitGatewayAttachment)
        pub fn build(self) -> crate::model::TransitGatewayAttachment {
            crate::model::TransitGatewayAttachment {
                transit_gateway_attachment_id: self.transit_gateway_attachment_id,
                transit_gateway_id: self.transit_gateway_id,
                transit_gateway_owner_id: self.transit_gateway_owner_id,
                resource_owner_id: self.resource_owner_id,
                resource_type: self.resource_type,
                resource_id: self.resource_id,
                state: self.state,
                association: self.association,
                creation_time: self.creation_time,
                tags: self.tags,
            }
        }
    }
}
impl TransitGatewayAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayAttachment`](crate::model::TransitGatewayAttachment)
    pub fn builder() -> crate::model::transit_gateway_attachment::Builder {
        crate::model::transit_gateway_attachment::Builder::default()
    }
}

/// <p>Describes an association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayAttachmentAssociation {
    /// <p>The ID of the route table for the transit gateway.</p>
    pub transit_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<crate::model::TransitGatewayAssociationState>,
}
impl std::fmt::Debug for TransitGatewayAttachmentAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayAttachmentAssociation");
        formatter.field(
            "transit_gateway_route_table_id",
            &self.transit_gateway_route_table_id,
        );
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`TransitGatewayAttachmentAssociation`](crate::model::TransitGatewayAttachmentAssociation)
pub mod transit_gateway_attachment_association {
    /// A builder for [`TransitGatewayAttachmentAssociation`](crate::model::TransitGatewayAttachmentAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the route table for the transit gateway.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_id = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayAssociationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayAttachmentAssociation`](crate::model::TransitGatewayAttachmentAssociation)
        pub fn build(self) -> crate::model::TransitGatewayAttachmentAssociation {
            crate::model::TransitGatewayAttachmentAssociation {
                transit_gateway_route_table_id: self.transit_gateway_route_table_id,
                state: self.state,
            }
        }
    }
}
impl TransitGatewayAttachmentAssociation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayAttachmentAssociation`](crate::model::TransitGatewayAttachmentAssociation)
    pub fn builder() -> crate::model::transit_gateway_attachment_association::Builder {
        crate::model::transit_gateway_attachment_association::Builder::default()
    }
}

/// <p>Describes a Traffic Mirror target.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficMirrorTarget {
    /// <p>The ID of the Traffic Mirror target.</p>
    pub traffic_mirror_target_id: std::option::Option<std::string::String>,
    /// <p>The network interface ID that is attached to the target.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Network Load Balancer.</p>
    pub network_load_balancer_arn: std::option::Option<std::string::String>,
    /// <p>The type of Traffic Mirror target.</p>
    pub r#type: std::option::Option<crate::model::TrafficMirrorTargetType>,
    /// <p>Information about the Traffic Mirror target.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the account that owns the Traffic Mirror target.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the Traffic Mirror target.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TrafficMirrorTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficMirrorTarget");
        formatter.field("traffic_mirror_target_id", &self.traffic_mirror_target_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("network_load_balancer_arn", &self.network_load_balancer_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("description", &self.description);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrafficMirrorTarget`](crate::model::TrafficMirrorTarget)
pub mod traffic_mirror_target {
    /// A builder for [`TrafficMirrorTarget`](crate::model::TrafficMirrorTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_mirror_target_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) network_load_balancer_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::TrafficMirrorTargetType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the Traffic Mirror target.</p>
        pub fn traffic_mirror_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.traffic_mirror_target_id = Some(input.into());
            self
        }
        pub fn set_traffic_mirror_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.traffic_mirror_target_id = input;
            self
        }
        /// <p>The network interface ID that is attached to the target.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Network Load Balancer.</p>
        pub fn network_load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_load_balancer_arn = Some(input.into());
            self
        }
        pub fn set_network_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_load_balancer_arn = input;
            self
        }
        /// <p>The type of Traffic Mirror target.</p>
        pub fn r#type(mut self, input: crate::model::TrafficMirrorTargetType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorTargetType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Information about the Traffic Mirror target.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the account that owns the Traffic Mirror target.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficMirrorTarget`](crate::model::TrafficMirrorTarget)
        pub fn build(self) -> crate::model::TrafficMirrorTarget {
            crate::model::TrafficMirrorTarget {
                traffic_mirror_target_id: self.traffic_mirror_target_id,
                network_interface_id: self.network_interface_id,
                network_load_balancer_arn: self.network_load_balancer_arn,
                r#type: self.r#type,
                description: self.description,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl TrafficMirrorTarget {
    /// Creates a new builder-style object to manufacture [`TrafficMirrorTarget`](crate::model::TrafficMirrorTarget)
    pub fn builder() -> crate::model::traffic_mirror_target::Builder {
        crate::model::traffic_mirror_target::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficMirrorTargetType {
    NetworkInterface,
    NetworkLoadBalancer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficMirrorTargetType {
    fn from(s: &str) -> Self {
        match s {
            "network-interface" => TrafficMirrorTargetType::NetworkInterface,
            "network-load-balancer" => TrafficMirrorTargetType::NetworkLoadBalancer,
            other => TrafficMirrorTargetType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficMirrorTargetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficMirrorTargetType::from(s))
    }
}
impl TrafficMirrorTargetType {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficMirrorTargetType::NetworkInterface => "network-interface",
            TrafficMirrorTargetType::NetworkLoadBalancer => "network-load-balancer",
            TrafficMirrorTargetType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["network-interface", "network-load-balancer"]
    }
}
impl AsRef<str> for TrafficMirrorTargetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagDescription {
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagDescription");
        formatter.field("key", &self.key);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`TagDescription`](crate::model::TagDescription)
pub mod tag_description {
    /// A builder for [`TagDescription`](crate::model::TagDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`TagDescription`](crate::model::TagDescription)
        pub fn build(self) -> crate::model::TagDescription {
            crate::model::TagDescription {
                key: self.key,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                value: self.value,
            }
        }
    }
}
impl TagDescription {
    /// Creates a new builder-style object to manufacture [`TagDescription`](crate::model::TagDescription)
    pub fn builder() -> crate::model::tag_description::Builder {
        crate::model::tag_description::Builder::default()
    }
}

/// <p>Describes a subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Subnet {
    /// <p>The Availability Zone of the subnet.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The AZ ID of the subnet.</p>
    pub availability_zone_id: std::option::Option<std::string::String>,
    /// <p>The number of unused private IPv4 addresses in the subnet. The IPv4 addresses for any
    /// stopped instances are considered unavailable.</p>
    pub available_ip_address_count: std::option::Option<i32>,
    /// <p>The IPv4 CIDR block assigned to the subnet.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Indicates whether this is the default subnet for the Availability Zone.</p>
    pub default_for_az: std::option::Option<bool>,
    /// <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
    pub map_public_ip_on_launch: std::option::Option<bool>,
    /// <p>Indicates whether a network interface created in this subnet (including a network
    /// interface created by <a>RunInstances</a>) receives a customer-owned IPv4 address.</p>
    pub map_customer_owned_ip_on_launch: std::option::Option<bool>,
    /// <p>The customer-owned IPv4 address pool associated with the subnet.</p>
    pub customer_owned_ipv4_pool: std::option::Option<std::string::String>,
    /// <p>The current state of the subnet.</p>
    pub state: std::option::Option<crate::model::SubnetState>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC the subnet is in.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the subnet.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether a network interface created in this subnet (including a network
    /// interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
    pub assign_ipv6_address_on_creation: std::option::Option<bool>,
    /// <p>Information about the IPv6 CIDR blocks associated with the subnet.</p>
    pub ipv6_cidr_block_association_set:
        std::option::Option<std::vec::Vec<crate::model::SubnetIpv6CidrBlockAssociation>>,
    /// <p>Any tags assigned to the subnet.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Amazon Resource Name (ARN) of the subnet.</p>
    pub subnet_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Subnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Subnet");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("availability_zone_id", &self.availability_zone_id);
        formatter.field(
            "available_ip_address_count",
            &self.available_ip_address_count,
        );
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("default_for_az", &self.default_for_az);
        formatter.field("map_public_ip_on_launch", &self.map_public_ip_on_launch);
        formatter.field(
            "map_customer_owned_ip_on_launch",
            &self.map_customer_owned_ip_on_launch,
        );
        formatter.field("customer_owned_ipv4_pool", &self.customer_owned_ipv4_pool);
        formatter.field("state", &self.state);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field(
            "assign_ipv6_address_on_creation",
            &self.assign_ipv6_address_on_creation,
        );
        formatter.field(
            "ipv6_cidr_block_association_set",
            &self.ipv6_cidr_block_association_set,
        );
        formatter.field("tags", &self.tags);
        formatter.field("subnet_arn", &self.subnet_arn);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.finish()
    }
}
/// See [`Subnet`](crate::model::Subnet)
pub mod subnet {
    /// A builder for [`Subnet`](crate::model::Subnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
        pub(crate) available_ip_address_count: std::option::Option<i32>,
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) default_for_az: std::option::Option<bool>,
        pub(crate) map_public_ip_on_launch: std::option::Option<bool>,
        pub(crate) map_customer_owned_ip_on_launch: std::option::Option<bool>,
        pub(crate) customer_owned_ipv4_pool: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::SubnetState>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) assign_ipv6_address_on_creation: std::option::Option<bool>,
        pub(crate) ipv6_cidr_block_association_set:
            std::option::Option<std::vec::Vec<crate::model::SubnetIpv6CidrBlockAssociation>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) subnet_arn: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Availability Zone of the subnet.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The AZ ID of the subnet.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// <p>The number of unused private IPv4 addresses in the subnet. The IPv4 addresses for any
        /// stopped instances are considered unavailable.</p>
        pub fn available_ip_address_count(mut self, input: i32) -> Self {
            self.available_ip_address_count = Some(input);
            self
        }
        pub fn set_available_ip_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.available_ip_address_count = input;
            self
        }
        /// <p>The IPv4 CIDR block assigned to the subnet.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Indicates whether this is the default subnet for the Availability Zone.</p>
        pub fn default_for_az(mut self, input: bool) -> Self {
            self.default_for_az = Some(input);
            self
        }
        pub fn set_default_for_az(mut self, input: std::option::Option<bool>) -> Self {
            self.default_for_az = input;
            self
        }
        /// <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
        pub fn map_public_ip_on_launch(mut self, input: bool) -> Self {
            self.map_public_ip_on_launch = Some(input);
            self
        }
        pub fn set_map_public_ip_on_launch(mut self, input: std::option::Option<bool>) -> Self {
            self.map_public_ip_on_launch = input;
            self
        }
        /// <p>Indicates whether a network interface created in this subnet (including a network
        /// interface created by <a>RunInstances</a>) receives a customer-owned IPv4 address.</p>
        pub fn map_customer_owned_ip_on_launch(mut self, input: bool) -> Self {
            self.map_customer_owned_ip_on_launch = Some(input);
            self
        }
        pub fn set_map_customer_owned_ip_on_launch(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.map_customer_owned_ip_on_launch = input;
            self
        }
        /// <p>The customer-owned IPv4 address pool associated with the subnet.</p>
        pub fn customer_owned_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_owned_ipv4_pool = Some(input.into());
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_owned_ipv4_pool = input;
            self
        }
        /// <p>The current state of the subnet.</p>
        pub fn state(mut self, input: crate::model::SubnetState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::SubnetState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of the VPC the subnet is in.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the subnet.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Indicates whether a network interface created in this subnet (including a network
        /// interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
        pub fn assign_ipv6_address_on_creation(mut self, input: bool) -> Self {
            self.assign_ipv6_address_on_creation = Some(input);
            self
        }
        pub fn set_assign_ipv6_address_on_creation(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.assign_ipv6_address_on_creation = input;
            self
        }
        pub fn ipv6_cidr_block_association_set(
            mut self,
            input: impl Into<crate::model::SubnetIpv6CidrBlockAssociation>,
        ) -> Self {
            let mut v = self.ipv6_cidr_block_association_set.unwrap_or_default();
            v.push(input.into());
            self.ipv6_cidr_block_association_set = Some(v);
            self
        }
        pub fn set_ipv6_cidr_block_association_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetIpv6CidrBlockAssociation>>,
        ) -> Self {
            self.ipv6_cidr_block_association_set = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the subnet.</p>
        pub fn subnet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_arn = Some(input.into());
            self
        }
        pub fn set_subnet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Subnet`](crate::model::Subnet)
        pub fn build(self) -> crate::model::Subnet {
            crate::model::Subnet {
                availability_zone: self.availability_zone,
                availability_zone_id: self.availability_zone_id,
                available_ip_address_count: self.available_ip_address_count,
                cidr_block: self.cidr_block,
                default_for_az: self.default_for_az,
                map_public_ip_on_launch: self.map_public_ip_on_launch,
                map_customer_owned_ip_on_launch: self.map_customer_owned_ip_on_launch,
                customer_owned_ipv4_pool: self.customer_owned_ipv4_pool,
                state: self.state,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                owner_id: self.owner_id,
                assign_ipv6_address_on_creation: self.assign_ipv6_address_on_creation,
                ipv6_cidr_block_association_set: self.ipv6_cidr_block_association_set,
                tags: self.tags,
                subnet_arn: self.subnet_arn,
                outpost_arn: self.outpost_arn,
            }
        }
    }
}
impl Subnet {
    /// Creates a new builder-style object to manufacture [`Subnet`](crate::model::Subnet)
    pub fn builder() -> crate::model::subnet::Builder {
        crate::model::subnet::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubnetState {
    Available,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubnetState {
    fn from(s: &str) -> Self {
        match s {
            "available" => SubnetState::Available,
            "pending" => SubnetState::Pending,
            other => SubnetState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubnetState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubnetState::from(s))
    }
}
impl SubnetState {
    pub fn as_str(&self) -> &str {
        match self {
            SubnetState::Available => "available",
            SubnetState::Pending => "pending",
            SubnetState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "pending"]
    }
}
impl AsRef<str> for SubnetState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The information about the AMI store task, including the progress of the task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StoreImageTaskResult {
    /// <p>The ID of the AMI that is being stored.</p>
    pub ami_id: std::option::Option<std::string::String>,
    /// <p>The time the task started.</p>
    pub task_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The name of the Amazon S3 bucket that contains the stored AMI object.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The name of the stored AMI object in the bucket.</p>
    pub s3object_key: std::option::Option<std::string::String>,
    /// <p>The progress of the task as a percentage.</p>
    pub progress_percentage: std::option::Option<i32>,
    /// <p>The state of the store task (<code>InProgress</code>, <code>Completed</code>, or
    /// <code>Failed</code>).</p>
    pub store_task_state: std::option::Option<std::string::String>,
    /// <p>If the tasks fails, the reason for the failure is returned. If the task succeeds,
    /// <code>null</code> is returned.</p>
    pub store_task_failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StoreImageTaskResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StoreImageTaskResult");
        formatter.field("ami_id", &self.ami_id);
        formatter.field("task_start_time", &self.task_start_time);
        formatter.field("bucket", &self.bucket);
        formatter.field("s3object_key", &self.s3object_key);
        formatter.field("progress_percentage", &self.progress_percentage);
        formatter.field("store_task_state", &self.store_task_state);
        formatter.field("store_task_failure_reason", &self.store_task_failure_reason);
        formatter.finish()
    }
}
/// See [`StoreImageTaskResult`](crate::model::StoreImageTaskResult)
pub mod store_image_task_result {
    /// A builder for [`StoreImageTaskResult`](crate::model::StoreImageTaskResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ami_id: std::option::Option<std::string::String>,
        pub(crate) task_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) s3object_key: std::option::Option<std::string::String>,
        pub(crate) progress_percentage: std::option::Option<i32>,
        pub(crate) store_task_state: std::option::Option<std::string::String>,
        pub(crate) store_task_failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the AMI that is being stored.</p>
        pub fn ami_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ami_id = Some(input.into());
            self
        }
        pub fn set_ami_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ami_id = input;
            self
        }
        /// <p>The time the task started.</p>
        pub fn task_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.task_start_time = Some(input);
            self
        }
        pub fn set_task_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.task_start_time = input;
            self
        }
        /// <p>The name of the Amazon S3 bucket that contains the stored AMI object.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The name of the stored AMI object in the bucket.</p>
        pub fn s3object_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3object_key = Some(input.into());
            self
        }
        pub fn set_s3object_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3object_key = input;
            self
        }
        /// <p>The progress of the task as a percentage.</p>
        pub fn progress_percentage(mut self, input: i32) -> Self {
            self.progress_percentage = Some(input);
            self
        }
        pub fn set_progress_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.progress_percentage = input;
            self
        }
        /// <p>The state of the store task (<code>InProgress</code>, <code>Completed</code>, or
        /// <code>Failed</code>).</p>
        pub fn store_task_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_task_state = Some(input.into());
            self
        }
        pub fn set_store_task_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.store_task_state = input;
            self
        }
        /// <p>If the tasks fails, the reason for the failure is returned. If the task succeeds,
        /// <code>null</code> is returned.</p>
        pub fn store_task_failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.store_task_failure_reason = Some(input.into());
            self
        }
        pub fn set_store_task_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.store_task_failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`StoreImageTaskResult`](crate::model::StoreImageTaskResult)
        pub fn build(self) -> crate::model::StoreImageTaskResult {
            crate::model::StoreImageTaskResult {
                ami_id: self.ami_id,
                task_start_time: self.task_start_time,
                bucket: self.bucket,
                s3object_key: self.s3object_key,
                progress_percentage: self.progress_percentage,
                store_task_state: self.store_task_state,
                store_task_failure_reason: self.store_task_failure_reason,
            }
        }
    }
}
impl StoreImageTaskResult {
    /// Creates a new builder-style object to manufacture [`StoreImageTaskResult`](crate::model::StoreImageTaskResult)
    pub fn builder() -> crate::model::store_image_task_result::Builder {
        crate::model::store_image_task_result::Builder::default()
    }
}

/// <p>Describes a stale security group (a security group that contains stale rules).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StaleSecurityGroup {
    /// <p>The description of the security group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>Information about the stale inbound rules in the security group.</p>
    pub stale_ip_permissions: std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
    /// <p>Information about the stale outbound rules in the security group.</p>
    pub stale_ip_permissions_egress:
        std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
    /// <p>The ID of the VPC for the security group.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StaleSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StaleSecurityGroup");
        formatter.field("description", &self.description);
        formatter.field("group_id", &self.group_id);
        formatter.field("group_name", &self.group_name);
        formatter.field("stale_ip_permissions", &self.stale_ip_permissions);
        formatter.field(
            "stale_ip_permissions_egress",
            &self.stale_ip_permissions_egress,
        );
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`StaleSecurityGroup`](crate::model::StaleSecurityGroup)
pub mod stale_security_group {
    /// A builder for [`StaleSecurityGroup`](crate::model::StaleSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) stale_ip_permissions:
            std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
        pub(crate) stale_ip_permissions_egress:
            std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description of the security group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        pub fn stale_ip_permissions(
            mut self,
            input: impl Into<crate::model::StaleIpPermission>,
        ) -> Self {
            let mut v = self.stale_ip_permissions.unwrap_or_default();
            v.push(input.into());
            self.stale_ip_permissions = Some(v);
            self
        }
        pub fn set_stale_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
        ) -> Self {
            self.stale_ip_permissions = input;
            self
        }
        pub fn stale_ip_permissions_egress(
            mut self,
            input: impl Into<crate::model::StaleIpPermission>,
        ) -> Self {
            let mut v = self.stale_ip_permissions_egress.unwrap_or_default();
            v.push(input.into());
            self.stale_ip_permissions_egress = Some(v);
            self
        }
        pub fn set_stale_ip_permissions_egress(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StaleIpPermission>>,
        ) -> Self {
            self.stale_ip_permissions_egress = input;
            self
        }
        /// <p>The ID of the VPC for the security group.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StaleSecurityGroup`](crate::model::StaleSecurityGroup)
        pub fn build(self) -> crate::model::StaleSecurityGroup {
            crate::model::StaleSecurityGroup {
                description: self.description,
                group_id: self.group_id,
                group_name: self.group_name,
                stale_ip_permissions: self.stale_ip_permissions,
                stale_ip_permissions_egress: self.stale_ip_permissions_egress,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl StaleSecurityGroup {
    /// Creates a new builder-style object to manufacture [`StaleSecurityGroup`](crate::model::StaleSecurityGroup)
    pub fn builder() -> crate::model::stale_security_group::Builder {
        crate::model::stale_security_group::Builder::default()
    }
}

/// <p>Describes a stale rule in a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StaleIpPermission {
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of
    /// <code>-1</code> indicates all ICMP types. </p>
    pub from_port: std::option::Option<i32>,
    /// <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number  (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
    pub ip_protocol: std::option::Option<std::string::String>,
    /// <p>The IP ranges. Not applicable for stale security group rules.</p>
    pub ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The prefix list IDs. Not applicable for stale security group rules.</p>
    pub prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of
    /// <code>-1</code> indicates all ICMP types. </p>
    pub to_port: std::option::Option<i32>,
    /// <p>The security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>
    pub user_id_group_pairs: std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
}
impl std::fmt::Debug for StaleIpPermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StaleIpPermission");
        formatter.field("from_port", &self.from_port);
        formatter.field("ip_protocol", &self.ip_protocol);
        formatter.field("ip_ranges", &self.ip_ranges);
        formatter.field("prefix_list_ids", &self.prefix_list_ids);
        formatter.field("to_port", &self.to_port);
        formatter.field("user_id_group_pairs", &self.user_id_group_pairs);
        formatter.finish()
    }
}
/// See [`StaleIpPermission`](crate::model::StaleIpPermission)
pub mod stale_ip_permission {
    /// A builder for [`StaleIpPermission`](crate::model::StaleIpPermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) ip_protocol: std::option::Option<std::string::String>,
        pub(crate) ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) to_port: std::option::Option<i32>,
        pub(crate) user_id_group_pairs:
            std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
    }
    impl Builder {
        /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of
        /// <code>-1</code> indicates all ICMP types. </p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number  (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_protocol = Some(input.into());
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_protocol = input;
            self
        }
        pub fn ip_ranges(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input.into());
            self.ip_ranges = Some(v);
            self
        }
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        pub fn prefix_list_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.prefix_list_ids.unwrap_or_default();
            v.push(input.into());
            self.prefix_list_ids = Some(v);
            self
        }
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.prefix_list_ids = input;
            self
        }
        /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of
        /// <code>-1</code> indicates all ICMP types. </p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        pub fn user_id_group_pairs(
            mut self,
            input: impl Into<crate::model::UserIdGroupPair>,
        ) -> Self {
            let mut v = self.user_id_group_pairs.unwrap_or_default();
            v.push(input.into());
            self.user_id_group_pairs = Some(v);
            self
        }
        pub fn set_user_id_group_pairs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UserIdGroupPair>>,
        ) -> Self {
            self.user_id_group_pairs = input;
            self
        }
        /// Consumes the builder and constructs a [`StaleIpPermission`](crate::model::StaleIpPermission)
        pub fn build(self) -> crate::model::StaleIpPermission {
            crate::model::StaleIpPermission {
                from_port: self.from_port,
                ip_protocol: self.ip_protocol,
                ip_ranges: self.ip_ranges,
                prefix_list_ids: self.prefix_list_ids,
                to_port: self.to_port,
                user_id_group_pairs: self.user_id_group_pairs,
            }
        }
    }
}
impl StaleIpPermission {
    /// Creates a new builder-style object to manufacture [`StaleIpPermission`](crate::model::StaleIpPermission)
    pub fn builder() -> crate::model::stale_ip_permission::Builder {
        crate::model::stale_ip_permission::Builder::default()
    }
}

/// <p>Describes the maximum price per hour that you are willing to pay for a Spot
/// Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotPrice {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>A general description of the AMI.</p>
    pub product_description: std::option::Option<crate::model::RiProductDescription>,
    /// <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The date and time the request was created, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for SpotPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotPrice");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("product_description", &self.product_description);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`SpotPrice`](crate::model::SpotPrice)
pub mod spot_price {
    /// A builder for [`SpotPrice`](crate::model::SpotPrice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) product_description: std::option::Option<crate::model::RiProductDescription>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>A general description of the AMI.</p>
        pub fn product_description(mut self, input: crate::model::RiProductDescription) -> Self {
            self.product_description = Some(input);
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<crate::model::RiProductDescription>,
        ) -> Self {
            self.product_description = input;
            self
        }
        /// <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The date and time the request was created, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotPrice`](crate::model::SpotPrice)
        pub fn build(self) -> crate::model::SpotPrice {
            crate::model::SpotPrice {
                availability_zone: self.availability_zone,
                instance_type: self.instance_type,
                product_description: self.product_description,
                spot_price: self.spot_price,
                timestamp: self.timestamp,
            }
        }
    }
}
impl SpotPrice {
    /// Creates a new builder-style object to manufacture [`SpotPrice`](crate::model::SpotPrice)
    pub fn builder() -> crate::model::spot_price::Builder {
        crate::model::spot_price::Builder::default()
    }
}

/// <p>Describes a Spot Fleet request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotFleetRequestConfig {
    /// <p>The progress of the Spot Fleet request.
    /// If there is an error, the status is <code>error</code>.
    /// After all requests are placed, the status is <code>pending_fulfillment</code>.
    /// If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>.
    /// If the size of the fleet is decreased, the status is <code>pending_termination</code>
    /// while Spot Instances are terminating.</p>
    pub activity_status: std::option::Option<crate::model::ActivityStatus>,
    /// <p>The creation date and time of the request.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The configuration of the Spot Fleet request.</p>
    pub spot_fleet_request_config: std::option::Option<crate::model::SpotFleetRequestConfigData>,
    /// <p>The ID of the Spot Fleet request.</p>
    pub spot_fleet_request_id: std::option::Option<std::string::String>,
    /// <p>The state of the Spot Fleet request.</p>
    pub spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
    /// <p>The tags for a Spot Fleet resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for SpotFleetRequestConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetRequestConfig");
        formatter.field("activity_status", &self.activity_status);
        formatter.field("create_time", &self.create_time);
        formatter.field("spot_fleet_request_config", &self.spot_fleet_request_config);
        formatter.field("spot_fleet_request_id", &self.spot_fleet_request_id);
        formatter.field("spot_fleet_request_state", &self.spot_fleet_request_state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SpotFleetRequestConfig`](crate::model::SpotFleetRequestConfig)
pub mod spot_fleet_request_config {
    /// A builder for [`SpotFleetRequestConfig`](crate::model::SpotFleetRequestConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activity_status: std::option::Option<crate::model::ActivityStatus>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) spot_fleet_request_config:
            std::option::Option<crate::model::SpotFleetRequestConfigData>,
        pub(crate) spot_fleet_request_id: std::option::Option<std::string::String>,
        pub(crate) spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The progress of the Spot Fleet request.
        /// If there is an error, the status is <code>error</code>.
        /// After all requests are placed, the status is <code>pending_fulfillment</code>.
        /// If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>.
        /// If the size of the fleet is decreased, the status is <code>pending_termination</code>
        /// while Spot Instances are terminating.</p>
        pub fn activity_status(mut self, input: crate::model::ActivityStatus) -> Self {
            self.activity_status = Some(input);
            self
        }
        pub fn set_activity_status(
            mut self,
            input: std::option::Option<crate::model::ActivityStatus>,
        ) -> Self {
            self.activity_status = input;
            self
        }
        /// <p>The creation date and time of the request.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The configuration of the Spot Fleet request.</p>
        pub fn spot_fleet_request_config(
            mut self,
            input: crate::model::SpotFleetRequestConfigData,
        ) -> Self {
            self.spot_fleet_request_config = Some(input);
            self
        }
        pub fn set_spot_fleet_request_config(
            mut self,
            input: std::option::Option<crate::model::SpotFleetRequestConfigData>,
        ) -> Self {
            self.spot_fleet_request_config = input;
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_fleet_request_id = Some(input.into());
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_fleet_request_id = input;
            self
        }
        /// <p>The state of the Spot Fleet request.</p>
        pub fn spot_fleet_request_state(mut self, input: crate::model::BatchState) -> Self {
            self.spot_fleet_request_state = Some(input);
            self
        }
        pub fn set_spot_fleet_request_state(
            mut self,
            input: std::option::Option<crate::model::BatchState>,
        ) -> Self {
            self.spot_fleet_request_state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotFleetRequestConfig`](crate::model::SpotFleetRequestConfig)
        pub fn build(self) -> crate::model::SpotFleetRequestConfig {
            crate::model::SpotFleetRequestConfig {
                activity_status: self.activity_status,
                create_time: self.create_time,
                spot_fleet_request_config: self.spot_fleet_request_config,
                spot_fleet_request_id: self.spot_fleet_request_id,
                spot_fleet_request_state: self.spot_fleet_request_state,
                tags: self.tags,
            }
        }
    }
}
impl SpotFleetRequestConfig {
    /// Creates a new builder-style object to manufacture [`SpotFleetRequestConfig`](crate::model::SpotFleetRequestConfig)
    pub fn builder() -> crate::model::spot_fleet_request_config::Builder {
        crate::model::spot_fleet_request_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchState {
    Active,
    Cancelled,
    CancelledRunning,
    CancelledTerminatingInstances,
    Failed,
    Modifying,
    Submitted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BatchState {
    fn from(s: &str) -> Self {
        match s {
            "active" => BatchState::Active,
            "cancelled" => BatchState::Cancelled,
            "cancelled_running" => BatchState::CancelledRunning,
            "cancelled_terminating" => BatchState::CancelledTerminatingInstances,
            "failed" => BatchState::Failed,
            "modifying" => BatchState::Modifying,
            "submitted" => BatchState::Submitted,
            other => BatchState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BatchState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchState::from(s))
    }
}
impl BatchState {
    pub fn as_str(&self) -> &str {
        match self {
            BatchState::Active => "active",
            BatchState::Cancelled => "cancelled",
            BatchState::CancelledRunning => "cancelled_running",
            BatchState::CancelledTerminatingInstances => "cancelled_terminating",
            BatchState::Failed => "failed",
            BatchState::Modifying => "modifying",
            BatchState::Submitted => "submitted",
            BatchState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "active",
            "cancelled",
            "cancelled_running",
            "cancelled_terminating",
            "failed",
            "modifying",
            "submitted",
        ]
    }
}
impl AsRef<str> for BatchState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActivityStatus {
    Error,
    Fulfilled,
    PendingFulfillment,
    PendingTermination,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActivityStatus {
    fn from(s: &str) -> Self {
        match s {
            "error" => ActivityStatus::Error,
            "fulfilled" => ActivityStatus::Fulfilled,
            "pending_fulfillment" => ActivityStatus::PendingFulfillment,
            "pending_termination" => ActivityStatus::PendingTermination,
            other => ActivityStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActivityStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActivityStatus::from(s))
    }
}
impl ActivityStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ActivityStatus::Error => "error",
            ActivityStatus::Fulfilled => "fulfilled",
            ActivityStatus::PendingFulfillment => "pending_fulfillment",
            ActivityStatus::PendingTermination => "pending_termination",
            ActivityStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "error",
            "fulfilled",
            "pending_fulfillment",
            "pending_termination",
        ]
    }
}
impl AsRef<str> for ActivityStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an event in the history of the Spot Fleet request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HistoryRecord {
    /// <p>Information about the event.</p>
    pub event_information: std::option::Option<crate::model::EventInformation>,
    /// <p>The event type.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>error</code> - An error with the Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>fleetRequestChange</code> - A change in the status or configuration of
    /// the Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>instanceChange</code> - An instance was launched or terminated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Information</code> - An informational event.</p>
    /// </li>
    /// </ul>
    pub event_type: std::option::Option<crate::model::EventType>,
    /// <p>The date and time of the event, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for HistoryRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HistoryRecord");
        formatter.field("event_information", &self.event_information);
        formatter.field("event_type", &self.event_type);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`HistoryRecord`](crate::model::HistoryRecord)
pub mod history_record {
    /// A builder for [`HistoryRecord`](crate::model::HistoryRecord)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_information: std::option::Option<crate::model::EventInformation>,
        pub(crate) event_type: std::option::Option<crate::model::EventType>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Information about the event.</p>
        pub fn event_information(mut self, input: crate::model::EventInformation) -> Self {
            self.event_information = Some(input);
            self
        }
        pub fn set_event_information(
            mut self,
            input: std::option::Option<crate::model::EventInformation>,
        ) -> Self {
            self.event_information = input;
            self
        }
        /// <p>The event type.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>error</code> - An error with the Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fleetRequestChange</code> - A change in the status or configuration of
        /// the Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instanceChange</code> - An instance was launched or terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Information</code> - An informational event.</p>
        /// </li>
        /// </ul>
        pub fn event_type(mut self, input: crate::model::EventType) -> Self {
            self.event_type = Some(input);
            self
        }
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::EventType>,
        ) -> Self {
            self.event_type = input;
            self
        }
        /// <p>The date and time of the event, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoryRecord`](crate::model::HistoryRecord)
        pub fn build(self) -> crate::model::HistoryRecord {
            crate::model::HistoryRecord {
                event_information: self.event_information,
                event_type: self.event_type,
                timestamp: self.timestamp,
            }
        }
    }
}
impl HistoryRecord {
    /// Creates a new builder-style object to manufacture [`HistoryRecord`](crate::model::HistoryRecord)
    pub fn builder() -> crate::model::history_record::Builder {
        crate::model::history_record::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventType {
    Error,
    BatchChange,
    Information,
    InstanceChange,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "error" => EventType::Error,
            "fleetRequestChange" => EventType::BatchChange,
            "information" => EventType::Information,
            "instanceChange" => EventType::InstanceChange,
            other => EventType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EventType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventType::from(s))
    }
}
impl EventType {
    pub fn as_str(&self) -> &str {
        match self {
            EventType::Error => "error",
            EventType::BatchChange => "fleetRequestChange",
            EventType::Information => "information",
            EventType::InstanceChange => "instanceChange",
            EventType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "error",
            "fleetRequestChange",
            "information",
            "instanceChange",
        ]
    }
}
impl AsRef<str> for EventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an EC2 Fleet or Spot Fleet event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventInformation {
    /// <p>The description of the event.</p>
    pub event_description: std::option::Option<std::string::String>,
    /// <p>The event.</p>
    /// <p>The following are the <code>error</code> events:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>iamFleetRoleInvalid</code> - The EC2 Fleet or Spot Fleet did not have the required
    /// permissions either to launch or terminate an instance.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not
    /// valid. For more information, see the description of the event.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the
    /// number of Spot Instances that you can launch.</p>
    /// </li>
    /// </ul>
    /// <p>The following are the <code>fleetRequestChange</code> events:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>active</code> - The EC2 Fleet or Spot Fleet request has been validated and Amazon EC2 is
    /// attempting to maintain the target number of running Spot Instances.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cancelled</code> - The EC2 Fleet or Spot Fleet request is canceled and has no running
    /// Spot Instances. The EC2 Fleet or Spot Fleet will be deleted two days after its instances
    /// were terminated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cancelled_running</code> - The EC2 Fleet or Spot Fleet request is canceled and does
    /// not launch additional Spot Instances. Existing Spot Instances continue to run
    /// until they are interrupted or terminated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cancelled_terminating</code> - The EC2 Fleet or Spot Fleet request is canceled and
    /// its Spot Instances are terminating.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>expired</code> - The EC2 Fleet or Spot Fleet request has expired. A subsequent event
    /// indicates that the instances were terminated, if the request was created with
    /// <code>TerminateInstancesWithExpiration</code> set.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>modify_in_progress</code> - A request to modify the EC2 Fleet or Spot Fleet request
    /// was accepted and is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>modify_succeeded</code> - The EC2 Fleet or Spot Fleet request was modified.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>submitted</code> - The EC2 Fleet or Spot Fleet request is being evaluated and Amazon EC2
    /// is preparing to launch the target number of Spot Instances.</p>
    /// </li>
    /// </ul>
    /// <p>The following are the <code>instanceChange</code> events:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>launched</code> - A request was fulfilled and a new instance was
    /// launched.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>terminated</code> - An instance was terminated by the user.</p>
    /// </li>
    /// </ul>
    /// <p>The following are the <code>Information</code> events:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid
    /// and several attempts to launch instances have failed. For more information, see
    /// the description of the event.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>launchSpecUnusable</code> - The price in a launch specification is not
    /// valid because it is below the Spot price or the Spot price is above the
    /// On-Demand price.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>fleetProgressHalted</code> - The price in every launch specification is
    /// not valid. A launch specification might become valid if the Spot price
    /// changes.</p>
    /// </li>
    /// </ul>
    pub event_sub_type: std::option::Option<std::string::String>,
    /// <p>The ID of the instance. This information is available only for
    /// <code>instanceChange</code> events.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventInformation");
        formatter.field("event_description", &self.event_description);
        formatter.field("event_sub_type", &self.event_sub_type);
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}
/// See [`EventInformation`](crate::model::EventInformation)
pub mod event_information {
    /// A builder for [`EventInformation`](crate::model::EventInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_description: std::option::Option<std::string::String>,
        pub(crate) event_sub_type: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description of the event.</p>
        pub fn event_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_description = Some(input.into());
            self
        }
        pub fn set_event_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_description = input;
            self
        }
        /// <p>The event.</p>
        /// <p>The following are the <code>error</code> events:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>iamFleetRoleInvalid</code> - The EC2 Fleet or Spot Fleet did not have the required
        /// permissions either to launch or terminate an instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not
        /// valid. For more information, see the description of the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the
        /// number of Spot Instances that you can launch.</p>
        /// </li>
        /// </ul>
        /// <p>The following are the <code>fleetRequestChange</code> events:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>active</code> - The EC2 Fleet or Spot Fleet request has been validated and Amazon EC2 is
        /// attempting to maintain the target number of running Spot Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelled</code> - The EC2 Fleet or Spot Fleet request is canceled and has no running
        /// Spot Instances. The EC2 Fleet or Spot Fleet will be deleted two days after its instances
        /// were terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelled_running</code> - The EC2 Fleet or Spot Fleet request is canceled and does
        /// not launch additional Spot Instances. Existing Spot Instances continue to run
        /// until they are interrupted or terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelled_terminating</code> - The EC2 Fleet or Spot Fleet request is canceled and
        /// its Spot Instances are terminating.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>expired</code> - The EC2 Fleet or Spot Fleet request has expired. A subsequent event
        /// indicates that the instances were terminated, if the request was created with
        /// <code>TerminateInstancesWithExpiration</code> set.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modify_in_progress</code> - A request to modify the EC2 Fleet or Spot Fleet request
        /// was accepted and is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modify_succeeded</code> - The EC2 Fleet or Spot Fleet request was modified.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>submitted</code> - The EC2 Fleet or Spot Fleet request is being evaluated and Amazon EC2
        /// is preparing to launch the target number of Spot Instances.</p>
        /// </li>
        /// </ul>
        /// <p>The following are the <code>instanceChange</code> events:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>launched</code> - A request was fulfilled and a new instance was
        /// launched.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>terminated</code> - An instance was terminated by the user.</p>
        /// </li>
        /// </ul>
        /// <p>The following are the <code>Information</code> events:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid
        /// and several attempts to launch instances have failed. For more information, see
        /// the description of the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launchSpecUnusable</code> - The price in a launch specification is not
        /// valid because it is below the Spot price or the Spot price is above the
        /// On-Demand price.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fleetProgressHalted</code> - The price in every launch specification is
        /// not valid. A launch specification might become valid if the Spot price
        /// changes.</p>
        /// </li>
        /// </ul>
        pub fn event_sub_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_sub_type = Some(input.into());
            self
        }
        pub fn set_event_sub_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_sub_type = input;
            self
        }
        /// <p>The ID of the instance. This information is available only for
        /// <code>instanceChange</code> events.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EventInformation`](crate::model::EventInformation)
        pub fn build(self) -> crate::model::EventInformation {
            crate::model::EventInformation {
                event_description: self.event_description,
                event_sub_type: self.event_sub_type,
                instance_id: self.instance_id,
            }
        }
    }
}
impl EventInformation {
    /// Creates a new builder-style object to manufacture [`EventInformation`](crate::model::EventInformation)
    pub fn builder() -> crate::model::event_information::Builder {
        crate::model::event_information::Builder::default()
    }
}

/// <p>Describes a running instance in a Spot Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveInstance {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the Spot Instance request.</p>
    pub spot_instance_request_id: std::option::Option<std::string::String>,
    /// <p>The health status of the instance. If the status of either the instance status check
    /// or the system status check is <code>impaired</code>, the health status of the instance
    /// is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
    pub instance_health: std::option::Option<crate::model::InstanceHealthStatus>,
}
impl std::fmt::Debug for ActiveInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveInstance");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("spot_instance_request_id", &self.spot_instance_request_id);
        formatter.field("instance_health", &self.instance_health);
        formatter.finish()
    }
}
/// See [`ActiveInstance`](crate::model::ActiveInstance)
pub mod active_instance {
    /// A builder for [`ActiveInstance`](crate::model::ActiveInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) spot_instance_request_id: std::option::Option<std::string::String>,
        pub(crate) instance_health: std::option::Option<crate::model::InstanceHealthStatus>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the Spot Instance request.</p>
        pub fn spot_instance_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_instance_request_id = Some(input.into());
            self
        }
        pub fn set_spot_instance_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_instance_request_id = input;
            self
        }
        /// <p>The health status of the instance. If the status of either the instance status check
        /// or the system status check is <code>impaired</code>, the health status of the instance
        /// is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
        pub fn instance_health(mut self, input: crate::model::InstanceHealthStatus) -> Self {
            self.instance_health = Some(input);
            self
        }
        pub fn set_instance_health(
            mut self,
            input: std::option::Option<crate::model::InstanceHealthStatus>,
        ) -> Self {
            self.instance_health = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveInstance`](crate::model::ActiveInstance)
        pub fn build(self) -> crate::model::ActiveInstance {
            crate::model::ActiveInstance {
                instance_id: self.instance_id,
                instance_type: self.instance_type,
                spot_instance_request_id: self.spot_instance_request_id,
                instance_health: self.instance_health,
            }
        }
    }
}
impl ActiveInstance {
    /// Creates a new builder-style object to manufacture [`ActiveInstance`](crate::model::ActiveInstance)
    pub fn builder() -> crate::model::active_instance::Builder {
        crate::model::active_instance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceHealthStatus {
    HealthyStatus,
    UnhealthyStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceHealthStatus {
    fn from(s: &str) -> Self {
        match s {
            "healthy" => InstanceHealthStatus::HealthyStatus,
            "unhealthy" => InstanceHealthStatus::UnhealthyStatus,
            other => InstanceHealthStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceHealthStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceHealthStatus::from(s))
    }
}
impl InstanceHealthStatus {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceHealthStatus::HealthyStatus => "healthy",
            InstanceHealthStatus::UnhealthyStatus => "unhealthy",
            InstanceHealthStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["healthy", "unhealthy"]
    }
}
impl AsRef<str> for InstanceHealthStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the data feed for a Spot Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotDatafeedSubscription {
    /// <p>The name of the Amazon S3 bucket where the Spot Instance data feed is located.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The fault codes for the Spot Instance request, if any.</p>
    pub fault: std::option::Option<crate::model::SpotInstanceStateFault>,
    /// <p>The Amazon Web Services account ID of the account.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The prefix for the data feed files.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>The state of the Spot Instance data feed subscription.</p>
    pub state: std::option::Option<crate::model::DatafeedSubscriptionState>,
}
impl std::fmt::Debug for SpotDatafeedSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotDatafeedSubscription");
        formatter.field("bucket", &self.bucket);
        formatter.field("fault", &self.fault);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("prefix", &self.prefix);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`SpotDatafeedSubscription`](crate::model::SpotDatafeedSubscription)
pub mod spot_datafeed_subscription {
    /// A builder for [`SpotDatafeedSubscription`](crate::model::SpotDatafeedSubscription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) fault: std::option::Option<crate::model::SpotInstanceStateFault>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::DatafeedSubscriptionState>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket where the Spot Instance data feed is located.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The fault codes for the Spot Instance request, if any.</p>
        pub fn fault(mut self, input: crate::model::SpotInstanceStateFault) -> Self {
            self.fault = Some(input);
            self
        }
        pub fn set_fault(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceStateFault>,
        ) -> Self {
            self.fault = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the account.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The prefix for the data feed files.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>The state of the Spot Instance data feed subscription.</p>
        pub fn state(mut self, input: crate::model::DatafeedSubscriptionState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::DatafeedSubscriptionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotDatafeedSubscription`](crate::model::SpotDatafeedSubscription)
        pub fn build(self) -> crate::model::SpotDatafeedSubscription {
            crate::model::SpotDatafeedSubscription {
                bucket: self.bucket,
                fault: self.fault,
                owner_id: self.owner_id,
                prefix: self.prefix,
                state: self.state,
            }
        }
    }
}
impl SpotDatafeedSubscription {
    /// Creates a new builder-style object to manufacture [`SpotDatafeedSubscription`](crate::model::SpotDatafeedSubscription)
    pub fn builder() -> crate::model::spot_datafeed_subscription::Builder {
        crate::model::spot_datafeed_subscription::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatafeedSubscriptionState {
    Active,
    Inactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DatafeedSubscriptionState {
    fn from(s: &str) -> Self {
        match s {
            "Active" => DatafeedSubscriptionState::Active,
            "Inactive" => DatafeedSubscriptionState::Inactive,
            other => DatafeedSubscriptionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DatafeedSubscriptionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatafeedSubscriptionState::from(s))
    }
}
impl DatafeedSubscriptionState {
    pub fn as_str(&self) -> &str {
        match self {
            DatafeedSubscriptionState::Active => "Active",
            DatafeedSubscriptionState::Inactive => "Inactive",
            DatafeedSubscriptionState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Active", "Inactive"]
    }
}
impl AsRef<str> for DatafeedSubscriptionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Snapshot {
    /// <p>The data encryption key identifier for the snapshot. This value is a unique identifier
    /// that corresponds to the data encryption key that was used to encrypt the original volume or
    /// snapshot copy. Because data encryption keys are inherited by volumes created from snapshots,
    /// and vice versa, if snapshots share the same data encryption key identifier, then they belong
    /// to the same volume/snapshot lineage. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
    pub data_encryption_key_id: std::option::Option<std::string::String>,
    /// <p>The description for the snapshot.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the snapshot is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the
    /// volume encryption key for the parent volume.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the EBS snapshot.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The progress of the snapshot, as a percentage.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is
    /// created.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The time stamp when the snapshot was initiated.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The snapshot state.</p>
    pub state: std::option::Option<crate::model::SnapshotState>,
    /// <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails
    /// (for example, if the proper Key Management Service (KMS) permissions are not obtained) this field displays error
    /// state details to help you diagnose why the error occurred. This parameter is only returned by
    /// <a>DescribeSnapshots</a>.</p>
    pub state_message: std::option::Option<std::string::String>,
    /// <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any
    /// purpose.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiB.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>The Amazon Web Services owner alias, from an Amazon-maintained list (<code>amazon</code>). This is not  
    /// the user-configured Amazon Web Services account alias set using the IAM console.</p>
    pub owner_alias: std::option::Option<std::string::String>,
    /// <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html">Amazon EBS local snapshots on Outposts</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the snapshot.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Snapshot");
        formatter.field("data_encryption_key_id", &self.data_encryption_key_id);
        formatter.field("description", &self.description);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("progress", &self.progress);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("start_time", &self.start_time);
        formatter.field("state", &self.state);
        formatter.field("state_message", &self.state_message);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Snapshot`](crate::model::Snapshot)
pub mod snapshot {
    /// A builder for [`Snapshot`](crate::model::Snapshot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_encryption_key_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) state: std::option::Option<crate::model::SnapshotState>,
        pub(crate) state_message: std::option::Option<std::string::String>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The data encryption key identifier for the snapshot. This value is a unique identifier
        /// that corresponds to the data encryption key that was used to encrypt the original volume or
        /// snapshot copy. Because data encryption keys are inherited by volumes created from snapshots,
        /// and vice versa, if snapshots share the same data encryption key identifier, then they belong
        /// to the same volume/snapshot lineage. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
        pub fn data_encryption_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_encryption_key_id = Some(input.into());
            self
        }
        pub fn set_data_encryption_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_encryption_key_id = input;
            self
        }
        /// <p>The description for the snapshot.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the snapshot is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the
        /// volume encryption key for the parent volume.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the EBS snapshot.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The progress of the snapshot, as a percentage.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is
        /// created.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The time stamp when the snapshot was initiated.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The snapshot state.</p>
        pub fn state(mut self, input: crate::model::SnapshotState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::SnapshotState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails
        /// (for example, if the proper Key Management Service (KMS) permissions are not obtained) this field displays error
        /// state details to help you diagnose why the error occurred. This parameter is only returned by
        /// <a>DescribeSnapshots</a>.</p>
        pub fn state_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_message = Some(input.into());
            self
        }
        pub fn set_state_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_message = input;
            self
        }
        /// <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any
        /// purpose.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>The size of the volume, in GiB.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The Amazon Web Services owner alias, from an Amazon-maintained list (<code>amazon</code>). This is not  
        /// the user-configured Amazon Web Services account alias set using the IAM console.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        /// <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html">Amazon EBS local snapshots on Outposts</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Snapshot`](crate::model::Snapshot)
        pub fn build(self) -> crate::model::Snapshot {
            crate::model::Snapshot {
                data_encryption_key_id: self.data_encryption_key_id,
                description: self.description,
                encrypted: self.encrypted,
                kms_key_id: self.kms_key_id,
                owner_id: self.owner_id,
                progress: self.progress,
                snapshot_id: self.snapshot_id,
                start_time: self.start_time,
                state: self.state,
                state_message: self.state_message,
                volume_id: self.volume_id,
                volume_size: self.volume_size,
                owner_alias: self.owner_alias,
                outpost_arn: self.outpost_arn,
                tags: self.tags,
            }
        }
    }
}
impl Snapshot {
    /// Creates a new builder-style object to manufacture [`Snapshot`](crate::model::Snapshot)
    pub fn builder() -> crate::model::snapshot::Builder {
        crate::model::snapshot::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotState {
    Completed,
    Error,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SnapshotState {
    fn from(s: &str) -> Self {
        match s {
            "completed" => SnapshotState::Completed,
            "error" => SnapshotState::Error,
            "pending" => SnapshotState::Pending,
            other => SnapshotState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SnapshotState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotState::from(s))
    }
}
impl SnapshotState {
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotState::Completed => "completed",
            SnapshotState::Error => "error",
            SnapshotState::Pending => "pending",
            SnapshotState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["completed", "error", "pending"]
    }
}
impl AsRef<str> for SnapshotState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroup {
    /// <p>A description of the security group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the security group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The inbound rules associated with the security group.</p>
    pub ip_permissions: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
    /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>[VPC only] The outbound rules associated with the security group.</p>
    pub ip_permissions_egress: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
    /// <p>Any tags assigned to the security group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>[VPC only] The ID of the VPC for the security group.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroup");
        formatter.field("description", &self.description);
        formatter.field("group_name", &self.group_name);
        formatter.field("ip_permissions", &self.ip_permissions);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("group_id", &self.group_id);
        formatter.field("ip_permissions_egress", &self.ip_permissions_egress);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`SecurityGroup`](crate::model::SecurityGroup)
pub mod security_group {
    /// A builder for [`SecurityGroup`](crate::model::SecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) ip_permissions: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) ip_permissions_egress:
            std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description of the security group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the security group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        pub fn ip_permissions(mut self, input: impl Into<crate::model::IpPermission>) -> Self {
            let mut v = self.ip_permissions.unwrap_or_default();
            v.push(input.into());
            self.ip_permissions = Some(v);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.ip_permissions = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the security group.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        pub fn ip_permissions_egress(
            mut self,
            input: impl Into<crate::model::IpPermission>,
        ) -> Self {
            let mut v = self.ip_permissions_egress.unwrap_or_default();
            v.push(input.into());
            self.ip_permissions_egress = Some(v);
            self
        }
        pub fn set_ip_permissions_egress(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.ip_permissions_egress = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>[VPC only] The ID of the VPC for the security group.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroup`](crate::model::SecurityGroup)
        pub fn build(self) -> crate::model::SecurityGroup {
            crate::model::SecurityGroup {
                description: self.description,
                group_name: self.group_name,
                ip_permissions: self.ip_permissions,
                owner_id: self.owner_id,
                group_id: self.group_id,
                ip_permissions_egress: self.ip_permissions_egress,
                tags: self.tags,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl SecurityGroup {
    /// Creates a new builder-style object to manufacture [`SecurityGroup`](crate::model::SecurityGroup)
    pub fn builder() -> crate::model::security_group::Builder {
        crate::model::security_group::Builder::default()
    }
}

/// <p>Describes a security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupRule {
    /// <p>The ID of the security group rule.</p>
    pub security_group_rule_id: std::option::Option<std::string::String>,
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the security group. </p>
    pub group_owner_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the security group rule is an outbound rule.</p>
    pub is_egress: std::option::Option<bool>,
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
    /// <code>icmpv6</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p>
    /// <p>Use <code>-1</code> to specify all protocols.</p>
    pub ip_protocol: std::option::Option<std::string::String>,
    /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type. A value
    /// of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must
    /// specify all codes.</p>
    pub from_port: std::option::Option<i32>,
    /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
    pub to_port: std::option::Option<i32>,
    /// <p>The IPv4 CIDR range.</p>
    pub cidr_ipv4: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR range.</p>
    pub cidr_ipv6: std::option::Option<std::string::String>,
    /// <p>The ID of the prefix list.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>Describes the security group that is referenced in the rule.</p>
    pub referenced_group_info: std::option::Option<crate::model::ReferencedSecurityGroup>,
    /// <p>The security group rule description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags applied to the security group rule.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for SecurityGroupRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupRule");
        formatter.field("security_group_rule_id", &self.security_group_rule_id);
        formatter.field("group_id", &self.group_id);
        formatter.field("group_owner_id", &self.group_owner_id);
        formatter.field("is_egress", &self.is_egress);
        formatter.field("ip_protocol", &self.ip_protocol);
        formatter.field("from_port", &self.from_port);
        formatter.field("to_port", &self.to_port);
        formatter.field("cidr_ipv4", &self.cidr_ipv4);
        formatter.field("cidr_ipv6", &self.cidr_ipv6);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("referenced_group_info", &self.referenced_group_info);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SecurityGroupRule`](crate::model::SecurityGroupRule)
pub mod security_group_rule {
    /// A builder for [`SecurityGroupRule`](crate::model::SecurityGroupRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_rule_id: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_owner_id: std::option::Option<std::string::String>,
        pub(crate) is_egress: std::option::Option<bool>,
        pub(crate) ip_protocol: std::option::Option<std::string::String>,
        pub(crate) from_port: std::option::Option<i32>,
        pub(crate) to_port: std::option::Option<i32>,
        pub(crate) cidr_ipv4: std::option::Option<std::string::String>,
        pub(crate) cidr_ipv6: std::option::Option<std::string::String>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) referenced_group_info:
            std::option::Option<crate::model::ReferencedSecurityGroup>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the security group rule.</p>
        pub fn security_group_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_group_rule_id = Some(input.into());
            self
        }
        pub fn set_security_group_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_group_rule_id = input;
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the security group. </p>
        pub fn group_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_owner_id = Some(input.into());
            self
        }
        pub fn set_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_owner_id = input;
            self
        }
        /// <p>Indicates whether the security group rule is an outbound rule.</p>
        pub fn is_egress(mut self, input: bool) -> Self {
            self.is_egress = Some(input);
            self
        }
        pub fn set_is_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.is_egress = input;
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
        /// <code>icmpv6</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p>
        /// <p>Use <code>-1</code> to specify all protocols.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_protocol = Some(input.into());
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_protocol = input;
            self
        }
        /// <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type. A value
        /// of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must
        /// specify all codes.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.from_port = Some(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.from_port = input;
            self
        }
        /// <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes. </p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.to_port = Some(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.to_port = input;
            self
        }
        /// <p>The IPv4 CIDR range.</p>
        pub fn cidr_ipv4(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv4 = Some(input.into());
            self
        }
        pub fn set_cidr_ipv4(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv4 = input;
            self
        }
        /// <p>The IPv6 CIDR range.</p>
        pub fn cidr_ipv6(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_ipv6 = Some(input.into());
            self
        }
        pub fn set_cidr_ipv6(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_ipv6 = input;
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>Describes the security group that is referenced in the rule.</p>
        pub fn referenced_group_info(
            mut self,
            input: crate::model::ReferencedSecurityGroup,
        ) -> Self {
            self.referenced_group_info = Some(input);
            self
        }
        pub fn set_referenced_group_info(
            mut self,
            input: std::option::Option<crate::model::ReferencedSecurityGroup>,
        ) -> Self {
            self.referenced_group_info = input;
            self
        }
        /// <p>The security group rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupRule`](crate::model::SecurityGroupRule)
        pub fn build(self) -> crate::model::SecurityGroupRule {
            crate::model::SecurityGroupRule {
                security_group_rule_id: self.security_group_rule_id,
                group_id: self.group_id,
                group_owner_id: self.group_owner_id,
                is_egress: self.is_egress,
                ip_protocol: self.ip_protocol,
                from_port: self.from_port,
                to_port: self.to_port,
                cidr_ipv4: self.cidr_ipv4,
                cidr_ipv6: self.cidr_ipv6,
                prefix_list_id: self.prefix_list_id,
                referenced_group_info: self.referenced_group_info,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl SecurityGroupRule {
    /// Creates a new builder-style object to manufacture [`SecurityGroupRule`](crate::model::SecurityGroupRule)
    pub fn builder() -> crate::model::security_group_rule::Builder {
        crate::model::security_group_rule::Builder::default()
    }
}

/// <p> Describes the security group that is referenced in the security group rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferencedSecurityGroup {
    /// <p>The ID of the security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The status of a VPC peering connection, if applicable.</p>
    pub peering_status: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC peering connection.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferencedSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferencedSecurityGroup");
        formatter.field("group_id", &self.group_id);
        formatter.field("peering_status", &self.peering_status);
        formatter.field("user_id", &self.user_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`ReferencedSecurityGroup`](crate::model::ReferencedSecurityGroup)
pub mod referenced_security_group {
    /// A builder for [`ReferencedSecurityGroup`](crate::model::ReferencedSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) peering_status: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The status of a VPC peering connection, if applicable.</p>
        pub fn peering_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_status = Some(input.into());
            self
        }
        pub fn set_peering_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.peering_status = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferencedSecurityGroup`](crate::model::ReferencedSecurityGroup)
        pub fn build(self) -> crate::model::ReferencedSecurityGroup {
            crate::model::ReferencedSecurityGroup {
                group_id: self.group_id,
                peering_status: self.peering_status,
                user_id: self.user_id,
                vpc_id: self.vpc_id,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl ReferencedSecurityGroup {
    /// Creates a new builder-style object to manufacture [`ReferencedSecurityGroup`](crate::model::ReferencedSecurityGroup)
    pub fn builder() -> crate::model::referenced_security_group::Builder {
        crate::model::referenced_security_group::Builder::default()
    }
}

/// <p>Describes a VPC with a security group that references your security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecurityGroupReference {
    /// <p>The ID of your security group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC with the referencing security group.</p>
    pub referencing_vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC peering connection.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecurityGroupReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecurityGroupReference");
        formatter.field("group_id", &self.group_id);
        formatter.field("referencing_vpc_id", &self.referencing_vpc_id);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`SecurityGroupReference`](crate::model::SecurityGroupReference)
pub mod security_group_reference {
    /// A builder for [`SecurityGroupReference`](crate::model::SecurityGroupReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) referencing_vpc_id: std::option::Option<std::string::String>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of your security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The ID of the VPC with the referencing security group.</p>
        pub fn referencing_vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.referencing_vpc_id = Some(input.into());
            self
        }
        pub fn set_referencing_vpc_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.referencing_vpc_id = input;
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SecurityGroupReference`](crate::model::SecurityGroupReference)
        pub fn build(self) -> crate::model::SecurityGroupReference {
            crate::model::SecurityGroupReference {
                group_id: self.group_id,
                referencing_vpc_id: self.referencing_vpc_id,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl SecurityGroupReference {
    /// Creates a new builder-style object to manufacture [`SecurityGroupReference`](crate::model::SecurityGroupReference)
    pub fn builder() -> crate::model::security_group_reference::Builder {
        crate::model::security_group_reference::Builder::default()
    }
}

/// <p>Describes the time period for a Scheduled Instance to start its first schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SlotStartTimeRangeRequest {
    /// <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
    pub earliest_time: std::option::Option<smithy_types::Instant>,
    /// <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
    pub latest_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for SlotStartTimeRangeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SlotStartTimeRangeRequest");
        formatter.field("earliest_time", &self.earliest_time);
        formatter.field("latest_time", &self.latest_time);
        formatter.finish()
    }
}
/// See [`SlotStartTimeRangeRequest`](crate::model::SlotStartTimeRangeRequest)
pub mod slot_start_time_range_request {
    /// A builder for [`SlotStartTimeRangeRequest`](crate::model::SlotStartTimeRangeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) earliest_time: std::option::Option<smithy_types::Instant>,
        pub(crate) latest_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
        pub fn earliest_time(mut self, input: smithy_types::Instant) -> Self {
            self.earliest_time = Some(input);
            self
        }
        pub fn set_earliest_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.earliest_time = input;
            self
        }
        /// <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
        pub fn latest_time(mut self, input: smithy_types::Instant) -> Self {
            self.latest_time = Some(input);
            self
        }
        pub fn set_latest_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SlotStartTimeRangeRequest`](crate::model::SlotStartTimeRangeRequest)
        pub fn build(self) -> crate::model::SlotStartTimeRangeRequest {
            crate::model::SlotStartTimeRangeRequest {
                earliest_time: self.earliest_time,
                latest_time: self.latest_time,
            }
        }
    }
}
impl SlotStartTimeRangeRequest {
    /// Creates a new builder-style object to manufacture [`SlotStartTimeRangeRequest`](crate::model::SlotStartTimeRangeRequest)
    pub fn builder() -> crate::model::slot_start_time_range_request::Builder {
        crate::model::slot_start_time_range_request::Builder::default()
    }
}

/// <p>Describes a schedule that is available for your Scheduled Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstanceAvailability {
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of available instances.</p>
    pub available_instance_count: std::option::Option<i32>,
    /// <p>The time period for the first schedule to start.</p>
    pub first_slot_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The hourly price for a single instance.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The maximum term. The only possible value is 365 days.</p>
    pub max_term_duration_in_days: std::option::Option<i32>,
    /// <p>The minimum term. The only possible value is 365 days.</p>
    pub min_term_duration_in_days: std::option::Option<i32>,
    /// <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
    pub network_platform: std::option::Option<std::string::String>,
    /// <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The purchase token. This token expires in two hours.</p>
    pub purchase_token: std::option::Option<std::string::String>,
    /// <p>The schedule recurrence.</p>
    pub recurrence: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
    /// <p>The number of hours in the schedule.</p>
    pub slot_duration_in_hours: std::option::Option<i32>,
    /// <p>The total number of hours for a single instance for the entire term.</p>
    pub total_scheduled_instance_hours: std::option::Option<i32>,
}
impl std::fmt::Debug for ScheduledInstanceAvailability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstanceAvailability");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("available_instance_count", &self.available_instance_count);
        formatter.field("first_slot_start_time", &self.first_slot_start_time);
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("max_term_duration_in_days", &self.max_term_duration_in_days);
        formatter.field("min_term_duration_in_days", &self.min_term_duration_in_days);
        formatter.field("network_platform", &self.network_platform);
        formatter.field("platform", &self.platform);
        formatter.field("purchase_token", &self.purchase_token);
        formatter.field("recurrence", &self.recurrence);
        formatter.field("slot_duration_in_hours", &self.slot_duration_in_hours);
        formatter.field(
            "total_scheduled_instance_hours",
            &self.total_scheduled_instance_hours,
        );
        formatter.finish()
    }
}
/// See [`ScheduledInstanceAvailability`](crate::model::ScheduledInstanceAvailability)
pub mod scheduled_instance_availability {
    /// A builder for [`ScheduledInstanceAvailability`](crate::model::ScheduledInstanceAvailability)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) available_instance_count: std::option::Option<i32>,
        pub(crate) first_slot_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) max_term_duration_in_days: std::option::Option<i32>,
        pub(crate) min_term_duration_in_days: std::option::Option<i32>,
        pub(crate) network_platform: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) purchase_token: std::option::Option<std::string::String>,
        pub(crate) recurrence: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
        pub(crate) slot_duration_in_hours: std::option::Option<i32>,
        pub(crate) total_scheduled_instance_hours: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of available instances.</p>
        pub fn available_instance_count(mut self, input: i32) -> Self {
            self.available_instance_count = Some(input);
            self
        }
        pub fn set_available_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.available_instance_count = input;
            self
        }
        /// <p>The time period for the first schedule to start.</p>
        pub fn first_slot_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.first_slot_start_time = Some(input);
            self
        }
        pub fn set_first_slot_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.first_slot_start_time = input;
            self
        }
        /// <p>The hourly price for a single instance.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The maximum term. The only possible value is 365 days.</p>
        pub fn max_term_duration_in_days(mut self, input: i32) -> Self {
            self.max_term_duration_in_days = Some(input);
            self
        }
        pub fn set_max_term_duration_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.max_term_duration_in_days = input;
            self
        }
        /// <p>The minimum term. The only possible value is 365 days.</p>
        pub fn min_term_duration_in_days(mut self, input: i32) -> Self {
            self.min_term_duration_in_days = Some(input);
            self
        }
        pub fn set_min_term_duration_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.min_term_duration_in_days = input;
            self
        }
        /// <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
        pub fn network_platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_platform = Some(input.into());
            self
        }
        pub fn set_network_platform(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_platform = input;
            self
        }
        /// <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The purchase token. This token expires in two hours.</p>
        pub fn purchase_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.purchase_token = Some(input.into());
            self
        }
        pub fn set_purchase_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.purchase_token = input;
            self
        }
        /// <p>The schedule recurrence.</p>
        pub fn recurrence(mut self, input: crate::model::ScheduledInstanceRecurrence) -> Self {
            self.recurrence = Some(input);
            self
        }
        pub fn set_recurrence(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstanceRecurrence>,
        ) -> Self {
            self.recurrence = input;
            self
        }
        /// <p>The number of hours in the schedule.</p>
        pub fn slot_duration_in_hours(mut self, input: i32) -> Self {
            self.slot_duration_in_hours = Some(input);
            self
        }
        pub fn set_slot_duration_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.slot_duration_in_hours = input;
            self
        }
        /// <p>The total number of hours for a single instance for the entire term.</p>
        pub fn total_scheduled_instance_hours(mut self, input: i32) -> Self {
            self.total_scheduled_instance_hours = Some(input);
            self
        }
        pub fn set_total_scheduled_instance_hours(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.total_scheduled_instance_hours = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstanceAvailability`](crate::model::ScheduledInstanceAvailability)
        pub fn build(self) -> crate::model::ScheduledInstanceAvailability {
            crate::model::ScheduledInstanceAvailability {
                availability_zone: self.availability_zone,
                available_instance_count: self.available_instance_count,
                first_slot_start_time: self.first_slot_start_time,
                hourly_price: self.hourly_price,
                instance_type: self.instance_type,
                max_term_duration_in_days: self.max_term_duration_in_days,
                min_term_duration_in_days: self.min_term_duration_in_days,
                network_platform: self.network_platform,
                platform: self.platform,
                purchase_token: self.purchase_token,
                recurrence: self.recurrence,
                slot_duration_in_hours: self.slot_duration_in_hours,
                total_scheduled_instance_hours: self.total_scheduled_instance_hours,
            }
        }
    }
}
impl ScheduledInstanceAvailability {
    /// Creates a new builder-style object to manufacture [`ScheduledInstanceAvailability`](crate::model::ScheduledInstanceAvailability)
    pub fn builder() -> crate::model::scheduled_instance_availability::Builder {
        crate::model::scheduled_instance_availability::Builder::default()
    }
}

/// <p>Describes the recurring schedule for a Scheduled Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledInstanceRecurrenceRequest {
    /// <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
    pub frequency: std::option::Option<std::string::String>,
    /// <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2
    /// weeks or every 2 months.</p>
    pub interval: std::option::Option<i32>,
    /// <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>
    pub occurrence_days: std::option::Option<std::vec::Vec<i32>>,
    /// <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
    pub occurrence_relative_to_end: std::option::Option<bool>,
    /// <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).
    /// This value is required for a monthly schedule.
    /// You can't specify <code>DayOfWeek</code> with a weekly schedule.
    /// You can't specify this value with a daily schedule.</p>
    pub occurrence_unit: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledInstanceRecurrenceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledInstanceRecurrenceRequest");
        formatter.field("frequency", &self.frequency);
        formatter.field("interval", &self.interval);
        formatter.field("occurrence_days", &self.occurrence_days);
        formatter.field(
            "occurrence_relative_to_end",
            &self.occurrence_relative_to_end,
        );
        formatter.field("occurrence_unit", &self.occurrence_unit);
        formatter.finish()
    }
}
/// See [`ScheduledInstanceRecurrenceRequest`](crate::model::ScheduledInstanceRecurrenceRequest)
pub mod scheduled_instance_recurrence_request {
    /// A builder for [`ScheduledInstanceRecurrenceRequest`](crate::model::ScheduledInstanceRecurrenceRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) frequency: std::option::Option<std::string::String>,
        pub(crate) interval: std::option::Option<i32>,
        pub(crate) occurrence_days: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) occurrence_relative_to_end: std::option::Option<bool>,
        pub(crate) occurrence_unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
        pub fn frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.frequency = Some(input.into());
            self
        }
        pub fn set_frequency(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.frequency = input;
            self
        }
        /// <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2
        /// weeks or every 2 months.</p>
        pub fn interval(mut self, input: i32) -> Self {
            self.interval = Some(input);
            self
        }
        pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.interval = input;
            self
        }
        pub fn occurrence_days(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.occurrence_days.unwrap_or_default();
            v.push(input.into());
            self.occurrence_days = Some(v);
            self
        }
        pub fn set_occurrence_days(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.occurrence_days = input;
            self
        }
        /// <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
        pub fn occurrence_relative_to_end(mut self, input: bool) -> Self {
            self.occurrence_relative_to_end = Some(input);
            self
        }
        pub fn set_occurrence_relative_to_end(mut self, input: std::option::Option<bool>) -> Self {
            self.occurrence_relative_to_end = input;
            self
        }
        /// <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).
        /// This value is required for a monthly schedule.
        /// You can't specify <code>DayOfWeek</code> with a weekly schedule.
        /// You can't specify this value with a daily schedule.</p>
        pub fn occurrence_unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.occurrence_unit = Some(input.into());
            self
        }
        pub fn set_occurrence_unit(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.occurrence_unit = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledInstanceRecurrenceRequest`](crate::model::ScheduledInstanceRecurrenceRequest)
        pub fn build(self) -> crate::model::ScheduledInstanceRecurrenceRequest {
            crate::model::ScheduledInstanceRecurrenceRequest {
                frequency: self.frequency,
                interval: self.interval,
                occurrence_days: self.occurrence_days,
                occurrence_relative_to_end: self.occurrence_relative_to_end,
                occurrence_unit: self.occurrence_unit,
            }
        }
    }
}
impl ScheduledInstanceRecurrenceRequest {
    /// Creates a new builder-style object to manufacture [`ScheduledInstanceRecurrenceRequest`](crate::model::ScheduledInstanceRecurrenceRequest)
    pub fn builder() -> crate::model::scheduled_instance_recurrence_request::Builder {
        crate::model::scheduled_instance_recurrence_request::Builder::default()
    }
}

/// <p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SlotDateTimeRangeRequest {
    /// <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
    pub earliest_time: std::option::Option<smithy_types::Instant>,
    /// <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
    pub latest_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for SlotDateTimeRangeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SlotDateTimeRangeRequest");
        formatter.field("earliest_time", &self.earliest_time);
        formatter.field("latest_time", &self.latest_time);
        formatter.finish()
    }
}
/// See [`SlotDateTimeRangeRequest`](crate::model::SlotDateTimeRangeRequest)
pub mod slot_date_time_range_request {
    /// A builder for [`SlotDateTimeRangeRequest`](crate::model::SlotDateTimeRangeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) earliest_time: std::option::Option<smithy_types::Instant>,
        pub(crate) latest_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
        pub fn earliest_time(mut self, input: smithy_types::Instant) -> Self {
            self.earliest_time = Some(input);
            self
        }
        pub fn set_earliest_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.earliest_time = input;
            self
        }
        /// <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
        pub fn latest_time(mut self, input: smithy_types::Instant) -> Self {
            self.latest_time = Some(input);
            self
        }
        pub fn set_latest_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SlotDateTimeRangeRequest`](crate::model::SlotDateTimeRangeRequest)
        pub fn build(self) -> crate::model::SlotDateTimeRangeRequest {
            crate::model::SlotDateTimeRangeRequest {
                earliest_time: self.earliest_time,
                latest_time: self.latest_time,
            }
        }
    }
}
impl SlotDateTimeRangeRequest {
    /// Creates a new builder-style object to manufacture [`SlotDateTimeRangeRequest`](crate::model::SlotDateTimeRangeRequest)
    pub fn builder() -> crate::model::slot_date_time_range_request::Builder {
        crate::model::slot_date_time_range_request::Builder::default()
    }
}

/// <p>Describes a route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RouteTable {
    /// <p>The associations between the route table and one or more subnets or a gateway.</p>
    pub associations: std::option::Option<std::vec::Vec<crate::model::RouteTableAssociation>>,
    /// <p>Any virtual private gateway (VGW) propagating routes.</p>
    pub propagating_vgws: std::option::Option<std::vec::Vec<crate::model::PropagatingVgw>>,
    /// <p>The ID of the route table.</p>
    pub route_table_id: std::option::Option<std::string::String>,
    /// <p>The routes in the route table.</p>
    pub routes: std::option::Option<std::vec::Vec<crate::model::Route>>,
    /// <p>Any tags assigned to the route table.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the route table.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RouteTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RouteTable");
        formatter.field("associations", &self.associations);
        formatter.field("propagating_vgws", &self.propagating_vgws);
        formatter.field("route_table_id", &self.route_table_id);
        formatter.field("routes", &self.routes);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`RouteTable`](crate::model::RouteTable)
pub mod route_table {
    /// A builder for [`RouteTable`](crate::model::RouteTable)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associations:
            std::option::Option<std::vec::Vec<crate::model::RouteTableAssociation>>,
        pub(crate) propagating_vgws:
            std::option::Option<std::vec::Vec<crate::model::PropagatingVgw>>,
        pub(crate) route_table_id: std::option::Option<std::string::String>,
        pub(crate) routes: std::option::Option<std::vec::Vec<crate::model::Route>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn associations(
            mut self,
            input: impl Into<crate::model::RouteTableAssociation>,
        ) -> Self {
            let mut v = self.associations.unwrap_or_default();
            v.push(input.into());
            self.associations = Some(v);
            self
        }
        pub fn set_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RouteTableAssociation>>,
        ) -> Self {
            self.associations = input;
            self
        }
        pub fn propagating_vgws(mut self, input: impl Into<crate::model::PropagatingVgw>) -> Self {
            let mut v = self.propagating_vgws.unwrap_or_default();
            v.push(input.into());
            self.propagating_vgws = Some(v);
            self
        }
        pub fn set_propagating_vgws(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PropagatingVgw>>,
        ) -> Self {
            self.propagating_vgws = input;
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_table_id = Some(input.into());
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_table_id = input;
            self
        }
        pub fn routes(mut self, input: impl Into<crate::model::Route>) -> Self {
            let mut v = self.routes.unwrap_or_default();
            v.push(input.into());
            self.routes = Some(v);
            self
        }
        pub fn set_routes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Route>>,
        ) -> Self {
            self.routes = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the route table.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RouteTable`](crate::model::RouteTable)
        pub fn build(self) -> crate::model::RouteTable {
            crate::model::RouteTable {
                associations: self.associations,
                propagating_vgws: self.propagating_vgws,
                route_table_id: self.route_table_id,
                routes: self.routes,
                tags: self.tags,
                vpc_id: self.vpc_id,
                owner_id: self.owner_id,
            }
        }
    }
}
impl RouteTable {
    /// Creates a new builder-style object to manufacture [`RouteTable`](crate::model::RouteTable)
    pub fn builder() -> crate::model::route_table::Builder {
        crate::model::route_table::Builder::default()
    }
}

/// <p>Describes a route in a route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Route {
    /// <p>The IPv4 CIDR block used for the destination match.</p>
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR block used for the destination match.</p>
    pub destination_ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>The prefix of the Amazon Web Service.</p>
    pub destination_prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The ID of the egress-only internet gateway.</p>
    pub egress_only_internet_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of a gateway attached to your VPC.</p>
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of a NAT instance in your VPC.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The ID of Amazon Web Services account that owns the instance.</p>
    pub instance_owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of a NAT gateway.</p>
    pub nat_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of a transit gateway.</p>
    pub transit_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the carrier gateway.</p>
    pub carrier_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>Describes how the route was created.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreateRoute</code> - The route was manually added to the route table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p>
    /// </li>
    /// </ul>
    pub origin: std::option::Option<crate::model::RouteOrigin>,
    /// <p>The state of the route. The <code>blackhole</code> state indicates that the
    /// route's target isn't available (for example, the specified gateway isn't attached to the
    /// VPC, or the specified NAT instance has been terminated).</p>
    pub state: std::option::Option<crate::model::RouteState>,
    /// <p>The ID of a VPC peering connection.</p>
    pub vpc_peering_connection_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Route {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Route");
        formatter.field("destination_cidr_block", &self.destination_cidr_block);
        formatter.field(
            "destination_ipv6_cidr_block",
            &self.destination_ipv6_cidr_block,
        );
        formatter.field(
            "destination_prefix_list_id",
            &self.destination_prefix_list_id,
        );
        formatter.field(
            "egress_only_internet_gateway_id",
            &self.egress_only_internet_gateway_id,
        );
        formatter.field("gateway_id", &self.gateway_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_owner_id", &self.instance_owner_id);
        formatter.field("nat_gateway_id", &self.nat_gateway_id);
        formatter.field("transit_gateway_id", &self.transit_gateway_id);
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("carrier_gateway_id", &self.carrier_gateway_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("origin", &self.origin);
        formatter.field("state", &self.state);
        formatter.field("vpc_peering_connection_id", &self.vpc_peering_connection_id);
        formatter.finish()
    }
}
/// See [`Route`](crate::model::Route)
pub mod route {
    /// A builder for [`Route`](crate::model::Route)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) destination_ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) destination_prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) egress_only_internet_gateway_id: std::option::Option<std::string::String>,
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_owner_id: std::option::Option<std::string::String>,
        pub(crate) nat_gateway_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) carrier_gateway_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<crate::model::RouteOrigin>,
        pub(crate) state: std::option::Option<crate::model::RouteState>,
        pub(crate) vpc_peering_connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 CIDR block used for the destination match.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr_block = input;
            self
        }
        /// <p>The IPv6 CIDR block used for the destination match.</p>
        pub fn destination_ipv6_cidr_block(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.destination_ipv6_cidr_block = Some(input.into());
            self
        }
        pub fn set_destination_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_ipv6_cidr_block = input;
            self
        }
        /// <p>The prefix of the Amazon Web Service.</p>
        pub fn destination_prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_prefix_list_id = Some(input.into());
            self
        }
        pub fn set_destination_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_prefix_list_id = input;
            self
        }
        /// <p>The ID of the egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = Some(input.into());
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = input;
            self
        }
        /// <p>The ID of a gateway attached to your VPC.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// <p>The ID of a NAT instance in your VPC.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The ID of Amazon Web Services account that owns the instance.</p>
        pub fn instance_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_owner_id = Some(input.into());
            self
        }
        pub fn set_instance_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_owner_id = input;
            self
        }
        /// <p>The ID of a NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.nat_gateway_id = Some(input.into());
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nat_gateway_id = input;
            self
        }
        /// <p>The ID of a transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_id = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The ID of the carrier gateway.</p>
        pub fn carrier_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier_gateway_id = Some(input.into());
            self
        }
        pub fn set_carrier_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.carrier_gateway_id = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>Describes how the route was created.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreateRoute</code> - The route was manually added to the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p>
        /// </li>
        /// </ul>
        pub fn origin(mut self, input: crate::model::RouteOrigin) -> Self {
            self.origin = Some(input);
            self
        }
        pub fn set_origin(mut self, input: std::option::Option<crate::model::RouteOrigin>) -> Self {
            self.origin = input;
            self
        }
        /// <p>The state of the route. The <code>blackhole</code> state indicates that the
        /// route's target isn't available (for example, the specified gateway isn't attached to the
        /// VPC, or the specified NAT instance has been terminated).</p>
        pub fn state(mut self, input: crate::model::RouteState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::RouteState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of a VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_peering_connection_id = Some(input.into());
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_peering_connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Route`](crate::model::Route)
        pub fn build(self) -> crate::model::Route {
            crate::model::Route {
                destination_cidr_block: self.destination_cidr_block,
                destination_ipv6_cidr_block: self.destination_ipv6_cidr_block,
                destination_prefix_list_id: self.destination_prefix_list_id,
                egress_only_internet_gateway_id: self.egress_only_internet_gateway_id,
                gateway_id: self.gateway_id,
                instance_id: self.instance_id,
                instance_owner_id: self.instance_owner_id,
                nat_gateway_id: self.nat_gateway_id,
                transit_gateway_id: self.transit_gateway_id,
                local_gateway_id: self.local_gateway_id,
                carrier_gateway_id: self.carrier_gateway_id,
                network_interface_id: self.network_interface_id,
                origin: self.origin,
                state: self.state,
                vpc_peering_connection_id: self.vpc_peering_connection_id,
            }
        }
    }
}
impl Route {
    /// Creates a new builder-style object to manufacture [`Route`](crate::model::Route)
    pub fn builder() -> crate::model::route::Builder {
        crate::model::route::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RouteState {
    Active,
    Blackhole,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RouteState {
    fn from(s: &str) -> Self {
        match s {
            "active" => RouteState::Active,
            "blackhole" => RouteState::Blackhole,
            other => RouteState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RouteState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RouteState::from(s))
    }
}
impl RouteState {
    pub fn as_str(&self) -> &str {
        match self {
            RouteState::Active => "active",
            RouteState::Blackhole => "blackhole",
            RouteState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "blackhole"]
    }
}
impl AsRef<str> for RouteState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RouteOrigin {
    CreateRoute,
    CreateRouteTable,
    EnableVgwRoutePropagation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RouteOrigin {
    fn from(s: &str) -> Self {
        match s {
            "CreateRoute" => RouteOrigin::CreateRoute,
            "CreateRouteTable" => RouteOrigin::CreateRouteTable,
            "EnableVgwRoutePropagation" => RouteOrigin::EnableVgwRoutePropagation,
            other => RouteOrigin::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RouteOrigin {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RouteOrigin::from(s))
    }
}
impl RouteOrigin {
    pub fn as_str(&self) -> &str {
        match self {
            RouteOrigin::CreateRoute => "CreateRoute",
            RouteOrigin::CreateRouteTable => "CreateRouteTable",
            RouteOrigin::EnableVgwRoutePropagation => "EnableVgwRoutePropagation",
            RouteOrigin::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreateRoute",
            "CreateRouteTable",
            "EnableVgwRoutePropagation",
        ]
    }
}
impl AsRef<str> for RouteOrigin {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a virtual private gateway propagating route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropagatingVgw {
    /// <p>The ID of the virtual private gateway.</p>
    pub gateway_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PropagatingVgw {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropagatingVgw");
        formatter.field("gateway_id", &self.gateway_id);
        formatter.finish()
    }
}
/// See [`PropagatingVgw`](crate::model::PropagatingVgw)
pub mod propagating_vgw {
    /// A builder for [`PropagatingVgw`](crate::model::PropagatingVgw)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PropagatingVgw`](crate::model::PropagatingVgw)
        pub fn build(self) -> crate::model::PropagatingVgw {
            crate::model::PropagatingVgw {
                gateway_id: self.gateway_id,
            }
        }
    }
}
impl PropagatingVgw {
    /// Creates a new builder-style object to manufacture [`PropagatingVgw`](crate::model::PropagatingVgw)
    pub fn builder() -> crate::model::propagating_vgw::Builder {
        crate::model::propagating_vgw::Builder::default()
    }
}

/// <p>Describes an association between a route table and a subnet or gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RouteTableAssociation {
    /// <p>Indicates whether this is the main route table.</p>
    pub main: std::option::Option<bool>,
    /// <p>The ID of the association.</p>
    pub route_table_association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route table.</p>
    pub route_table_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the internet gateway or virtual private gateway.</p>
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    pub association_state: std::option::Option<crate::model::RouteTableAssociationState>,
}
impl std::fmt::Debug for RouteTableAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RouteTableAssociation");
        formatter.field("main", &self.main);
        formatter.field(
            "route_table_association_id",
            &self.route_table_association_id,
        );
        formatter.field("route_table_id", &self.route_table_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("gateway_id", &self.gateway_id);
        formatter.field("association_state", &self.association_state);
        formatter.finish()
    }
}
/// See [`RouteTableAssociation`](crate::model::RouteTableAssociation)
pub mod route_table_association {
    /// A builder for [`RouteTableAssociation`](crate::model::RouteTableAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) main: std::option::Option<bool>,
        pub(crate) route_table_association_id: std::option::Option<std::string::String>,
        pub(crate) route_table_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) association_state: std::option::Option<crate::model::RouteTableAssociationState>,
    }
    impl Builder {
        /// <p>Indicates whether this is the main route table.</p>
        pub fn main(mut self, input: bool) -> Self {
            self.main = Some(input);
            self
        }
        pub fn set_main(mut self, input: std::option::Option<bool>) -> Self {
            self.main = input;
            self
        }
        /// <p>The ID of the association.</p>
        pub fn route_table_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_table_association_id = Some(input.into());
            self
        }
        pub fn set_route_table_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_table_association_id = input;
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_table_id = Some(input.into());
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_table_id = input;
            self
        }
        /// <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of the internet gateway or virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn association_state(
            mut self,
            input: crate::model::RouteTableAssociationState,
        ) -> Self {
            self.association_state = Some(input);
            self
        }
        pub fn set_association_state(
            mut self,
            input: std::option::Option<crate::model::RouteTableAssociationState>,
        ) -> Self {
            self.association_state = input;
            self
        }
        /// Consumes the builder and constructs a [`RouteTableAssociation`](crate::model::RouteTableAssociation)
        pub fn build(self) -> crate::model::RouteTableAssociation {
            crate::model::RouteTableAssociation {
                main: self.main,
                route_table_association_id: self.route_table_association_id,
                route_table_id: self.route_table_id,
                subnet_id: self.subnet_id,
                gateway_id: self.gateway_id,
                association_state: self.association_state,
            }
        }
    }
}
impl RouteTableAssociation {
    /// Creates a new builder-style object to manufacture [`RouteTableAssociation`](crate::model::RouteTableAssociation)
    pub fn builder() -> crate::model::route_table_association::Builder {
        crate::model::route_table_association::Builder::default()
    }
}

/// <p>Describes a Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesOffering {
    /// <p>The Availability Zone in which the Reserved Instance can be used.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The duration of the Reserved Instance, in seconds.</p>
    pub duration: std::option::Option<i64>,
    /// <p>The purchase price of the Reserved Instance.</p>
    pub fixed_price: std::option::Option<f32>,
    /// <p>The instance type on which the Reserved Instance can be used.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The Reserved Instance product platform description.</p>
    pub product_description: std::option::Option<crate::model::RiProductDescription>,
    /// <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a>
    /// to confirm that an exchange can be made.</p>
    pub reserved_instances_offering_id: std::option::Option<std::string::String>,
    /// <p>The usage price of the Reserved Instance, per hour.</p>
    pub usage_price: std::option::Option<f32>,
    /// <p>The currency of the Reserved Instance offering you are purchasing. It's
    /// specified using ISO 4217 standard currency codes. At this time,
    /// the only supported currency is <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The tenancy of the instance.</p>
    pub instance_tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or Amazon Web Services.
    /// If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
    pub marketplace: std::option::Option<bool>,
    /// <p>If <code>convertible</code> it can be exchanged for Reserved Instances of
    /// the same or higher monetary value, with different configurations. If <code>standard</code>, it is not
    /// possible to perform an exchange.</p>
    pub offering_class: std::option::Option<crate::model::OfferingClassType>,
    /// <p>The Reserved Instance offering type.</p>
    pub offering_type: std::option::Option<crate::model::OfferingTypeValues>,
    /// <p>The pricing details of the Reserved Instance offering.</p>
    pub pricing_details: std::option::Option<std::vec::Vec<crate::model::PricingDetail>>,
    /// <p>The recurring charge tag assigned to the resource.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    /// <p>Whether the Reserved Instance is applied to instances in a Region or an Availability Zone.</p>
    pub scope: std::option::Option<crate::model::Scope>,
}
impl std::fmt::Debug for ReservedInstancesOffering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesOffering");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("duration", &self.duration);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("product_description", &self.product_description);
        formatter.field(
            "reserved_instances_offering_id",
            &self.reserved_instances_offering_id,
        );
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("instance_tenancy", &self.instance_tenancy);
        formatter.field("marketplace", &self.marketplace);
        formatter.field("offering_class", &self.offering_class);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("pricing_details", &self.pricing_details);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.field("scope", &self.scope);
        formatter.finish()
    }
}
/// See [`ReservedInstancesOffering`](crate::model::ReservedInstancesOffering)
pub mod reserved_instances_offering {
    /// A builder for [`ReservedInstancesOffering`](crate::model::ReservedInstancesOffering)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) duration: std::option::Option<i64>,
        pub(crate) fixed_price: std::option::Option<f32>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) product_description: std::option::Option<crate::model::RiProductDescription>,
        pub(crate) reserved_instances_offering_id: std::option::Option<std::string::String>,
        pub(crate) usage_price: std::option::Option<f32>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) instance_tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) marketplace: std::option::Option<bool>,
        pub(crate) offering_class: std::option::Option<crate::model::OfferingClassType>,
        pub(crate) offering_type: std::option::Option<crate::model::OfferingTypeValues>,
        pub(crate) pricing_details: std::option::Option<std::vec::Vec<crate::model::PricingDetail>>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
    }
    impl Builder {
        /// <p>The Availability Zone in which the Reserved Instance can be used.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The duration of the Reserved Instance, in seconds.</p>
        pub fn duration(mut self, input: i64) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The purchase price of the Reserved Instance.</p>
        pub fn fixed_price(mut self, input: f32) -> Self {
            self.fixed_price = Some(input);
            self
        }
        pub fn set_fixed_price(mut self, input: std::option::Option<f32>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The instance type on which the Reserved Instance can be used.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The Reserved Instance product platform description.</p>
        pub fn product_description(mut self, input: crate::model::RiProductDescription) -> Self {
            self.product_description = Some(input);
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<crate::model::RiProductDescription>,
        ) -> Self {
            self.product_description = input;
            self
        }
        /// <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a>
        /// to confirm that an exchange can be made.</p>
        pub fn reserved_instances_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instances_offering_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_offering_id = input;
            self
        }
        /// <p>The usage price of the Reserved Instance, per hour.</p>
        pub fn usage_price(mut self, input: f32) -> Self {
            self.usage_price = Some(input);
            self
        }
        pub fn set_usage_price(mut self, input: std::option::Option<f32>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency of the Reserved Instance offering you are purchasing. It's
        /// specified using ISO 4217 standard currency codes. At this time,
        /// the only supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The tenancy of the instance.</p>
        pub fn instance_tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.instance_tenancy = Some(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::Tenancy>,
        ) -> Self {
            self.instance_tenancy = input;
            self
        }
        /// <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or Amazon Web Services.
        /// If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
        pub fn marketplace(mut self, input: bool) -> Self {
            self.marketplace = Some(input);
            self
        }
        pub fn set_marketplace(mut self, input: std::option::Option<bool>) -> Self {
            self.marketplace = input;
            self
        }
        /// <p>If <code>convertible</code> it can be exchanged for Reserved Instances of
        /// the same or higher monetary value, with different configurations. If <code>standard</code>, it is not
        /// possible to perform an exchange.</p>
        pub fn offering_class(mut self, input: crate::model::OfferingClassType) -> Self {
            self.offering_class = Some(input);
            self
        }
        pub fn set_offering_class(
            mut self,
            input: std::option::Option<crate::model::OfferingClassType>,
        ) -> Self {
            self.offering_class = input;
            self
        }
        /// <p>The Reserved Instance offering type.</p>
        pub fn offering_type(mut self, input: crate::model::OfferingTypeValues) -> Self {
            self.offering_type = Some(input);
            self
        }
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<crate::model::OfferingTypeValues>,
        ) -> Self {
            self.offering_type = input;
            self
        }
        pub fn pricing_details(mut self, input: impl Into<crate::model::PricingDetail>) -> Self {
            let mut v = self.pricing_details.unwrap_or_default();
            v.push(input.into());
            self.pricing_details = Some(v);
            self
        }
        pub fn set_pricing_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PricingDetail>>,
        ) -> Self {
            self.pricing_details = input;
            self
        }
        pub fn recurring_charges(
            mut self,
            input: impl Into<crate::model::RecurringCharge>,
        ) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input.into());
            self.recurring_charges = Some(v);
            self
        }
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// <p>Whether the Reserved Instance is applied to instances in a Region or an Availability Zone.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesOffering`](crate::model::ReservedInstancesOffering)
        pub fn build(self) -> crate::model::ReservedInstancesOffering {
            crate::model::ReservedInstancesOffering {
                availability_zone: self.availability_zone,
                duration: self.duration,
                fixed_price: self.fixed_price,
                instance_type: self.instance_type,
                product_description: self.product_description,
                reserved_instances_offering_id: self.reserved_instances_offering_id,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                instance_tenancy: self.instance_tenancy,
                marketplace: self.marketplace,
                offering_class: self.offering_class,
                offering_type: self.offering_type,
                pricing_details: self.pricing_details,
                recurring_charges: self.recurring_charges,
                scope: self.scope,
            }
        }
    }
}
impl ReservedInstancesOffering {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesOffering`](crate::model::ReservedInstancesOffering)
    pub fn builder() -> crate::model::reserved_instances_offering::Builder {
        crate::model::reserved_instances_offering::Builder::default()
    }
}

/// <p>Describes a recurring charge.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecurringCharge {
    /// <p>The amount of the recurring charge.</p>
    pub amount: std::option::Option<f64>,
    /// <p>The frequency of the recurring charge.</p>
    pub frequency: std::option::Option<crate::model::RecurringChargeFrequency>,
}
impl std::fmt::Debug for RecurringCharge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecurringCharge");
        formatter.field("amount", &self.amount);
        formatter.field("frequency", &self.frequency);
        formatter.finish()
    }
}
/// See [`RecurringCharge`](crate::model::RecurringCharge)
pub mod recurring_charge {
    /// A builder for [`RecurringCharge`](crate::model::RecurringCharge)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount: std::option::Option<f64>,
        pub(crate) frequency: std::option::Option<crate::model::RecurringChargeFrequency>,
    }
    impl Builder {
        /// <p>The amount of the recurring charge.</p>
        pub fn amount(mut self, input: f64) -> Self {
            self.amount = Some(input);
            self
        }
        pub fn set_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The frequency of the recurring charge.</p>
        pub fn frequency(mut self, input: crate::model::RecurringChargeFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::RecurringChargeFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`RecurringCharge`](crate::model::RecurringCharge)
        pub fn build(self) -> crate::model::RecurringCharge {
            crate::model::RecurringCharge {
                amount: self.amount,
                frequency: self.frequency,
            }
        }
    }
}
impl RecurringCharge {
    /// Creates a new builder-style object to manufacture [`RecurringCharge`](crate::model::RecurringCharge)
    pub fn builder() -> crate::model::recurring_charge::Builder {
        crate::model::recurring_charge::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecurringChargeFrequency {
    Hourly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecurringChargeFrequency {
    fn from(s: &str) -> Self {
        match s {
            "Hourly" => RecurringChargeFrequency::Hourly,
            other => RecurringChargeFrequency::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecurringChargeFrequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecurringChargeFrequency::from(s))
    }
}
impl RecurringChargeFrequency {
    pub fn as_str(&self) -> &str {
        match self {
            RecurringChargeFrequency::Hourly => "Hourly",
            RecurringChargeFrequency::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Hourly"]
    }
}
impl AsRef<str> for RecurringChargeFrequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Reserved Instance offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PricingDetail {
    /// <p>The number of reservations available for the price.</p>
    pub count: std::option::Option<i32>,
    /// <p>The price per instance.</p>
    pub price: std::option::Option<f64>,
}
impl std::fmt::Debug for PricingDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PricingDetail");
        formatter.field("count", &self.count);
        formatter.field("price", &self.price);
        formatter.finish()
    }
}
/// See [`PricingDetail`](crate::model::PricingDetail)
pub mod pricing_detail {
    /// A builder for [`PricingDetail`](crate::model::PricingDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) price: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The number of reservations available for the price.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The price per instance.</p>
        pub fn price(mut self, input: f64) -> Self {
            self.price = Some(input);
            self
        }
        pub fn set_price(mut self, input: std::option::Option<f64>) -> Self {
            self.price = input;
            self
        }
        /// Consumes the builder and constructs a [`PricingDetail`](crate::model::PricingDetail)
        pub fn build(self) -> crate::model::PricingDetail {
            crate::model::PricingDetail {
                count: self.count,
                price: self.price,
            }
        }
    }
}
impl PricingDetail {
    /// Creates a new builder-style object to manufacture [`PricingDetail`](crate::model::PricingDetail)
    pub fn builder() -> crate::model::pricing_detail::Builder {
        crate::model::pricing_detail::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OfferingTypeValues {
    AllUpfront,
    HeavyUtilization,
    LightUtilization,
    MediumUtilization,
    NoUpfront,
    PartialUpfront,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OfferingTypeValues {
    fn from(s: &str) -> Self {
        match s {
            "All Upfront" => OfferingTypeValues::AllUpfront,
            "Heavy Utilization" => OfferingTypeValues::HeavyUtilization,
            "Light Utilization" => OfferingTypeValues::LightUtilization,
            "Medium Utilization" => OfferingTypeValues::MediumUtilization,
            "No Upfront" => OfferingTypeValues::NoUpfront,
            "Partial Upfront" => OfferingTypeValues::PartialUpfront,
            other => OfferingTypeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OfferingTypeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OfferingTypeValues::from(s))
    }
}
impl OfferingTypeValues {
    pub fn as_str(&self) -> &str {
        match self {
            OfferingTypeValues::AllUpfront => "All Upfront",
            OfferingTypeValues::HeavyUtilization => "Heavy Utilization",
            OfferingTypeValues::LightUtilization => "Light Utilization",
            OfferingTypeValues::MediumUtilization => "Medium Utilization",
            OfferingTypeValues::NoUpfront => "No Upfront",
            OfferingTypeValues::PartialUpfront => "Partial Upfront",
            OfferingTypeValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "All Upfront",
            "Heavy Utilization",
            "Light Utilization",
            "Medium Utilization",
            "No Upfront",
            "Partial Upfront",
        ]
    }
}
impl AsRef<str> for OfferingTypeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OfferingClassType {
    Convertible,
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OfferingClassType {
    fn from(s: &str) -> Self {
        match s {
            "convertible" => OfferingClassType::Convertible,
            "standard" => OfferingClassType::Standard,
            other => OfferingClassType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OfferingClassType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OfferingClassType::from(s))
    }
}
impl OfferingClassType {
    pub fn as_str(&self) -> &str {
        match self {
            OfferingClassType::Convertible => "convertible",
            OfferingClassType::Standard => "standard",
            OfferingClassType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["convertible", "standard"]
    }
}
impl AsRef<str> for OfferingClassType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Reserved Instance modification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesModification {
    /// <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent.
    /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
    /// Idempotency</a>.</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The time when the modification request was created.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>The time for the modification to become effective.</p>
    pub effective_date: std::option::Option<smithy_types::Instant>,
    /// <p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>
    pub modification_results:
        std::option::Option<std::vec::Vec<crate::model::ReservedInstancesModificationResult>>,
    /// <p>The IDs of one or more Reserved Instances.</p>
    pub reserved_instances_ids:
        std::option::Option<std::vec::Vec<crate::model::ReservedInstancesId>>,
    /// <p>A unique ID for the Reserved Instance modification.</p>
    pub reserved_instances_modification_id: std::option::Option<std::string::String>,
    /// <p>The status of the Reserved Instances modification request.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The reason for the status.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The time when the modification request was last updated.</p>
    pub update_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ReservedInstancesModification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesModification");
        formatter.field("client_token", &self.client_token);
        formatter.field("create_date", &self.create_date);
        formatter.field("effective_date", &self.effective_date);
        formatter.field("modification_results", &self.modification_results);
        formatter.field("reserved_instances_ids", &self.reserved_instances_ids);
        formatter.field(
            "reserved_instances_modification_id",
            &self.reserved_instances_modification_id,
        );
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("update_date", &self.update_date);
        formatter.finish()
    }
}
/// See [`ReservedInstancesModification`](crate::model::ReservedInstancesModification)
pub mod reserved_instances_modification {
    /// A builder for [`ReservedInstancesModification`](crate::model::ReservedInstancesModification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) effective_date: std::option::Option<smithy_types::Instant>,
        pub(crate) modification_results:
            std::option::Option<std::vec::Vec<crate::model::ReservedInstancesModificationResult>>,
        pub(crate) reserved_instances_ids:
            std::option::Option<std::vec::Vec<crate::model::ReservedInstancesId>>,
        pub(crate) reserved_instances_modification_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) update_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The time when the modification request was created.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The time for the modification to become effective.</p>
        pub fn effective_date(mut self, input: smithy_types::Instant) -> Self {
            self.effective_date = Some(input);
            self
        }
        pub fn set_effective_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.effective_date = input;
            self
        }
        pub fn modification_results(
            mut self,
            input: impl Into<crate::model::ReservedInstancesModificationResult>,
        ) -> Self {
            let mut v = self.modification_results.unwrap_or_default();
            v.push(input.into());
            self.modification_results = Some(v);
            self
        }
        pub fn set_modification_results(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ReservedInstancesModificationResult>,
            >,
        ) -> Self {
            self.modification_results = input;
            self
        }
        pub fn reserved_instances_ids(
            mut self,
            input: impl Into<crate::model::ReservedInstancesId>,
        ) -> Self {
            let mut v = self.reserved_instances_ids.unwrap_or_default();
            v.push(input.into());
            self.reserved_instances_ids = Some(v);
            self
        }
        pub fn set_reserved_instances_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReservedInstancesId>>,
        ) -> Self {
            self.reserved_instances_ids = input;
            self
        }
        /// <p>A unique ID for the Reserved Instance modification.</p>
        pub fn reserved_instances_modification_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instances_modification_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_modification_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_modification_id = input;
            self
        }
        /// <p>The status of the Reserved Instances modification request.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason for the status.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The time when the modification request was last updated.</p>
        pub fn update_date(mut self, input: smithy_types::Instant) -> Self {
            self.update_date = Some(input);
            self
        }
        pub fn set_update_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesModification`](crate::model::ReservedInstancesModification)
        pub fn build(self) -> crate::model::ReservedInstancesModification {
            crate::model::ReservedInstancesModification {
                client_token: self.client_token,
                create_date: self.create_date,
                effective_date: self.effective_date,
                modification_results: self.modification_results,
                reserved_instances_ids: self.reserved_instances_ids,
                reserved_instances_modification_id: self.reserved_instances_modification_id,
                status: self.status,
                status_message: self.status_message,
                update_date: self.update_date,
            }
        }
    }
}
impl ReservedInstancesModification {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesModification`](crate::model::ReservedInstancesModification)
    pub fn builder() -> crate::model::reserved_instances_modification::Builder {
        crate::model::reserved_instances_modification::Builder::default()
    }
}

/// <p>Describes the ID of a Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesId {
    /// <p>The ID of the Reserved Instance.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedInstancesId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesId");
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.finish()
    }
}
/// See [`ReservedInstancesId`](crate::model::ReservedInstancesId)
pub mod reserved_instances_id {
    /// A builder for [`ReservedInstancesId`](crate::model::ReservedInstancesId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesId`](crate::model::ReservedInstancesId)
        pub fn build(self) -> crate::model::ReservedInstancesId {
            crate::model::ReservedInstancesId {
                reserved_instances_id: self.reserved_instances_id,
            }
        }
    }
}
impl ReservedInstancesId {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesId`](crate::model::ReservedInstancesId)
    pub fn builder() -> crate::model::reserved_instances_id::Builder {
        crate::model::reserved_instances_id::Builder::default()
    }
}

/// <p>Describes the modification request/s.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesModificationResult {
    /// <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
    /// <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
    pub target_configuration: std::option::Option<crate::model::ReservedInstancesConfiguration>,
}
impl std::fmt::Debug for ReservedInstancesModificationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesModificationResult");
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.field("target_configuration", &self.target_configuration);
        formatter.finish()
    }
}
/// See [`ReservedInstancesModificationResult`](crate::model::ReservedInstancesModificationResult)
pub mod reserved_instances_modification_result {
    /// A builder for [`ReservedInstancesModificationResult`](crate::model::ReservedInstancesModificationResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
        pub(crate) target_configuration:
            std::option::Option<crate::model::ReservedInstancesConfiguration>,
    }
    impl Builder {
        /// <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
        pub fn target_configuration(
            mut self,
            input: crate::model::ReservedInstancesConfiguration,
        ) -> Self {
            self.target_configuration = Some(input);
            self
        }
        pub fn set_target_configuration(
            mut self,
            input: std::option::Option<crate::model::ReservedInstancesConfiguration>,
        ) -> Self {
            self.target_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesModificationResult`](crate::model::ReservedInstancesModificationResult)
        pub fn build(self) -> crate::model::ReservedInstancesModificationResult {
            crate::model::ReservedInstancesModificationResult {
                reserved_instances_id: self.reserved_instances_id,
                target_configuration: self.target_configuration,
            }
        }
    }
}
impl ReservedInstancesModificationResult {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesModificationResult`](crate::model::ReservedInstancesModificationResult)
    pub fn builder() -> crate::model::reserved_instances_modification_result::Builder {
        crate::model::reserved_instances_modification_result::Builder::default()
    }
}

/// <p>Describes a Reserved Instance listing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstancesListing {
    /// <p>A unique, case-sensitive key supplied by the client to ensure that the request is
    /// idempotent. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The time the listing was created.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>The number of instances in this state.</p>
    pub instance_counts: std::option::Option<std::vec::Vec<crate::model::InstanceCount>>,
    /// <p>The price of the Reserved Instance listing.</p>
    pub price_schedules: std::option::Option<std::vec::Vec<crate::model::PriceSchedule>>,
    /// <p>The ID of the Reserved Instance.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Reserved Instance listing.</p>
    pub reserved_instances_listing_id: std::option::Option<std::string::String>,
    /// <p>The status of the Reserved Instance listing.</p>
    pub status: std::option::Option<crate::model::ListingStatus>,
    /// <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The last modified timestamp of the listing.</p>
    pub update_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ReservedInstancesListing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstancesListing");
        formatter.field("client_token", &self.client_token);
        formatter.field("create_date", &self.create_date);
        formatter.field("instance_counts", &self.instance_counts);
        formatter.field("price_schedules", &self.price_schedules);
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.field(
            "reserved_instances_listing_id",
            &self.reserved_instances_listing_id,
        );
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("tags", &self.tags);
        formatter.field("update_date", &self.update_date);
        formatter.finish()
    }
}
/// See [`ReservedInstancesListing`](crate::model::ReservedInstancesListing)
pub mod reserved_instances_listing {
    /// A builder for [`ReservedInstancesListing`](crate::model::ReservedInstancesListing)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_counts: std::option::Option<std::vec::Vec<crate::model::InstanceCount>>,
        pub(crate) price_schedules: std::option::Option<std::vec::Vec<crate::model::PriceSchedule>>,
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
        pub(crate) reserved_instances_listing_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ListingStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) update_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>A unique, case-sensitive key supplied by the client to ensure that the request is
        /// idempotent. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The time the listing was created.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        pub fn instance_counts(mut self, input: impl Into<crate::model::InstanceCount>) -> Self {
            let mut v = self.instance_counts.unwrap_or_default();
            v.push(input.into());
            self.instance_counts = Some(v);
            self
        }
        pub fn set_instance_counts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceCount>>,
        ) -> Self {
            self.instance_counts = input;
            self
        }
        pub fn price_schedules(mut self, input: impl Into<crate::model::PriceSchedule>) -> Self {
            let mut v = self.price_schedules.unwrap_or_default();
            v.push(input.into());
            self.price_schedules = Some(v);
            self
        }
        pub fn set_price_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PriceSchedule>>,
        ) -> Self {
            self.price_schedules = input;
            self
        }
        /// <p>The ID of the Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// <p>The ID of the Reserved Instance listing.</p>
        pub fn reserved_instances_listing_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reserved_instances_listing_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_listing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_listing_id = input;
            self
        }
        /// <p>The status of the Reserved Instance listing.</p>
        pub fn status(mut self, input: crate::model::ListingStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ListingStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The last modified timestamp of the listing.</p>
        pub fn update_date(mut self, input: smithy_types::Instant) -> Self {
            self.update_date = Some(input);
            self
        }
        pub fn set_update_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_date = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstancesListing`](crate::model::ReservedInstancesListing)
        pub fn build(self) -> crate::model::ReservedInstancesListing {
            crate::model::ReservedInstancesListing {
                client_token: self.client_token,
                create_date: self.create_date,
                instance_counts: self.instance_counts,
                price_schedules: self.price_schedules,
                reserved_instances_id: self.reserved_instances_id,
                reserved_instances_listing_id: self.reserved_instances_listing_id,
                status: self.status,
                status_message: self.status_message,
                tags: self.tags,
                update_date: self.update_date,
            }
        }
    }
}
impl ReservedInstancesListing {
    /// Creates a new builder-style object to manufacture [`ReservedInstancesListing`](crate::model::ReservedInstancesListing)
    pub fn builder() -> crate::model::reserved_instances_listing::Builder {
        crate::model::reserved_instances_listing::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListingStatus {
    Active,
    Cancelled,
    Closed,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListingStatus {
    fn from(s: &str) -> Self {
        match s {
            "active" => ListingStatus::Active,
            "cancelled" => ListingStatus::Cancelled,
            "closed" => ListingStatus::Closed,
            "pending" => ListingStatus::Pending,
            other => ListingStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListingStatus::from(s))
    }
}
impl ListingStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ListingStatus::Active => "active",
            ListingStatus::Cancelled => "cancelled",
            ListingStatus::Closed => "closed",
            ListingStatus::Pending => "pending",
            ListingStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "closed", "pending"]
    }
}
impl AsRef<str> for ListingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the price for a Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PriceSchedule {
    /// <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p>
    /// <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
    pub active: std::option::Option<bool>,
    /// <p>The currency for transacting the Reserved Instance resale.
    /// At this time, the only supported currency is <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The fixed price for the term.</p>
    pub price: std::option::Option<f64>,
    /// <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
    pub term: std::option::Option<i64>,
}
impl std::fmt::Debug for PriceSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PriceSchedule");
        formatter.field("active", &self.active);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("price", &self.price);
        formatter.field("term", &self.term);
        formatter.finish()
    }
}
/// See [`PriceSchedule`](crate::model::PriceSchedule)
pub mod price_schedule {
    /// A builder for [`PriceSchedule`](crate::model::PriceSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active: std::option::Option<bool>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) price: std::option::Option<f64>,
        pub(crate) term: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p>
        /// <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// <p>The currency for transacting the Reserved Instance resale.
        /// At this time, the only supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The fixed price for the term.</p>
        pub fn price(mut self, input: f64) -> Self {
            self.price = Some(input);
            self
        }
        pub fn set_price(mut self, input: std::option::Option<f64>) -> Self {
            self.price = input;
            self
        }
        /// <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
        pub fn term(mut self, input: i64) -> Self {
            self.term = Some(input);
            self
        }
        pub fn set_term(mut self, input: std::option::Option<i64>) -> Self {
            self.term = input;
            self
        }
        /// Consumes the builder and constructs a [`PriceSchedule`](crate::model::PriceSchedule)
        pub fn build(self) -> crate::model::PriceSchedule {
            crate::model::PriceSchedule {
                active: self.active,
                currency_code: self.currency_code,
                price: self.price,
                term: self.term,
            }
        }
    }
}
impl PriceSchedule {
    /// Creates a new builder-style object to manufacture [`PriceSchedule`](crate::model::PriceSchedule)
    pub fn builder() -> crate::model::price_schedule::Builder {
        crate::model::price_schedule::Builder::default()
    }
}

/// <p>Describes a Reserved Instance listing state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceCount {
    /// <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The states of the listed Reserved Instances.</p>
    pub state: std::option::Option<crate::model::ListingState>,
}
impl std::fmt::Debug for InstanceCount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceCount");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`InstanceCount`](crate::model::InstanceCount)
pub mod instance_count {
    /// A builder for [`InstanceCount`](crate::model::InstanceCount)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::ListingState>,
    }
    impl Builder {
        /// <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The states of the listed Reserved Instances.</p>
        pub fn state(mut self, input: crate::model::ListingState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::ListingState>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCount`](crate::model::InstanceCount)
        pub fn build(self) -> crate::model::InstanceCount {
            crate::model::InstanceCount {
                instance_count: self.instance_count,
                state: self.state,
            }
        }
    }
}
impl InstanceCount {
    /// Creates a new builder-style object to manufacture [`InstanceCount`](crate::model::InstanceCount)
    pub fn builder() -> crate::model::instance_count::Builder {
        crate::model::instance_count::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListingState {
    Available,
    Cancelled,
    Pending,
    Sold,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListingState {
    fn from(s: &str) -> Self {
        match s {
            "available" => ListingState::Available,
            "cancelled" => ListingState::Cancelled,
            "pending" => ListingState::Pending,
            "sold" => ListingState::Sold,
            other => ListingState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListingState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListingState::from(s))
    }
}
impl ListingState {
    pub fn as_str(&self) -> &str {
        match self {
            ListingState::Available => "available",
            ListingState::Cancelled => "cancelled",
            ListingState::Pending => "pending",
            ListingState::Sold => "sold",
            ListingState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "cancelled", "pending", "sold"]
    }
}
impl AsRef<str> for ListingState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedInstances {
    /// <p>The Availability Zone in which the Reserved Instance can be used.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The duration of the Reserved Instance, in seconds.</p>
    pub duration: std::option::Option<i64>,
    /// <p>The time when the Reserved Instance expires.</p>
    pub end: std::option::Option<smithy_types::Instant>,
    /// <p>The purchase price of the Reserved Instance.</p>
    pub fixed_price: std::option::Option<f32>,
    /// <p>The number of reservations purchased.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The instance type on which the Reserved Instance can be used.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The Reserved Instance product platform description.</p>
    pub product_description: std::option::Option<crate::model::RiProductDescription>,
    /// <p>The ID of the Reserved Instance.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
    /// <p>The date and time the Reserved Instance started.</p>
    pub start: std::option::Option<smithy_types::Instant>,
    /// <p>The state of the Reserved Instance purchase.</p>
    pub state: std::option::Option<crate::model::ReservedInstanceState>,
    /// <p>The usage price of the Reserved Instance, per hour.</p>
    pub usage_price: std::option::Option<f32>,
    /// <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes.
    /// At this time, the only supported currency is <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The tenancy of the instance.</p>
    pub instance_tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>The offering class of the Reserved Instance.</p>
    pub offering_class: std::option::Option<crate::model::OfferingClassType>,
    /// <p>The Reserved Instance offering type.</p>
    pub offering_type: std::option::Option<crate::model::OfferingTypeValues>,
    /// <p>The recurring charge tag assigned to the resource.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    /// <p>The scope of the Reserved Instance.</p>
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>Any tags assigned to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ReservedInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedInstances");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("duration", &self.duration);
        formatter.field("end", &self.end);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("product_description", &self.product_description);
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.field("start", &self.start);
        formatter.field("state", &self.state);
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("instance_tenancy", &self.instance_tenancy);
        formatter.field("offering_class", &self.offering_class);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.field("scope", &self.scope);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ReservedInstances`](crate::model::ReservedInstances)
pub mod reserved_instances {
    /// A builder for [`ReservedInstances`](crate::model::ReservedInstances)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) duration: std::option::Option<i64>,
        pub(crate) end: std::option::Option<smithy_types::Instant>,
        pub(crate) fixed_price: std::option::Option<f32>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) product_description: std::option::Option<crate::model::RiProductDescription>,
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
        pub(crate) start: std::option::Option<smithy_types::Instant>,
        pub(crate) state: std::option::Option<crate::model::ReservedInstanceState>,
        pub(crate) usage_price: std::option::Option<f32>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) instance_tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) offering_class: std::option::Option<crate::model::OfferingClassType>,
        pub(crate) offering_type: std::option::Option<crate::model::OfferingTypeValues>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Availability Zone in which the Reserved Instance can be used.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The duration of the Reserved Instance, in seconds.</p>
        pub fn duration(mut self, input: i64) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The time when the Reserved Instance expires.</p>
        pub fn end(mut self, input: smithy_types::Instant) -> Self {
            self.end = Some(input);
            self
        }
        pub fn set_end(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end = input;
            self
        }
        /// <p>The purchase price of the Reserved Instance.</p>
        pub fn fixed_price(mut self, input: f32) -> Self {
            self.fixed_price = Some(input);
            self
        }
        pub fn set_fixed_price(mut self, input: std::option::Option<f32>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The number of reservations purchased.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The instance type on which the Reserved Instance can be used.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The Reserved Instance product platform description.</p>
        pub fn product_description(mut self, input: crate::model::RiProductDescription) -> Self {
            self.product_description = Some(input);
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<crate::model::RiProductDescription>,
        ) -> Self {
            self.product_description = input;
            self
        }
        /// <p>The ID of the Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// <p>The date and time the Reserved Instance started.</p>
        pub fn start(mut self, input: smithy_types::Instant) -> Self {
            self.start = Some(input);
            self
        }
        pub fn set_start(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start = input;
            self
        }
        /// <p>The state of the Reserved Instance purchase.</p>
        pub fn state(mut self, input: crate::model::ReservedInstanceState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ReservedInstanceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The usage price of the Reserved Instance, per hour.</p>
        pub fn usage_price(mut self, input: f32) -> Self {
            self.usage_price = Some(input);
            self
        }
        pub fn set_usage_price(mut self, input: std::option::Option<f32>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes.
        /// At this time, the only supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The tenancy of the instance.</p>
        pub fn instance_tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.instance_tenancy = Some(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::Tenancy>,
        ) -> Self {
            self.instance_tenancy = input;
            self
        }
        /// <p>The offering class of the Reserved Instance.</p>
        pub fn offering_class(mut self, input: crate::model::OfferingClassType) -> Self {
            self.offering_class = Some(input);
            self
        }
        pub fn set_offering_class(
            mut self,
            input: std::option::Option<crate::model::OfferingClassType>,
        ) -> Self {
            self.offering_class = input;
            self
        }
        /// <p>The Reserved Instance offering type.</p>
        pub fn offering_type(mut self, input: crate::model::OfferingTypeValues) -> Self {
            self.offering_type = Some(input);
            self
        }
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<crate::model::OfferingTypeValues>,
        ) -> Self {
            self.offering_type = input;
            self
        }
        pub fn recurring_charges(
            mut self,
            input: impl Into<crate::model::RecurringCharge>,
        ) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input.into());
            self.recurring_charges = Some(v);
            self
        }
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// <p>The scope of the Reserved Instance.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedInstances`](crate::model::ReservedInstances)
        pub fn build(self) -> crate::model::ReservedInstances {
            crate::model::ReservedInstances {
                availability_zone: self.availability_zone,
                duration: self.duration,
                end: self.end,
                fixed_price: self.fixed_price,
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                product_description: self.product_description,
                reserved_instances_id: self.reserved_instances_id,
                start: self.start,
                state: self.state,
                usage_price: self.usage_price,
                currency_code: self.currency_code,
                instance_tenancy: self.instance_tenancy,
                offering_class: self.offering_class,
                offering_type: self.offering_type,
                recurring_charges: self.recurring_charges,
                scope: self.scope,
                tags: self.tags,
            }
        }
    }
}
impl ReservedInstances {
    /// Creates a new builder-style object to manufacture [`ReservedInstances`](crate::model::ReservedInstances)
    pub fn builder() -> crate::model::reserved_instances::Builder {
        crate::model::reserved_instances::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReservedInstanceState {
    Active,
    PaymentFailed,
    PaymentPending,
    Queued,
    QueuedDeleted,
    Retired,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReservedInstanceState {
    fn from(s: &str) -> Self {
        match s {
            "active" => ReservedInstanceState::Active,
            "payment-failed" => ReservedInstanceState::PaymentFailed,
            "payment-pending" => ReservedInstanceState::PaymentPending,
            "queued" => ReservedInstanceState::Queued,
            "queued-deleted" => ReservedInstanceState::QueuedDeleted,
            "retired" => ReservedInstanceState::Retired,
            other => ReservedInstanceState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReservedInstanceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReservedInstanceState::from(s))
    }
}
impl ReservedInstanceState {
    pub fn as_str(&self) -> &str {
        match self {
            ReservedInstanceState::Active => "active",
            ReservedInstanceState::PaymentFailed => "payment-failed",
            ReservedInstanceState::PaymentPending => "payment-pending",
            ReservedInstanceState::Queued => "queued",
            ReservedInstanceState::QueuedDeleted => "queued-deleted",
            ReservedInstanceState::Retired => "retired",
            ReservedInstanceState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "active",
            "payment-failed",
            "payment-pending",
            "queued",
            "queued-deleted",
            "retired",
        ]
    }
}
impl AsRef<str> for ReservedInstanceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a root volume replacement task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplaceRootVolumeTask {
    /// <p>The ID of the root volume replacement task.</p>
    pub replace_root_volume_task_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance for which the root volume replacement task was created.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The state of the task. The task can be in one of the following states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>pending</code> - the replacement volume is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>in-progress</code> - the original volume is being detached and the
    /// replacement volume is being attached.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>succeeded</code> - the replacement volume has been successfully attached
    /// to the instance and the instance is available.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failing</code> - the replacement task is in the process of failing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failed</code> - the replacement task has failed but the original root
    /// volume is still attached.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failing-detached</code> - the replacement task is in the process of failing.
    /// The instance might have no root volume attached.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failed-detached</code> - the replacement task has failed and the instance
    /// has no root volume attached.</p>
    /// </li>
    /// </ul>
    pub task_state: std::option::Option<crate::model::ReplaceRootVolumeTaskState>,
    /// <p>The time the task was started.</p>
    pub start_time: std::option::Option<std::string::String>,
    /// <p>The time the task completed.</p>
    pub complete_time: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ReplaceRootVolumeTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplaceRootVolumeTask");
        formatter.field(
            "replace_root_volume_task_id",
            &self.replace_root_volume_task_id,
        );
        formatter.field("instance_id", &self.instance_id);
        formatter.field("task_state", &self.task_state);
        formatter.field("start_time", &self.start_time);
        formatter.field("complete_time", &self.complete_time);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ReplaceRootVolumeTask`](crate::model::ReplaceRootVolumeTask)
pub mod replace_root_volume_task {
    /// A builder for [`ReplaceRootVolumeTask`](crate::model::ReplaceRootVolumeTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) replace_root_volume_task_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) task_state: std::option::Option<crate::model::ReplaceRootVolumeTaskState>,
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) complete_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the root volume replacement task.</p>
        pub fn replace_root_volume_task_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.replace_root_volume_task_id = Some(input.into());
            self
        }
        pub fn set_replace_root_volume_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replace_root_volume_task_id = input;
            self
        }
        /// <p>The ID of the instance for which the root volume replacement task was created.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The state of the task. The task can be in one of the following states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>pending</code> - the replacement volume is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>in-progress</code> - the original volume is being detached and the
        /// replacement volume is being attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>succeeded</code> - the replacement volume has been successfully attached
        /// to the instance and the instance is available.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failing</code> - the replacement task is in the process of failing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed</code> - the replacement task has failed but the original root
        /// volume is still attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failing-detached</code> - the replacement task is in the process of failing.
        /// The instance might have no root volume attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed-detached</code> - the replacement task has failed and the instance
        /// has no root volume attached.</p>
        /// </li>
        /// </ul>
        pub fn task_state(mut self, input: crate::model::ReplaceRootVolumeTaskState) -> Self {
            self.task_state = Some(input);
            self
        }
        pub fn set_task_state(
            mut self,
            input: std::option::Option<crate::model::ReplaceRootVolumeTaskState>,
        ) -> Self {
            self.task_state = input;
            self
        }
        /// <p>The time the task was started.</p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time the task completed.</p>
        pub fn complete_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.complete_time = Some(input.into());
            self
        }
        pub fn set_complete_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.complete_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplaceRootVolumeTask`](crate::model::ReplaceRootVolumeTask)
        pub fn build(self) -> crate::model::ReplaceRootVolumeTask {
            crate::model::ReplaceRootVolumeTask {
                replace_root_volume_task_id: self.replace_root_volume_task_id,
                instance_id: self.instance_id,
                task_state: self.task_state,
                start_time: self.start_time,
                complete_time: self.complete_time,
                tags: self.tags,
            }
        }
    }
}
impl ReplaceRootVolumeTask {
    /// Creates a new builder-style object to manufacture [`ReplaceRootVolumeTask`](crate::model::ReplaceRootVolumeTask)
    pub fn builder() -> crate::model::replace_root_volume_task::Builder {
        crate::model::replace_root_volume_task::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplaceRootVolumeTaskState {
    Failed,
    FailedDetached,
    Failing,
    InProgress,
    Pending,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReplaceRootVolumeTaskState {
    fn from(s: &str) -> Self {
        match s {
            "failed" => ReplaceRootVolumeTaskState::Failed,
            "failed-detached" => ReplaceRootVolumeTaskState::FailedDetached,
            "failing" => ReplaceRootVolumeTaskState::Failing,
            "in-progress" => ReplaceRootVolumeTaskState::InProgress,
            "pending" => ReplaceRootVolumeTaskState::Pending,
            "succeeded" => ReplaceRootVolumeTaskState::Succeeded,
            other => ReplaceRootVolumeTaskState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReplaceRootVolumeTaskState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplaceRootVolumeTaskState::from(s))
    }
}
impl ReplaceRootVolumeTaskState {
    pub fn as_str(&self) -> &str {
        match self {
            ReplaceRootVolumeTaskState::Failed => "failed",
            ReplaceRootVolumeTaskState::FailedDetached => "failed-detached",
            ReplaceRootVolumeTaskState::Failing => "failing",
            ReplaceRootVolumeTaskState::InProgress => "in-progress",
            ReplaceRootVolumeTaskState::Pending => "pending",
            ReplaceRootVolumeTaskState::Succeeded => "succeeded",
            ReplaceRootVolumeTaskState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "failed",
            "failed-detached",
            "failing",
            "in-progress",
            "pending",
            "succeeded",
        ]
    }
}
impl AsRef<str> for ReplaceRootVolumeTaskState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Region {
    /// <p>The Region service endpoint.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The name of the Region.</p>
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The Region opt-in status. The possible values are <code>opt-in-not-required</code>, <code>opted-in</code>, and
    /// <code>not-opted-in</code>.</p>
    pub opt_in_status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Region {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Region");
        formatter.field("endpoint", &self.endpoint);
        formatter.field("region_name", &self.region_name);
        formatter.field("opt_in_status", &self.opt_in_status);
        formatter.finish()
    }
}
/// See [`Region`](crate::model::Region)
pub mod region {
    /// A builder for [`Region`](crate::model::Region)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) opt_in_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Region service endpoint.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The name of the Region.</p>
        pub fn region_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.region_name = Some(input.into());
            self
        }
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region_name = input;
            self
        }
        /// <p>The Region opt-in status. The possible values are <code>opt-in-not-required</code>, <code>opted-in</code>, and
        /// <code>not-opted-in</code>.</p>
        pub fn opt_in_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.opt_in_status = Some(input.into());
            self
        }
        pub fn set_opt_in_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.opt_in_status = input;
            self
        }
        /// Consumes the builder and constructs a [`Region`](crate::model::Region)
        pub fn build(self) -> crate::model::Region {
            crate::model::Region {
                endpoint: self.endpoint,
                region_name: self.region_name,
                opt_in_status: self.opt_in_status,
            }
        }
    }
}
impl Region {
    /// Creates a new builder-style object to manufacture [`Region`](crate::model::Region)
    pub fn builder() -> crate::model::region::Builder {
        crate::model::region::Builder::default()
    }
}

/// <p>Describes an IPv4 address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicIpv4Pool {
    /// <p>The ID of the address pool.</p>
    pub pool_id: std::option::Option<std::string::String>,
    /// <p>A description of the address pool.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The address ranges.</p>
    pub pool_address_ranges: std::option::Option<std::vec::Vec<crate::model::PublicIpv4PoolRange>>,
    /// <p>The total number of addresses.</p>
    pub total_address_count: std::option::Option<i32>,
    /// <p>The total number of available addresses.</p>
    pub total_available_address_count: std::option::Option<i32>,
    /// <p>The name of the location from which the address pool is advertised.
    /// A network border group is a unique set of Availability Zones or Local Zones
    /// from where Amazon Web Services advertises public IP addresses.</p>
    pub network_border_group: std::option::Option<std::string::String>,
    /// <p>Any tags for the address pool.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for PublicIpv4Pool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicIpv4Pool");
        formatter.field("pool_id", &self.pool_id);
        formatter.field("description", &self.description);
        formatter.field("pool_address_ranges", &self.pool_address_ranges);
        formatter.field("total_address_count", &self.total_address_count);
        formatter.field(
            "total_available_address_count",
            &self.total_available_address_count,
        );
        formatter.field("network_border_group", &self.network_border_group);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`PublicIpv4Pool`](crate::model::PublicIpv4Pool)
pub mod public_ipv4_pool {
    /// A builder for [`PublicIpv4Pool`](crate::model::PublicIpv4Pool)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pool_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) pool_address_ranges:
            std::option::Option<std::vec::Vec<crate::model::PublicIpv4PoolRange>>,
        pub(crate) total_address_count: std::option::Option<i32>,
        pub(crate) total_available_address_count: std::option::Option<i32>,
        pub(crate) network_border_group: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the address pool.</p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pool_id = Some(input.into());
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pool_id = input;
            self
        }
        /// <p>A description of the address pool.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn pool_address_ranges(
            mut self,
            input: impl Into<crate::model::PublicIpv4PoolRange>,
        ) -> Self {
            let mut v = self.pool_address_ranges.unwrap_or_default();
            v.push(input.into());
            self.pool_address_ranges = Some(v);
            self
        }
        pub fn set_pool_address_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PublicIpv4PoolRange>>,
        ) -> Self {
            self.pool_address_ranges = input;
            self
        }
        /// <p>The total number of addresses.</p>
        pub fn total_address_count(mut self, input: i32) -> Self {
            self.total_address_count = Some(input);
            self
        }
        pub fn set_total_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_address_count = input;
            self
        }
        /// <p>The total number of available addresses.</p>
        pub fn total_available_address_count(mut self, input: i32) -> Self {
            self.total_available_address_count = Some(input);
            self
        }
        pub fn set_total_available_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.total_available_address_count = input;
            self
        }
        /// <p>The name of the location from which the address pool is advertised.
        /// A network border group is a unique set of Availability Zones or Local Zones
        /// from where Amazon Web Services advertises public IP addresses.</p>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_border_group = Some(input.into());
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_border_group = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicIpv4Pool`](crate::model::PublicIpv4Pool)
        pub fn build(self) -> crate::model::PublicIpv4Pool {
            crate::model::PublicIpv4Pool {
                pool_id: self.pool_id,
                description: self.description,
                pool_address_ranges: self.pool_address_ranges,
                total_address_count: self.total_address_count,
                total_available_address_count: self.total_available_address_count,
                network_border_group: self.network_border_group,
                tags: self.tags,
            }
        }
    }
}
impl PublicIpv4Pool {
    /// Creates a new builder-style object to manufacture [`PublicIpv4Pool`](crate::model::PublicIpv4Pool)
    pub fn builder() -> crate::model::public_ipv4_pool::Builder {
        crate::model::public_ipv4_pool::Builder::default()
    }
}

/// <p>Describes an address range of an IPv4 address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicIpv4PoolRange {
    /// <p>The first IP address in the range.</p>
    pub first_address: std::option::Option<std::string::String>,
    /// <p>The last IP address in the range.</p>
    pub last_address: std::option::Option<std::string::String>,
    /// <p>The number of addresses in the range.</p>
    pub address_count: std::option::Option<i32>,
    /// <p>The number of available addresses in the range.</p>
    pub available_address_count: std::option::Option<i32>,
}
impl std::fmt::Debug for PublicIpv4PoolRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicIpv4PoolRange");
        formatter.field("first_address", &self.first_address);
        formatter.field("last_address", &self.last_address);
        formatter.field("address_count", &self.address_count);
        formatter.field("available_address_count", &self.available_address_count);
        formatter.finish()
    }
}
/// See [`PublicIpv4PoolRange`](crate::model::PublicIpv4PoolRange)
pub mod public_ipv4_pool_range {
    /// A builder for [`PublicIpv4PoolRange`](crate::model::PublicIpv4PoolRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) first_address: std::option::Option<std::string::String>,
        pub(crate) last_address: std::option::Option<std::string::String>,
        pub(crate) address_count: std::option::Option<i32>,
        pub(crate) available_address_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The first IP address in the range.</p>
        pub fn first_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_address = Some(input.into());
            self
        }
        pub fn set_first_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.first_address = input;
            self
        }
        /// <p>The last IP address in the range.</p>
        pub fn last_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_address = Some(input.into());
            self
        }
        pub fn set_last_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_address = input;
            self
        }
        /// <p>The number of addresses in the range.</p>
        pub fn address_count(mut self, input: i32) -> Self {
            self.address_count = Some(input);
            self
        }
        pub fn set_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.address_count = input;
            self
        }
        /// <p>The number of available addresses in the range.</p>
        pub fn available_address_count(mut self, input: i32) -> Self {
            self.available_address_count = Some(input);
            self
        }
        pub fn set_available_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.available_address_count = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicIpv4PoolRange`](crate::model::PublicIpv4PoolRange)
        pub fn build(self) -> crate::model::PublicIpv4PoolRange {
            crate::model::PublicIpv4PoolRange {
                first_address: self.first_address,
                last_address: self.last_address,
                address_count: self.address_count,
                available_address_count: self.available_address_count,
            }
        }
    }
}
impl PublicIpv4PoolRange {
    /// Creates a new builder-style object to manufacture [`PublicIpv4PoolRange`](crate::model::PublicIpv4PoolRange)
    pub fn builder() -> crate::model::public_ipv4_pool_range::Builder {
        crate::model::public_ipv4_pool_range::Builder::default()
    }
}

/// <p>PrincipalIdFormat description</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrincipalIdFormat {
    /// <p>PrincipalIdFormatARN description</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>PrincipalIdFormatStatuses description</p>
    pub statuses: std::option::Option<std::vec::Vec<crate::model::IdFormat>>,
}
impl std::fmt::Debug for PrincipalIdFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrincipalIdFormat");
        formatter.field("arn", &self.arn);
        formatter.field("statuses", &self.statuses);
        formatter.finish()
    }
}
/// See [`PrincipalIdFormat`](crate::model::PrincipalIdFormat)
pub mod principal_id_format {
    /// A builder for [`PrincipalIdFormat`](crate::model::PrincipalIdFormat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) statuses: std::option::Option<std::vec::Vec<crate::model::IdFormat>>,
    }
    impl Builder {
        /// <p>PrincipalIdFormatARN description</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        pub fn statuses(mut self, input: impl Into<crate::model::IdFormat>) -> Self {
            let mut v = self.statuses.unwrap_or_default();
            v.push(input.into());
            self.statuses = Some(v);
            self
        }
        pub fn set_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IdFormat>>,
        ) -> Self {
            self.statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`PrincipalIdFormat`](crate::model::PrincipalIdFormat)
        pub fn build(self) -> crate::model::PrincipalIdFormat {
            crate::model::PrincipalIdFormat {
                arn: self.arn,
                statuses: self.statuses,
            }
        }
    }
}
impl PrincipalIdFormat {
    /// Creates a new builder-style object to manufacture [`PrincipalIdFormat`](crate::model::PrincipalIdFormat)
    pub fn builder() -> crate::model::principal_id_format::Builder {
        crate::model::principal_id_format::Builder::default()
    }
}

/// <p>Describes the ID format for a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdFormat {
    /// <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
    pub deadline: std::option::Option<smithy_types::Instant>,
    /// <p>The type of resource.</p>
    pub resource: std::option::Option<std::string::String>,
    /// <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
    pub use_long_ids: std::option::Option<bool>,
}
impl std::fmt::Debug for IdFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdFormat");
        formatter.field("deadline", &self.deadline);
        formatter.field("resource", &self.resource);
        formatter.field("use_long_ids", &self.use_long_ids);
        formatter.finish()
    }
}
/// See [`IdFormat`](crate::model::IdFormat)
pub mod id_format {
    /// A builder for [`IdFormat`](crate::model::IdFormat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) deadline: std::option::Option<smithy_types::Instant>,
        pub(crate) resource: std::option::Option<std::string::String>,
        pub(crate) use_long_ids: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
        pub fn deadline(mut self, input: smithy_types::Instant) -> Self {
            self.deadline = Some(input);
            self
        }
        pub fn set_deadline(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.deadline = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource = Some(input.into());
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource = input;
            self
        }
        /// <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
        pub fn use_long_ids(mut self, input: bool) -> Self {
            self.use_long_ids = Some(input);
            self
        }
        pub fn set_use_long_ids(mut self, input: std::option::Option<bool>) -> Self {
            self.use_long_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`IdFormat`](crate::model::IdFormat)
        pub fn build(self) -> crate::model::IdFormat {
            crate::model::IdFormat {
                deadline: self.deadline,
                resource: self.resource,
                use_long_ids: self.use_long_ids,
            }
        }
    }
}
impl IdFormat {
    /// Creates a new builder-style object to manufacture [`IdFormat`](crate::model::IdFormat)
    pub fn builder() -> crate::model::id_format::Builder {
        crate::model::id_format::Builder::default()
    }
}

/// <p>Describes prefixes for Amazon Web Services services.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrefixList {
    /// <p>The IP address range of the Amazon Web Service.</p>
    pub cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the prefix.</p>
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The name of the prefix.</p>
    pub prefix_list_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PrefixList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrefixList");
        formatter.field("cidrs", &self.cidrs);
        formatter.field("prefix_list_id", &self.prefix_list_id);
        formatter.field("prefix_list_name", &self.prefix_list_name);
        formatter.finish()
    }
}
/// See [`PrefixList`](crate::model::PrefixList)
pub mod prefix_list {
    /// A builder for [`PrefixList`](crate::model::PrefixList)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) prefix_list_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn cidrs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cidrs.unwrap_or_default();
            v.push(input.into());
            self.cidrs = Some(v);
            self
        }
        pub fn set_cidrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cidrs = input;
            self
        }
        /// <p>The ID of the prefix.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_id = input;
            self
        }
        /// <p>The name of the prefix.</p>
        pub fn prefix_list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_name = Some(input.into());
            self
        }
        pub fn set_prefix_list_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prefix_list_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PrefixList`](crate::model::PrefixList)
        pub fn build(self) -> crate::model::PrefixList {
            crate::model::PrefixList {
                cidrs: self.cidrs,
                prefix_list_id: self.prefix_list_id,
                prefix_list_name: self.prefix_list_name,
            }
        }
    }
}
impl PrefixList {
    /// Creates a new builder-style object to manufacture [`PrefixList`](crate::model::PrefixList)
    pub fn builder() -> crate::model::prefix_list::Builder {
        crate::model::prefix_list::Builder::default()
    }
}

/// <p>Describes a placement group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlacementGroup {
    /// <p>The name of the placement group.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The state of the placement group.</p>
    pub state: std::option::Option<crate::model::PlacementGroupState>,
    /// <p>The placement strategy.</p>
    pub strategy: std::option::Option<crate::model::PlacementStrategy>,
    /// <p>The number of partitions. Valid only if <b>strategy</b> is
    /// set to <code>partition</code>.</p>
    pub partition_count: std::option::Option<i32>,
    /// <p>The ID of the placement group.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>Any tags applied to the placement group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for PlacementGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlacementGroup");
        formatter.field("group_name", &self.group_name);
        formatter.field("state", &self.state);
        formatter.field("strategy", &self.strategy);
        formatter.field("partition_count", &self.partition_count);
        formatter.field("group_id", &self.group_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`PlacementGroup`](crate::model::PlacementGroup)
pub mod placement_group {
    /// A builder for [`PlacementGroup`](crate::model::PlacementGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::PlacementGroupState>,
        pub(crate) strategy: std::option::Option<crate::model::PlacementStrategy>,
        pub(crate) partition_count: std::option::Option<i32>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the placement group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The state of the placement group.</p>
        pub fn state(mut self, input: crate::model::PlacementGroupState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::PlacementGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The placement strategy.</p>
        pub fn strategy(mut self, input: crate::model::PlacementStrategy) -> Self {
            self.strategy = Some(input);
            self
        }
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::PlacementStrategy>,
        ) -> Self {
            self.strategy = input;
            self
        }
        /// <p>The number of partitions. Valid only if <b>strategy</b> is
        /// set to <code>partition</code>.</p>
        pub fn partition_count(mut self, input: i32) -> Self {
            self.partition_count = Some(input);
            self
        }
        pub fn set_partition_count(mut self, input: std::option::Option<i32>) -> Self {
            self.partition_count = input;
            self
        }
        /// <p>The ID of the placement group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementGroup`](crate::model::PlacementGroup)
        pub fn build(self) -> crate::model::PlacementGroup {
            crate::model::PlacementGroup {
                group_name: self.group_name,
                state: self.state,
                strategy: self.strategy,
                partition_count: self.partition_count,
                group_id: self.group_id,
                tags: self.tags,
            }
        }
    }
}
impl PlacementGroup {
    /// Creates a new builder-style object to manufacture [`PlacementGroup`](crate::model::PlacementGroup)
    pub fn builder() -> crate::model::placement_group::Builder {
        crate::model::placement_group::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlacementStrategy {
    Cluster,
    Partition,
    Spread,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlacementStrategy {
    fn from(s: &str) -> Self {
        match s {
            "cluster" => PlacementStrategy::Cluster,
            "partition" => PlacementStrategy::Partition,
            "spread" => PlacementStrategy::Spread,
            other => PlacementStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlacementStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlacementStrategy::from(s))
    }
}
impl PlacementStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            PlacementStrategy::Cluster => "cluster",
            PlacementStrategy::Partition => "partition",
            PlacementStrategy::Spread => "spread",
            PlacementStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["cluster", "partition", "spread"]
    }
}
impl AsRef<str> for PlacementStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlacementGroupState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlacementGroupState {
    fn from(s: &str) -> Self {
        match s {
            "available" => PlacementGroupState::Available,
            "deleted" => PlacementGroupState::Deleted,
            "deleting" => PlacementGroupState::Deleting,
            "pending" => PlacementGroupState::Pending,
            other => PlacementGroupState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlacementGroupState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlacementGroupState::from(s))
    }
}
impl PlacementGroupState {
    pub fn as_str(&self) -> &str {
        match self {
            PlacementGroupState::Available => "available",
            PlacementGroupState::Deleted => "deleted",
            PlacementGroupState::Deleting => "deleting",
            PlacementGroupState::Pending => "pending",
            PlacementGroupState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for PlacementGroupState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterface {
    /// <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
    pub association: std::option::Option<crate::model::NetworkInterfaceAssociation>,
    /// <p>The network interface attachment.</p>
    pub attachment: std::option::Option<crate::model::NetworkInterfaceAttachment>,
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>A description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Any security groups for the network interface.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>The type of network interface.</p>
    pub interface_type: std::option::Option<crate::model::NetworkInterfaceType>,
    /// <p>The IPv6 addresses associated with the network interface.</p>
    pub ipv6_addresses:
        std::option::Option<std::vec::Vec<crate::model::NetworkInterfaceIpv6Address>>,
    /// <p>The MAC address.</p>
    pub mac_address: std::option::Option<std::string::String>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The private DNS name.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The private IPv4 addresses associated with the network interface.</p>
    pub private_ip_addresses:
        std::option::Option<std::vec::Vec<crate::model::NetworkInterfacePrivateIpAddress>>,
    /// <p>The IPv4 prefixes that are assigned to the network interface.</p>
    pub ipv4_prefixes: std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecification>>,
    /// <p>The IPv6 prefixes that are assigned to the network interface.</p>
    pub ipv6_prefixes: std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecification>>,
    /// <p>The alias or Amazon Web Services account ID of the principal or service that created the network interface.</p>
    pub requester_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network interface is being managed by Amazon Web Services.</p>
    pub requester_managed: std::option::Option<bool>,
    /// <p>Indicates whether source/destination checking is enabled.</p>
    pub source_dest_check: std::option::Option<bool>,
    /// <p>The status of the network interface.</p>
    pub status: std::option::Option<crate::model::NetworkInterfaceStatus>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the network interface.</p>
    pub tag_set: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterface");
        formatter.field("association", &self.association);
        formatter.field("attachment", &self.attachment);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("description", &self.description);
        formatter.field("groups", &self.groups);
        formatter.field("interface_type", &self.interface_type);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("mac_address", &self.mac_address);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field("ipv4_prefixes", &self.ipv4_prefixes);
        formatter.field("ipv6_prefixes", &self.ipv6_prefixes);
        formatter.field("requester_id", &self.requester_id);
        formatter.field("requester_managed", &self.requester_managed);
        formatter.field("source_dest_check", &self.source_dest_check);
        formatter.field("status", &self.status);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("tag_set", &self.tag_set);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface)
pub mod network_interface {
    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association: std::option::Option<crate::model::NetworkInterfaceAssociation>,
        pub(crate) attachment: std::option::Option<crate::model::NetworkInterfaceAttachment>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) interface_type: std::option::Option<crate::model::NetworkInterfaceType>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterfaceIpv6Address>>,
        pub(crate) mac_address: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterfacePrivateIpAddress>>,
        pub(crate) ipv4_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecification>>,
        pub(crate) ipv6_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecification>>,
        pub(crate) requester_id: std::option::Option<std::string::String>,
        pub(crate) requester_managed: std::option::Option<bool>,
        pub(crate) source_dest_check: std::option::Option<bool>,
        pub(crate) status: std::option::Option<crate::model::NetworkInterfaceStatus>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) tag_set: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
        pub fn association(mut self, input: crate::model::NetworkInterfaceAssociation) -> Self {
            self.association = Some(input);
            self
        }
        pub fn set_association(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceAssociation>,
        ) -> Self {
            self.association = input;
            self
        }
        /// <p>The network interface attachment.</p>
        pub fn attachment(mut self, input: crate::model::NetworkInterfaceAttachment) -> Self {
            self.attachment = Some(input);
            self
        }
        pub fn set_attachment(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceAttachment>,
        ) -> Self {
            self.attachment = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>A description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The type of network interface.</p>
        pub fn interface_type(mut self, input: crate::model::NetworkInterfaceType) -> Self {
            self.interface_type = Some(input);
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceType>,
        ) -> Self {
            self.interface_type = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::NetworkInterfaceIpv6Address>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterfaceIpv6Address>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The MAC address.</p>
        pub fn mac_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_address = Some(input.into());
            self
        }
        pub fn set_mac_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_address = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the network interface.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The private DNS name.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_addresses(
            mut self,
            input: impl Into<crate::model::NetworkInterfacePrivateIpAddress>,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.private_ip_addresses = Some(v);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::NetworkInterfacePrivateIpAddress>,
            >,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        pub fn ipv4_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv4PrefixSpecification>,
        ) -> Self {
            let mut v = self.ipv4_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv4_prefixes = Some(v);
            self
        }
        pub fn set_ipv4_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecification>>,
        ) -> Self {
            self.ipv4_prefixes = input;
            self
        }
        pub fn ipv6_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv6PrefixSpecification>,
        ) -> Self {
            let mut v = self.ipv6_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv6_prefixes = Some(v);
            self
        }
        pub fn set_ipv6_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecification>>,
        ) -> Self {
            self.ipv6_prefixes = input;
            self
        }
        /// <p>The alias or Amazon Web Services account ID of the principal or service that created the network interface.</p>
        pub fn requester_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_id = Some(input.into());
            self
        }
        pub fn set_requester_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.requester_id = input;
            self
        }
        /// <p>Indicates whether the network interface is being managed by Amazon Web Services.</p>
        pub fn requester_managed(mut self, input: bool) -> Self {
            self.requester_managed = Some(input);
            self
        }
        pub fn set_requester_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.requester_managed = input;
            self
        }
        /// <p>Indicates whether source/destination checking is enabled.</p>
        pub fn source_dest_check(mut self, input: bool) -> Self {
            self.source_dest_check = Some(input);
            self
        }
        pub fn set_source_dest_check(mut self, input: std::option::Option<bool>) -> Self {
            self.source_dest_check = input;
            self
        }
        /// <p>The status of the network interface.</p>
        pub fn status(mut self, input: crate::model::NetworkInterfaceStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        pub fn tag_set(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tag_set.unwrap_or_default();
            v.push(input.into());
            self.tag_set = Some(v);
            self
        }
        pub fn set_tag_set(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tag_set = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface)
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                association: self.association,
                attachment: self.attachment,
                availability_zone: self.availability_zone,
                description: self.description,
                groups: self.groups,
                interface_type: self.interface_type,
                ipv6_addresses: self.ipv6_addresses,
                mac_address: self.mac_address,
                network_interface_id: self.network_interface_id,
                outpost_arn: self.outpost_arn,
                owner_id: self.owner_id,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                ipv4_prefixes: self.ipv4_prefixes,
                ipv6_prefixes: self.ipv6_prefixes,
                requester_id: self.requester_id,
                requester_managed: self.requester_managed,
                source_dest_check: self.source_dest_check,
                status: self.status,
                subnet_id: self.subnet_id,
                tag_set: self.tag_set,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface)
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>Describes the IPv6 prefix.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6PrefixSpecification {
    /// <p>The IPv6 prefix.</p>
    pub ipv6_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv6PrefixSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6PrefixSpecification");
        formatter.field("ipv6_prefix", &self.ipv6_prefix);
        formatter.finish()
    }
}
/// See [`Ipv6PrefixSpecification`](crate::model::Ipv6PrefixSpecification)
pub mod ipv6_prefix_specification {
    /// A builder for [`Ipv6PrefixSpecification`](crate::model::Ipv6PrefixSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 prefix.</p>
        pub fn ipv6_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_prefix = Some(input.into());
            self
        }
        pub fn set_ipv6_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6PrefixSpecification`](crate::model::Ipv6PrefixSpecification)
        pub fn build(self) -> crate::model::Ipv6PrefixSpecification {
            crate::model::Ipv6PrefixSpecification {
                ipv6_prefix: self.ipv6_prefix,
            }
        }
    }
}
impl Ipv6PrefixSpecification {
    /// Creates a new builder-style object to manufacture [`Ipv6PrefixSpecification`](crate::model::Ipv6PrefixSpecification)
    pub fn builder() -> crate::model::ipv6_prefix_specification::Builder {
        crate::model::ipv6_prefix_specification::Builder::default()
    }
}

/// <p>Describes an IPv4 prefix.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv4PrefixSpecification {
    /// <p>The IPv4 prefix. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html">
    /// Assigning prefixes to Amazon EC2 network interfaces</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub ipv4_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ipv4PrefixSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv4PrefixSpecification");
        formatter.field("ipv4_prefix", &self.ipv4_prefix);
        formatter.finish()
    }
}
/// See [`Ipv4PrefixSpecification`](crate::model::Ipv4PrefixSpecification)
pub mod ipv4_prefix_specification {
    /// A builder for [`Ipv4PrefixSpecification`](crate::model::Ipv4PrefixSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv4_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv4 prefix. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html">
        /// Assigning prefixes to Amazon EC2 network interfaces</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn ipv4_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv4_prefix = Some(input.into());
            self
        }
        pub fn set_ipv4_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv4_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv4PrefixSpecification`](crate::model::Ipv4PrefixSpecification)
        pub fn build(self) -> crate::model::Ipv4PrefixSpecification {
            crate::model::Ipv4PrefixSpecification {
                ipv4_prefix: self.ipv4_prefix,
            }
        }
    }
}
impl Ipv4PrefixSpecification {
    /// Creates a new builder-style object to manufacture [`Ipv4PrefixSpecification`](crate::model::Ipv4PrefixSpecification)
    pub fn builder() -> crate::model::ipv4_prefix_specification::Builder {
        crate::model::ipv4_prefix_specification::Builder::default()
    }
}

/// <p>Describes the private IPv4 address of a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfacePrivateIpAddress {
    /// <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
    pub association: std::option::Option<crate::model::NetworkInterfaceAssociation>,
    /// <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
    pub primary: std::option::Option<bool>,
    /// <p>The private DNS name.</p>
    pub private_dns_name: std::option::Option<std::string::String>,
    /// <p>The private IPv4 address.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterfacePrivateIpAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfacePrivateIpAddress");
        formatter.field("association", &self.association);
        formatter.field("primary", &self.primary);
        formatter.field("private_dns_name", &self.private_dns_name);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`NetworkInterfacePrivateIpAddress`](crate::model::NetworkInterfacePrivateIpAddress)
pub mod network_interface_private_ip_address {
    /// A builder for [`NetworkInterfacePrivateIpAddress`](crate::model::NetworkInterfacePrivateIpAddress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association: std::option::Option<crate::model::NetworkInterfaceAssociation>,
        pub(crate) primary: std::option::Option<bool>,
        pub(crate) private_dns_name: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
        pub fn association(mut self, input: crate::model::NetworkInterfaceAssociation) -> Self {
            self.association = Some(input);
            self
        }
        pub fn set_association(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceAssociation>,
        ) -> Self {
            self.association = input;
            self
        }
        /// <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
        pub fn primary(mut self, input: bool) -> Self {
            self.primary = Some(input);
            self
        }
        pub fn set_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.primary = input;
            self
        }
        /// <p>The private DNS name.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_dns_name = Some(input.into());
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_dns_name = input;
            self
        }
        /// <p>The private IPv4 address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfacePrivateIpAddress`](crate::model::NetworkInterfacePrivateIpAddress)
        pub fn build(self) -> crate::model::NetworkInterfacePrivateIpAddress {
            crate::model::NetworkInterfacePrivateIpAddress {
                association: self.association,
                primary: self.primary,
                private_dns_name: self.private_dns_name,
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl NetworkInterfacePrivateIpAddress {
    /// Creates a new builder-style object to manufacture [`NetworkInterfacePrivateIpAddress`](crate::model::NetworkInterfacePrivateIpAddress)
    pub fn builder() -> crate::model::network_interface_private_ip_address::Builder {
        crate::model::network_interface_private_ip_address::Builder::default()
    }
}

/// <p>Describes association information for an Elastic IP address (IPv4 only), or a Carrier
/// IP address (for a network interface which resides in a subnet in a Wavelength
/// Zone).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfaceAssociation {
    /// <p>The allocation ID.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The association ID.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Elastic IP address owner.</p>
    pub ip_owner_id: std::option::Option<std::string::String>,
    /// <p>The public DNS name.</p>
    pub public_dns_name: std::option::Option<std::string::String>,
    /// <p>The address of the Elastic IP address bound to the network
    /// interface.</p>
    pub public_ip: std::option::Option<std::string::String>,
    /// <p>The customer-owned IP address associated with the network interface.</p>
    pub customer_owned_ip: std::option::Option<std::string::String>,
    /// <p>The carrier IP address associated with the network interface.</p>
    /// <p>This option is only available when the network interface is in a subnet which is associated with a Wavelength Zone.</p>
    pub carrier_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterfaceAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfaceAssociation");
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("ip_owner_id", &self.ip_owner_id);
        formatter.field("public_dns_name", &self.public_dns_name);
        formatter.field("public_ip", &self.public_ip);
        formatter.field("customer_owned_ip", &self.customer_owned_ip);
        formatter.field("carrier_ip", &self.carrier_ip);
        formatter.finish()
    }
}
/// See [`NetworkInterfaceAssociation`](crate::model::NetworkInterfaceAssociation)
pub mod network_interface_association {
    /// A builder for [`NetworkInterfaceAssociation`](crate::model::NetworkInterfaceAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) ip_owner_id: std::option::Option<std::string::String>,
        pub(crate) public_dns_name: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
        pub(crate) customer_owned_ip: std::option::Option<std::string::String>,
        pub(crate) carrier_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The allocation ID.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The ID of the Elastic IP address owner.</p>
        pub fn ip_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_owner_id = Some(input.into());
            self
        }
        pub fn set_ip_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_owner_id = input;
            self
        }
        /// <p>The public DNS name.</p>
        pub fn public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_dns_name = Some(input.into());
            self
        }
        pub fn set_public_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_dns_name = input;
            self
        }
        /// <p>The address of the Elastic IP address bound to the network
        /// interface.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// <p>The customer-owned IP address associated with the network interface.</p>
        pub fn customer_owned_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_owned_ip = Some(input.into());
            self
        }
        pub fn set_customer_owned_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_owned_ip = input;
            self
        }
        /// <p>The carrier IP address associated with the network interface.</p>
        /// <p>This option is only available when the network interface is in a subnet which is associated with a Wavelength Zone.</p>
        pub fn carrier_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier_ip = Some(input.into());
            self
        }
        pub fn set_carrier_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.carrier_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfaceAssociation`](crate::model::NetworkInterfaceAssociation)
        pub fn build(self) -> crate::model::NetworkInterfaceAssociation {
            crate::model::NetworkInterfaceAssociation {
                allocation_id: self.allocation_id,
                association_id: self.association_id,
                ip_owner_id: self.ip_owner_id,
                public_dns_name: self.public_dns_name,
                public_ip: self.public_ip,
                customer_owned_ip: self.customer_owned_ip,
                carrier_ip: self.carrier_ip,
            }
        }
    }
}
impl NetworkInterfaceAssociation {
    /// Creates a new builder-style object to manufacture [`NetworkInterfaceAssociation`](crate::model::NetworkInterfaceAssociation)
    pub fn builder() -> crate::model::network_interface_association::Builder {
        crate::model::network_interface_association::Builder::default()
    }
}

/// <p>Describes an IPv6 address associated with a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfaceIpv6Address {
    /// <p>The IPv6 address.</p>
    pub ipv6_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterfaceIpv6Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfaceIpv6Address");
        formatter.field("ipv6_address", &self.ipv6_address);
        formatter.finish()
    }
}
/// See [`NetworkInterfaceIpv6Address`](crate::model::NetworkInterfaceIpv6Address)
pub mod network_interface_ipv6_address {
    /// A builder for [`NetworkInterfaceIpv6Address`](crate::model::NetworkInterfaceIpv6Address)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 address.</p>
        pub fn ipv6_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_address = Some(input.into());
            self
        }
        pub fn set_ipv6_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_address = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfaceIpv6Address`](crate::model::NetworkInterfaceIpv6Address)
        pub fn build(self) -> crate::model::NetworkInterfaceIpv6Address {
            crate::model::NetworkInterfaceIpv6Address {
                ipv6_address: self.ipv6_address,
            }
        }
    }
}
impl NetworkInterfaceIpv6Address {
    /// Creates a new builder-style object to manufacture [`NetworkInterfaceIpv6Address`](crate::model::NetworkInterfaceIpv6Address)
    pub fn builder() -> crate::model::network_interface_ipv6_address::Builder {
        crate::model::network_interface_ipv6_address::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceType {
    Efa,
    Interface,
    NatGateway,
    Trunk,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkInterfaceType {
    fn from(s: &str) -> Self {
        match s {
            "efa" => NetworkInterfaceType::Efa,
            "interface" => NetworkInterfaceType::Interface,
            "natGateway" => NetworkInterfaceType::NatGateway,
            "trunk" => NetworkInterfaceType::Trunk,
            other => NetworkInterfaceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkInterfaceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceType::from(s))
    }
}
impl NetworkInterfaceType {
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceType::Efa => "efa",
            NetworkInterfaceType::Interface => "interface",
            NetworkInterfaceType::NatGateway => "natGateway",
            NetworkInterfaceType::Trunk => "trunk",
            NetworkInterfaceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["efa", "interface", "natGateway", "trunk"]
    }
}
impl AsRef<str> for NetworkInterfaceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network interface attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfaceAttachment {
    /// <p>The timestamp indicating when the attachment initiated.</p>
    pub attach_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the network interface attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The device index of the network interface attachment on the instance.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The index of the network card.</p>
    pub network_card_index: std::option::Option<i32>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
    pub instance_owner_id: std::option::Option<std::string::String>,
    /// <p>The attachment state.</p>
    pub status: std::option::Option<crate::model::AttachmentStatus>,
}
impl std::fmt::Debug for NetworkInterfaceAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfaceAttachment");
        formatter.field("attach_time", &self.attach_time);
        formatter.field("attachment_id", &self.attachment_id);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("device_index", &self.device_index);
        formatter.field("network_card_index", &self.network_card_index);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_owner_id", &self.instance_owner_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`NetworkInterfaceAttachment`](crate::model::NetworkInterfaceAttachment)
pub mod network_interface_attachment {
    /// A builder for [`NetworkInterfaceAttachment`](crate::model::NetworkInterfaceAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attach_time: std::option::Option<smithy_types::Instant>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) network_card_index: std::option::Option<i32>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_owner_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AttachmentStatus>,
    }
    impl Builder {
        /// <p>The timestamp indicating when the attachment initiated.</p>
        pub fn attach_time(mut self, input: smithy_types::Instant) -> Self {
            self.attach_time = Some(input);
            self
        }
        pub fn set_attach_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.attach_time = input;
            self
        }
        /// <p>The ID of the network interface attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The device index of the network interface attachment on the instance.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        /// <p>The index of the network card.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the instance.</p>
        pub fn instance_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_owner_id = Some(input.into());
            self
        }
        pub fn set_instance_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_owner_id = input;
            self
        }
        /// <p>The attachment state.</p>
        pub fn status(mut self, input: crate::model::AttachmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AttachmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfaceAttachment`](crate::model::NetworkInterfaceAttachment)
        pub fn build(self) -> crate::model::NetworkInterfaceAttachment {
            crate::model::NetworkInterfaceAttachment {
                attach_time: self.attach_time,
                attachment_id: self.attachment_id,
                delete_on_termination: self.delete_on_termination,
                device_index: self.device_index,
                network_card_index: self.network_card_index,
                instance_id: self.instance_id,
                instance_owner_id: self.instance_owner_id,
                status: self.status,
            }
        }
    }
}
impl NetworkInterfaceAttachment {
    /// Creates a new builder-style object to manufacture [`NetworkInterfaceAttachment`](crate::model::NetworkInterfaceAttachment)
    pub fn builder() -> crate::model::network_interface_attachment::Builder {
        crate::model::network_interface_attachment::Builder::default()
    }
}

/// <p>Describes a permission for a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfacePermission {
    /// <p>The ID of the network interface permission.</p>
    pub network_interface_permission_id: std::option::Option<std::string::String>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    pub aws_account_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Service.</p>
    pub aws_service: std::option::Option<std::string::String>,
    /// <p>The type of permission.</p>
    pub permission: std::option::Option<crate::model::InterfacePermissionType>,
    /// <p>Information about the state of the permission.</p>
    pub permission_state: std::option::Option<crate::model::NetworkInterfacePermissionState>,
}
impl std::fmt::Debug for NetworkInterfacePermission {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfacePermission");
        formatter.field(
            "network_interface_permission_id",
            &self.network_interface_permission_id,
        );
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("aws_account_id", &self.aws_account_id);
        formatter.field("aws_service", &self.aws_service);
        formatter.field("permission", &self.permission);
        formatter.field("permission_state", &self.permission_state);
        formatter.finish()
    }
}
/// See [`NetworkInterfacePermission`](crate::model::NetworkInterfacePermission)
pub mod network_interface_permission {
    /// A builder for [`NetworkInterfacePermission`](crate::model::NetworkInterfacePermission)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_permission_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
        pub(crate) aws_service: std::option::Option<std::string::String>,
        pub(crate) permission: std::option::Option<crate::model::InterfacePermissionType>,
        pub(crate) permission_state:
            std::option::Option<crate::model::NetworkInterfacePermissionState>,
    }
    impl Builder {
        /// <p>The ID of the network interface permission.</p>
        pub fn network_interface_permission_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_interface_permission_id = Some(input.into());
            self
        }
        pub fn set_network_interface_permission_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_permission_id = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// <p>The Amazon Web Service.</p>
        pub fn aws_service(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_service = Some(input.into());
            self
        }
        pub fn set_aws_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_service = input;
            self
        }
        /// <p>The type of permission.</p>
        pub fn permission(mut self, input: crate::model::InterfacePermissionType) -> Self {
            self.permission = Some(input);
            self
        }
        pub fn set_permission(
            mut self,
            input: std::option::Option<crate::model::InterfacePermissionType>,
        ) -> Self {
            self.permission = input;
            self
        }
        /// <p>Information about the state of the permission.</p>
        pub fn permission_state(
            mut self,
            input: crate::model::NetworkInterfacePermissionState,
        ) -> Self {
            self.permission_state = Some(input);
            self
        }
        pub fn set_permission_state(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfacePermissionState>,
        ) -> Self {
            self.permission_state = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfacePermission`](crate::model::NetworkInterfacePermission)
        pub fn build(self) -> crate::model::NetworkInterfacePermission {
            crate::model::NetworkInterfacePermission {
                network_interface_permission_id: self.network_interface_permission_id,
                network_interface_id: self.network_interface_id,
                aws_account_id: self.aws_account_id,
                aws_service: self.aws_service,
                permission: self.permission,
                permission_state: self.permission_state,
            }
        }
    }
}
impl NetworkInterfacePermission {
    /// Creates a new builder-style object to manufacture [`NetworkInterfacePermission`](crate::model::NetworkInterfacePermission)
    pub fn builder() -> crate::model::network_interface_permission::Builder {
        crate::model::network_interface_permission::Builder::default()
    }
}

/// <p>Describes the state of a network interface permission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterfacePermissionState {
    /// <p>The state of the permission.</p>
    pub state: std::option::Option<crate::model::NetworkInterfacePermissionStateCode>,
    /// <p>A status message, if applicable.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterfacePermissionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterfacePermissionState");
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`NetworkInterfacePermissionState`](crate::model::NetworkInterfacePermissionState)
pub mod network_interface_permission_state {
    /// A builder for [`NetworkInterfacePermissionState`](crate::model::NetworkInterfacePermissionState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::NetworkInterfacePermissionStateCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the permission.</p>
        pub fn state(mut self, input: crate::model::NetworkInterfacePermissionStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfacePermissionStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>A status message, if applicable.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterfacePermissionState`](crate::model::NetworkInterfacePermissionState)
        pub fn build(self) -> crate::model::NetworkInterfacePermissionState {
            crate::model::NetworkInterfacePermissionState {
                state: self.state,
                status_message: self.status_message,
            }
        }
    }
}
impl NetworkInterfacePermissionState {
    /// Creates a new builder-style object to manufacture [`NetworkInterfacePermissionState`](crate::model::NetworkInterfacePermissionState)
    pub fn builder() -> crate::model::network_interface_permission_state::Builder {
        crate::model::network_interface_permission_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfacePermissionStateCode {
    Granted,
    Pending,
    Revoked,
    Revoking,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkInterfacePermissionStateCode {
    fn from(s: &str) -> Self {
        match s {
            "granted" => NetworkInterfacePermissionStateCode::Granted,
            "pending" => NetworkInterfacePermissionStateCode::Pending,
            "revoked" => NetworkInterfacePermissionStateCode::Revoked,
            "revoking" => NetworkInterfacePermissionStateCode::Revoking,
            other => NetworkInterfacePermissionStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkInterfacePermissionStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfacePermissionStateCode::from(s))
    }
}
impl NetworkInterfacePermissionStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfacePermissionStateCode::Granted => "granted",
            NetworkInterfacePermissionStateCode::Pending => "pending",
            NetworkInterfacePermissionStateCode::Revoked => "revoked",
            NetworkInterfacePermissionStateCode::Revoking => "revoking",
            NetworkInterfacePermissionStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["granted", "pending", "revoked", "revoking"]
    }
}
impl AsRef<str> for NetworkInterfacePermissionStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InterfacePermissionType {
    EipAssociate,
    InstanceAttach,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InterfacePermissionType {
    fn from(s: &str) -> Self {
        match s {
            "EIP-ASSOCIATE" => InterfacePermissionType::EipAssociate,
            "INSTANCE-ATTACH" => InterfacePermissionType::InstanceAttach,
            other => InterfacePermissionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InterfacePermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InterfacePermissionType::from(s))
    }
}
impl InterfacePermissionType {
    pub fn as_str(&self) -> &str {
        match self {
            InterfacePermissionType::EipAssociate => "EIP-ASSOCIATE",
            InterfacePermissionType::InstanceAttach => "INSTANCE-ATTACH",
            InterfacePermissionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EIP-ASSOCIATE", "INSTANCE-ATTACH"]
    }
}
impl AsRef<str> for InterfacePermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceAttribute {
    Attachment,
    Description,
    GroupSet,
    SourceDestCheck,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkInterfaceAttribute {
    fn from(s: &str) -> Self {
        match s {
            "attachment" => NetworkInterfaceAttribute::Attachment,
            "description" => NetworkInterfaceAttribute::Description,
            "groupSet" => NetworkInterfaceAttribute::GroupSet,
            "sourceDestCheck" => NetworkInterfaceAttribute::SourceDestCheck,
            other => NetworkInterfaceAttribute::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkInterfaceAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceAttribute::from(s))
    }
}
impl NetworkInterfaceAttribute {
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceAttribute::Attachment => "attachment",
            NetworkInterfaceAttribute::Description => "description",
            NetworkInterfaceAttribute::GroupSet => "groupSet",
            NetworkInterfaceAttribute::SourceDestCheck => "sourceDestCheck",
            NetworkInterfaceAttribute::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["attachment", "description", "groupSet", "sourceDestCheck"]
    }
}
impl AsRef<str> for NetworkInterfaceAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a path.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInsightsPath {
    /// <p>The ID of the path.</p>
    pub network_insights_path_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the path.</p>
    pub network_insights_path_arn: std::option::Option<std::string::String>,
    /// <p>The time stamp when the path was created.</p>
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Web Services resource that is the source of the path.</p>
    pub source: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services resource that is the destination of the path.</p>
    pub destination: std::option::Option<std::string::String>,
    /// <p>The IP address of the Amazon Web Services resource that is the source of the path.</p>
    pub source_ip: std::option::Option<std::string::String>,
    /// <p>The IP address of the Amazon Web Services resource that is the destination of the path.</p>
    pub destination_ip: std::option::Option<std::string::String>,
    /// <p>The protocol.</p>
    pub protocol: std::option::Option<crate::model::Protocol>,
    /// <p>The destination port.</p>
    pub destination_port: std::option::Option<i32>,
    /// <p>The tags associated with the path.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for NetworkInsightsPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInsightsPath");
        formatter.field("network_insights_path_id", &self.network_insights_path_id);
        formatter.field("network_insights_path_arn", &self.network_insights_path_arn);
        formatter.field("created_date", &self.created_date);
        formatter.field("source", &self.source);
        formatter.field("destination", &self.destination);
        formatter.field("source_ip", &self.source_ip);
        formatter.field("destination_ip", &self.destination_ip);
        formatter.field("protocol", &self.protocol);
        formatter.field("destination_port", &self.destination_port);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`NetworkInsightsPath`](crate::model::NetworkInsightsPath)
pub mod network_insights_path {
    /// A builder for [`NetworkInsightsPath`](crate::model::NetworkInsightsPath)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_insights_path_id: std::option::Option<std::string::String>,
        pub(crate) network_insights_path_arn: std::option::Option<std::string::String>,
        pub(crate) created_date: std::option::Option<smithy_types::Instant>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) source_ip: std::option::Option<std::string::String>,
        pub(crate) destination_ip: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<crate::model::Protocol>,
        pub(crate) destination_port: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the path.</p>
        pub fn network_insights_path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_insights_path_id = Some(input.into());
            self
        }
        pub fn set_network_insights_path_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_insights_path_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the path.</p>
        pub fn network_insights_path_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_insights_path_arn = Some(input.into());
            self
        }
        pub fn set_network_insights_path_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_insights_path_arn = input;
            self
        }
        /// <p>The time stamp when the path was created.</p>
        pub fn created_date(mut self, input: smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        pub fn set_created_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The Amazon Web Services resource that is the source of the path.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The Amazon Web Services resource that is the destination of the path.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>The IP address of the Amazon Web Services resource that is the source of the path.</p>
        pub fn source_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_ip = Some(input.into());
            self
        }
        pub fn set_source_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_ip = input;
            self
        }
        /// <p>The IP address of the Amazon Web Services resource that is the destination of the path.</p>
        pub fn destination_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_ip = Some(input.into());
            self
        }
        pub fn set_destination_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_ip = input;
            self
        }
        /// <p>The protocol.</p>
        pub fn protocol(mut self, input: crate::model::Protocol) -> Self {
            self.protocol = Some(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::Protocol>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The destination port.</p>
        pub fn destination_port(mut self, input: i32) -> Self {
            self.destination_port = Some(input);
            self
        }
        pub fn set_destination_port(mut self, input: std::option::Option<i32>) -> Self {
            self.destination_port = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInsightsPath`](crate::model::NetworkInsightsPath)
        pub fn build(self) -> crate::model::NetworkInsightsPath {
            crate::model::NetworkInsightsPath {
                network_insights_path_id: self.network_insights_path_id,
                network_insights_path_arn: self.network_insights_path_arn,
                created_date: self.created_date,
                source: self.source,
                destination: self.destination,
                source_ip: self.source_ip,
                destination_ip: self.destination_ip,
                protocol: self.protocol,
                destination_port: self.destination_port,
                tags: self.tags,
            }
        }
    }
}
impl NetworkInsightsPath {
    /// Creates a new builder-style object to manufacture [`NetworkInsightsPath`](crate::model::NetworkInsightsPath)
    pub fn builder() -> crate::model::network_insights_path::Builder {
        crate::model::network_insights_path::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Protocol {
    Tcp,
    Udp,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Protocol {
    fn from(s: &str) -> Self {
        match s {
            "tcp" => Protocol::Tcp,
            "udp" => Protocol::Udp,
            other => Protocol::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Protocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Protocol::from(s))
    }
}
impl Protocol {
    pub fn as_str(&self) -> &str {
        match self {
            Protocol::Tcp => "tcp",
            Protocol::Udp => "udp",
            Protocol::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["tcp", "udp"]
    }
}
impl AsRef<str> for Protocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network ACL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkAcl {
    /// <p>Any associations between the network ACL and one or more subnets</p>
    pub associations: std::option::Option<std::vec::Vec<crate::model::NetworkAclAssociation>>,
    /// <p>One or more entries (rules) in the network ACL.</p>
    pub entries: std::option::Option<std::vec::Vec<crate::model::NetworkAclEntry>>,
    /// <p>Indicates whether this is the default network ACL for the VPC.</p>
    pub is_default: std::option::Option<bool>,
    /// <p>The ID of the network ACL.</p>
    pub network_acl_id: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the network ACL.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC for the network ACL.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the network ACL.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkAcl");
        formatter.field("associations", &self.associations);
        formatter.field("entries", &self.entries);
        formatter.field("is_default", &self.is_default);
        formatter.field("network_acl_id", &self.network_acl_id);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`NetworkAcl`](crate::model::NetworkAcl)
pub mod network_acl {
    /// A builder for [`NetworkAcl`](crate::model::NetworkAcl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associations:
            std::option::Option<std::vec::Vec<crate::model::NetworkAclAssociation>>,
        pub(crate) entries: std::option::Option<std::vec::Vec<crate::model::NetworkAclEntry>>,
        pub(crate) is_default: std::option::Option<bool>,
        pub(crate) network_acl_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn associations(
            mut self,
            input: impl Into<crate::model::NetworkAclAssociation>,
        ) -> Self {
            let mut v = self.associations.unwrap_or_default();
            v.push(input.into());
            self.associations = Some(v);
            self
        }
        pub fn set_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkAclAssociation>>,
        ) -> Self {
            self.associations = input;
            self
        }
        pub fn entries(mut self, input: impl Into<crate::model::NetworkAclEntry>) -> Self {
            let mut v = self.entries.unwrap_or_default();
            v.push(input.into());
            self.entries = Some(v);
            self
        }
        pub fn set_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkAclEntry>>,
        ) -> Self {
            self.entries = input;
            self
        }
        /// <p>Indicates whether this is the default network ACL for the VPC.</p>
        pub fn is_default(mut self, input: bool) -> Self {
            self.is_default = Some(input);
            self
        }
        pub fn set_is_default(mut self, input: std::option::Option<bool>) -> Self {
            self.is_default = input;
            self
        }
        /// <p>The ID of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_id = Some(input.into());
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the VPC for the network ACL.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the network ACL.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkAcl`](crate::model::NetworkAcl)
        pub fn build(self) -> crate::model::NetworkAcl {
            crate::model::NetworkAcl {
                associations: self.associations,
                entries: self.entries,
                is_default: self.is_default,
                network_acl_id: self.network_acl_id,
                tags: self.tags,
                vpc_id: self.vpc_id,
                owner_id: self.owner_id,
            }
        }
    }
}
impl NetworkAcl {
    /// Creates a new builder-style object to manufacture [`NetworkAcl`](crate::model::NetworkAcl)
    pub fn builder() -> crate::model::network_acl::Builder {
        crate::model::network_acl::Builder::default()
    }
}

/// <p>Describes an entry in a network ACL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkAclEntry {
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub cidr_block: std::option::Option<std::string::String>,
    /// <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
    pub egress: std::option::Option<bool>,
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub icmp_type_code: std::option::Option<crate::model::IcmpTypeCode>,
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub ipv6_cidr_block: std::option::Option<std::string::String>,
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub port_range: std::option::Option<crate::model::PortRange>,
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    pub protocol: std::option::Option<std::string::String>,
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    pub rule_action: std::option::Option<crate::model::RuleAction>,
    /// <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
    pub rule_number: std::option::Option<i32>,
}
impl std::fmt::Debug for NetworkAclEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkAclEntry");
        formatter.field("cidr_block", &self.cidr_block);
        formatter.field("egress", &self.egress);
        formatter.field("icmp_type_code", &self.icmp_type_code);
        formatter.field("ipv6_cidr_block", &self.ipv6_cidr_block);
        formatter.field("port_range", &self.port_range);
        formatter.field("protocol", &self.protocol);
        formatter.field("rule_action", &self.rule_action);
        formatter.field("rule_number", &self.rule_number);
        formatter.finish()
    }
}
/// See [`NetworkAclEntry`](crate::model::NetworkAclEntry)
pub mod network_acl_entry {
    /// A builder for [`NetworkAclEntry`](crate::model::NetworkAclEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr_block: std::option::Option<std::string::String>,
        pub(crate) egress: std::option::Option<bool>,
        pub(crate) icmp_type_code: std::option::Option<crate::model::IcmpTypeCode>,
        pub(crate) ipv6_cidr_block: std::option::Option<std::string::String>,
        pub(crate) port_range: std::option::Option<crate::model::PortRange>,
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) rule_action: std::option::Option<crate::model::RuleAction>,
        pub(crate) rule_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr_block = Some(input.into());
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr_block = input;
            self
        }
        /// <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.egress = Some(input);
            self
        }
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.egress = input;
            self
        }
        /// <p>ICMP protocol: The ICMP type and code.</p>
        pub fn icmp_type_code(mut self, input: crate::model::IcmpTypeCode) -> Self {
            self.icmp_type_code = Some(input);
            self
        }
        pub fn set_icmp_type_code(
            mut self,
            input: std::option::Option<crate::model::IcmpTypeCode>,
        ) -> Self {
            self.icmp_type_code = input;
            self
        }
        /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_cidr_block = Some(input.into());
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ipv6_cidr_block = input;
            self
        }
        /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
        pub fn port_range(mut self, input: crate::model::PortRange) -> Self {
            self.port_range = Some(input);
            self
        }
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.port_range = input;
            self
        }
        /// <p>The protocol number. A value of "-1" means all protocols.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
        pub fn rule_action(mut self, input: crate::model::RuleAction) -> Self {
            self.rule_action = Some(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::RuleAction>,
        ) -> Self {
            self.rule_action = input;
            self
        }
        /// <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.rule_number = Some(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.rule_number = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkAclEntry`](crate::model::NetworkAclEntry)
        pub fn build(self) -> crate::model::NetworkAclEntry {
            crate::model::NetworkAclEntry {
                cidr_block: self.cidr_block,
                egress: self.egress,
                icmp_type_code: self.icmp_type_code,
                ipv6_cidr_block: self.ipv6_cidr_block,
                port_range: self.port_range,
                protocol: self.protocol,
                rule_action: self.rule_action,
                rule_number: self.rule_number,
            }
        }
    }
}
impl NetworkAclEntry {
    /// Creates a new builder-style object to manufacture [`NetworkAclEntry`](crate::model::NetworkAclEntry)
    pub fn builder() -> crate::model::network_acl_entry::Builder {
        crate::model::network_acl_entry::Builder::default()
    }
}

/// <p>Describes an association between a network ACL and a subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkAclAssociation {
    /// <p>The ID of the association between a network ACL and a subnet.</p>
    pub network_acl_association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the network ACL.</p>
    pub network_acl_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet.</p>
    pub subnet_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkAclAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkAclAssociation");
        formatter.field(
            "network_acl_association_id",
            &self.network_acl_association_id,
        );
        formatter.field("network_acl_id", &self.network_acl_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.finish()
    }
}
/// See [`NetworkAclAssociation`](crate::model::NetworkAclAssociation)
pub mod network_acl_association {
    /// A builder for [`NetworkAclAssociation`](crate::model::NetworkAclAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_acl_association_id: std::option::Option<std::string::String>,
        pub(crate) network_acl_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the association between a network ACL and a subnet.</p>
        pub fn network_acl_association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_association_id = Some(input.into());
            self
        }
        pub fn set_network_acl_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_association_id = input;
            self
        }
        /// <p>The ID of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_acl_id = Some(input.into());
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_acl_id = input;
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkAclAssociation`](crate::model::NetworkAclAssociation)
        pub fn build(self) -> crate::model::NetworkAclAssociation {
            crate::model::NetworkAclAssociation {
                network_acl_association_id: self.network_acl_association_id,
                network_acl_id: self.network_acl_id,
                subnet_id: self.subnet_id,
            }
        }
    }
}
impl NetworkAclAssociation {
    /// Creates a new builder-style object to manufacture [`NetworkAclAssociation`](crate::model::NetworkAclAssociation)
    pub fn builder() -> crate::model::network_acl_association::Builder {
        crate::model::network_acl_association::Builder::default()
    }
}

/// <p>Describes a NAT gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NatGateway {
    /// <p>The date and time the NAT gateway was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time the NAT gateway was deleted, if applicable.</p>
    pub delete_time: std::option::Option<smithy_types::Instant>,
    /// <p>If the NAT gateway could not be created, specifies the error code for the failure.
    /// (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> |
    /// <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> |
    /// <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
    pub failure_code: std::option::Option<std::string::String>,
    /// <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p>
    /// <ul>
    /// <li>
    /// <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p>
    /// </li>
    /// <li>
    /// <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p>
    /// </li>
    /// <li>
    /// <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p>
    /// </li>
    /// <li>
    /// <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p>
    /// </li>
    /// <li>
    /// <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p>
    /// </li>
    /// <li>
    /// <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p>
    /// </li>
    /// </ul>
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>Information about the IP addresses and network interface associated with the NAT gateway.</p>
    pub nat_gateway_addresses: std::option::Option<std::vec::Vec<crate::model::NatGatewayAddress>>,
    /// <p>The ID of the NAT gateway.</p>
    pub nat_gateway_id: std::option::Option<std::string::String>,
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through
    /// the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub provisioned_bandwidth: std::option::Option<crate::model::ProvisionedBandwidth>,
    /// <p>The state of the NAT gateway.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>pending</code>: The NAT gateway is being created and is not ready to process
    /// traffic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failed</code>: The NAT gateway could not be created. Check the
    /// <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>available</code>: The NAT gateway is able to process traffic. This status remains
    /// until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deleting</code>: The NAT gateway is in the process of being terminated and may
    /// still be processing traffic.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deleted</code>: The NAT gateway has been terminated and is no longer processing
    /// traffic.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<crate::model::NatGatewayState>,
    /// <p>The ID of the subnet in which the NAT gateway is located.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC in which the NAT gateway is located.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The tags for the NAT gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Indicates whether the NAT gateway supports public or private connectivity.</p>
    pub connectivity_type: std::option::Option<crate::model::ConnectivityType>,
}
impl std::fmt::Debug for NatGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NatGateway");
        formatter.field("create_time", &self.create_time);
        formatter.field("delete_time", &self.delete_time);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_message", &self.failure_message);
        formatter.field("nat_gateway_addresses", &self.nat_gateway_addresses);
        formatter.field("nat_gateway_id", &self.nat_gateway_id);
        formatter.field("provisioned_bandwidth", &self.provisioned_bandwidth);
        formatter.field("state", &self.state);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("tags", &self.tags);
        formatter.field("connectivity_type", &self.connectivity_type);
        formatter.finish()
    }
}
/// See [`NatGateway`](crate::model::NatGateway)
pub mod nat_gateway {
    /// A builder for [`NatGateway`](crate::model::NatGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) delete_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_code: std::option::Option<std::string::String>,
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) nat_gateway_addresses:
            std::option::Option<std::vec::Vec<crate::model::NatGatewayAddress>>,
        pub(crate) nat_gateway_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_bandwidth: std::option::Option<crate::model::ProvisionedBandwidth>,
        pub(crate) state: std::option::Option<crate::model::NatGatewayState>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) connectivity_type: std::option::Option<crate::model::ConnectivityType>,
    }
    impl Builder {
        /// <p>The date and time the NAT gateway was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The date and time the NAT gateway was deleted, if applicable.</p>
        pub fn delete_time(mut self, input: smithy_types::Instant) -> Self {
            self.delete_time = Some(input);
            self
        }
        pub fn set_delete_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.delete_time = input;
            self
        }
        /// <p>If the NAT gateway could not be created, specifies the error code for the failure.
        /// (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> |
        /// <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> |
        /// <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
        pub fn failure_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_code = Some(input.into());
            self
        }
        pub fn set_failure_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p>
        /// <ul>
        /// <li>
        /// <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p>
        /// </li>
        /// <li>
        /// <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p>
        /// </li>
        /// <li>
        /// <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p>
        /// </li>
        /// <li>
        /// <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p>
        /// </li>
        /// <li>
        /// <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p>
        /// </li>
        /// <li>
        /// <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p>
        /// </li>
        /// </ul>
        pub fn failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(input.into());
            self
        }
        pub fn set_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = input;
            self
        }
        pub fn nat_gateway_addresses(
            mut self,
            input: impl Into<crate::model::NatGatewayAddress>,
        ) -> Self {
            let mut v = self.nat_gateway_addresses.unwrap_or_default();
            v.push(input.into());
            self.nat_gateway_addresses = Some(v);
            self
        }
        pub fn set_nat_gateway_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NatGatewayAddress>>,
        ) -> Self {
            self.nat_gateway_addresses = input;
            self
        }
        /// <p>The ID of the NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.nat_gateway_id = Some(input.into());
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nat_gateway_id = input;
            self
        }
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through
        /// the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn provisioned_bandwidth(mut self, input: crate::model::ProvisionedBandwidth) -> Self {
            self.provisioned_bandwidth = Some(input);
            self
        }
        pub fn set_provisioned_bandwidth(
            mut self,
            input: std::option::Option<crate::model::ProvisionedBandwidth>,
        ) -> Self {
            self.provisioned_bandwidth = input;
            self
        }
        /// <p>The state of the NAT gateway.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>pending</code>: The NAT gateway is being created and is not ready to process
        /// traffic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed</code>: The NAT gateway could not be created. Check the
        /// <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available</code>: The NAT gateway is able to process traffic. This status remains
        /// until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleting</code>: The NAT gateway is in the process of being terminated and may
        /// still be processing traffic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleted</code>: The NAT gateway has been terminated and is no longer processing
        /// traffic.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::NatGatewayState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::NatGatewayState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the subnet in which the NAT gateway is located.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The ID of the VPC in which the NAT gateway is located.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Indicates whether the NAT gateway supports public or private connectivity.</p>
        pub fn connectivity_type(mut self, input: crate::model::ConnectivityType) -> Self {
            self.connectivity_type = Some(input);
            self
        }
        pub fn set_connectivity_type(
            mut self,
            input: std::option::Option<crate::model::ConnectivityType>,
        ) -> Self {
            self.connectivity_type = input;
            self
        }
        /// Consumes the builder and constructs a [`NatGateway`](crate::model::NatGateway)
        pub fn build(self) -> crate::model::NatGateway {
            crate::model::NatGateway {
                create_time: self.create_time,
                delete_time: self.delete_time,
                failure_code: self.failure_code,
                failure_message: self.failure_message,
                nat_gateway_addresses: self.nat_gateway_addresses,
                nat_gateway_id: self.nat_gateway_id,
                provisioned_bandwidth: self.provisioned_bandwidth,
                state: self.state,
                subnet_id: self.subnet_id,
                vpc_id: self.vpc_id,
                tags: self.tags,
                connectivity_type: self.connectivity_type,
            }
        }
    }
}
impl NatGateway {
    /// Creates a new builder-style object to manufacture [`NatGateway`](crate::model::NatGateway)
    pub fn builder() -> crate::model::nat_gateway::Builder {
        crate::model::nat_gateway::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectivityType {
    Private,
    Public,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConnectivityType {
    fn from(s: &str) -> Self {
        match s {
            "private" => ConnectivityType::Private,
            "public" => ConnectivityType::Public,
            other => ConnectivityType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConnectivityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectivityType::from(s))
    }
}
impl ConnectivityType {
    pub fn as_str(&self) -> &str {
        match self {
            ConnectivityType::Private => "private",
            ConnectivityType::Public => "public",
            ConnectivityType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["private", "public"]
    }
}
impl AsRef<str> for ConnectivityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NatGatewayState {
    Available,
    Deleted,
    Deleting,
    Failed,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NatGatewayState {
    fn from(s: &str) -> Self {
        match s {
            "available" => NatGatewayState::Available,
            "deleted" => NatGatewayState::Deleted,
            "deleting" => NatGatewayState::Deleting,
            "failed" => NatGatewayState::Failed,
            "pending" => NatGatewayState::Pending,
            other => NatGatewayState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NatGatewayState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NatGatewayState::from(s))
    }
}
impl NatGatewayState {
    pub fn as_str(&self) -> &str {
        match self {
            NatGatewayState::Available => "available",
            NatGatewayState::Deleted => "deleted",
            NatGatewayState::Deleting => "deleting",
            NatGatewayState::Failed => "failed",
            NatGatewayState::Pending => "pending",
            NatGatewayState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "failed", "pending"]
    }
}
impl AsRef<str> for NatGatewayState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedBandwidth {
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub provision_time: std::option::Option<smithy_types::Instant>,
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub provisioned: std::option::Option<std::string::String>,
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub request_time: std::option::Option<smithy_types::Instant>,
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub requested: std::option::Option<std::string::String>,
    /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedBandwidth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedBandwidth");
        formatter.field("provision_time", &self.provision_time);
        formatter.field("provisioned", &self.provisioned);
        formatter.field("request_time", &self.request_time);
        formatter.field("requested", &self.requested);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ProvisionedBandwidth`](crate::model::ProvisionedBandwidth)
pub mod provisioned_bandwidth {
    /// A builder for [`ProvisionedBandwidth`](crate::model::ProvisionedBandwidth)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provision_time: std::option::Option<smithy_types::Instant>,
        pub(crate) provisioned: std::option::Option<std::string::String>,
        pub(crate) request_time: std::option::Option<smithy_types::Instant>,
        pub(crate) requested: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn provision_time(mut self, input: smithy_types::Instant) -> Self {
            self.provision_time = Some(input);
            self
        }
        pub fn set_provision_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.provision_time = input;
            self
        }
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn provisioned(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned = Some(input.into());
            self
        }
        pub fn set_provisioned(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provisioned = input;
            self
        }
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn request_time(mut self, input: smithy_types::Instant) -> Self {
            self.request_time = Some(input);
            self
        }
        pub fn set_request_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.request_time = input;
            self
        }
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn requested(mut self, input: impl Into<std::string::String>) -> Self {
            self.requested = Some(input.into());
            self
        }
        pub fn set_requested(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.requested = input;
            self
        }
        /// <p>Reserved. If you need to sustain traffic greater than the <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedBandwidth`](crate::model::ProvisionedBandwidth)
        pub fn build(self) -> crate::model::ProvisionedBandwidth {
            crate::model::ProvisionedBandwidth {
                provision_time: self.provision_time,
                provisioned: self.provisioned,
                request_time: self.request_time,
                requested: self.requested,
                status: self.status,
            }
        }
    }
}
impl ProvisionedBandwidth {
    /// Creates a new builder-style object to manufacture [`ProvisionedBandwidth`](crate::model::ProvisionedBandwidth)
    pub fn builder() -> crate::model::provisioned_bandwidth::Builder {
        crate::model::provisioned_bandwidth::Builder::default()
    }
}

/// <p>Describes the IP addresses and network interface associated with a NAT gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NatGatewayAddress {
    /// <p>[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The ID of the network interface associated with the NAT gateway.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The private IP address associated with the NAT gateway.</p>
    pub private_ip: std::option::Option<std::string::String>,
    /// <p>[Public NAT gateway only] The Elastic IP address associated with the NAT gateway.</p>
    pub public_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NatGatewayAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NatGatewayAddress");
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip", &self.private_ip);
        formatter.field("public_ip", &self.public_ip);
        formatter.finish()
    }
}
/// See [`NatGatewayAddress`](crate::model::NatGatewayAddress)
pub mod nat_gateway_address {
    /// A builder for [`NatGatewayAddress`](crate::model::NatGatewayAddress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The ID of the network interface associated with the NAT gateway.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The private IP address associated with the NAT gateway.</p>
        pub fn private_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip = Some(input.into());
            self
        }
        pub fn set_private_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.private_ip = input;
            self
        }
        /// <p>[Public NAT gateway only] The Elastic IP address associated with the NAT gateway.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`NatGatewayAddress`](crate::model::NatGatewayAddress)
        pub fn build(self) -> crate::model::NatGatewayAddress {
            crate::model::NatGatewayAddress {
                allocation_id: self.allocation_id,
                network_interface_id: self.network_interface_id,
                private_ip: self.private_ip,
                public_ip: self.public_ip,
            }
        }
    }
}
impl NatGatewayAddress {
    /// Creates a new builder-style object to manufacture [`NatGatewayAddress`](crate::model::NatGatewayAddress)
    pub fn builder() -> crate::model::nat_gateway_address::Builder {
        crate::model::nat_gateway_address::Builder::default()
    }
}

/// <p>Describes the status of a moving Elastic IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MovingAddressStatus {
    /// <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
    pub move_status: std::option::Option<crate::model::MoveStatus>,
    /// <p>The Elastic IP address.</p>
    pub public_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MovingAddressStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MovingAddressStatus");
        formatter.field("move_status", &self.move_status);
        formatter.field("public_ip", &self.public_ip);
        formatter.finish()
    }
}
/// See [`MovingAddressStatus`](crate::model::MovingAddressStatus)
pub mod moving_address_status {
    /// A builder for [`MovingAddressStatus`](crate::model::MovingAddressStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) move_status: std::option::Option<crate::model::MoveStatus>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
        pub fn move_status(mut self, input: crate::model::MoveStatus) -> Self {
            self.move_status = Some(input);
            self
        }
        pub fn set_move_status(
            mut self,
            input: std::option::Option<crate::model::MoveStatus>,
        ) -> Self {
            self.move_status = input;
            self
        }
        /// <p>The Elastic IP address.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`MovingAddressStatus`](crate::model::MovingAddressStatus)
        pub fn build(self) -> crate::model::MovingAddressStatus {
            crate::model::MovingAddressStatus {
                move_status: self.move_status,
                public_ip: self.public_ip,
            }
        }
    }
}
impl MovingAddressStatus {
    /// Creates a new builder-style object to manufacture [`MovingAddressStatus`](crate::model::MovingAddressStatus)
    pub fn builder() -> crate::model::moving_address_status::Builder {
        crate::model::moving_address_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MoveStatus {
    MovingToVpc,
    RestoringToClassic,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MoveStatus {
    fn from(s: &str) -> Self {
        match s {
            "movingToVpc" => MoveStatus::MovingToVpc,
            "restoringToClassic" => MoveStatus::RestoringToClassic,
            other => MoveStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MoveStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MoveStatus::from(s))
    }
}
impl MoveStatus {
    pub fn as_str(&self) -> &str {
        match self {
            MoveStatus::MovingToVpc => "movingToVpc",
            MoveStatus::RestoringToClassic => "restoringToClassic",
            MoveStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["movingToVpc", "restoringToClassic"]
    }
}
impl AsRef<str> for MoveStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a local gateway virtual interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayVirtualInterface {
    /// <p>The ID of the virtual interface.</p>
    pub local_gateway_virtual_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VLAN.</p>
    pub vlan: std::option::Option<i32>,
    /// <p>The local address.</p>
    pub local_address: std::option::Option<std::string::String>,
    /// <p>The peer address.</p>
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) of the local gateway.</p>
    pub local_bgp_asn: std::option::Option<i32>,
    /// <p>The peer BGP ASN.</p>
    pub peer_bgp_asn: std::option::Option<i32>,
    /// <p>The AWS account ID that owns the local gateway virtual interface.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the virtual interface.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGatewayVirtualInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGatewayVirtualInterface");
        formatter.field(
            "local_gateway_virtual_interface_id",
            &self.local_gateway_virtual_interface_id,
        );
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("vlan", &self.vlan);
        formatter.field("local_address", &self.local_address);
        formatter.field("peer_address", &self.peer_address);
        formatter.field("local_bgp_asn", &self.local_bgp_asn);
        formatter.field("peer_bgp_asn", &self.peer_bgp_asn);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGatewayVirtualInterface`](crate::model::LocalGatewayVirtualInterface)
pub mod local_gateway_virtual_interface {
    /// A builder for [`LocalGatewayVirtualInterface`](crate::model::LocalGatewayVirtualInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_virtual_interface_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) vlan: std::option::Option<i32>,
        pub(crate) local_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) local_bgp_asn: std::option::Option<i32>,
        pub(crate) peer_bgp_asn: std::option::Option<i32>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the virtual interface.</p>
        pub fn local_gateway_virtual_interface_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_virtual_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_id = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The ID of the VLAN.</p>
        pub fn vlan(mut self, input: i32) -> Self {
            self.vlan = Some(input);
            self
        }
        pub fn set_vlan(mut self, input: std::option::Option<i32>) -> Self {
            self.vlan = input;
            self
        }
        /// <p>The local address.</p>
        pub fn local_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_address = Some(input.into());
            self
        }
        pub fn set_local_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_address = input;
            self
        }
        /// <p>The peer address.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input;
            self
        }
        /// <p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) of the local gateway.</p>
        pub fn local_bgp_asn(mut self, input: i32) -> Self {
            self.local_bgp_asn = Some(input);
            self
        }
        pub fn set_local_bgp_asn(mut self, input: std::option::Option<i32>) -> Self {
            self.local_bgp_asn = input;
            self
        }
        /// <p>The peer BGP ASN.</p>
        pub fn peer_bgp_asn(mut self, input: i32) -> Self {
            self.peer_bgp_asn = Some(input);
            self
        }
        pub fn set_peer_bgp_asn(mut self, input: std::option::Option<i32>) -> Self {
            self.peer_bgp_asn = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway virtual interface.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayVirtualInterface`](crate::model::LocalGatewayVirtualInterface)
        pub fn build(self) -> crate::model::LocalGatewayVirtualInterface {
            crate::model::LocalGatewayVirtualInterface {
                local_gateway_virtual_interface_id: self.local_gateway_virtual_interface_id,
                local_gateway_id: self.local_gateway_id,
                vlan: self.vlan,
                local_address: self.local_address,
                peer_address: self.peer_address,
                local_bgp_asn: self.local_bgp_asn,
                peer_bgp_asn: self.peer_bgp_asn,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl LocalGatewayVirtualInterface {
    /// Creates a new builder-style object to manufacture [`LocalGatewayVirtualInterface`](crate::model::LocalGatewayVirtualInterface)
    pub fn builder() -> crate::model::local_gateway_virtual_interface::Builder {
        crate::model::local_gateway_virtual_interface::Builder::default()
    }
}

/// <p>Describes a local gateway virtual interface group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayVirtualInterfaceGroup {
    /// <p>The ID of the virtual interface group.</p>
    pub local_gateway_virtual_interface_group_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the virtual interfaces.</p>
    pub local_gateway_virtual_interface_ids:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway virtual interface group.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the virtual interface group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGatewayVirtualInterfaceGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGatewayVirtualInterfaceGroup");
        formatter.field(
            "local_gateway_virtual_interface_group_id",
            &self.local_gateway_virtual_interface_group_id,
        );
        formatter.field(
            "local_gateway_virtual_interface_ids",
            &self.local_gateway_virtual_interface_ids,
        );
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGatewayVirtualInterfaceGroup`](crate::model::LocalGatewayVirtualInterfaceGroup)
pub mod local_gateway_virtual_interface_group {
    /// A builder for [`LocalGatewayVirtualInterfaceGroup`](crate::model::LocalGatewayVirtualInterfaceGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_virtual_interface_group_id:
            std::option::Option<std::string::String>,
        pub(crate) local_gateway_virtual_interface_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the virtual interface group.</p>
        pub fn local_gateway_virtual_interface_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_virtual_interface_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = input;
            self
        }
        pub fn local_gateway_virtual_interface_ids(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.local_gateway_virtual_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.local_gateway_virtual_interface_ids = Some(v);
            self
        }
        pub fn set_local_gateway_virtual_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.local_gateway_virtual_interface_ids = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway virtual interface group.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayVirtualInterfaceGroup`](crate::model::LocalGatewayVirtualInterfaceGroup)
        pub fn build(self) -> crate::model::LocalGatewayVirtualInterfaceGroup {
            crate::model::LocalGatewayVirtualInterfaceGroup {
                local_gateway_virtual_interface_group_id: self
                    .local_gateway_virtual_interface_group_id,
                local_gateway_virtual_interface_ids: self.local_gateway_virtual_interface_ids,
                local_gateway_id: self.local_gateway_id,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl LocalGatewayVirtualInterfaceGroup {
    /// Creates a new builder-style object to manufacture [`LocalGatewayVirtualInterfaceGroup`](crate::model::LocalGatewayVirtualInterfaceGroup)
    pub fn builder() -> crate::model::local_gateway_virtual_interface_group::Builder {
        crate::model::local_gateway_virtual_interface_group::Builder::default()
    }
}

/// <p>Describes a local gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGateway {
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the local gateway.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the local gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGateway");
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGateway`](crate::model::LocalGateway)
pub mod local_gateway {
    /// A builder for [`LocalGateway`](crate::model::LocalGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The state of the local gateway.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGateway`](crate::model::LocalGateway)
        pub fn build(self) -> crate::model::LocalGateway {
            crate::model::LocalGateway {
                local_gateway_id: self.local_gateway_id,
                outpost_arn: self.outpost_arn,
                owner_id: self.owner_id,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl LocalGateway {
    /// Creates a new builder-style object to manufacture [`LocalGateway`](crate::model::LocalGateway)
    pub fn builder() -> crate::model::local_gateway::Builder {
        crate::model::local_gateway::Builder::default()
    }
}

/// <p>Describes an association between a local gateway route table and a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayRouteTableVpcAssociation {
    /// <p>The ID of the association.</p>
    pub local_gateway_route_table_vpc_association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway route table.</p>
    pub local_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the local gateway route table for the association.</p>
    pub local_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway route table for the association.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the association.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGatewayRouteTableVpcAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGatewayRouteTableVpcAssociation");
        formatter.field(
            "local_gateway_route_table_vpc_association_id",
            &self.local_gateway_route_table_vpc_association_id,
        );
        formatter.field(
            "local_gateway_route_table_id",
            &self.local_gateway_route_table_id,
        );
        formatter.field(
            "local_gateway_route_table_arn",
            &self.local_gateway_route_table_arn,
        );
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGatewayRouteTableVpcAssociation`](crate::model::LocalGatewayRouteTableVpcAssociation)
pub mod local_gateway_route_table_vpc_association {
    /// A builder for [`LocalGatewayRouteTableVpcAssociation`](crate::model::LocalGatewayRouteTableVpcAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_route_table_vpc_association_id:
            std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the association.</p>
        pub fn local_gateway_route_table_vpc_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_vpc_association_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_vpc_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_vpc_association_id = input;
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the local gateway route table for the association.</p>
        pub fn local_gateway_route_table_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway route table for the association.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayRouteTableVpcAssociation`](crate::model::LocalGatewayRouteTableVpcAssociation)
        pub fn build(self) -> crate::model::LocalGatewayRouteTableVpcAssociation {
            crate::model::LocalGatewayRouteTableVpcAssociation {
                local_gateway_route_table_vpc_association_id: self
                    .local_gateway_route_table_vpc_association_id,
                local_gateway_route_table_id: self.local_gateway_route_table_id,
                local_gateway_route_table_arn: self.local_gateway_route_table_arn,
                local_gateway_id: self.local_gateway_id,
                vpc_id: self.vpc_id,
                owner_id: self.owner_id,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl LocalGatewayRouteTableVpcAssociation {
    /// Creates a new builder-style object to manufacture [`LocalGatewayRouteTableVpcAssociation`](crate::model::LocalGatewayRouteTableVpcAssociation)
    pub fn builder() -> crate::model::local_gateway_route_table_vpc_association::Builder {
        crate::model::local_gateway_route_table_vpc_association::Builder::default()
    }
}

/// <p>Describes an association between a local gateway route table and a virtual interface group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    /// <p>The ID of the association.</p>
    pub local_gateway_route_table_virtual_interface_group_association_id:
        std::option::Option<std::string::String>,
    /// <p>The ID of the virtual interface group.</p>
    pub local_gateway_virtual_interface_group_id: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway route table.</p>
    pub local_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the local gateway route table for the virtual interface group.</p>
    pub local_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway virtual interface group association.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the association.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("LocalGatewayRouteTableVirtualInterfaceGroupAssociation");
        formatter.field(
            "local_gateway_route_table_virtual_interface_group_association_id",
            &self.local_gateway_route_table_virtual_interface_group_association_id,
        );
        formatter.field(
            "local_gateway_virtual_interface_group_id",
            &self.local_gateway_virtual_interface_group_id,
        );
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field(
            "local_gateway_route_table_id",
            &self.local_gateway_route_table_id,
        );
        formatter.field(
            "local_gateway_route_table_arn",
            &self.local_gateway_route_table_arn,
        );
        formatter.field("owner_id", &self.owner_id);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGatewayRouteTableVirtualInterfaceGroupAssociation`](crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation)
pub mod local_gateway_route_table_virtual_interface_group_association {
    /// A builder for [`LocalGatewayRouteTableVirtualInterfaceGroupAssociation`](crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_route_table_virtual_interface_group_association_id:
            std::option::Option<std::string::String>,
        pub(crate) local_gateway_virtual_interface_group_id:
            std::option::Option<std::string::String>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the association.</p>
        pub fn local_gateway_route_table_virtual_interface_group_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_virtual_interface_group_association_id =
                Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_virtual_interface_group_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_virtual_interface_group_association_id = input;
            self
        }
        /// <p>The ID of the virtual interface group.</p>
        pub fn local_gateway_virtual_interface_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_virtual_interface_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_virtual_interface_group_id = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the local gateway route table for the virtual interface group.</p>
        pub fn local_gateway_route_table_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway virtual interface group association.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayRouteTableVirtualInterfaceGroupAssociation`](crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation)
        pub fn build(self) -> crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
            crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
                local_gateway_route_table_virtual_interface_group_association_id: self
                    .local_gateway_route_table_virtual_interface_group_association_id,
                local_gateway_virtual_interface_group_id: self
                    .local_gateway_virtual_interface_group_id,
                local_gateway_id: self.local_gateway_id,
                local_gateway_route_table_id: self.local_gateway_route_table_id,
                local_gateway_route_table_arn: self.local_gateway_route_table_arn,
                owner_id: self.owner_id,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl LocalGatewayRouteTableVirtualInterfaceGroupAssociation {
    /// Creates a new builder-style object to manufacture [`LocalGatewayRouteTableVirtualInterfaceGroupAssociation`](crate::model::LocalGatewayRouteTableVirtualInterfaceGroupAssociation)
    pub fn builder(
    ) -> crate::model::local_gateway_route_table_virtual_interface_group_association::Builder {
        crate::model::local_gateway_route_table_virtual_interface_group_association::Builder::default()
    }
}

/// <p>Describes a local gateway route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalGatewayRouteTable {
    /// <p>The ID of the local gateway route table.</p>
    pub local_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the local gateway route table.</p>
    pub local_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the local gateway.</p>
    pub local_gateway_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>The AWS account ID that owns the local gateway route table.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The state of the local gateway route table.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the local gateway route table.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LocalGatewayRouteTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalGatewayRouteTable");
        formatter.field(
            "local_gateway_route_table_id",
            &self.local_gateway_route_table_id,
        );
        formatter.field(
            "local_gateway_route_table_arn",
            &self.local_gateway_route_table_arn,
        );
        formatter.field("local_gateway_id", &self.local_gateway_id);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LocalGatewayRouteTable`](crate::model::LocalGatewayRouteTable)
pub mod local_gateway_route_table {
    /// A builder for [`LocalGatewayRouteTable`](crate::model::LocalGatewayRouteTable)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) local_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) local_gateway_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the local gateway route table.</p>
        pub fn local_gateway_route_table_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_arn = input;
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_gateway_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// <p>The AWS account ID that owns the local gateway route table.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The state of the local gateway route table.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LocalGatewayRouteTable`](crate::model::LocalGatewayRouteTable)
        pub fn build(self) -> crate::model::LocalGatewayRouteTable {
            crate::model::LocalGatewayRouteTable {
                local_gateway_route_table_id: self.local_gateway_route_table_id,
                local_gateway_route_table_arn: self.local_gateway_route_table_arn,
                local_gateway_id: self.local_gateway_id,
                outpost_arn: self.outpost_arn,
                owner_id: self.owner_id,
                state: self.state,
                tags: self.tags,
            }
        }
    }
}
impl LocalGatewayRouteTable {
    /// Creates a new builder-style object to manufacture [`LocalGatewayRouteTable`](crate::model::LocalGatewayRouteTable)
    pub fn builder() -> crate::model::local_gateway_route_table::Builder {
        crate::model::local_gateway_route_table::Builder::default()
    }
}

/// <p>Describes a launch template version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateVersion {
    /// <p>The ID of the launch template.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The version number.</p>
    pub version_number: std::option::Option<i64>,
    /// <p>The description for the version.</p>
    pub version_description: std::option::Option<std::string::String>,
    /// <p>The time the version was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The principal that created the version.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>Indicates whether the version is the default version.</p>
    pub default_version: std::option::Option<bool>,
    /// <p>Information about the launch template.</p>
    pub launch_template_data: std::option::Option<crate::model::ResponseLaunchTemplateData>,
}
impl std::fmt::Debug for LaunchTemplateVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateVersion");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version_number", &self.version_number);
        formatter.field("version_description", &self.version_description);
        formatter.field("create_time", &self.create_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("default_version", &self.default_version);
        formatter.field("launch_template_data", &self.launch_template_data);
        formatter.finish()
    }
}
/// See [`LaunchTemplateVersion`](crate::model::LaunchTemplateVersion)
pub mod launch_template_version {
    /// A builder for [`LaunchTemplateVersion`](crate::model::LaunchTemplateVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) version_description: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) default_version: std::option::Option<bool>,
        pub(crate) launch_template_data:
            std::option::Option<crate::model::ResponseLaunchTemplateData>,
    }
    impl Builder {
        /// <p>The ID of the launch template.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The version number.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>The description for the version.</p>
        pub fn version_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_description = Some(input.into());
            self
        }
        pub fn set_version_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.version_description = input;
            self
        }
        /// <p>The time the version was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The principal that created the version.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Indicates whether the version is the default version.</p>
        pub fn default_version(mut self, input: bool) -> Self {
            self.default_version = Some(input);
            self
        }
        pub fn set_default_version(mut self, input: std::option::Option<bool>) -> Self {
            self.default_version = input;
            self
        }
        /// <p>Information about the launch template.</p>
        pub fn launch_template_data(
            mut self,
            input: crate::model::ResponseLaunchTemplateData,
        ) -> Self {
            self.launch_template_data = Some(input);
            self
        }
        pub fn set_launch_template_data(
            mut self,
            input: std::option::Option<crate::model::ResponseLaunchTemplateData>,
        ) -> Self {
            self.launch_template_data = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateVersion`](crate::model::LaunchTemplateVersion)
        pub fn build(self) -> crate::model::LaunchTemplateVersion {
            crate::model::LaunchTemplateVersion {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version_number: self.version_number,
                version_description: self.version_description,
                create_time: self.create_time,
                created_by: self.created_by,
                default_version: self.default_version,
                launch_template_data: self.launch_template_data,
            }
        }
    }
}
impl LaunchTemplateVersion {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateVersion`](crate::model::LaunchTemplateVersion)
    pub fn builder() -> crate::model::launch_template_version::Builder {
        crate::model::launch_template_version::Builder::default()
    }
}

/// <p>Describes a key pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KeyPairInfo {
    /// <p>The ID of the key pair.</p>
    pub key_pair_id: std::option::Option<std::string::String>,
    /// <p>If you used <a>CreateKeyPair</a> to create the key pair:</p>
    /// <ul>
    /// <li>
    /// <p>For RSA key pairs, the key fingerprint is the SHA-1 digest of the DER encoded private key.
    /// </p>
    /// </li>
    /// <li>
    /// <p>For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which
    /// is the default for OpenSSH, starting with <a href="http://www.openssh.com/txt/release-6.8">OpenSSH 6.8</a>.</p>
    /// </li>
    /// </ul>
    /// <p>If you used <a>ImportKeyPair</a> to provide Amazon Web Services the public key:</p>
    /// <ul>
    /// <li>
    /// <p>For RSA key pairs, the key fingerprint is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
    /// </li>
    /// <li>
    /// <p>For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256
    /// digest, which is the default for OpenSSH, starting with <a href="http://www.openssh.com/txt/release-6.8">OpenSSH 6.8</a>.</p>
    /// </li>
    /// </ul>
    pub key_fingerprint: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The type of key pair.</p>
    pub key_type: std::option::Option<crate::model::KeyType>,
    /// <p>Any tags applied to the key pair.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for KeyPairInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeyPairInfo");
        formatter.field("key_pair_id", &self.key_pair_id);
        formatter.field("key_fingerprint", &self.key_fingerprint);
        formatter.field("key_name", &self.key_name);
        formatter.field("key_type", &self.key_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`KeyPairInfo`](crate::model::KeyPairInfo)
pub mod key_pair_info {
    /// A builder for [`KeyPairInfo`](crate::model::KeyPairInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_pair_id: std::option::Option<std::string::String>,
        pub(crate) key_fingerprint: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) key_type: std::option::Option<crate::model::KeyType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the key pair.</p>
        pub fn key_pair_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_id = Some(input.into());
            self
        }
        pub fn set_key_pair_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_pair_id = input;
            self
        }
        /// <p>If you used <a>CreateKeyPair</a> to create the key pair:</p>
        /// <ul>
        /// <li>
        /// <p>For RSA key pairs, the key fingerprint is the SHA-1 digest of the DER encoded private key.
        /// </p>
        /// </li>
        /// <li>
        /// <p>For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256 digest, which
        /// is the default for OpenSSH, starting with <a href="http://www.openssh.com/txt/release-6.8">OpenSSH 6.8</a>.</p>
        /// </li>
        /// </ul>
        /// <p>If you used <a>ImportKeyPair</a> to provide Amazon Web Services the public key:</p>
        /// <ul>
        /// <li>
        /// <p>For RSA key pairs, the key fingerprint is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
        /// </li>
        /// <li>
        /// <p>For ED25519 key pairs, the key fingerprint is the base64-encoded SHA-256
        /// digest, which is the default for OpenSSH, starting with <a href="http://www.openssh.com/txt/release-6.8">OpenSSH 6.8</a>.</p>
        /// </li>
        /// </ul>
        pub fn key_fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_fingerprint = Some(input.into());
            self
        }
        pub fn set_key_fingerprint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_fingerprint = input;
            self
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The type of key pair.</p>
        pub fn key_type(mut self, input: crate::model::KeyType) -> Self {
            self.key_type = Some(input);
            self
        }
        pub fn set_key_type(mut self, input: std::option::Option<crate::model::KeyType>) -> Self {
            self.key_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPairInfo`](crate::model::KeyPairInfo)
        pub fn build(self) -> crate::model::KeyPairInfo {
            crate::model::KeyPairInfo {
                key_pair_id: self.key_pair_id,
                key_fingerprint: self.key_fingerprint,
                key_name: self.key_name,
                key_type: self.key_type,
                tags: self.tags,
            }
        }
    }
}
impl KeyPairInfo {
    /// Creates a new builder-style object to manufacture [`KeyPairInfo`](crate::model::KeyPairInfo)
    pub fn builder() -> crate::model::key_pair_info::Builder {
        crate::model::key_pair_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum KeyType {
    Ed25519,
    Rsa,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for KeyType {
    fn from(s: &str) -> Self {
        match s {
            "ed25519" => KeyType::Ed25519,
            "rsa" => KeyType::Rsa,
            other => KeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for KeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(KeyType::from(s))
    }
}
impl KeyType {
    pub fn as_str(&self) -> &str {
        match self {
            KeyType::Ed25519 => "ed25519",
            KeyType::Rsa => "rsa",
            KeyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ed25519", "rsa"]
    }
}
impl AsRef<str> for KeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an IPv6 address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ipv6Pool {
    /// <p>The ID of the address pool.</p>
    pub pool_id: std::option::Option<std::string::String>,
    /// <p>The description for the address pool.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The CIDR blocks for the address pool.</p>
    pub pool_cidr_blocks: std::option::Option<std::vec::Vec<crate::model::PoolCidrBlock>>,
    /// <p>Any tags for the address pool.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Ipv6Pool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ipv6Pool");
        formatter.field("pool_id", &self.pool_id);
        formatter.field("description", &self.description);
        formatter.field("pool_cidr_blocks", &self.pool_cidr_blocks);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Ipv6Pool`](crate::model::Ipv6Pool)
pub mod ipv6_pool {
    /// A builder for [`Ipv6Pool`](crate::model::Ipv6Pool)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pool_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) pool_cidr_blocks:
            std::option::Option<std::vec::Vec<crate::model::PoolCidrBlock>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the address pool.</p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pool_id = Some(input.into());
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pool_id = input;
            self
        }
        /// <p>The description for the address pool.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn pool_cidr_blocks(mut self, input: impl Into<crate::model::PoolCidrBlock>) -> Self {
            let mut v = self.pool_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.pool_cidr_blocks = Some(v);
            self
        }
        pub fn set_pool_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PoolCidrBlock>>,
        ) -> Self {
            self.pool_cidr_blocks = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Ipv6Pool`](crate::model::Ipv6Pool)
        pub fn build(self) -> crate::model::Ipv6Pool {
            crate::model::Ipv6Pool {
                pool_id: self.pool_id,
                description: self.description,
                pool_cidr_blocks: self.pool_cidr_blocks,
                tags: self.tags,
            }
        }
    }
}
impl Ipv6Pool {
    /// Creates a new builder-style object to manufacture [`Ipv6Pool`](crate::model::Ipv6Pool)
    pub fn builder() -> crate::model::ipv6_pool::Builder {
        crate::model::ipv6_pool::Builder::default()
    }
}

/// <p>Describes a CIDR block for an address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PoolCidrBlock {
    /// <p>The CIDR block.</p>
    pub cidr: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PoolCidrBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PoolCidrBlock");
        formatter.field("cidr", &self.cidr);
        formatter.finish()
    }
}
/// See [`PoolCidrBlock`](crate::model::PoolCidrBlock)
pub mod pool_cidr_block {
    /// A builder for [`PoolCidrBlock`](crate::model::PoolCidrBlock)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CIDR block.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input;
            self
        }
        /// Consumes the builder and constructs a [`PoolCidrBlock`](crate::model::PoolCidrBlock)
        pub fn build(self) -> crate::model::PoolCidrBlock {
            crate::model::PoolCidrBlock { cidr: self.cidr }
        }
    }
}
impl PoolCidrBlock {
    /// Creates a new builder-style object to manufacture [`PoolCidrBlock`](crate::model::PoolCidrBlock)
    pub fn builder() -> crate::model::pool_cidr_block::Builder {
        crate::model::pool_cidr_block::Builder::default()
    }
}

/// <p>Describes an internet gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternetGateway {
    /// <p>Any VPCs attached to the internet gateway.</p>
    pub attachments: std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
    /// <p>The ID of the internet gateway.</p>
    pub internet_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the internet gateway.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the internet gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for InternetGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternetGateway");
        formatter.field("attachments", &self.attachments);
        formatter.field("internet_gateway_id", &self.internet_gateway_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`InternetGateway`](crate::model::InternetGateway)
pub mod internet_gateway {
    /// A builder for [`InternetGateway`](crate::model::InternetGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachments:
            std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
        pub(crate) internet_gateway_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        pub fn attachments(
            mut self,
            input: impl Into<crate::model::InternetGatewayAttachment>,
        ) -> Self {
            let mut v = self.attachments.unwrap_or_default();
            v.push(input.into());
            self.attachments = Some(v);
            self
        }
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
        ) -> Self {
            self.attachments = input;
            self
        }
        /// <p>The ID of the internet gateway.</p>
        pub fn internet_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.internet_gateway_id = Some(input.into());
            self
        }
        pub fn set_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.internet_gateway_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the internet gateway.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`InternetGateway`](crate::model::InternetGateway)
        pub fn build(self) -> crate::model::InternetGateway {
            crate::model::InternetGateway {
                attachments: self.attachments,
                internet_gateway_id: self.internet_gateway_id,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl InternetGateway {
    /// Creates a new builder-style object to manufacture [`InternetGateway`](crate::model::InternetGateway)
    pub fn builder() -> crate::model::internet_gateway::Builder {
        crate::model::internet_gateway::Builder::default()
    }
}

/// <p>Describes the attachment of a VPC to an internet gateway or an egress-only internet
/// gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternetGatewayAttachment {
    /// <p>The current state of the attachment. For an internet gateway, the state is
    /// <code>available</code> when attached to a VPC; otherwise, this value is not
    /// returned.</p>
    pub state: std::option::Option<crate::model::AttachmentStatus>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternetGatewayAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternetGatewayAttachment");
        formatter.field("state", &self.state);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`InternetGatewayAttachment`](crate::model::InternetGatewayAttachment)
pub mod internet_gateway_attachment {
    /// A builder for [`InternetGatewayAttachment`](crate::model::InternetGatewayAttachment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AttachmentStatus>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of the attachment. For an internet gateway, the state is
        /// <code>available</code> when attached to a VPC; otherwise, this value is not
        /// returned.</p>
        pub fn state(mut self, input: crate::model::AttachmentStatus) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AttachmentStatus>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InternetGatewayAttachment`](crate::model::InternetGatewayAttachment)
        pub fn build(self) -> crate::model::InternetGatewayAttachment {
            crate::model::InternetGatewayAttachment {
                state: self.state,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl InternetGatewayAttachment {
    /// Creates a new builder-style object to manufacture [`InternetGatewayAttachment`](crate::model::InternetGatewayAttachment)
    pub fn builder() -> crate::model::internet_gateway_attachment::Builder {
        crate::model::internet_gateway_attachment::Builder::default()
    }
}

/// <p>Describes the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceTypeInfo {
    /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>Indicates whether the instance type is current generation.</p>
    pub current_generation: std::option::Option<bool>,
    /// <p>Indicates whether the instance type is eligible for the free tier.</p>
    pub free_tier_eligible: std::option::Option<bool>,
    /// <p>Indicates whether the instance type is offered for spot or On-Demand.</p>
    pub supported_usage_classes: std::option::Option<std::vec::Vec<crate::model::UsageClassType>>,
    /// <p>The supported root device types.</p>
    pub supported_root_device_types:
        std::option::Option<std::vec::Vec<crate::model::RootDeviceType>>,
    /// <p>The supported virtualization types.</p>
    pub supported_virtualization_types:
        std::option::Option<std::vec::Vec<crate::model::VirtualizationType>>,
    /// <p>Indicates whether the instance is a bare metal instance type.</p>
    pub bare_metal: std::option::Option<bool>,
    /// <p>The hypervisor for the instance type.</p>
    pub hypervisor: std::option::Option<crate::model::InstanceTypeHypervisor>,
    /// <p>Describes the processor.</p>
    pub processor_info: std::option::Option<crate::model::ProcessorInfo>,
    /// <p>Describes the vCPU configurations for the instance type.</p>
    pub v_cpu_info: std::option::Option<crate::model::VCpuInfo>,
    /// <p>Describes the memory for the instance type.</p>
    pub memory_info: std::option::Option<crate::model::MemoryInfo>,
    /// <p>Indicates whether instance storage is supported.</p>
    pub instance_storage_supported: std::option::Option<bool>,
    /// <p>Describes the instance storage for the instance type.</p>
    pub instance_storage_info: std::option::Option<crate::model::InstanceStorageInfo>,
    /// <p>Describes the Amazon EBS settings for the instance type.</p>
    pub ebs_info: std::option::Option<crate::model::EbsInfo>,
    /// <p>Describes the network settings for the instance type.</p>
    pub network_info: std::option::Option<crate::model::NetworkInfo>,
    /// <p>Describes the GPU accelerator settings for the instance type.</p>
    pub gpu_info: std::option::Option<crate::model::GpuInfo>,
    /// <p>Describes the FPGA accelerator settings for the instance type.</p>
    pub fpga_info: std::option::Option<crate::model::FpgaInfo>,
    /// <p>Describes the placement group settings for the instance type.</p>
    pub placement_group_info: std::option::Option<crate::model::PlacementGroupInfo>,
    /// <p>Describes the Inference accelerator settings for the instance type.</p>
    pub inference_accelerator_info: std::option::Option<crate::model::InferenceAcceleratorInfo>,
    /// <p>Indicates whether On-Demand hibernation is supported.</p>
    pub hibernation_supported: std::option::Option<bool>,
    /// <p>Indicates whether the instance type is a burstable performance instance type.</p>
    pub burstable_performance_supported: std::option::Option<bool>,
    /// <p>Indicates whether Dedicated Hosts are supported on the instance type.</p>
    pub dedicated_hosts_supported: std::option::Option<bool>,
    /// <p>Indicates whether auto recovery is supported.</p>
    pub auto_recovery_supported: std::option::Option<bool>,
    /// <p>The supported boot modes. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
    /// <i>Amazon EC2 User Guide</i>.</p>
    pub supported_boot_modes: std::option::Option<std::vec::Vec<crate::model::BootModeType>>,
}
impl std::fmt::Debug for InstanceTypeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceTypeInfo");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("free_tier_eligible", &self.free_tier_eligible);
        formatter.field("supported_usage_classes", &self.supported_usage_classes);
        formatter.field(
            "supported_root_device_types",
            &self.supported_root_device_types,
        );
        formatter.field(
            "supported_virtualization_types",
            &self.supported_virtualization_types,
        );
        formatter.field("bare_metal", &self.bare_metal);
        formatter.field("hypervisor", &self.hypervisor);
        formatter.field("processor_info", &self.processor_info);
        formatter.field("v_cpu_info", &self.v_cpu_info);
        formatter.field("memory_info", &self.memory_info);
        formatter.field(
            "instance_storage_supported",
            &self.instance_storage_supported,
        );
        formatter.field("instance_storage_info", &self.instance_storage_info);
        formatter.field("ebs_info", &self.ebs_info);
        formatter.field("network_info", &self.network_info);
        formatter.field("gpu_info", &self.gpu_info);
        formatter.field("fpga_info", &self.fpga_info);
        formatter.field("placement_group_info", &self.placement_group_info);
        formatter.field(
            "inference_accelerator_info",
            &self.inference_accelerator_info,
        );
        formatter.field("hibernation_supported", &self.hibernation_supported);
        formatter.field(
            "burstable_performance_supported",
            &self.burstable_performance_supported,
        );
        formatter.field("dedicated_hosts_supported", &self.dedicated_hosts_supported);
        formatter.field("auto_recovery_supported", &self.auto_recovery_supported);
        formatter.field("supported_boot_modes", &self.supported_boot_modes);
        formatter.finish()
    }
}
/// See [`InstanceTypeInfo`](crate::model::InstanceTypeInfo)
pub mod instance_type_info {
    /// A builder for [`InstanceTypeInfo`](crate::model::InstanceTypeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) free_tier_eligible: std::option::Option<bool>,
        pub(crate) supported_usage_classes:
            std::option::Option<std::vec::Vec<crate::model::UsageClassType>>,
        pub(crate) supported_root_device_types:
            std::option::Option<std::vec::Vec<crate::model::RootDeviceType>>,
        pub(crate) supported_virtualization_types:
            std::option::Option<std::vec::Vec<crate::model::VirtualizationType>>,
        pub(crate) bare_metal: std::option::Option<bool>,
        pub(crate) hypervisor: std::option::Option<crate::model::InstanceTypeHypervisor>,
        pub(crate) processor_info: std::option::Option<crate::model::ProcessorInfo>,
        pub(crate) v_cpu_info: std::option::Option<crate::model::VCpuInfo>,
        pub(crate) memory_info: std::option::Option<crate::model::MemoryInfo>,
        pub(crate) instance_storage_supported: std::option::Option<bool>,
        pub(crate) instance_storage_info: std::option::Option<crate::model::InstanceStorageInfo>,
        pub(crate) ebs_info: std::option::Option<crate::model::EbsInfo>,
        pub(crate) network_info: std::option::Option<crate::model::NetworkInfo>,
        pub(crate) gpu_info: std::option::Option<crate::model::GpuInfo>,
        pub(crate) fpga_info: std::option::Option<crate::model::FpgaInfo>,
        pub(crate) placement_group_info: std::option::Option<crate::model::PlacementGroupInfo>,
        pub(crate) inference_accelerator_info:
            std::option::Option<crate::model::InferenceAcceleratorInfo>,
        pub(crate) hibernation_supported: std::option::Option<bool>,
        pub(crate) burstable_performance_supported: std::option::Option<bool>,
        pub(crate) dedicated_hosts_supported: std::option::Option<bool>,
        pub(crate) auto_recovery_supported: std::option::Option<bool>,
        pub(crate) supported_boot_modes:
            std::option::Option<std::vec::Vec<crate::model::BootModeType>>,
    }
    impl Builder {
        /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Indicates whether the instance type is current generation.</p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Indicates whether the instance type is eligible for the free tier.</p>
        pub fn free_tier_eligible(mut self, input: bool) -> Self {
            self.free_tier_eligible = Some(input);
            self
        }
        pub fn set_free_tier_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.free_tier_eligible = input;
            self
        }
        pub fn supported_usage_classes(
            mut self,
            input: impl Into<crate::model::UsageClassType>,
        ) -> Self {
            let mut v = self.supported_usage_classes.unwrap_or_default();
            v.push(input.into());
            self.supported_usage_classes = Some(v);
            self
        }
        pub fn set_supported_usage_classes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UsageClassType>>,
        ) -> Self {
            self.supported_usage_classes = input;
            self
        }
        pub fn supported_root_device_types(
            mut self,
            input: impl Into<crate::model::RootDeviceType>,
        ) -> Self {
            let mut v = self.supported_root_device_types.unwrap_or_default();
            v.push(input.into());
            self.supported_root_device_types = Some(v);
            self
        }
        pub fn set_supported_root_device_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RootDeviceType>>,
        ) -> Self {
            self.supported_root_device_types = input;
            self
        }
        pub fn supported_virtualization_types(
            mut self,
            input: impl Into<crate::model::VirtualizationType>,
        ) -> Self {
            let mut v = self.supported_virtualization_types.unwrap_or_default();
            v.push(input.into());
            self.supported_virtualization_types = Some(v);
            self
        }
        pub fn set_supported_virtualization_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VirtualizationType>>,
        ) -> Self {
            self.supported_virtualization_types = input;
            self
        }
        /// <p>Indicates whether the instance is a bare metal instance type.</p>
        pub fn bare_metal(mut self, input: bool) -> Self {
            self.bare_metal = Some(input);
            self
        }
        pub fn set_bare_metal(mut self, input: std::option::Option<bool>) -> Self {
            self.bare_metal = input;
            self
        }
        /// <p>The hypervisor for the instance type.</p>
        pub fn hypervisor(mut self, input: crate::model::InstanceTypeHypervisor) -> Self {
            self.hypervisor = Some(input);
            self
        }
        pub fn set_hypervisor(
            mut self,
            input: std::option::Option<crate::model::InstanceTypeHypervisor>,
        ) -> Self {
            self.hypervisor = input;
            self
        }
        /// <p>Describes the processor.</p>
        pub fn processor_info(mut self, input: crate::model::ProcessorInfo) -> Self {
            self.processor_info = Some(input);
            self
        }
        pub fn set_processor_info(
            mut self,
            input: std::option::Option<crate::model::ProcessorInfo>,
        ) -> Self {
            self.processor_info = input;
            self
        }
        /// <p>Describes the vCPU configurations for the instance type.</p>
        pub fn v_cpu_info(mut self, input: crate::model::VCpuInfo) -> Self {
            self.v_cpu_info = Some(input);
            self
        }
        pub fn set_v_cpu_info(
            mut self,
            input: std::option::Option<crate::model::VCpuInfo>,
        ) -> Self {
            self.v_cpu_info = input;
            self
        }
        /// <p>Describes the memory for the instance type.</p>
        pub fn memory_info(mut self, input: crate::model::MemoryInfo) -> Self {
            self.memory_info = Some(input);
            self
        }
        pub fn set_memory_info(
            mut self,
            input: std::option::Option<crate::model::MemoryInfo>,
        ) -> Self {
            self.memory_info = input;
            self
        }
        /// <p>Indicates whether instance storage is supported.</p>
        pub fn instance_storage_supported(mut self, input: bool) -> Self {
            self.instance_storage_supported = Some(input);
            self
        }
        pub fn set_instance_storage_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.instance_storage_supported = input;
            self
        }
        /// <p>Describes the instance storage for the instance type.</p>
        pub fn instance_storage_info(mut self, input: crate::model::InstanceStorageInfo) -> Self {
            self.instance_storage_info = Some(input);
            self
        }
        pub fn set_instance_storage_info(
            mut self,
            input: std::option::Option<crate::model::InstanceStorageInfo>,
        ) -> Self {
            self.instance_storage_info = input;
            self
        }
        /// <p>Describes the Amazon EBS settings for the instance type.</p>
        pub fn ebs_info(mut self, input: crate::model::EbsInfo) -> Self {
            self.ebs_info = Some(input);
            self
        }
        pub fn set_ebs_info(mut self, input: std::option::Option<crate::model::EbsInfo>) -> Self {
            self.ebs_info = input;
            self
        }
        /// <p>Describes the network settings for the instance type.</p>
        pub fn network_info(mut self, input: crate::model::NetworkInfo) -> Self {
            self.network_info = Some(input);
            self
        }
        pub fn set_network_info(
            mut self,
            input: std::option::Option<crate::model::NetworkInfo>,
        ) -> Self {
            self.network_info = input;
            self
        }
        /// <p>Describes the GPU accelerator settings for the instance type.</p>
        pub fn gpu_info(mut self, input: crate::model::GpuInfo) -> Self {
            self.gpu_info = Some(input);
            self
        }
        pub fn set_gpu_info(mut self, input: std::option::Option<crate::model::GpuInfo>) -> Self {
            self.gpu_info = input;
            self
        }
        /// <p>Describes the FPGA accelerator settings for the instance type.</p>
        pub fn fpga_info(mut self, input: crate::model::FpgaInfo) -> Self {
            self.fpga_info = Some(input);
            self
        }
        pub fn set_fpga_info(mut self, input: std::option::Option<crate::model::FpgaInfo>) -> Self {
            self.fpga_info = input;
            self
        }
        /// <p>Describes the placement group settings for the instance type.</p>
        pub fn placement_group_info(mut self, input: crate::model::PlacementGroupInfo) -> Self {
            self.placement_group_info = Some(input);
            self
        }
        pub fn set_placement_group_info(
            mut self,
            input: std::option::Option<crate::model::PlacementGroupInfo>,
        ) -> Self {
            self.placement_group_info = input;
            self
        }
        /// <p>Describes the Inference accelerator settings for the instance type.</p>
        pub fn inference_accelerator_info(
            mut self,
            input: crate::model::InferenceAcceleratorInfo,
        ) -> Self {
            self.inference_accelerator_info = Some(input);
            self
        }
        pub fn set_inference_accelerator_info(
            mut self,
            input: std::option::Option<crate::model::InferenceAcceleratorInfo>,
        ) -> Self {
            self.inference_accelerator_info = input;
            self
        }
        /// <p>Indicates whether On-Demand hibernation is supported.</p>
        pub fn hibernation_supported(mut self, input: bool) -> Self {
            self.hibernation_supported = Some(input);
            self
        }
        pub fn set_hibernation_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.hibernation_supported = input;
            self
        }
        /// <p>Indicates whether the instance type is a burstable performance instance type.</p>
        pub fn burstable_performance_supported(mut self, input: bool) -> Self {
            self.burstable_performance_supported = Some(input);
            self
        }
        pub fn set_burstable_performance_supported(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.burstable_performance_supported = input;
            self
        }
        /// <p>Indicates whether Dedicated Hosts are supported on the instance type.</p>
        pub fn dedicated_hosts_supported(mut self, input: bool) -> Self {
            self.dedicated_hosts_supported = Some(input);
            self
        }
        pub fn set_dedicated_hosts_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.dedicated_hosts_supported = input;
            self
        }
        /// <p>Indicates whether auto recovery is supported.</p>
        pub fn auto_recovery_supported(mut self, input: bool) -> Self {
            self.auto_recovery_supported = Some(input);
            self
        }
        pub fn set_auto_recovery_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_recovery_supported = input;
            self
        }
        pub fn supported_boot_modes(
            mut self,
            input: impl Into<crate::model::BootModeType>,
        ) -> Self {
            let mut v = self.supported_boot_modes.unwrap_or_default();
            v.push(input.into());
            self.supported_boot_modes = Some(v);
            self
        }
        pub fn set_supported_boot_modes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BootModeType>>,
        ) -> Self {
            self.supported_boot_modes = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTypeInfo`](crate::model::InstanceTypeInfo)
        pub fn build(self) -> crate::model::InstanceTypeInfo {
            crate::model::InstanceTypeInfo {
                instance_type: self.instance_type,
                current_generation: self.current_generation,
                free_tier_eligible: self.free_tier_eligible,
                supported_usage_classes: self.supported_usage_classes,
                supported_root_device_types: self.supported_root_device_types,
                supported_virtualization_types: self.supported_virtualization_types,
                bare_metal: self.bare_metal,
                hypervisor: self.hypervisor,
                processor_info: self.processor_info,
                v_cpu_info: self.v_cpu_info,
                memory_info: self.memory_info,
                instance_storage_supported: self.instance_storage_supported,
                instance_storage_info: self.instance_storage_info,
                ebs_info: self.ebs_info,
                network_info: self.network_info,
                gpu_info: self.gpu_info,
                fpga_info: self.fpga_info,
                placement_group_info: self.placement_group_info,
                inference_accelerator_info: self.inference_accelerator_info,
                hibernation_supported: self.hibernation_supported,
                burstable_performance_supported: self.burstable_performance_supported,
                dedicated_hosts_supported: self.dedicated_hosts_supported,
                auto_recovery_supported: self.auto_recovery_supported,
                supported_boot_modes: self.supported_boot_modes,
            }
        }
    }
}
impl InstanceTypeInfo {
    /// Creates a new builder-style object to manufacture [`InstanceTypeInfo`](crate::model::InstanceTypeInfo)
    pub fn builder() -> crate::model::instance_type_info::Builder {
        crate::model::instance_type_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BootModeType {
    LegacyBios,
    Uefi,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BootModeType {
    fn from(s: &str) -> Self {
        match s {
            "legacy-bios" => BootModeType::LegacyBios,
            "uefi" => BootModeType::Uefi,
            other => BootModeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BootModeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BootModeType::from(s))
    }
}
impl BootModeType {
    pub fn as_str(&self) -> &str {
        match self {
            BootModeType::LegacyBios => "legacy-bios",
            BootModeType::Uefi => "uefi",
            BootModeType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["legacy-bios", "uefi"]
    }
}
impl AsRef<str> for BootModeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Inference accelerators for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceAcceleratorInfo {
    /// <p>Describes the Inference accelerators for the instance type.</p>
    pub accelerators: std::option::Option<std::vec::Vec<crate::model::InferenceDeviceInfo>>,
}
impl std::fmt::Debug for InferenceAcceleratorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceAcceleratorInfo");
        formatter.field("accelerators", &self.accelerators);
        formatter.finish()
    }
}
/// See [`InferenceAcceleratorInfo`](crate::model::InferenceAcceleratorInfo)
pub mod inference_accelerator_info {
    /// A builder for [`InferenceAcceleratorInfo`](crate::model::InferenceAcceleratorInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accelerators:
            std::option::Option<std::vec::Vec<crate::model::InferenceDeviceInfo>>,
    }
    impl Builder {
        pub fn accelerators(mut self, input: impl Into<crate::model::InferenceDeviceInfo>) -> Self {
            let mut v = self.accelerators.unwrap_or_default();
            v.push(input.into());
            self.accelerators = Some(v);
            self
        }
        pub fn set_accelerators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InferenceDeviceInfo>>,
        ) -> Self {
            self.accelerators = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceAcceleratorInfo`](crate::model::InferenceAcceleratorInfo)
        pub fn build(self) -> crate::model::InferenceAcceleratorInfo {
            crate::model::InferenceAcceleratorInfo {
                accelerators: self.accelerators,
            }
        }
    }
}
impl InferenceAcceleratorInfo {
    /// Creates a new builder-style object to manufacture [`InferenceAcceleratorInfo`](crate::model::InferenceAcceleratorInfo)
    pub fn builder() -> crate::model::inference_accelerator_info::Builder {
        crate::model::inference_accelerator_info::Builder::default()
    }
}

/// <p>Describes the Inference accelerators for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceDeviceInfo {
    /// <p>The number of Inference accelerators for the instance type.</p>
    pub count: std::option::Option<i32>,
    /// <p>The name of the Inference accelerator.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The manufacturer of the Inference accelerator.</p>
    pub manufacturer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InferenceDeviceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceDeviceInfo");
        formatter.field("count", &self.count);
        formatter.field("name", &self.name);
        formatter.field("manufacturer", &self.manufacturer);
        formatter.finish()
    }
}
/// See [`InferenceDeviceInfo`](crate::model::InferenceDeviceInfo)
pub mod inference_device_info {
    /// A builder for [`InferenceDeviceInfo`](crate::model::InferenceDeviceInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) manufacturer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of Inference accelerators for the instance type.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The name of the Inference accelerator.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The manufacturer of the Inference accelerator.</p>
        pub fn manufacturer(mut self, input: impl Into<std::string::String>) -> Self {
            self.manufacturer = Some(input.into());
            self
        }
        pub fn set_manufacturer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.manufacturer = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceDeviceInfo`](crate::model::InferenceDeviceInfo)
        pub fn build(self) -> crate::model::InferenceDeviceInfo {
            crate::model::InferenceDeviceInfo {
                count: self.count,
                name: self.name,
                manufacturer: self.manufacturer,
            }
        }
    }
}
impl InferenceDeviceInfo {
    /// Creates a new builder-style object to manufacture [`InferenceDeviceInfo`](crate::model::InferenceDeviceInfo)
    pub fn builder() -> crate::model::inference_device_info::Builder {
        crate::model::inference_device_info::Builder::default()
    }
}

/// <p>Describes the placement group support of the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlacementGroupInfo {
    /// <p>The supported placement group types.</p>
    pub supported_strategies:
        std::option::Option<std::vec::Vec<crate::model::PlacementGroupStrategy>>,
}
impl std::fmt::Debug for PlacementGroupInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlacementGroupInfo");
        formatter.field("supported_strategies", &self.supported_strategies);
        formatter.finish()
    }
}
/// See [`PlacementGroupInfo`](crate::model::PlacementGroupInfo)
pub mod placement_group_info {
    /// A builder for [`PlacementGroupInfo`](crate::model::PlacementGroupInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) supported_strategies:
            std::option::Option<std::vec::Vec<crate::model::PlacementGroupStrategy>>,
    }
    impl Builder {
        pub fn supported_strategies(
            mut self,
            input: impl Into<crate::model::PlacementGroupStrategy>,
        ) -> Self {
            let mut v = self.supported_strategies.unwrap_or_default();
            v.push(input.into());
            self.supported_strategies = Some(v);
            self
        }
        pub fn set_supported_strategies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementGroupStrategy>>,
        ) -> Self {
            self.supported_strategies = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementGroupInfo`](crate::model::PlacementGroupInfo)
        pub fn build(self) -> crate::model::PlacementGroupInfo {
            crate::model::PlacementGroupInfo {
                supported_strategies: self.supported_strategies,
            }
        }
    }
}
impl PlacementGroupInfo {
    /// Creates a new builder-style object to manufacture [`PlacementGroupInfo`](crate::model::PlacementGroupInfo)
    pub fn builder() -> crate::model::placement_group_info::Builder {
        crate::model::placement_group_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlacementGroupStrategy {
    Cluster,
    Partition,
    Spread,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlacementGroupStrategy {
    fn from(s: &str) -> Self {
        match s {
            "cluster" => PlacementGroupStrategy::Cluster,
            "partition" => PlacementGroupStrategy::Partition,
            "spread" => PlacementGroupStrategy::Spread,
            other => PlacementGroupStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlacementGroupStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlacementGroupStrategy::from(s))
    }
}
impl PlacementGroupStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            PlacementGroupStrategy::Cluster => "cluster",
            PlacementGroupStrategy::Partition => "partition",
            PlacementGroupStrategy::Spread => "spread",
            PlacementGroupStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["cluster", "partition", "spread"]
    }
}
impl AsRef<str> for PlacementGroupStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the FPGAs for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaInfo {
    /// <p>Describes the FPGAs for the instance type.</p>
    pub fpgas: std::option::Option<std::vec::Vec<crate::model::FpgaDeviceInfo>>,
    /// <p>The total memory of all FPGA accelerators for the instance type.</p>
    pub total_fpga_memory_in_mi_b: std::option::Option<i32>,
}
impl std::fmt::Debug for FpgaInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaInfo");
        formatter.field("fpgas", &self.fpgas);
        formatter.field("total_fpga_memory_in_mi_b", &self.total_fpga_memory_in_mi_b);
        formatter.finish()
    }
}
/// See [`FpgaInfo`](crate::model::FpgaInfo)
pub mod fpga_info {
    /// A builder for [`FpgaInfo`](crate::model::FpgaInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpgas: std::option::Option<std::vec::Vec<crate::model::FpgaDeviceInfo>>,
        pub(crate) total_fpga_memory_in_mi_b: std::option::Option<i32>,
    }
    impl Builder {
        pub fn fpgas(mut self, input: impl Into<crate::model::FpgaDeviceInfo>) -> Self {
            let mut v = self.fpgas.unwrap_or_default();
            v.push(input.into());
            self.fpgas = Some(v);
            self
        }
        pub fn set_fpgas(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FpgaDeviceInfo>>,
        ) -> Self {
            self.fpgas = input;
            self
        }
        /// <p>The total memory of all FPGA accelerators for the instance type.</p>
        pub fn total_fpga_memory_in_mi_b(mut self, input: i32) -> Self {
            self.total_fpga_memory_in_mi_b = Some(input);
            self
        }
        pub fn set_total_fpga_memory_in_mi_b(mut self, input: std::option::Option<i32>) -> Self {
            self.total_fpga_memory_in_mi_b = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaInfo`](crate::model::FpgaInfo)
        pub fn build(self) -> crate::model::FpgaInfo {
            crate::model::FpgaInfo {
                fpgas: self.fpgas,
                total_fpga_memory_in_mi_b: self.total_fpga_memory_in_mi_b,
            }
        }
    }
}
impl FpgaInfo {
    /// Creates a new builder-style object to manufacture [`FpgaInfo`](crate::model::FpgaInfo)
    pub fn builder() -> crate::model::fpga_info::Builder {
        crate::model::fpga_info::Builder::default()
    }
}

/// <p>Describes the FPGA accelerator for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaDeviceInfo {
    /// <p>The name of the FPGA accelerator.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The manufacturer of the FPGA accelerator.</p>
    pub manufacturer: std::option::Option<std::string::String>,
    /// <p>The count of FPGA accelerators for the instance type.</p>
    pub count: std::option::Option<i32>,
    /// <p>Describes the memory for the FPGA accelerator for the instance type.</p>
    pub memory_info: std::option::Option<crate::model::FpgaDeviceMemoryInfo>,
}
impl std::fmt::Debug for FpgaDeviceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaDeviceInfo");
        formatter.field("name", &self.name);
        formatter.field("manufacturer", &self.manufacturer);
        formatter.field("count", &self.count);
        formatter.field("memory_info", &self.memory_info);
        formatter.finish()
    }
}
/// See [`FpgaDeviceInfo`](crate::model::FpgaDeviceInfo)
pub mod fpga_device_info {
    /// A builder for [`FpgaDeviceInfo`](crate::model::FpgaDeviceInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) manufacturer: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) memory_info: std::option::Option<crate::model::FpgaDeviceMemoryInfo>,
    }
    impl Builder {
        /// <p>The name of the FPGA accelerator.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The manufacturer of the FPGA accelerator.</p>
        pub fn manufacturer(mut self, input: impl Into<std::string::String>) -> Self {
            self.manufacturer = Some(input.into());
            self
        }
        pub fn set_manufacturer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.manufacturer = input;
            self
        }
        /// <p>The count of FPGA accelerators for the instance type.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>Describes the memory for the FPGA accelerator for the instance type.</p>
        pub fn memory_info(mut self, input: crate::model::FpgaDeviceMemoryInfo) -> Self {
            self.memory_info = Some(input);
            self
        }
        pub fn set_memory_info(
            mut self,
            input: std::option::Option<crate::model::FpgaDeviceMemoryInfo>,
        ) -> Self {
            self.memory_info = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaDeviceInfo`](crate::model::FpgaDeviceInfo)
        pub fn build(self) -> crate::model::FpgaDeviceInfo {
            crate::model::FpgaDeviceInfo {
                name: self.name,
                manufacturer: self.manufacturer,
                count: self.count,
                memory_info: self.memory_info,
            }
        }
    }
}
impl FpgaDeviceInfo {
    /// Creates a new builder-style object to manufacture [`FpgaDeviceInfo`](crate::model::FpgaDeviceInfo)
    pub fn builder() -> crate::model::fpga_device_info::Builder {
        crate::model::fpga_device_info::Builder::default()
    }
}

/// <p>Describes the memory for the FPGA accelerator for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaDeviceMemoryInfo {
    /// <p>The size of the memory available to the FPGA accelerator, in MiB.</p>
    pub size_in_mi_b: std::option::Option<i32>,
}
impl std::fmt::Debug for FpgaDeviceMemoryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaDeviceMemoryInfo");
        formatter.field("size_in_mi_b", &self.size_in_mi_b);
        formatter.finish()
    }
}
/// See [`FpgaDeviceMemoryInfo`](crate::model::FpgaDeviceMemoryInfo)
pub mod fpga_device_memory_info {
    /// A builder for [`FpgaDeviceMemoryInfo`](crate::model::FpgaDeviceMemoryInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size_in_mi_b: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The size of the memory available to the FPGA accelerator, in MiB.</p>
        pub fn size_in_mi_b(mut self, input: i32) -> Self {
            self.size_in_mi_b = Some(input);
            self
        }
        pub fn set_size_in_mi_b(mut self, input: std::option::Option<i32>) -> Self {
            self.size_in_mi_b = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaDeviceMemoryInfo`](crate::model::FpgaDeviceMemoryInfo)
        pub fn build(self) -> crate::model::FpgaDeviceMemoryInfo {
            crate::model::FpgaDeviceMemoryInfo {
                size_in_mi_b: self.size_in_mi_b,
            }
        }
    }
}
impl FpgaDeviceMemoryInfo {
    /// Creates a new builder-style object to manufacture [`FpgaDeviceMemoryInfo`](crate::model::FpgaDeviceMemoryInfo)
    pub fn builder() -> crate::model::fpga_device_memory_info::Builder {
        crate::model::fpga_device_memory_info::Builder::default()
    }
}

/// <p>Describes the GPU accelerators for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GpuInfo {
    /// <p>Describes the GPU accelerators for the instance type.</p>
    pub gpus: std::option::Option<std::vec::Vec<crate::model::GpuDeviceInfo>>,
    /// <p>The total size of the memory for the GPU accelerators for the instance type, in MiB.</p>
    pub total_gpu_memory_in_mi_b: std::option::Option<i32>,
}
impl std::fmt::Debug for GpuInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GpuInfo");
        formatter.field("gpus", &self.gpus);
        formatter.field("total_gpu_memory_in_mi_b", &self.total_gpu_memory_in_mi_b);
        formatter.finish()
    }
}
/// See [`GpuInfo`](crate::model::GpuInfo)
pub mod gpu_info {
    /// A builder for [`GpuInfo`](crate::model::GpuInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gpus: std::option::Option<std::vec::Vec<crate::model::GpuDeviceInfo>>,
        pub(crate) total_gpu_memory_in_mi_b: std::option::Option<i32>,
    }
    impl Builder {
        pub fn gpus(mut self, input: impl Into<crate::model::GpuDeviceInfo>) -> Self {
            let mut v = self.gpus.unwrap_or_default();
            v.push(input.into());
            self.gpus = Some(v);
            self
        }
        pub fn set_gpus(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GpuDeviceInfo>>,
        ) -> Self {
            self.gpus = input;
            self
        }
        /// <p>The total size of the memory for the GPU accelerators for the instance type, in MiB.</p>
        pub fn total_gpu_memory_in_mi_b(mut self, input: i32) -> Self {
            self.total_gpu_memory_in_mi_b = Some(input);
            self
        }
        pub fn set_total_gpu_memory_in_mi_b(mut self, input: std::option::Option<i32>) -> Self {
            self.total_gpu_memory_in_mi_b = input;
            self
        }
        /// Consumes the builder and constructs a [`GpuInfo`](crate::model::GpuInfo)
        pub fn build(self) -> crate::model::GpuInfo {
            crate::model::GpuInfo {
                gpus: self.gpus,
                total_gpu_memory_in_mi_b: self.total_gpu_memory_in_mi_b,
            }
        }
    }
}
impl GpuInfo {
    /// Creates a new builder-style object to manufacture [`GpuInfo`](crate::model::GpuInfo)
    pub fn builder() -> crate::model::gpu_info::Builder {
        crate::model::gpu_info::Builder::default()
    }
}

/// <p>Describes the GPU accelerators for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GpuDeviceInfo {
    /// <p>The name of the GPU accelerator.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The manufacturer of the GPU accelerator.</p>
    pub manufacturer: std::option::Option<std::string::String>,
    /// <p>The number of GPUs for the instance type.</p>
    pub count: std::option::Option<i32>,
    /// <p>Describes the memory available to the GPU accelerator.</p>
    pub memory_info: std::option::Option<crate::model::GpuDeviceMemoryInfo>,
}
impl std::fmt::Debug for GpuDeviceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GpuDeviceInfo");
        formatter.field("name", &self.name);
        formatter.field("manufacturer", &self.manufacturer);
        formatter.field("count", &self.count);
        formatter.field("memory_info", &self.memory_info);
        formatter.finish()
    }
}
/// See [`GpuDeviceInfo`](crate::model::GpuDeviceInfo)
pub mod gpu_device_info {
    /// A builder for [`GpuDeviceInfo`](crate::model::GpuDeviceInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) manufacturer: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) memory_info: std::option::Option<crate::model::GpuDeviceMemoryInfo>,
    }
    impl Builder {
        /// <p>The name of the GPU accelerator.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The manufacturer of the GPU accelerator.</p>
        pub fn manufacturer(mut self, input: impl Into<std::string::String>) -> Self {
            self.manufacturer = Some(input.into());
            self
        }
        pub fn set_manufacturer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.manufacturer = input;
            self
        }
        /// <p>The number of GPUs for the instance type.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>Describes the memory available to the GPU accelerator.</p>
        pub fn memory_info(mut self, input: crate::model::GpuDeviceMemoryInfo) -> Self {
            self.memory_info = Some(input);
            self
        }
        pub fn set_memory_info(
            mut self,
            input: std::option::Option<crate::model::GpuDeviceMemoryInfo>,
        ) -> Self {
            self.memory_info = input;
            self
        }
        /// Consumes the builder and constructs a [`GpuDeviceInfo`](crate::model::GpuDeviceInfo)
        pub fn build(self) -> crate::model::GpuDeviceInfo {
            crate::model::GpuDeviceInfo {
                name: self.name,
                manufacturer: self.manufacturer,
                count: self.count,
                memory_info: self.memory_info,
            }
        }
    }
}
impl GpuDeviceInfo {
    /// Creates a new builder-style object to manufacture [`GpuDeviceInfo`](crate::model::GpuDeviceInfo)
    pub fn builder() -> crate::model::gpu_device_info::Builder {
        crate::model::gpu_device_info::Builder::default()
    }
}

/// <p>Describes the memory available to the GPU accelerator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GpuDeviceMemoryInfo {
    /// <p>The size of the memory available to the GPU accelerator, in MiB.</p>
    pub size_in_mi_b: std::option::Option<i32>,
}
impl std::fmt::Debug for GpuDeviceMemoryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GpuDeviceMemoryInfo");
        formatter.field("size_in_mi_b", &self.size_in_mi_b);
        formatter.finish()
    }
}
/// See [`GpuDeviceMemoryInfo`](crate::model::GpuDeviceMemoryInfo)
pub mod gpu_device_memory_info {
    /// A builder for [`GpuDeviceMemoryInfo`](crate::model::GpuDeviceMemoryInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size_in_mi_b: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The size of the memory available to the GPU accelerator, in MiB.</p>
        pub fn size_in_mi_b(mut self, input: i32) -> Self {
            self.size_in_mi_b = Some(input);
            self
        }
        pub fn set_size_in_mi_b(mut self, input: std::option::Option<i32>) -> Self {
            self.size_in_mi_b = input;
            self
        }
        /// Consumes the builder and constructs a [`GpuDeviceMemoryInfo`](crate::model::GpuDeviceMemoryInfo)
        pub fn build(self) -> crate::model::GpuDeviceMemoryInfo {
            crate::model::GpuDeviceMemoryInfo {
                size_in_mi_b: self.size_in_mi_b,
            }
        }
    }
}
impl GpuDeviceMemoryInfo {
    /// Creates a new builder-style object to manufacture [`GpuDeviceMemoryInfo`](crate::model::GpuDeviceMemoryInfo)
    pub fn builder() -> crate::model::gpu_device_memory_info::Builder {
        crate::model::gpu_device_memory_info::Builder::default()
    }
}

/// <p>Describes the networking features of the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInfo {
    /// <p>The network performance.</p>
    pub network_performance: std::option::Option<std::string::String>,
    /// <p>The maximum number of network interfaces for the instance type.</p>
    pub maximum_network_interfaces: std::option::Option<i32>,
    /// <p>The maximum number of physical network cards that can be allocated to the instance.</p>
    pub maximum_network_cards: std::option::Option<i32>,
    /// <p>The index of the default network card, starting at 0.</p>
    pub default_network_card_index: std::option::Option<i32>,
    /// <p>Describes the network cards for the instance type.</p>
    pub network_cards: std::option::Option<std::vec::Vec<crate::model::NetworkCardInfo>>,
    /// <p>The maximum number of IPv4 addresses per network interface.</p>
    pub ipv4_addresses_per_interface: std::option::Option<i32>,
    /// <p>The maximum number of IPv6 addresses per network interface.</p>
    pub ipv6_addresses_per_interface: std::option::Option<i32>,
    /// <p>Indicates whether IPv6 is supported.</p>
    pub ipv6_supported: std::option::Option<bool>,
    /// <p>Indicates whether Elastic Network Adapter (ENA) is supported.</p>
    pub ena_support: std::option::Option<crate::model::EnaSupport>,
    /// <p>Indicates whether Elastic Fabric Adapter (EFA) is supported.</p>
    pub efa_supported: std::option::Option<bool>,
    /// <p>Describes the Elastic Fabric Adapters for the instance type.</p>
    pub efa_info: std::option::Option<crate::model::EfaInfo>,
    /// <p>Indicates whether the instance type automatically encrypts in-transit traffic between instances.</p>
    pub encryption_in_transit_supported: std::option::Option<bool>,
}
impl std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInfo");
        formatter.field("network_performance", &self.network_performance);
        formatter.field(
            "maximum_network_interfaces",
            &self.maximum_network_interfaces,
        );
        formatter.field("maximum_network_cards", &self.maximum_network_cards);
        formatter.field(
            "default_network_card_index",
            &self.default_network_card_index,
        );
        formatter.field("network_cards", &self.network_cards);
        formatter.field(
            "ipv4_addresses_per_interface",
            &self.ipv4_addresses_per_interface,
        );
        formatter.field(
            "ipv6_addresses_per_interface",
            &self.ipv6_addresses_per_interface,
        );
        formatter.field("ipv6_supported", &self.ipv6_supported);
        formatter.field("ena_support", &self.ena_support);
        formatter.field("efa_supported", &self.efa_supported);
        formatter.field("efa_info", &self.efa_info);
        formatter.field(
            "encryption_in_transit_supported",
            &self.encryption_in_transit_supported,
        );
        formatter.finish()
    }
}
/// See [`NetworkInfo`](crate::model::NetworkInfo)
pub mod network_info {
    /// A builder for [`NetworkInfo`](crate::model::NetworkInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_performance: std::option::Option<std::string::String>,
        pub(crate) maximum_network_interfaces: std::option::Option<i32>,
        pub(crate) maximum_network_cards: std::option::Option<i32>,
        pub(crate) default_network_card_index: std::option::Option<i32>,
        pub(crate) network_cards: std::option::Option<std::vec::Vec<crate::model::NetworkCardInfo>>,
        pub(crate) ipv4_addresses_per_interface: std::option::Option<i32>,
        pub(crate) ipv6_addresses_per_interface: std::option::Option<i32>,
        pub(crate) ipv6_supported: std::option::Option<bool>,
        pub(crate) ena_support: std::option::Option<crate::model::EnaSupport>,
        pub(crate) efa_supported: std::option::Option<bool>,
        pub(crate) efa_info: std::option::Option<crate::model::EfaInfo>,
        pub(crate) encryption_in_transit_supported: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The network performance.</p>
        pub fn network_performance(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_performance = Some(input.into());
            self
        }
        pub fn set_network_performance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_performance = input;
            self
        }
        /// <p>The maximum number of network interfaces for the instance type.</p>
        pub fn maximum_network_interfaces(mut self, input: i32) -> Self {
            self.maximum_network_interfaces = Some(input);
            self
        }
        pub fn set_maximum_network_interfaces(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_network_interfaces = input;
            self
        }
        /// <p>The maximum number of physical network cards that can be allocated to the instance.</p>
        pub fn maximum_network_cards(mut self, input: i32) -> Self {
            self.maximum_network_cards = Some(input);
            self
        }
        pub fn set_maximum_network_cards(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_network_cards = input;
            self
        }
        /// <p>The index of the default network card, starting at 0.</p>
        pub fn default_network_card_index(mut self, input: i32) -> Self {
            self.default_network_card_index = Some(input);
            self
        }
        pub fn set_default_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.default_network_card_index = input;
            self
        }
        pub fn network_cards(mut self, input: impl Into<crate::model::NetworkCardInfo>) -> Self {
            let mut v = self.network_cards.unwrap_or_default();
            v.push(input.into());
            self.network_cards = Some(v);
            self
        }
        pub fn set_network_cards(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkCardInfo>>,
        ) -> Self {
            self.network_cards = input;
            self
        }
        /// <p>The maximum number of IPv4 addresses per network interface.</p>
        pub fn ipv4_addresses_per_interface(mut self, input: i32) -> Self {
            self.ipv4_addresses_per_interface = Some(input);
            self
        }
        pub fn set_ipv4_addresses_per_interface(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv4_addresses_per_interface = input;
            self
        }
        /// <p>The maximum number of IPv6 addresses per network interface.</p>
        pub fn ipv6_addresses_per_interface(mut self, input: i32) -> Self {
            self.ipv6_addresses_per_interface = Some(input);
            self
        }
        pub fn set_ipv6_addresses_per_interface(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_addresses_per_interface = input;
            self
        }
        /// <p>Indicates whether IPv6 is supported.</p>
        pub fn ipv6_supported(mut self, input: bool) -> Self {
            self.ipv6_supported = Some(input);
            self
        }
        pub fn set_ipv6_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.ipv6_supported = input;
            self
        }
        /// <p>Indicates whether Elastic Network Adapter (ENA) is supported.</p>
        pub fn ena_support(mut self, input: crate::model::EnaSupport) -> Self {
            self.ena_support = Some(input);
            self
        }
        pub fn set_ena_support(
            mut self,
            input: std::option::Option<crate::model::EnaSupport>,
        ) -> Self {
            self.ena_support = input;
            self
        }
        /// <p>Indicates whether Elastic Fabric Adapter (EFA) is supported.</p>
        pub fn efa_supported(mut self, input: bool) -> Self {
            self.efa_supported = Some(input);
            self
        }
        pub fn set_efa_supported(mut self, input: std::option::Option<bool>) -> Self {
            self.efa_supported = input;
            self
        }
        /// <p>Describes the Elastic Fabric Adapters for the instance type.</p>
        pub fn efa_info(mut self, input: crate::model::EfaInfo) -> Self {
            self.efa_info = Some(input);
            self
        }
        pub fn set_efa_info(mut self, input: std::option::Option<crate::model::EfaInfo>) -> Self {
            self.efa_info = input;
            self
        }
        /// <p>Indicates whether the instance type automatically encrypts in-transit traffic between instances.</p>
        pub fn encryption_in_transit_supported(mut self, input: bool) -> Self {
            self.encryption_in_transit_supported = Some(input);
            self
        }
        pub fn set_encryption_in_transit_supported(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.encryption_in_transit_supported = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInfo`](crate::model::NetworkInfo)
        pub fn build(self) -> crate::model::NetworkInfo {
            crate::model::NetworkInfo {
                network_performance: self.network_performance,
                maximum_network_interfaces: self.maximum_network_interfaces,
                maximum_network_cards: self.maximum_network_cards,
                default_network_card_index: self.default_network_card_index,
                network_cards: self.network_cards,
                ipv4_addresses_per_interface: self.ipv4_addresses_per_interface,
                ipv6_addresses_per_interface: self.ipv6_addresses_per_interface,
                ipv6_supported: self.ipv6_supported,
                ena_support: self.ena_support,
                efa_supported: self.efa_supported,
                efa_info: self.efa_info,
                encryption_in_transit_supported: self.encryption_in_transit_supported,
            }
        }
    }
}
impl NetworkInfo {
    /// Creates a new builder-style object to manufacture [`NetworkInfo`](crate::model::NetworkInfo)
    pub fn builder() -> crate::model::network_info::Builder {
        crate::model::network_info::Builder::default()
    }
}

/// <p>Describes the Elastic Fabric Adapters for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EfaInfo {
    /// <p>The maximum number of Elastic Fabric Adapters for the instance type.</p>
    pub maximum_efa_interfaces: std::option::Option<i32>,
}
impl std::fmt::Debug for EfaInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EfaInfo");
        formatter.field("maximum_efa_interfaces", &self.maximum_efa_interfaces);
        formatter.finish()
    }
}
/// See [`EfaInfo`](crate::model::EfaInfo)
pub mod efa_info {
    /// A builder for [`EfaInfo`](crate::model::EfaInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_efa_interfaces: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of Elastic Fabric Adapters for the instance type.</p>
        pub fn maximum_efa_interfaces(mut self, input: i32) -> Self {
            self.maximum_efa_interfaces = Some(input);
            self
        }
        pub fn set_maximum_efa_interfaces(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_efa_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`EfaInfo`](crate::model::EfaInfo)
        pub fn build(self) -> crate::model::EfaInfo {
            crate::model::EfaInfo {
                maximum_efa_interfaces: self.maximum_efa_interfaces,
            }
        }
    }
}
impl EfaInfo {
    /// Creates a new builder-style object to manufacture [`EfaInfo`](crate::model::EfaInfo)
    pub fn builder() -> crate::model::efa_info::Builder {
        crate::model::efa_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnaSupport {
    Required,
    Supported,
    Unsupported,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EnaSupport {
    fn from(s: &str) -> Self {
        match s {
            "required" => EnaSupport::Required,
            "supported" => EnaSupport::Supported,
            "unsupported" => EnaSupport::Unsupported,
            other => EnaSupport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EnaSupport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnaSupport::from(s))
    }
}
impl EnaSupport {
    pub fn as_str(&self) -> &str {
        match self {
            EnaSupport::Required => "required",
            EnaSupport::Supported => "supported",
            EnaSupport::Unsupported => "unsupported",
            EnaSupport::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["required", "supported", "unsupported"]
    }
}
impl AsRef<str> for EnaSupport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the network card support of the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkCardInfo {
    /// <p>The index of the network card.</p>
    pub network_card_index: std::option::Option<i32>,
    /// <p>The network performance of the network card.</p>
    pub network_performance: std::option::Option<std::string::String>,
    /// <p>The maximum number of network interfaces for the network card.</p>
    pub maximum_network_interfaces: std::option::Option<i32>,
}
impl std::fmt::Debug for NetworkCardInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkCardInfo");
        formatter.field("network_card_index", &self.network_card_index);
        formatter.field("network_performance", &self.network_performance);
        formatter.field(
            "maximum_network_interfaces",
            &self.maximum_network_interfaces,
        );
        formatter.finish()
    }
}
/// See [`NetworkCardInfo`](crate::model::NetworkCardInfo)
pub mod network_card_info {
    /// A builder for [`NetworkCardInfo`](crate::model::NetworkCardInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_card_index: std::option::Option<i32>,
        pub(crate) network_performance: std::option::Option<std::string::String>,
        pub(crate) maximum_network_interfaces: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The index of the network card.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        /// <p>The network performance of the network card.</p>
        pub fn network_performance(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_performance = Some(input.into());
            self
        }
        pub fn set_network_performance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_performance = input;
            self
        }
        /// <p>The maximum number of network interfaces for the network card.</p>
        pub fn maximum_network_interfaces(mut self, input: i32) -> Self {
            self.maximum_network_interfaces = Some(input);
            self
        }
        pub fn set_maximum_network_interfaces(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_network_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkCardInfo`](crate::model::NetworkCardInfo)
        pub fn build(self) -> crate::model::NetworkCardInfo {
            crate::model::NetworkCardInfo {
                network_card_index: self.network_card_index,
                network_performance: self.network_performance,
                maximum_network_interfaces: self.maximum_network_interfaces,
            }
        }
    }
}
impl NetworkCardInfo {
    /// Creates a new builder-style object to manufacture [`NetworkCardInfo`](crate::model::NetworkCardInfo)
    pub fn builder() -> crate::model::network_card_info::Builder {
        crate::model::network_card_info::Builder::default()
    }
}

/// <p>Describes the Amazon EBS features supported by the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsInfo {
    /// <p>Indicates whether the instance type is Amazon EBS-optimized. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html">Amazon EBS-optimized
    /// instances</a> in <i>Amazon EC2 User Guide</i>.</p>
    pub ebs_optimized_support: std::option::Option<crate::model::EbsOptimizedSupport>,
    /// <p>Indicates whether Amazon EBS encryption is supported.</p>
    pub encryption_support: std::option::Option<crate::model::EbsEncryptionSupport>,
    /// <p>Describes the optimized EBS performance for the instance type.</p>
    pub ebs_optimized_info: std::option::Option<crate::model::EbsOptimizedInfo>,
    /// <p>Indicates whether non-volatile memory express (NVMe) is supported.</p>
    pub nvme_support: std::option::Option<crate::model::EbsNvmeSupport>,
}
impl std::fmt::Debug for EbsInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsInfo");
        formatter.field("ebs_optimized_support", &self.ebs_optimized_support);
        formatter.field("encryption_support", &self.encryption_support);
        formatter.field("ebs_optimized_info", &self.ebs_optimized_info);
        formatter.field("nvme_support", &self.nvme_support);
        formatter.finish()
    }
}
/// See [`EbsInfo`](crate::model::EbsInfo)
pub mod ebs_info {
    /// A builder for [`EbsInfo`](crate::model::EbsInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_optimized_support: std::option::Option<crate::model::EbsOptimizedSupport>,
        pub(crate) encryption_support: std::option::Option<crate::model::EbsEncryptionSupport>,
        pub(crate) ebs_optimized_info: std::option::Option<crate::model::EbsOptimizedInfo>,
        pub(crate) nvme_support: std::option::Option<crate::model::EbsNvmeSupport>,
    }
    impl Builder {
        /// <p>Indicates whether the instance type is Amazon EBS-optimized. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html">Amazon EBS-optimized
        /// instances</a> in <i>Amazon EC2 User Guide</i>.</p>
        pub fn ebs_optimized_support(mut self, input: crate::model::EbsOptimizedSupport) -> Self {
            self.ebs_optimized_support = Some(input);
            self
        }
        pub fn set_ebs_optimized_support(
            mut self,
            input: std::option::Option<crate::model::EbsOptimizedSupport>,
        ) -> Self {
            self.ebs_optimized_support = input;
            self
        }
        /// <p>Indicates whether Amazon EBS encryption is supported.</p>
        pub fn encryption_support(mut self, input: crate::model::EbsEncryptionSupport) -> Self {
            self.encryption_support = Some(input);
            self
        }
        pub fn set_encryption_support(
            mut self,
            input: std::option::Option<crate::model::EbsEncryptionSupport>,
        ) -> Self {
            self.encryption_support = input;
            self
        }
        /// <p>Describes the optimized EBS performance for the instance type.</p>
        pub fn ebs_optimized_info(mut self, input: crate::model::EbsOptimizedInfo) -> Self {
            self.ebs_optimized_info = Some(input);
            self
        }
        pub fn set_ebs_optimized_info(
            mut self,
            input: std::option::Option<crate::model::EbsOptimizedInfo>,
        ) -> Self {
            self.ebs_optimized_info = input;
            self
        }
        /// <p>Indicates whether non-volatile memory express (NVMe) is supported.</p>
        pub fn nvme_support(mut self, input: crate::model::EbsNvmeSupport) -> Self {
            self.nvme_support = Some(input);
            self
        }
        pub fn set_nvme_support(
            mut self,
            input: std::option::Option<crate::model::EbsNvmeSupport>,
        ) -> Self {
            self.nvme_support = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsInfo`](crate::model::EbsInfo)
        pub fn build(self) -> crate::model::EbsInfo {
            crate::model::EbsInfo {
                ebs_optimized_support: self.ebs_optimized_support,
                encryption_support: self.encryption_support,
                ebs_optimized_info: self.ebs_optimized_info,
                nvme_support: self.nvme_support,
            }
        }
    }
}
impl EbsInfo {
    /// Creates a new builder-style object to manufacture [`EbsInfo`](crate::model::EbsInfo)
    pub fn builder() -> crate::model::ebs_info::Builder {
        crate::model::ebs_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EbsNvmeSupport {
    Required,
    Supported,
    Unsupported,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EbsNvmeSupport {
    fn from(s: &str) -> Self {
        match s {
            "required" => EbsNvmeSupport::Required,
            "supported" => EbsNvmeSupport::Supported,
            "unsupported" => EbsNvmeSupport::Unsupported,
            other => EbsNvmeSupport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EbsNvmeSupport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EbsNvmeSupport::from(s))
    }
}
impl EbsNvmeSupport {
    pub fn as_str(&self) -> &str {
        match self {
            EbsNvmeSupport::Required => "required",
            EbsNvmeSupport::Supported => "supported",
            EbsNvmeSupport::Unsupported => "unsupported",
            EbsNvmeSupport::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["required", "supported", "unsupported"]
    }
}
impl AsRef<str> for EbsNvmeSupport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the optimized EBS performance for supported instance types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsOptimizedInfo {
    /// <p>The baseline bandwidth performance for an EBS-optimized instance type, in Mbps.</p>
    pub baseline_bandwidth_in_mbps: std::option::Option<i32>,
    /// <p>The baseline throughput performance for an EBS-optimized instance type, in MB/s.</p>
    pub baseline_throughput_in_m_bps: std::option::Option<f64>,
    /// <p>The baseline input/output storage operations per seconds for an EBS-optimized instance type.</p>
    pub baseline_iops: std::option::Option<i32>,
    /// <p>The maximum bandwidth performance for an EBS-optimized instance type, in Mbps.</p>
    pub maximum_bandwidth_in_mbps: std::option::Option<i32>,
    /// <p>The maximum throughput performance for an EBS-optimized instance type, in MB/s.</p>
    pub maximum_throughput_in_m_bps: std::option::Option<f64>,
    /// <p>The maximum input/output storage operations per second for an EBS-optimized instance type.</p>
    pub maximum_iops: std::option::Option<i32>,
}
impl std::fmt::Debug for EbsOptimizedInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsOptimizedInfo");
        formatter.field(
            "baseline_bandwidth_in_mbps",
            &self.baseline_bandwidth_in_mbps,
        );
        formatter.field(
            "baseline_throughput_in_m_bps",
            &self.baseline_throughput_in_m_bps,
        );
        formatter.field("baseline_iops", &self.baseline_iops);
        formatter.field("maximum_bandwidth_in_mbps", &self.maximum_bandwidth_in_mbps);
        formatter.field(
            "maximum_throughput_in_m_bps",
            &self.maximum_throughput_in_m_bps,
        );
        formatter.field("maximum_iops", &self.maximum_iops);
        formatter.finish()
    }
}
/// See [`EbsOptimizedInfo`](crate::model::EbsOptimizedInfo)
pub mod ebs_optimized_info {
    /// A builder for [`EbsOptimizedInfo`](crate::model::EbsOptimizedInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baseline_bandwidth_in_mbps: std::option::Option<i32>,
        pub(crate) baseline_throughput_in_m_bps: std::option::Option<f64>,
        pub(crate) baseline_iops: std::option::Option<i32>,
        pub(crate) maximum_bandwidth_in_mbps: std::option::Option<i32>,
        pub(crate) maximum_throughput_in_m_bps: std::option::Option<f64>,
        pub(crate) maximum_iops: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The baseline bandwidth performance for an EBS-optimized instance type, in Mbps.</p>
        pub fn baseline_bandwidth_in_mbps(mut self, input: i32) -> Self {
            self.baseline_bandwidth_in_mbps = Some(input);
            self
        }
        pub fn set_baseline_bandwidth_in_mbps(mut self, input: std::option::Option<i32>) -> Self {
            self.baseline_bandwidth_in_mbps = input;
            self
        }
        /// <p>The baseline throughput performance for an EBS-optimized instance type, in MB/s.</p>
        pub fn baseline_throughput_in_m_bps(mut self, input: f64) -> Self {
            self.baseline_throughput_in_m_bps = Some(input);
            self
        }
        pub fn set_baseline_throughput_in_m_bps(mut self, input: std::option::Option<f64>) -> Self {
            self.baseline_throughput_in_m_bps = input;
            self
        }
        /// <p>The baseline input/output storage operations per seconds for an EBS-optimized instance type.</p>
        pub fn baseline_iops(mut self, input: i32) -> Self {
            self.baseline_iops = Some(input);
            self
        }
        pub fn set_baseline_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.baseline_iops = input;
            self
        }
        /// <p>The maximum bandwidth performance for an EBS-optimized instance type, in Mbps.</p>
        pub fn maximum_bandwidth_in_mbps(mut self, input: i32) -> Self {
            self.maximum_bandwidth_in_mbps = Some(input);
            self
        }
        pub fn set_maximum_bandwidth_in_mbps(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_bandwidth_in_mbps = input;
            self
        }
        /// <p>The maximum throughput performance for an EBS-optimized instance type, in MB/s.</p>
        pub fn maximum_throughput_in_m_bps(mut self, input: f64) -> Self {
            self.maximum_throughput_in_m_bps = Some(input);
            self
        }
        pub fn set_maximum_throughput_in_m_bps(mut self, input: std::option::Option<f64>) -> Self {
            self.maximum_throughput_in_m_bps = input;
            self
        }
        /// <p>The maximum input/output storage operations per second for an EBS-optimized instance type.</p>
        pub fn maximum_iops(mut self, input: i32) -> Self {
            self.maximum_iops = Some(input);
            self
        }
        pub fn set_maximum_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_iops = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsOptimizedInfo`](crate::model::EbsOptimizedInfo)
        pub fn build(self) -> crate::model::EbsOptimizedInfo {
            crate::model::EbsOptimizedInfo {
                baseline_bandwidth_in_mbps: self.baseline_bandwidth_in_mbps,
                baseline_throughput_in_m_bps: self.baseline_throughput_in_m_bps,
                baseline_iops: self.baseline_iops,
                maximum_bandwidth_in_mbps: self.maximum_bandwidth_in_mbps,
                maximum_throughput_in_m_bps: self.maximum_throughput_in_m_bps,
                maximum_iops: self.maximum_iops,
            }
        }
    }
}
impl EbsOptimizedInfo {
    /// Creates a new builder-style object to manufacture [`EbsOptimizedInfo`](crate::model::EbsOptimizedInfo)
    pub fn builder() -> crate::model::ebs_optimized_info::Builder {
        crate::model::ebs_optimized_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EbsEncryptionSupport {
    Supported,
    Unsupported,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EbsEncryptionSupport {
    fn from(s: &str) -> Self {
        match s {
            "supported" => EbsEncryptionSupport::Supported,
            "unsupported" => EbsEncryptionSupport::Unsupported,
            other => EbsEncryptionSupport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EbsEncryptionSupport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EbsEncryptionSupport::from(s))
    }
}
impl EbsEncryptionSupport {
    pub fn as_str(&self) -> &str {
        match self {
            EbsEncryptionSupport::Supported => "supported",
            EbsEncryptionSupport::Unsupported => "unsupported",
            EbsEncryptionSupport::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["supported", "unsupported"]
    }
}
impl AsRef<str> for EbsEncryptionSupport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EbsOptimizedSupport {
    Default,
    Supported,
    Unsupported,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EbsOptimizedSupport {
    fn from(s: &str) -> Self {
        match s {
            "default" => EbsOptimizedSupport::Default,
            "supported" => EbsOptimizedSupport::Supported,
            "unsupported" => EbsOptimizedSupport::Unsupported,
            other => EbsOptimizedSupport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EbsOptimizedSupport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EbsOptimizedSupport::from(s))
    }
}
impl EbsOptimizedSupport {
    pub fn as_str(&self) -> &str {
        match self {
            EbsOptimizedSupport::Default => "default",
            EbsOptimizedSupport::Supported => "supported",
            EbsOptimizedSupport::Unsupported => "unsupported",
            EbsOptimizedSupport::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["default", "supported", "unsupported"]
    }
}
impl AsRef<str> for EbsOptimizedSupport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the disks that are available for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStorageInfo {
    /// <p>The total size of the disks, in GB.</p>
    pub total_size_in_gb: std::option::Option<i64>,
    /// <p>Describes the disks that are available for the instance type.</p>
    pub disks: std::option::Option<std::vec::Vec<crate::model::DiskInfo>>,
    /// <p>Indicates whether non-volatile memory express (NVMe) is supported for instance store.</p>
    pub nvme_support: std::option::Option<crate::model::EphemeralNvmeSupport>,
}
impl std::fmt::Debug for InstanceStorageInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStorageInfo");
        formatter.field("total_size_in_gb", &self.total_size_in_gb);
        formatter.field("disks", &self.disks);
        formatter.field("nvme_support", &self.nvme_support);
        formatter.finish()
    }
}
/// See [`InstanceStorageInfo`](crate::model::InstanceStorageInfo)
pub mod instance_storage_info {
    /// A builder for [`InstanceStorageInfo`](crate::model::InstanceStorageInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_size_in_gb: std::option::Option<i64>,
        pub(crate) disks: std::option::Option<std::vec::Vec<crate::model::DiskInfo>>,
        pub(crate) nvme_support: std::option::Option<crate::model::EphemeralNvmeSupport>,
    }
    impl Builder {
        /// <p>The total size of the disks, in GB.</p>
        pub fn total_size_in_gb(mut self, input: i64) -> Self {
            self.total_size_in_gb = Some(input);
            self
        }
        pub fn set_total_size_in_gb(mut self, input: std::option::Option<i64>) -> Self {
            self.total_size_in_gb = input;
            self
        }
        pub fn disks(mut self, input: impl Into<crate::model::DiskInfo>) -> Self {
            let mut v = self.disks.unwrap_or_default();
            v.push(input.into());
            self.disks = Some(v);
            self
        }
        pub fn set_disks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DiskInfo>>,
        ) -> Self {
            self.disks = input;
            self
        }
        /// <p>Indicates whether non-volatile memory express (NVMe) is supported for instance store.</p>
        pub fn nvme_support(mut self, input: crate::model::EphemeralNvmeSupport) -> Self {
            self.nvme_support = Some(input);
            self
        }
        pub fn set_nvme_support(
            mut self,
            input: std::option::Option<crate::model::EphemeralNvmeSupport>,
        ) -> Self {
            self.nvme_support = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStorageInfo`](crate::model::InstanceStorageInfo)
        pub fn build(self) -> crate::model::InstanceStorageInfo {
            crate::model::InstanceStorageInfo {
                total_size_in_gb: self.total_size_in_gb,
                disks: self.disks,
                nvme_support: self.nvme_support,
            }
        }
    }
}
impl InstanceStorageInfo {
    /// Creates a new builder-style object to manufacture [`InstanceStorageInfo`](crate::model::InstanceStorageInfo)
    pub fn builder() -> crate::model::instance_storage_info::Builder {
        crate::model::instance_storage_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EphemeralNvmeSupport {
    Required,
    Supported,
    Unsupported,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EphemeralNvmeSupport {
    fn from(s: &str) -> Self {
        match s {
            "required" => EphemeralNvmeSupport::Required,
            "supported" => EphemeralNvmeSupport::Supported,
            "unsupported" => EphemeralNvmeSupport::Unsupported,
            other => EphemeralNvmeSupport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EphemeralNvmeSupport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EphemeralNvmeSupport::from(s))
    }
}
impl EphemeralNvmeSupport {
    pub fn as_str(&self) -> &str {
        match self {
            EphemeralNvmeSupport::Required => "required",
            EphemeralNvmeSupport::Supported => "supported",
            EphemeralNvmeSupport::Unsupported => "unsupported",
            EphemeralNvmeSupport::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["required", "supported", "unsupported"]
    }
}
impl AsRef<str> for EphemeralNvmeSupport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the disk.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskInfo {
    /// <p>The size of the disk in GB.</p>
    pub size_in_gb: std::option::Option<i64>,
    /// <p>The number of disks with this configuration.</p>
    pub count: std::option::Option<i32>,
    /// <p>The type of disk.</p>
    pub r#type: std::option::Option<crate::model::DiskType>,
}
impl std::fmt::Debug for DiskInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskInfo");
        formatter.field("size_in_gb", &self.size_in_gb);
        formatter.field("count", &self.count);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`DiskInfo`](crate::model::DiskInfo)
pub mod disk_info {
    /// A builder for [`DiskInfo`](crate::model::DiskInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size_in_gb: std::option::Option<i64>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::DiskType>,
    }
    impl Builder {
        /// <p>The size of the disk in GB.</p>
        pub fn size_in_gb(mut self, input: i64) -> Self {
            self.size_in_gb = Some(input);
            self
        }
        pub fn set_size_in_gb(mut self, input: std::option::Option<i64>) -> Self {
            self.size_in_gb = input;
            self
        }
        /// <p>The number of disks with this configuration.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The type of disk.</p>
        pub fn r#type(mut self, input: crate::model::DiskType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::DiskType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskInfo`](crate::model::DiskInfo)
        pub fn build(self) -> crate::model::DiskInfo {
            crate::model::DiskInfo {
                size_in_gb: self.size_in_gb,
                count: self.count,
                r#type: self.r#type,
            }
        }
    }
}
impl DiskInfo {
    /// Creates a new builder-style object to manufacture [`DiskInfo`](crate::model::DiskInfo)
    pub fn builder() -> crate::model::disk_info::Builder {
        crate::model::disk_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DiskType {
    Hdd,
    Ssd,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DiskType {
    fn from(s: &str) -> Self {
        match s {
            "hdd" => DiskType::Hdd,
            "ssd" => DiskType::Ssd,
            other => DiskType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DiskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DiskType::from(s))
    }
}
impl DiskType {
    pub fn as_str(&self) -> &str {
        match self {
            DiskType::Hdd => "hdd",
            DiskType::Ssd => "ssd",
            DiskType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["hdd", "ssd"]
    }
}
impl AsRef<str> for DiskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the memory for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MemoryInfo {
    /// <p>The size of the memory, in MiB.</p>
    pub size_in_mi_b: std::option::Option<i64>,
}
impl std::fmt::Debug for MemoryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MemoryInfo");
        formatter.field("size_in_mi_b", &self.size_in_mi_b);
        formatter.finish()
    }
}
/// See [`MemoryInfo`](crate::model::MemoryInfo)
pub mod memory_info {
    /// A builder for [`MemoryInfo`](crate::model::MemoryInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size_in_mi_b: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The size of the memory, in MiB.</p>
        pub fn size_in_mi_b(mut self, input: i64) -> Self {
            self.size_in_mi_b = Some(input);
            self
        }
        pub fn set_size_in_mi_b(mut self, input: std::option::Option<i64>) -> Self {
            self.size_in_mi_b = input;
            self
        }
        /// Consumes the builder and constructs a [`MemoryInfo`](crate::model::MemoryInfo)
        pub fn build(self) -> crate::model::MemoryInfo {
            crate::model::MemoryInfo {
                size_in_mi_b: self.size_in_mi_b,
            }
        }
    }
}
impl MemoryInfo {
    /// Creates a new builder-style object to manufacture [`MemoryInfo`](crate::model::MemoryInfo)
    pub fn builder() -> crate::model::memory_info::Builder {
        crate::model::memory_info::Builder::default()
    }
}

/// <p>Describes the vCPU configurations for the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VCpuInfo {
    /// <p>The default number of vCPUs for the instance type.</p>
    pub default_v_cpus: std::option::Option<i32>,
    /// <p>The default number of cores for the instance type.</p>
    pub default_cores: std::option::Option<i32>,
    /// <p>The default number of threads per core for the instance type.</p>
    pub default_threads_per_core: std::option::Option<i32>,
    /// <p>The valid number of cores that can be configured for the instance type.</p>
    pub valid_cores: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The valid number of threads per core that can be configured for the instance type. </p>
    pub valid_threads_per_core: std::option::Option<std::vec::Vec<i32>>,
}
impl std::fmt::Debug for VCpuInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VCpuInfo");
        formatter.field("default_v_cpus", &self.default_v_cpus);
        formatter.field("default_cores", &self.default_cores);
        formatter.field("default_threads_per_core", &self.default_threads_per_core);
        formatter.field("valid_cores", &self.valid_cores);
        formatter.field("valid_threads_per_core", &self.valid_threads_per_core);
        formatter.finish()
    }
}
/// See [`VCpuInfo`](crate::model::VCpuInfo)
pub mod v_cpu_info {
    /// A builder for [`VCpuInfo`](crate::model::VCpuInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_v_cpus: std::option::Option<i32>,
        pub(crate) default_cores: std::option::Option<i32>,
        pub(crate) default_threads_per_core: std::option::Option<i32>,
        pub(crate) valid_cores: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) valid_threads_per_core: std::option::Option<std::vec::Vec<i32>>,
    }
    impl Builder {
        /// <p>The default number of vCPUs for the instance type.</p>
        pub fn default_v_cpus(mut self, input: i32) -> Self {
            self.default_v_cpus = Some(input);
            self
        }
        pub fn set_default_v_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.default_v_cpus = input;
            self
        }
        /// <p>The default number of cores for the instance type.</p>
        pub fn default_cores(mut self, input: i32) -> Self {
            self.default_cores = Some(input);
            self
        }
        pub fn set_default_cores(mut self, input: std::option::Option<i32>) -> Self {
            self.default_cores = input;
            self
        }
        /// <p>The default number of threads per core for the instance type.</p>
        pub fn default_threads_per_core(mut self, input: i32) -> Self {
            self.default_threads_per_core = Some(input);
            self
        }
        pub fn set_default_threads_per_core(mut self, input: std::option::Option<i32>) -> Self {
            self.default_threads_per_core = input;
            self
        }
        pub fn valid_cores(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.valid_cores.unwrap_or_default();
            v.push(input.into());
            self.valid_cores = Some(v);
            self
        }
        pub fn set_valid_cores(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.valid_cores = input;
            self
        }
        pub fn valid_threads_per_core(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.valid_threads_per_core.unwrap_or_default();
            v.push(input.into());
            self.valid_threads_per_core = Some(v);
            self
        }
        pub fn set_valid_threads_per_core(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.valid_threads_per_core = input;
            self
        }
        /// Consumes the builder and constructs a [`VCpuInfo`](crate::model::VCpuInfo)
        pub fn build(self) -> crate::model::VCpuInfo {
            crate::model::VCpuInfo {
                default_v_cpus: self.default_v_cpus,
                default_cores: self.default_cores,
                default_threads_per_core: self.default_threads_per_core,
                valid_cores: self.valid_cores,
                valid_threads_per_core: self.valid_threads_per_core,
            }
        }
    }
}
impl VCpuInfo {
    /// Creates a new builder-style object to manufacture [`VCpuInfo`](crate::model::VCpuInfo)
    pub fn builder() -> crate::model::v_cpu_info::Builder {
        crate::model::v_cpu_info::Builder::default()
    }
}

/// <p>Describes the processor used by the instance type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessorInfo {
    /// <p>The architectures supported by the instance type.</p>
    pub supported_architectures: std::option::Option<std::vec::Vec<crate::model::ArchitectureType>>,
    /// <p>The speed of the processor, in GHz.</p>
    pub sustained_clock_speed_in_ghz: std::option::Option<f64>,
}
impl std::fmt::Debug for ProcessorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessorInfo");
        formatter.field("supported_architectures", &self.supported_architectures);
        formatter.field(
            "sustained_clock_speed_in_ghz",
            &self.sustained_clock_speed_in_ghz,
        );
        formatter.finish()
    }
}
/// See [`ProcessorInfo`](crate::model::ProcessorInfo)
pub mod processor_info {
    /// A builder for [`ProcessorInfo`](crate::model::ProcessorInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) supported_architectures:
            std::option::Option<std::vec::Vec<crate::model::ArchitectureType>>,
        pub(crate) sustained_clock_speed_in_ghz: std::option::Option<f64>,
    }
    impl Builder {
        pub fn supported_architectures(
            mut self,
            input: impl Into<crate::model::ArchitectureType>,
        ) -> Self {
            let mut v = self.supported_architectures.unwrap_or_default();
            v.push(input.into());
            self.supported_architectures = Some(v);
            self
        }
        pub fn set_supported_architectures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ArchitectureType>>,
        ) -> Self {
            self.supported_architectures = input;
            self
        }
        /// <p>The speed of the processor, in GHz.</p>
        pub fn sustained_clock_speed_in_ghz(mut self, input: f64) -> Self {
            self.sustained_clock_speed_in_ghz = Some(input);
            self
        }
        pub fn set_sustained_clock_speed_in_ghz(mut self, input: std::option::Option<f64>) -> Self {
            self.sustained_clock_speed_in_ghz = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessorInfo`](crate::model::ProcessorInfo)
        pub fn build(self) -> crate::model::ProcessorInfo {
            crate::model::ProcessorInfo {
                supported_architectures: self.supported_architectures,
                sustained_clock_speed_in_ghz: self.sustained_clock_speed_in_ghz,
            }
        }
    }
}
impl ProcessorInfo {
    /// Creates a new builder-style object to manufacture [`ProcessorInfo`](crate::model::ProcessorInfo)
    pub fn builder() -> crate::model::processor_info::Builder {
        crate::model::processor_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArchitectureType {
    Arm64,
    I386,
    X8664,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArchitectureType {
    fn from(s: &str) -> Self {
        match s {
            "arm64" => ArchitectureType::Arm64,
            "i386" => ArchitectureType::I386,
            "x86_64" => ArchitectureType::X8664,
            other => ArchitectureType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArchitectureType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArchitectureType::from(s))
    }
}
impl ArchitectureType {
    pub fn as_str(&self) -> &str {
        match self {
            ArchitectureType::Arm64 => "arm64",
            ArchitectureType::I386 => "i386",
            ArchitectureType::X8664 => "x86_64",
            ArchitectureType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["arm64", "i386", "x86_64"]
    }
}
impl AsRef<str> for ArchitectureType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceTypeHypervisor {
    Nitro,
    Xen,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceTypeHypervisor {
    fn from(s: &str) -> Self {
        match s {
            "nitro" => InstanceTypeHypervisor::Nitro,
            "xen" => InstanceTypeHypervisor::Xen,
            other => InstanceTypeHypervisor::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceTypeHypervisor {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceTypeHypervisor::from(s))
    }
}
impl InstanceTypeHypervisor {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceTypeHypervisor::Nitro => "nitro",
            InstanceTypeHypervisor::Xen => "xen",
            InstanceTypeHypervisor::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["nitro", "xen"]
    }
}
impl AsRef<str> for InstanceTypeHypervisor {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RootDeviceType {
    Ebs,
    InstanceStore,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RootDeviceType {
    fn from(s: &str) -> Self {
        match s {
            "ebs" => RootDeviceType::Ebs,
            "instance-store" => RootDeviceType::InstanceStore,
            other => RootDeviceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RootDeviceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RootDeviceType::from(s))
    }
}
impl RootDeviceType {
    pub fn as_str(&self) -> &str {
        match self {
            RootDeviceType::Ebs => "ebs",
            RootDeviceType::InstanceStore => "instance-store",
            RootDeviceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ebs", "instance-store"]
    }
}
impl AsRef<str> for RootDeviceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageClassType {
    OnDemand,
    Spot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageClassType {
    fn from(s: &str) -> Self {
        match s {
            "on-demand" => UsageClassType::OnDemand,
            "spot" => UsageClassType::Spot,
            other => UsageClassType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageClassType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageClassType::from(s))
    }
}
impl UsageClassType {
    pub fn as_str(&self) -> &str {
        match self {
            UsageClassType::OnDemand => "on-demand",
            UsageClassType::Spot => "spot",
            UsageClassType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["on-demand", "spot"]
    }
}
impl AsRef<str> for UsageClassType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The instance types offered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceTypeOffering {
    /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The location type.</p>
    pub location_type: std::option::Option<crate::model::LocationType>,
    /// <p>The identifier for the location. This depends on the location type. For example, if the location type is
    /// <code>region</code>, the location is the Region code (for example, <code>us-east-2</code>.)</p>
    pub location: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceTypeOffering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceTypeOffering");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("location_type", &self.location_type);
        formatter.field("location", &self.location);
        formatter.finish()
    }
}
/// See [`InstanceTypeOffering`](crate::model::InstanceTypeOffering)
pub mod instance_type_offering {
    /// A builder for [`InstanceTypeOffering`](crate::model::InstanceTypeOffering)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) location_type: std::option::Option<crate::model::LocationType>,
        pub(crate) location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The location type.</p>
        pub fn location_type(mut self, input: crate::model::LocationType) -> Self {
            self.location_type = Some(input);
            self
        }
        pub fn set_location_type(
            mut self,
            input: std::option::Option<crate::model::LocationType>,
        ) -> Self {
            self.location_type = input;
            self
        }
        /// <p>The identifier for the location. This depends on the location type. For example, if the location type is
        /// <code>region</code>, the location is the Region code (for example, <code>us-east-2</code>.)</p>
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceTypeOffering`](crate::model::InstanceTypeOffering)
        pub fn build(self) -> crate::model::InstanceTypeOffering {
            crate::model::InstanceTypeOffering {
                instance_type: self.instance_type,
                location_type: self.location_type,
                location: self.location,
            }
        }
    }
}
impl InstanceTypeOffering {
    /// Creates a new builder-style object to manufacture [`InstanceTypeOffering`](crate::model::InstanceTypeOffering)
    pub fn builder() -> crate::model::instance_type_offering::Builder {
        crate::model::instance_type_offering::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LocationType {
    AvailabilityZone,
    AvailabilityZoneId,
    Region,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LocationType {
    fn from(s: &str) -> Self {
        match s {
            "availability-zone" => LocationType::AvailabilityZone,
            "availability-zone-id" => LocationType::AvailabilityZoneId,
            "region" => LocationType::Region,
            other => LocationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LocationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LocationType::from(s))
    }
}
impl LocationType {
    pub fn as_str(&self) -> &str {
        match self {
            LocationType::AvailabilityZone => "availability-zone",
            LocationType::AvailabilityZoneId => "availability-zone-id",
            LocationType::Region => "region",
            LocationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["availability-zone", "availability-zone-id", "region"]
    }
}
impl AsRef<str> for LocationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the status of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStatus {
    /// <p>The Availability Zone of the instance.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
    /// <p>Any scheduled events associated with the instance.</p>
    pub events: std::option::Option<std::vec::Vec<crate::model::InstanceStatusEvent>>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires
    /// that an instance be in the <code>running</code> state.</p>
    pub instance_state: std::option::Option<crate::model::InstanceState>,
    /// <p>Reports impaired functionality that stems from issues internal to the instance, such
    /// as impaired reachability.</p>
    pub instance_status: std::option::Option<crate::model::InstanceStatusSummary>,
    /// <p>Reports impaired functionality that stems from issues related to the systems that
    /// support an instance, such as hardware failures and network connectivity problems.</p>
    pub system_status: std::option::Option<crate::model::InstanceStatusSummary>,
}
impl std::fmt::Debug for InstanceStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStatus");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.field("events", &self.events);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_state", &self.instance_state);
        formatter.field("instance_status", &self.instance_status);
        formatter.field("system_status", &self.system_status);
        formatter.finish()
    }
}
/// See [`InstanceStatus`](crate::model::InstanceStatus)
pub mod instance_status {
    /// A builder for [`InstanceStatus`](crate::model::InstanceStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::InstanceStatusEvent>>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_state: std::option::Option<crate::model::InstanceState>,
        pub(crate) instance_status: std::option::Option<crate::model::InstanceStatusSummary>,
        pub(crate) system_status: std::option::Option<crate::model::InstanceStatusSummary>,
    }
    impl Builder {
        /// <p>The Availability Zone of the instance.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        pub fn events(mut self, input: impl Into<crate::model::InstanceStatusEvent>) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input.into());
            self.events = Some(v);
            self
        }
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceStatusEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires
        /// that an instance be in the <code>running</code> state.</p>
        pub fn instance_state(mut self, input: crate::model::InstanceState) -> Self {
            self.instance_state = Some(input);
            self
        }
        pub fn set_instance_state(
            mut self,
            input: std::option::Option<crate::model::InstanceState>,
        ) -> Self {
            self.instance_state = input;
            self
        }
        /// <p>Reports impaired functionality that stems from issues internal to the instance, such
        /// as impaired reachability.</p>
        pub fn instance_status(mut self, input: crate::model::InstanceStatusSummary) -> Self {
            self.instance_status = Some(input);
            self
        }
        pub fn set_instance_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatusSummary>,
        ) -> Self {
            self.instance_status = input;
            self
        }
        /// <p>Reports impaired functionality that stems from issues related to the systems that
        /// support an instance, such as hardware failures and network connectivity problems.</p>
        pub fn system_status(mut self, input: crate::model::InstanceStatusSummary) -> Self {
            self.system_status = Some(input);
            self
        }
        pub fn set_system_status(
            mut self,
            input: std::option::Option<crate::model::InstanceStatusSummary>,
        ) -> Self {
            self.system_status = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatus`](crate::model::InstanceStatus)
        pub fn build(self) -> crate::model::InstanceStatus {
            crate::model::InstanceStatus {
                availability_zone: self.availability_zone,
                outpost_arn: self.outpost_arn,
                events: self.events,
                instance_id: self.instance_id,
                instance_state: self.instance_state,
                instance_status: self.instance_status,
                system_status: self.system_status,
            }
        }
    }
}
impl InstanceStatus {
    /// Creates a new builder-style object to manufacture [`InstanceStatus`](crate::model::InstanceStatus)
    pub fn builder() -> crate::model::instance_status::Builder {
        crate::model::instance_status::Builder::default()
    }
}

/// <p>Describes the status of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStatusSummary {
    /// <p>The system instance health or application instance health.</p>
    pub details: std::option::Option<std::vec::Vec<crate::model::InstanceStatusDetails>>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::SummaryStatus>,
}
impl std::fmt::Debug for InstanceStatusSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStatusSummary");
        formatter.field("details", &self.details);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`InstanceStatusSummary`](crate::model::InstanceStatusSummary)
pub mod instance_status_summary {
    /// A builder for [`InstanceStatusSummary`](crate::model::InstanceStatusSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) details: std::option::Option<std::vec::Vec<crate::model::InstanceStatusDetails>>,
        pub(crate) status: std::option::Option<crate::model::SummaryStatus>,
    }
    impl Builder {
        pub fn details(mut self, input: impl Into<crate::model::InstanceStatusDetails>) -> Self {
            let mut v = self.details.unwrap_or_default();
            v.push(input.into());
            self.details = Some(v);
            self
        }
        pub fn set_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceStatusDetails>>,
        ) -> Self {
            self.details = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::SummaryStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SummaryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatusSummary`](crate::model::InstanceStatusSummary)
        pub fn build(self) -> crate::model::InstanceStatusSummary {
            crate::model::InstanceStatusSummary {
                details: self.details,
                status: self.status,
            }
        }
    }
}
impl InstanceStatusSummary {
    /// Creates a new builder-style object to manufacture [`InstanceStatusSummary`](crate::model::InstanceStatusSummary)
    pub fn builder() -> crate::model::instance_status_summary::Builder {
        crate::model::instance_status_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SummaryStatus {
    Impaired,
    Initializing,
    InsufficientData,
    NotApplicable,
    Ok,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SummaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "impaired" => SummaryStatus::Impaired,
            "initializing" => SummaryStatus::Initializing,
            "insufficient-data" => SummaryStatus::InsufficientData,
            "not-applicable" => SummaryStatus::NotApplicable,
            "ok" => SummaryStatus::Ok,
            other => SummaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SummaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SummaryStatus::from(s))
    }
}
impl SummaryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SummaryStatus::Impaired => "impaired",
            SummaryStatus::Initializing => "initializing",
            SummaryStatus::InsufficientData => "insufficient-data",
            SummaryStatus::NotApplicable => "not-applicable",
            SummaryStatus::Ok => "ok",
            SummaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "impaired",
            "initializing",
            "insufficient-data",
            "not-applicable",
            "ok",
        ]
    }
}
impl AsRef<str> for SummaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the instance status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceStatusDetails {
    /// <p>The time when a status check failed. For an instance that was launched and impaired,
    /// this is the time when the instance was launched.</p>
    pub impaired_since: std::option::Option<smithy_types::Instant>,
    /// <p>The type of instance status.</p>
    pub name: std::option::Option<crate::model::StatusName>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::StatusType>,
}
impl std::fmt::Debug for InstanceStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceStatusDetails");
        formatter.field("impaired_since", &self.impaired_since);
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`InstanceStatusDetails`](crate::model::InstanceStatusDetails)
pub mod instance_status_details {
    /// A builder for [`InstanceStatusDetails`](crate::model::InstanceStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) impaired_since: std::option::Option<smithy_types::Instant>,
        pub(crate) name: std::option::Option<crate::model::StatusName>,
        pub(crate) status: std::option::Option<crate::model::StatusType>,
    }
    impl Builder {
        /// <p>The time when a status check failed. For an instance that was launched and impaired,
        /// this is the time when the instance was launched.</p>
        pub fn impaired_since(mut self, input: smithy_types::Instant) -> Self {
            self.impaired_since = Some(input);
            self
        }
        pub fn set_impaired_since(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.impaired_since = input;
            self
        }
        /// <p>The type of instance status.</p>
        pub fn name(mut self, input: crate::model::StatusName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::StatusName>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::StatusType) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::StatusType>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceStatusDetails`](crate::model::InstanceStatusDetails)
        pub fn build(self) -> crate::model::InstanceStatusDetails {
            crate::model::InstanceStatusDetails {
                impaired_since: self.impaired_since,
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl InstanceStatusDetails {
    /// Creates a new builder-style object to manufacture [`InstanceStatusDetails`](crate::model::InstanceStatusDetails)
    pub fn builder() -> crate::model::instance_status_details::Builder {
        crate::model::instance_status_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatusType {
    Failed,
    Initializing,
    InsufficientData,
    Passed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StatusType {
    fn from(s: &str) -> Self {
        match s {
            "failed" => StatusType::Failed,
            "initializing" => StatusType::Initializing,
            "insufficient-data" => StatusType::InsufficientData,
            "passed" => StatusType::Passed,
            other => StatusType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatusType::from(s))
    }
}
impl StatusType {
    pub fn as_str(&self) -> &str {
        match self {
            StatusType::Failed => "failed",
            StatusType::Initializing => "initializing",
            StatusType::InsufficientData => "insufficient-data",
            StatusType::Passed => "passed",
            StatusType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["failed", "initializing", "insufficient-data", "passed"]
    }
}
impl AsRef<str> for StatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StatusName {
    Reachability,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StatusName {
    fn from(s: &str) -> Self {
        match s {
            "reachability" => StatusName::Reachability,
            other => StatusName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StatusName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StatusName::from(s))
    }
}
impl StatusName {
    pub fn as_str(&self) -> &str {
        match self {
            StatusName::Reachability => "reachability",
            StatusName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["reachability"]
    }
}
impl AsRef<str> for StatusName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a launch request for one or more instances, and includes
/// owner, requester, and security group information that applies to all
/// instances in the launch request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Reservation {
    /// <p>[EC2-Classic only] The security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>The instances.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::Instance>>,
    /// <p>The ID of the Amazon Web Services account that owns the reservation.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the requester that launched the instances on your behalf (for example,
    /// Amazon Web Services Management Console or Auto Scaling).</p>
    pub requester_id: std::option::Option<std::string::String>,
    /// <p>The ID of the reservation.</p>
    pub reservation_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Reservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Reservation");
        formatter.field("groups", &self.groups);
        formatter.field("instances", &self.instances);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("requester_id", &self.requester_id);
        formatter.field("reservation_id", &self.reservation_id);
        formatter.finish()
    }
}
/// See [`Reservation`](crate::model::Reservation)
pub mod reservation {
    /// A builder for [`Reservation`](crate::model::Reservation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) instances: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) requester_id: std::option::Option<std::string::String>,
        pub(crate) reservation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.groups = input;
            self
        }
        pub fn instances(mut self, input: impl Into<crate::model::Instance>) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the reservation.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The ID of the requester that launched the instances on your behalf (for example,
        /// Amazon Web Services Management Console or Auto Scaling).</p>
        pub fn requester_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_id = Some(input.into());
            self
        }
        pub fn set_requester_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.requester_id = input;
            self
        }
        /// <p>The ID of the reservation.</p>
        pub fn reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reservation_id = Some(input.into());
            self
        }
        pub fn set_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reservation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Reservation`](crate::model::Reservation)
        pub fn build(self) -> crate::model::Reservation {
            crate::model::Reservation {
                groups: self.groups,
                instances: self.instances,
                owner_id: self.owner_id,
                requester_id: self.requester_id,
                reservation_id: self.reservation_id,
            }
        }
    }
}
impl Reservation {
    /// Creates a new builder-style object to manufacture [`Reservation`](crate::model::Reservation)
    pub fn builder() -> crate::model::reservation::Builder {
        crate::model::reservation::Builder::default()
    }
}

/// <p>Describes the credit option for CPU usage of a burstable performance instance. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceCreditSpecification {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The credit option for CPU usage of the instance. Valid values are
    /// <code>standard</code> and <code>unlimited</code>.</p>
    pub cpu_credits: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceCreditSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceCreditSpecification");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("cpu_credits", &self.cpu_credits);
        formatter.finish()
    }
}
/// See [`InstanceCreditSpecification`](crate::model::InstanceCreditSpecification)
pub mod instance_credit_specification {
    /// A builder for [`InstanceCreditSpecification`](crate::model::InstanceCreditSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) cpu_credits: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The credit option for CPU usage of the instance. Valid values are
        /// <code>standard</code> and <code>unlimited</code>.</p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu_credits = Some(input.into());
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu_credits = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCreditSpecification`](crate::model::InstanceCreditSpecification)
        pub fn build(self) -> crate::model::InstanceCreditSpecification {
            crate::model::InstanceCreditSpecification {
                instance_id: self.instance_id,
                cpu_credits: self.cpu_credits,
            }
        }
    }
}
impl InstanceCreditSpecification {
    /// Creates a new builder-style object to manufacture [`InstanceCreditSpecification`](crate::model::InstanceCreditSpecification)
    pub fn builder() -> crate::model::instance_credit_specification::Builder {
        crate::model::instance_credit_specification::Builder::default()
    }
}

/// <p>Describes an import snapshot task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportSnapshotTask {
    /// <p>A description of the import snapshot task.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the import snapshot task.</p>
    pub import_task_id: std::option::Option<std::string::String>,
    /// <p>Describes an import snapshot task.</p>
    pub snapshot_task_detail: std::option::Option<crate::model::SnapshotTaskDetail>,
    /// <p>The tags for the import snapshot task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ImportSnapshotTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportSnapshotTask");
        formatter.field("description", &self.description);
        formatter.field("import_task_id", &self.import_task_id);
        formatter.field("snapshot_task_detail", &self.snapshot_task_detail);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ImportSnapshotTask`](crate::model::ImportSnapshotTask)
pub mod import_snapshot_task {
    /// A builder for [`ImportSnapshotTask`](crate::model::ImportSnapshotTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) import_task_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_task_detail: std::option::Option<crate::model::SnapshotTaskDetail>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A description of the import snapshot task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the import snapshot task.</p>
        pub fn import_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_task_id = Some(input.into());
            self
        }
        pub fn set_import_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.import_task_id = input;
            self
        }
        /// <p>Describes an import snapshot task.</p>
        pub fn snapshot_task_detail(mut self, input: crate::model::SnapshotTaskDetail) -> Self {
            self.snapshot_task_detail = Some(input);
            self
        }
        pub fn set_snapshot_task_detail(
            mut self,
            input: std::option::Option<crate::model::SnapshotTaskDetail>,
        ) -> Self {
            self.snapshot_task_detail = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportSnapshotTask`](crate::model::ImportSnapshotTask)
        pub fn build(self) -> crate::model::ImportSnapshotTask {
            crate::model::ImportSnapshotTask {
                description: self.description,
                import_task_id: self.import_task_id,
                snapshot_task_detail: self.snapshot_task_detail,
                tags: self.tags,
            }
        }
    }
}
impl ImportSnapshotTask {
    /// Creates a new builder-style object to manufacture [`ImportSnapshotTask`](crate::model::ImportSnapshotTask)
    pub fn builder() -> crate::model::import_snapshot_task::Builder {
        crate::model::import_snapshot_task::Builder::default()
    }
}

/// <p>Describes an import image task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportImageTask {
    /// <p>The architecture of the virtual machine.</p>
    /// <p>Valid values: <code>i386</code> | <code>x86_64</code> | <code>arm64</code>
    /// </p>
    pub architecture: std::option::Option<std::string::String>,
    /// <p>A description of the import task.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the image is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The target hypervisor for the import task.</p>
    /// <p>Valid values: <code>xen</code>
    /// </p>
    pub hypervisor: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The ID of the import image task.</p>
    pub import_task_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the KMS key that was used to create the encrypted image.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The license type of the virtual machine.</p>
    pub license_type: std::option::Option<std::string::String>,
    /// <p>The description string for the import image task.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The percentage of progress of the import image task.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>Information about the snapshots.</p>
    pub snapshot_details: std::option::Option<std::vec::Vec<crate::model::SnapshotDetail>>,
    /// <p>A brief status for the import image task.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>A descriptive status message for the import image task.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The tags for the import image task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ARNs of the license configurations that are associated with the import image task.</p>
    pub license_specifications:
        std::option::Option<std::vec::Vec<crate::model::ImportImageLicenseConfigurationResponse>>,
    /// <p>The usage operation value.</p>
    pub usage_operation: std::option::Option<std::string::String>,
    /// <p>The boot mode of the virtual machine.</p>
    pub boot_mode: std::option::Option<crate::model::BootModeValues>,
}
impl std::fmt::Debug for ImportImageTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportImageTask");
        formatter.field("architecture", &self.architecture);
        formatter.field("description", &self.description);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("hypervisor", &self.hypervisor);
        formatter.field("image_id", &self.image_id);
        formatter.field("import_task_id", &self.import_task_id);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("license_type", &self.license_type);
        formatter.field("platform", &self.platform);
        formatter.field("progress", &self.progress);
        formatter.field("snapshot_details", &self.snapshot_details);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("tags", &self.tags);
        formatter.field("license_specifications", &self.license_specifications);
        formatter.field("usage_operation", &self.usage_operation);
        formatter.field("boot_mode", &self.boot_mode);
        formatter.finish()
    }
}
/// See [`ImportImageTask`](crate::model::ImportImageTask)
pub mod import_image_task {
    /// A builder for [`ImportImageTask`](crate::model::ImportImageTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) architecture: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) hypervisor: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) import_task_id: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) license_type: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) snapshot_details:
            std::option::Option<std::vec::Vec<crate::model::SnapshotDetail>>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) license_specifications: std::option::Option<
            std::vec::Vec<crate::model::ImportImageLicenseConfigurationResponse>,
        >,
        pub(crate) usage_operation: std::option::Option<std::string::String>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootModeValues>,
    }
    impl Builder {
        /// <p>The architecture of the virtual machine.</p>
        /// <p>Valid values: <code>i386</code> | <code>x86_64</code> | <code>arm64</code>
        /// </p>
        pub fn architecture(mut self, input: impl Into<std::string::String>) -> Self {
            self.architecture = Some(input.into());
            self
        }
        pub fn set_architecture(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.architecture = input;
            self
        }
        /// <p>A description of the import task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the image is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The target hypervisor for the import task.</p>
        /// <p>Valid values: <code>xen</code>
        /// </p>
        pub fn hypervisor(mut self, input: impl Into<std::string::String>) -> Self {
            self.hypervisor = Some(input.into());
            self
        }
        pub fn set_hypervisor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hypervisor = input;
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The ID of the import image task.</p>
        pub fn import_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_task_id = Some(input.into());
            self
        }
        pub fn set_import_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.import_task_id = input;
            self
        }
        /// <p>The identifier for the KMS key that was used to create the encrypted image.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The license type of the virtual machine.</p>
        pub fn license_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_type = Some(input.into());
            self
        }
        pub fn set_license_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.license_type = input;
            self
        }
        /// <p>The description string for the import image task.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The percentage of progress of the import image task.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        pub fn snapshot_details(mut self, input: impl Into<crate::model::SnapshotDetail>) -> Self {
            let mut v = self.snapshot_details.unwrap_or_default();
            v.push(input.into());
            self.snapshot_details = Some(v);
            self
        }
        pub fn set_snapshot_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SnapshotDetail>>,
        ) -> Self {
            self.snapshot_details = input;
            self
        }
        /// <p>A brief status for the import image task.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>A descriptive status message for the import image task.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn license_specifications(
            mut self,
            input: impl Into<crate::model::ImportImageLicenseConfigurationResponse>,
        ) -> Self {
            let mut v = self.license_specifications.unwrap_or_default();
            v.push(input.into());
            self.license_specifications = Some(v);
            self
        }
        pub fn set_license_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ImportImageLicenseConfigurationResponse>,
            >,
        ) -> Self {
            self.license_specifications = input;
            self
        }
        /// <p>The usage operation value.</p>
        pub fn usage_operation(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_operation = Some(input.into());
            self
        }
        pub fn set_usage_operation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_operation = input;
            self
        }
        /// <p>The boot mode of the virtual machine.</p>
        pub fn boot_mode(mut self, input: crate::model::BootModeValues) -> Self {
            self.boot_mode = Some(input);
            self
        }
        pub fn set_boot_mode(
            mut self,
            input: std::option::Option<crate::model::BootModeValues>,
        ) -> Self {
            self.boot_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportImageTask`](crate::model::ImportImageTask)
        pub fn build(self) -> crate::model::ImportImageTask {
            crate::model::ImportImageTask {
                architecture: self.architecture,
                description: self.description,
                encrypted: self.encrypted,
                hypervisor: self.hypervisor,
                image_id: self.image_id,
                import_task_id: self.import_task_id,
                kms_key_id: self.kms_key_id,
                license_type: self.license_type,
                platform: self.platform,
                progress: self.progress,
                snapshot_details: self.snapshot_details,
                status: self.status,
                status_message: self.status_message,
                tags: self.tags,
                license_specifications: self.license_specifications,
                usage_operation: self.usage_operation,
                boot_mode: self.boot_mode,
            }
        }
    }
}
impl ImportImageTask {
    /// Creates a new builder-style object to manufacture [`ImportImageTask`](crate::model::ImportImageTask)
    pub fn builder() -> crate::model::import_image_task::Builder {
        crate::model::import_image_task::Builder::default()
    }
}

/// <p>Describes an image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Image {
    /// <p>The architecture of the image.</p>
    pub architecture: std::option::Option<crate::model::ArchitectureValues>,
    /// <p>The date and time the image was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The ID of the AMI.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The location of the AMI.</p>
    pub image_location: std::option::Option<std::string::String>,
    /// <p>The type of image.</p>
    pub image_type: std::option::Option<crate::model::ImageTypeValues>,
    /// <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if
    /// this image has public launch permissions or <code>false</code>
    /// if it has only implicit and explicit launch permissions.</p>
    pub public: std::option::Option<bool>,
    /// <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the image.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>This value is set to <code>windows</code> for Windows AMIs; otherwise, it is blank.</p>
    pub platform: std::option::Option<crate::model::PlatformValues>,
    /// <p>The platform details associated with the billing code of the AMI. For more information,
    /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html">Understanding
    /// AMI billing</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub platform_details: std::option::Option<std::string::String>,
    /// <p>The operation of the Amazon EC2 instance and the billing code that is associated with the AMI.
    /// <code>usageOperation</code> corresponds to the <a href="https://docs.aws.amazon.com/cur/latest/userguide/Lineitem-columns.html#Lineitem-details-O-Operation">lineitem/Operation</a> column on your Amazon Web Services Cost and Usage Report and in the <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/price-changes.html">Amazon Web Services Price
    /// List API</a>. You can view these fields on the <b>Instances</b> or
    /// <b>AMIs</b> pages in the Amazon EC2 console, or in the responses that are
    /// returned by the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html">DescribeImages</a>
    /// command in the Amazon EC2 API, or the <a href="https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-images.html">describe-images</a>
    /// command in the CLI.</p>
    pub usage_operation: std::option::Option<std::string::String>,
    /// <p>Any product codes associated with the AMI.</p>
    pub product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
    /// <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
    pub state: std::option::Option<crate::model::ImageState>,
    /// <p>Any block device mapping entries.</p>
    pub block_device_mappings: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
    /// <p>The description of the AMI that was provided during image creation.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Specifies whether enhanced networking with ENA is enabled.</p>
    pub ena_support: std::option::Option<bool>,
    /// <p>The hypervisor type of the image.</p>
    pub hypervisor: std::option::Option<crate::model::HypervisorType>,
    /// <p>The Amazon Web Services account alias (for example, <code>amazon</code>, <code>self</code>) or
    /// the Amazon Web Services account ID of the AMI owner.</p>
    pub image_owner_alias: std::option::Option<std::string::String>,
    /// <p>The name of the AMI that was provided during image creation.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
    pub root_device_name: std::option::Option<std::string::String>,
    /// <p>The type of root device used by the AMI. The AMI can use an Amazon EBS volume or an instance store volume.</p>
    pub root_device_type: std::option::Option<crate::model::DeviceType>,
    /// <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
    pub sriov_net_support: std::option::Option<std::string::String>,
    /// <p>The reason for the state change.</p>
    pub state_reason: std::option::Option<crate::model::StateReason>,
    /// <p>Any tags assigned to the image.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The type of virtualization of the AMI.</p>
    pub virtualization_type: std::option::Option<crate::model::VirtualizationType>,
    /// <p>The boot mode of the image. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub boot_mode: std::option::Option<crate::model::BootModeValues>,
    /// <p>The date and time to deprecate the AMI, in UTC, in the following format:
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z.
    /// If you specified a value for seconds, Amazon EC2 rounds the seconds to the
    /// nearest minute.</p>
    pub deprecation_time: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Image");
        formatter.field("architecture", &self.architecture);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("image_id", &self.image_id);
        formatter.field("image_location", &self.image_location);
        formatter.field("image_type", &self.image_type);
        formatter.field("public", &self.public);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("platform", &self.platform);
        formatter.field("platform_details", &self.platform_details);
        formatter.field("usage_operation", &self.usage_operation);
        formatter.field("product_codes", &self.product_codes);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("state", &self.state);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("description", &self.description);
        formatter.field("ena_support", &self.ena_support);
        formatter.field("hypervisor", &self.hypervisor);
        formatter.field("image_owner_alias", &self.image_owner_alias);
        formatter.field("name", &self.name);
        formatter.field("root_device_name", &self.root_device_name);
        formatter.field("root_device_type", &self.root_device_type);
        formatter.field("sriov_net_support", &self.sriov_net_support);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("tags", &self.tags);
        formatter.field("virtualization_type", &self.virtualization_type);
        formatter.field("boot_mode", &self.boot_mode);
        formatter.field("deprecation_time", &self.deprecation_time);
        formatter.finish()
    }
}
/// See [`Image`](crate::model::Image)
pub mod image {
    /// A builder for [`Image`](crate::model::Image)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) architecture: std::option::Option<crate::model::ArchitectureValues>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) image_location: std::option::Option<std::string::String>,
        pub(crate) image_type: std::option::Option<crate::model::ImageTypeValues>,
        pub(crate) public: std::option::Option<bool>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::PlatformValues>,
        pub(crate) platform_details: std::option::Option<std::string::String>,
        pub(crate) usage_operation: std::option::Option<std::string::String>,
        pub(crate) product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ImageState>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ena_support: std::option::Option<bool>,
        pub(crate) hypervisor: std::option::Option<crate::model::HypervisorType>,
        pub(crate) image_owner_alias: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) root_device_name: std::option::Option<std::string::String>,
        pub(crate) root_device_type: std::option::Option<crate::model::DeviceType>,
        pub(crate) sriov_net_support: std::option::Option<std::string::String>,
        pub(crate) state_reason: std::option::Option<crate::model::StateReason>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) virtualization_type: std::option::Option<crate::model::VirtualizationType>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootModeValues>,
        pub(crate) deprecation_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The architecture of the image.</p>
        pub fn architecture(mut self, input: crate::model::ArchitectureValues) -> Self {
            self.architecture = Some(input);
            self
        }
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::ArchitectureValues>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// <p>The date and time the image was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The location of the AMI.</p>
        pub fn image_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_location = Some(input.into());
            self
        }
        pub fn set_image_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_location = input;
            self
        }
        /// <p>The type of image.</p>
        pub fn image_type(mut self, input: crate::model::ImageTypeValues) -> Self {
            self.image_type = Some(input);
            self
        }
        pub fn set_image_type(
            mut self,
            input: std::option::Option<crate::model::ImageTypeValues>,
        ) -> Self {
            self.image_type = input;
            self
        }
        /// <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if
        /// this image has public launch permissions or <code>false</code>
        /// if it has only implicit and explicit launch permissions.</p>
        pub fn public(mut self, input: bool) -> Self {
            self.public = Some(input);
            self
        }
        pub fn set_public(mut self, input: std::option::Option<bool>) -> Self {
            self.public = input;
            self
        }
        /// <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the image.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>This value is set to <code>windows</code> for Windows AMIs; otherwise, it is blank.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// <p>The platform details associated with the billing code of the AMI. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html">Understanding
        /// AMI billing</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn platform_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_details = Some(input.into());
            self
        }
        pub fn set_platform_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_details = input;
            self
        }
        /// <p>The operation of the Amazon EC2 instance and the billing code that is associated with the AMI.
        /// <code>usageOperation</code> corresponds to the <a href="https://docs.aws.amazon.com/cur/latest/userguide/Lineitem-columns.html#Lineitem-details-O-Operation">lineitem/Operation</a> column on your Amazon Web Services Cost and Usage Report and in the <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/price-changes.html">Amazon Web Services Price
        /// List API</a>. You can view these fields on the <b>Instances</b> or
        /// <b>AMIs</b> pages in the Amazon EC2 console, or in the responses that are
        /// returned by the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html">DescribeImages</a>
        /// command in the Amazon EC2 API, or the <a href="https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-images.html">describe-images</a>
        /// command in the CLI.</p>
        pub fn usage_operation(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_operation = Some(input.into());
            self
        }
        pub fn set_usage_operation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_operation = input;
            self
        }
        pub fn product_codes(mut self, input: impl Into<crate::model::ProductCode>) -> Self {
            let mut v = self.product_codes.unwrap_or_default();
            v.push(input.into());
            self.product_codes = Some(v);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        ) -> Self {
            self.product_codes = input;
            self
        }
        /// <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        /// <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
        pub fn state(mut self, input: crate::model::ImageState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::ImageState>) -> Self {
            self.state = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>The description of the AMI that was provided during image creation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Specifies whether enhanced networking with ENA is enabled.</p>
        pub fn ena_support(mut self, input: bool) -> Self {
            self.ena_support = Some(input);
            self
        }
        pub fn set_ena_support(mut self, input: std::option::Option<bool>) -> Self {
            self.ena_support = input;
            self
        }
        /// <p>The hypervisor type of the image.</p>
        pub fn hypervisor(mut self, input: crate::model::HypervisorType) -> Self {
            self.hypervisor = Some(input);
            self
        }
        pub fn set_hypervisor(
            mut self,
            input: std::option::Option<crate::model::HypervisorType>,
        ) -> Self {
            self.hypervisor = input;
            self
        }
        /// <p>The Amazon Web Services account alias (for example, <code>amazon</code>, <code>self</code>) or
        /// the Amazon Web Services account ID of the AMI owner.</p>
        pub fn image_owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_owner_alias = Some(input.into());
            self
        }
        pub fn set_image_owner_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_owner_alias = input;
            self
        }
        /// <p>The name of the AMI that was provided during image creation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        pub fn root_device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.root_device_name = Some(input.into());
            self
        }
        pub fn set_root_device_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.root_device_name = input;
            self
        }
        /// <p>The type of root device used by the AMI. The AMI can use an Amazon EBS volume or an instance store volume.</p>
        pub fn root_device_type(mut self, input: crate::model::DeviceType) -> Self {
            self.root_device_type = Some(input);
            self
        }
        pub fn set_root_device_type(
            mut self,
            input: std::option::Option<crate::model::DeviceType>,
        ) -> Self {
            self.root_device_type = input;
            self
        }
        /// <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
        pub fn sriov_net_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.sriov_net_support = Some(input.into());
            self
        }
        pub fn set_sriov_net_support(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sriov_net_support = input;
            self
        }
        /// <p>The reason for the state change.</p>
        pub fn state_reason(mut self, input: crate::model::StateReason) -> Self {
            self.state_reason = Some(input);
            self
        }
        pub fn set_state_reason(
            mut self,
            input: std::option::Option<crate::model::StateReason>,
        ) -> Self {
            self.state_reason = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The type of virtualization of the AMI.</p>
        pub fn virtualization_type(mut self, input: crate::model::VirtualizationType) -> Self {
            self.virtualization_type = Some(input);
            self
        }
        pub fn set_virtualization_type(
            mut self,
            input: std::option::Option<crate::model::VirtualizationType>,
        ) -> Self {
            self.virtualization_type = input;
            self
        }
        /// <p>The boot mode of the image. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn boot_mode(mut self, input: crate::model::BootModeValues) -> Self {
            self.boot_mode = Some(input);
            self
        }
        pub fn set_boot_mode(
            mut self,
            input: std::option::Option<crate::model::BootModeValues>,
        ) -> Self {
            self.boot_mode = input;
            self
        }
        /// <p>The date and time to deprecate the AMI, in UTC, in the following format:
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z.
        /// If you specified a value for seconds, Amazon EC2 rounds the seconds to the
        /// nearest minute.</p>
        pub fn deprecation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.deprecation_time = Some(input.into());
            self
        }
        pub fn set_deprecation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deprecation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Image`](crate::model::Image)
        pub fn build(self) -> crate::model::Image {
            crate::model::Image {
                architecture: self.architecture,
                creation_date: self.creation_date,
                image_id: self.image_id,
                image_location: self.image_location,
                image_type: self.image_type,
                public: self.public,
                kernel_id: self.kernel_id,
                owner_id: self.owner_id,
                platform: self.platform,
                platform_details: self.platform_details,
                usage_operation: self.usage_operation,
                product_codes: self.product_codes,
                ramdisk_id: self.ramdisk_id,
                state: self.state,
                block_device_mappings: self.block_device_mappings,
                description: self.description,
                ena_support: self.ena_support,
                hypervisor: self.hypervisor,
                image_owner_alias: self.image_owner_alias,
                name: self.name,
                root_device_name: self.root_device_name,
                root_device_type: self.root_device_type,
                sriov_net_support: self.sriov_net_support,
                state_reason: self.state_reason,
                tags: self.tags,
                virtualization_type: self.virtualization_type,
                boot_mode: self.boot_mode,
                deprecation_time: self.deprecation_time,
            }
        }
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::model::Image)
    pub fn builder() -> crate::model::image::Builder {
        crate::model::image::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageState {
    Available,
    Deregistered,
    Error,
    Failed,
    Invalid,
    Pending,
    Transient,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageState {
    fn from(s: &str) -> Self {
        match s {
            "available" => ImageState::Available,
            "deregistered" => ImageState::Deregistered,
            "error" => ImageState::Error,
            "failed" => ImageState::Failed,
            "invalid" => ImageState::Invalid,
            "pending" => ImageState::Pending,
            "transient" => ImageState::Transient,
            other => ImageState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageState::from(s))
    }
}
impl ImageState {
    pub fn as_str(&self) -> &str {
        match self {
            ImageState::Available => "available",
            ImageState::Deregistered => "deregistered",
            ImageState::Error => "error",
            ImageState::Failed => "failed",
            ImageState::Invalid => "invalid",
            ImageState::Pending => "pending",
            ImageState::Transient => "transient",
            ImageState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "available",
            "deregistered",
            "error",
            "failed",
            "invalid",
            "pending",
            "transient",
        ]
    }
}
impl AsRef<str> for ImageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageTypeValues {
    Kernel,
    Machine,
    Ramdisk,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageTypeValues {
    fn from(s: &str) -> Self {
        match s {
            "kernel" => ImageTypeValues::Kernel,
            "machine" => ImageTypeValues::Machine,
            "ramdisk" => ImageTypeValues::Ramdisk,
            other => ImageTypeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageTypeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageTypeValues::from(s))
    }
}
impl ImageTypeValues {
    pub fn as_str(&self) -> &str {
        match self {
            ImageTypeValues::Kernel => "kernel",
            ImageTypeValues::Machine => "machine",
            ImageTypeValues::Ramdisk => "ramdisk",
            ImageTypeValues::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["kernel", "machine", "ramdisk"]
    }
}
impl AsRef<str> for ImageTypeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageAttributeName {
    BlockDeviceMapping,
    BootMode,
    Description,
    Kernel,
    LaunchPermission,
    ProductCodes,
    Ramdisk,
    SriovNetSupport,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "blockDeviceMapping" => ImageAttributeName::BlockDeviceMapping,
            "bootMode" => ImageAttributeName::BootMode,
            "description" => ImageAttributeName::Description,
            "kernel" => ImageAttributeName::Kernel,
            "launchPermission" => ImageAttributeName::LaunchPermission,
            "productCodes" => ImageAttributeName::ProductCodes,
            "ramdisk" => ImageAttributeName::Ramdisk,
            "sriovNetSupport" => ImageAttributeName::SriovNetSupport,
            other => ImageAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageAttributeName::from(s))
    }
}
impl ImageAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            ImageAttributeName::BlockDeviceMapping => "blockDeviceMapping",
            ImageAttributeName::BootMode => "bootMode",
            ImageAttributeName::Description => "description",
            ImageAttributeName::Kernel => "kernel",
            ImageAttributeName::LaunchPermission => "launchPermission",
            ImageAttributeName::ProductCodes => "productCodes",
            ImageAttributeName::Ramdisk => "ramdisk",
            ImageAttributeName::SriovNetSupport => "sriovNetSupport",
            ImageAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "blockDeviceMapping",
            "bootMode",
            "description",
            "kernel",
            "launchPermission",
            "productCodes",
            "ramdisk",
            "sriovNetSupport",
        ]
    }
}
impl AsRef<str> for ImageAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the properties of the Dedicated Host.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Host {
    /// <p>Whether auto-placement is on or off.</p>
    pub auto_placement: std::option::Option<crate::model::AutoPlacement>,
    /// <p>The Availability Zone of the Dedicated Host.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>Information about the instances running on the Dedicated Host.</p>
    pub available_capacity: std::option::Option<crate::model::AvailableCapacity>,
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The ID of the Dedicated Host.</p>
    pub host_id: std::option::Option<std::string::String>,
    /// <p>The hardware specifications of the Dedicated Host.</p>
    pub host_properties: std::option::Option<crate::model::HostProperties>,
    /// <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response
    /// if the Dedicated Host doesn't have an associated reservation.</p>
    pub host_reservation_id: std::option::Option<std::string::String>,
    /// <p>The IDs and instance type that are currently running on the Dedicated
    /// Host.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::HostInstance>>,
    /// <p>The Dedicated Host's state.</p>
    pub state: std::option::Option<crate::model::AllocationState>,
    /// <p>The time that the Dedicated Host was allocated.</p>
    pub allocation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the Dedicated Host was released.</p>
    pub release_time: std::option::Option<smithy_types::Instant>,
    /// <p>Any tags assigned to the Dedicated Host.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Indicates whether host recovery is enabled or disabled for the Dedicated Host.</p>
    pub host_recovery: std::option::Option<crate::model::HostRecovery>,
    /// <p>Indicates whether the Dedicated Host supports multiple instance types of the same instance family.
    /// If the value is <code>on</code>, the Dedicated Host supports multiple instance types in the instance family.
    /// If the value is <code>off</code>, the Dedicated Host supports a single instance type only.</p>
    pub allows_multiple_instance_types:
        std::option::Option<crate::model::AllowsMultipleInstanceTypes>,
    /// <p>The ID of the Amazon Web Services account that owns the Dedicated Host.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Availability Zone in which the Dedicated Host is allocated.</p>
    pub availability_zone_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the Dedicated Host is in a host resource group. If
    /// <b>memberOfServiceLinkedResourceGroup</b> is
    /// <code>true</code>, the host is in a host resource group; otherwise, it is not.</p>
    pub member_of_service_linked_resource_group: std::option::Option<bool>,
}
impl std::fmt::Debug for Host {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Host");
        formatter.field("auto_placement", &self.auto_placement);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("available_capacity", &self.available_capacity);
        formatter.field("client_token", &self.client_token);
        formatter.field("host_id", &self.host_id);
        formatter.field("host_properties", &self.host_properties);
        formatter.field("host_reservation_id", &self.host_reservation_id);
        formatter.field("instances", &self.instances);
        formatter.field("state", &self.state);
        formatter.field("allocation_time", &self.allocation_time);
        formatter.field("release_time", &self.release_time);
        formatter.field("tags", &self.tags);
        formatter.field("host_recovery", &self.host_recovery);
        formatter.field(
            "allows_multiple_instance_types",
            &self.allows_multiple_instance_types,
        );
        formatter.field("owner_id", &self.owner_id);
        formatter.field("availability_zone_id", &self.availability_zone_id);
        formatter.field(
            "member_of_service_linked_resource_group",
            &self.member_of_service_linked_resource_group,
        );
        formatter.finish()
    }
}
/// See [`Host`](crate::model::Host)
pub mod host {
    /// A builder for [`Host`](crate::model::Host)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_placement: std::option::Option<crate::model::AutoPlacement>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) available_capacity: std::option::Option<crate::model::AvailableCapacity>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) host_id: std::option::Option<std::string::String>,
        pub(crate) host_properties: std::option::Option<crate::model::HostProperties>,
        pub(crate) host_reservation_id: std::option::Option<std::string::String>,
        pub(crate) instances: std::option::Option<std::vec::Vec<crate::model::HostInstance>>,
        pub(crate) state: std::option::Option<crate::model::AllocationState>,
        pub(crate) allocation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) release_time: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) host_recovery: std::option::Option<crate::model::HostRecovery>,
        pub(crate) allows_multiple_instance_types:
            std::option::Option<crate::model::AllowsMultipleInstanceTypes>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
        pub(crate) member_of_service_linked_resource_group: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether auto-placement is on or off.</p>
        pub fn auto_placement(mut self, input: crate::model::AutoPlacement) -> Self {
            self.auto_placement = Some(input);
            self
        }
        pub fn set_auto_placement(
            mut self,
            input: std::option::Option<crate::model::AutoPlacement>,
        ) -> Self {
            self.auto_placement = input;
            self
        }
        /// <p>The Availability Zone of the Dedicated Host.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>Information about the instances running on the Dedicated Host.</p>
        pub fn available_capacity(mut self, input: crate::model::AvailableCapacity) -> Self {
            self.available_capacity = Some(input);
            self
        }
        pub fn set_available_capacity(
            mut self,
            input: std::option::Option<crate::model::AvailableCapacity>,
        ) -> Self {
            self.available_capacity = input;
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The ID of the Dedicated Host.</p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_id = Some(input.into());
            self
        }
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_id = input;
            self
        }
        /// <p>The hardware specifications of the Dedicated Host.</p>
        pub fn host_properties(mut self, input: crate::model::HostProperties) -> Self {
            self.host_properties = Some(input);
            self
        }
        pub fn set_host_properties(
            mut self,
            input: std::option::Option<crate::model::HostProperties>,
        ) -> Self {
            self.host_properties = input;
            self
        }
        /// <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response
        /// if the Dedicated Host doesn't have an associated reservation.</p>
        pub fn host_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_reservation_id = Some(input.into());
            self
        }
        pub fn set_host_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_reservation_id = input;
            self
        }
        pub fn instances(mut self, input: impl Into<crate::model::HostInstance>) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HostInstance>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// <p>The Dedicated Host's state.</p>
        pub fn state(mut self, input: crate::model::AllocationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AllocationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time that the Dedicated Host was allocated.</p>
        pub fn allocation_time(mut self, input: smithy_types::Instant) -> Self {
            self.allocation_time = Some(input);
            self
        }
        pub fn set_allocation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.allocation_time = input;
            self
        }
        /// <p>The time that the Dedicated Host was released.</p>
        pub fn release_time(mut self, input: smithy_types::Instant) -> Self {
            self.release_time = Some(input);
            self
        }
        pub fn set_release_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.release_time = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Indicates whether host recovery is enabled or disabled for the Dedicated Host.</p>
        pub fn host_recovery(mut self, input: crate::model::HostRecovery) -> Self {
            self.host_recovery = Some(input);
            self
        }
        pub fn set_host_recovery(
            mut self,
            input: std::option::Option<crate::model::HostRecovery>,
        ) -> Self {
            self.host_recovery = input;
            self
        }
        /// <p>Indicates whether the Dedicated Host supports multiple instance types of the same instance family.
        /// If the value is <code>on</code>, the Dedicated Host supports multiple instance types in the instance family.
        /// If the value is <code>off</code>, the Dedicated Host supports a single instance type only.</p>
        pub fn allows_multiple_instance_types(
            mut self,
            input: crate::model::AllowsMultipleInstanceTypes,
        ) -> Self {
            self.allows_multiple_instance_types = Some(input);
            self
        }
        pub fn set_allows_multiple_instance_types(
            mut self,
            input: std::option::Option<crate::model::AllowsMultipleInstanceTypes>,
        ) -> Self {
            self.allows_multiple_instance_types = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the Dedicated Host.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The ID of the Availability Zone in which the Dedicated Host is allocated.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// <p>Indicates whether the Dedicated Host is in a host resource group. If
        /// <b>memberOfServiceLinkedResourceGroup</b> is
        /// <code>true</code>, the host is in a host resource group; otherwise, it is not.</p>
        pub fn member_of_service_linked_resource_group(mut self, input: bool) -> Self {
            self.member_of_service_linked_resource_group = Some(input);
            self
        }
        pub fn set_member_of_service_linked_resource_group(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.member_of_service_linked_resource_group = input;
            self
        }
        /// Consumes the builder and constructs a [`Host`](crate::model::Host)
        pub fn build(self) -> crate::model::Host {
            crate::model::Host {
                auto_placement: self.auto_placement,
                availability_zone: self.availability_zone,
                available_capacity: self.available_capacity,
                client_token: self.client_token,
                host_id: self.host_id,
                host_properties: self.host_properties,
                host_reservation_id: self.host_reservation_id,
                instances: self.instances,
                state: self.state,
                allocation_time: self.allocation_time,
                release_time: self.release_time,
                tags: self.tags,
                host_recovery: self.host_recovery,
                allows_multiple_instance_types: self.allows_multiple_instance_types,
                owner_id: self.owner_id,
                availability_zone_id: self.availability_zone_id,
                member_of_service_linked_resource_group: self
                    .member_of_service_linked_resource_group,
            }
        }
    }
}
impl Host {
    /// Creates a new builder-style object to manufacture [`Host`](crate::model::Host)
    pub fn builder() -> crate::model::host::Builder {
        crate::model::host::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AllowsMultipleInstanceTypes {
    Off,
    On,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AllowsMultipleInstanceTypes {
    fn from(s: &str) -> Self {
        match s {
            "off" => AllowsMultipleInstanceTypes::Off,
            "on" => AllowsMultipleInstanceTypes::On,
            other => AllowsMultipleInstanceTypes::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AllowsMultipleInstanceTypes {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AllowsMultipleInstanceTypes::from(s))
    }
}
impl AllowsMultipleInstanceTypes {
    pub fn as_str(&self) -> &str {
        match self {
            AllowsMultipleInstanceTypes::Off => "off",
            AllowsMultipleInstanceTypes::On => "on",
            AllowsMultipleInstanceTypes::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["off", "on"]
    }
}
impl AsRef<str> for AllowsMultipleInstanceTypes {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AllocationState {
    Available,
    Pending,
    PermanentFailure,
    Released,
    ReleasedPermanentFailure,
    UnderAssessment,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AllocationState {
    fn from(s: &str) -> Self {
        match s {
            "available" => AllocationState::Available,
            "pending" => AllocationState::Pending,
            "permanent-failure" => AllocationState::PermanentFailure,
            "released" => AllocationState::Released,
            "released-permanent-failure" => AllocationState::ReleasedPermanentFailure,
            "under-assessment" => AllocationState::UnderAssessment,
            other => AllocationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AllocationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AllocationState::from(s))
    }
}
impl AllocationState {
    pub fn as_str(&self) -> &str {
        match self {
            AllocationState::Available => "available",
            AllocationState::Pending => "pending",
            AllocationState::PermanentFailure => "permanent-failure",
            AllocationState::Released => "released",
            AllocationState::ReleasedPermanentFailure => "released-permanent-failure",
            AllocationState::UnderAssessment => "under-assessment",
            AllocationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "available",
            "pending",
            "permanent-failure",
            "released",
            "released-permanent-failure",
            "under-assessment",
        ]
    }
}
impl AsRef<str> for AllocationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an instance running on a Dedicated Host.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HostInstance {
    /// <p>The ID of instance that is running on the Dedicated Host.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance type (for example, <code>m3.medium</code>) of the running instance.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the instance.</p>
    pub owner_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HostInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HostInstance");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("owner_id", &self.owner_id);
        formatter.finish()
    }
}
/// See [`HostInstance`](crate::model::HostInstance)
pub mod host_instance {
    /// A builder for [`HostInstance`](crate::model::HostInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of instance that is running on the Dedicated Host.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance type (for example, <code>m3.medium</code>) of the running instance.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the instance.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// Consumes the builder and constructs a [`HostInstance`](crate::model::HostInstance)
        pub fn build(self) -> crate::model::HostInstance {
            crate::model::HostInstance {
                instance_id: self.instance_id,
                instance_type: self.instance_type,
                owner_id: self.owner_id,
            }
        }
    }
}
impl HostInstance {
    /// Creates a new builder-style object to manufacture [`HostInstance`](crate::model::HostInstance)
    pub fn builder() -> crate::model::host_instance::Builder {
        crate::model::host_instance::Builder::default()
    }
}

/// <p>Describes the properties of a Dedicated Host.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HostProperties {
    /// <p>The number of cores on the Dedicated Host.</p>
    pub cores: std::option::Option<i32>,
    /// <p>The instance type supported by the Dedicated Host. For example, <code>m5.large</code>.
    /// If the host supports multiple instance types, no <b>instanceType</b>
    /// is returned.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The instance family supported by the Dedicated Host. For example, <code>m5</code>.</p>
    pub instance_family: std::option::Option<std::string::String>,
    /// <p>The number of sockets on the Dedicated Host.</p>
    pub sockets: std::option::Option<i32>,
    /// <p>The total number of vCPUs on the Dedicated Host.</p>
    pub total_v_cpus: std::option::Option<i32>,
}
impl std::fmt::Debug for HostProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HostProperties");
        formatter.field("cores", &self.cores);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_family", &self.instance_family);
        formatter.field("sockets", &self.sockets);
        formatter.field("total_v_cpus", &self.total_v_cpus);
        formatter.finish()
    }
}
/// See [`HostProperties`](crate::model::HostProperties)
pub mod host_properties {
    /// A builder for [`HostProperties`](crate::model::HostProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cores: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) instance_family: std::option::Option<std::string::String>,
        pub(crate) sockets: std::option::Option<i32>,
        pub(crate) total_v_cpus: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of cores on the Dedicated Host.</p>
        pub fn cores(mut self, input: i32) -> Self {
            self.cores = Some(input);
            self
        }
        pub fn set_cores(mut self, input: std::option::Option<i32>) -> Self {
            self.cores = input;
            self
        }
        /// <p>The instance type supported by the Dedicated Host. For example, <code>m5.large</code>.
        /// If the host supports multiple instance types, no <b>instanceType</b>
        /// is returned.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The instance family supported by the Dedicated Host. For example, <code>m5</code>.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_family = Some(input.into());
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The number of sockets on the Dedicated Host.</p>
        pub fn sockets(mut self, input: i32) -> Self {
            self.sockets = Some(input);
            self
        }
        pub fn set_sockets(mut self, input: std::option::Option<i32>) -> Self {
            self.sockets = input;
            self
        }
        /// <p>The total number of vCPUs on the Dedicated Host.</p>
        pub fn total_v_cpus(mut self, input: i32) -> Self {
            self.total_v_cpus = Some(input);
            self
        }
        pub fn set_total_v_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.total_v_cpus = input;
            self
        }
        /// Consumes the builder and constructs a [`HostProperties`](crate::model::HostProperties)
        pub fn build(self) -> crate::model::HostProperties {
            crate::model::HostProperties {
                cores: self.cores,
                instance_type: self.instance_type,
                instance_family: self.instance_family,
                sockets: self.sockets,
                total_v_cpus: self.total_v_cpus,
            }
        }
    }
}
impl HostProperties {
    /// Creates a new builder-style object to manufacture [`HostProperties`](crate::model::HostProperties)
    pub fn builder() -> crate::model::host_properties::Builder {
        crate::model::host_properties::Builder::default()
    }
}

/// <p>The capacity information for instances that can be launched onto the Dedicated Host. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailableCapacity {
    /// <p>The number of instances that can be launched onto the Dedicated Host depending on
    /// the host's available capacity. For Dedicated Hosts that support multiple instance types,
    /// this parameter represents the number of instances for each instance size that is
    /// supported on the host.</p>
    pub available_instance_capacity:
        std::option::Option<std::vec::Vec<crate::model::InstanceCapacity>>,
    /// <p>The number of vCPUs available for launching instances onto the Dedicated Host.</p>
    pub available_v_cpus: std::option::Option<i32>,
}
impl std::fmt::Debug for AvailableCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailableCapacity");
        formatter.field(
            "available_instance_capacity",
            &self.available_instance_capacity,
        );
        formatter.field("available_v_cpus", &self.available_v_cpus);
        formatter.finish()
    }
}
/// See [`AvailableCapacity`](crate::model::AvailableCapacity)
pub mod available_capacity {
    /// A builder for [`AvailableCapacity`](crate::model::AvailableCapacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) available_instance_capacity:
            std::option::Option<std::vec::Vec<crate::model::InstanceCapacity>>,
        pub(crate) available_v_cpus: std::option::Option<i32>,
    }
    impl Builder {
        pub fn available_instance_capacity(
            mut self,
            input: impl Into<crate::model::InstanceCapacity>,
        ) -> Self {
            let mut v = self.available_instance_capacity.unwrap_or_default();
            v.push(input.into());
            self.available_instance_capacity = Some(v);
            self
        }
        pub fn set_available_instance_capacity(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceCapacity>>,
        ) -> Self {
            self.available_instance_capacity = input;
            self
        }
        /// <p>The number of vCPUs available for launching instances onto the Dedicated Host.</p>
        pub fn available_v_cpus(mut self, input: i32) -> Self {
            self.available_v_cpus = Some(input);
            self
        }
        pub fn set_available_v_cpus(mut self, input: std::option::Option<i32>) -> Self {
            self.available_v_cpus = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailableCapacity`](crate::model::AvailableCapacity)
        pub fn build(self) -> crate::model::AvailableCapacity {
            crate::model::AvailableCapacity {
                available_instance_capacity: self.available_instance_capacity,
                available_v_cpus: self.available_v_cpus,
            }
        }
    }
}
impl AvailableCapacity {
    /// Creates a new builder-style object to manufacture [`AvailableCapacity`](crate::model::AvailableCapacity)
    pub fn builder() -> crate::model::available_capacity::Builder {
        crate::model::available_capacity::Builder::default()
    }
}

/// <p>Information about the number of instances that can be launched onto the Dedicated
/// Host.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceCapacity {
    /// <p>The number of instances that can be launched onto the Dedicated Host based on the
    /// host's available capacity.</p>
    pub available_capacity: std::option::Option<i32>,
    /// <p>The instance type supported by the Dedicated Host.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The total number of instances that can be launched onto the Dedicated Host if there
    /// are no instances running on it.</p>
    pub total_capacity: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceCapacity");
        formatter.field("available_capacity", &self.available_capacity);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("total_capacity", &self.total_capacity);
        formatter.finish()
    }
}
/// See [`InstanceCapacity`](crate::model::InstanceCapacity)
pub mod instance_capacity {
    /// A builder for [`InstanceCapacity`](crate::model::InstanceCapacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) available_capacity: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) total_capacity: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of instances that can be launched onto the Dedicated Host based on the
        /// host's available capacity.</p>
        pub fn available_capacity(mut self, input: i32) -> Self {
            self.available_capacity = Some(input);
            self
        }
        pub fn set_available_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.available_capacity = input;
            self
        }
        /// <p>The instance type supported by the Dedicated Host.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The total number of instances that can be launched onto the Dedicated Host if there
        /// are no instances running on it.</p>
        pub fn total_capacity(mut self, input: i32) -> Self {
            self.total_capacity = Some(input);
            self
        }
        pub fn set_total_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.total_capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceCapacity`](crate::model::InstanceCapacity)
        pub fn build(self) -> crate::model::InstanceCapacity {
            crate::model::InstanceCapacity {
                available_capacity: self.available_capacity,
                instance_type: self.instance_type,
                total_capacity: self.total_capacity,
            }
        }
    }
}
impl InstanceCapacity {
    /// Creates a new builder-style object to manufacture [`InstanceCapacity`](crate::model::InstanceCapacity)
    pub fn builder() -> crate::model::instance_capacity::Builder {
        crate::model::instance_capacity::Builder::default()
    }
}

/// <p>Details about the Dedicated Host Reservation and associated Dedicated
/// Hosts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HostReservation {
    /// <p>The number of Dedicated Hosts the reservation is associated with.</p>
    pub count: std::option::Option<i32>,
    /// <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code>
    /// amounts are specified. At this time, the only supported currency is
    /// <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The length of the reservation's term, specified in seconds. Can be <code>31536000
    /// (1 year)</code> | <code>94608000 (3 years)</code>.</p>
    pub duration: std::option::Option<i32>,
    /// <p>The date and time that the reservation ends.</p>
    pub end: std::option::Option<smithy_types::Instant>,
    /// <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
    pub host_id_set: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
    pub host_reservation_id: std::option::Option<std::string::String>,
    /// <p>The hourly price of the reservation.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The instance family of the Dedicated Host Reservation. The instance family on the
    /// Dedicated Host must be the same in order for it to benefit from the
    /// reservation.</p>
    pub instance_family: std::option::Option<std::string::String>,
    /// <p>The ID of the reservation. This remains the same regardless of which Dedicated
    /// Hosts are associated with it.</p>
    pub offering_id: std::option::Option<std::string::String>,
    /// <p>The payment option selected for this reservation.</p>
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The date and time that the reservation started.</p>
    pub start: std::option::Option<smithy_types::Instant>,
    /// <p>The state of the reservation.</p>
    pub state: std::option::Option<crate::model::ReservationState>,
    /// <p>The upfront price of the reservation.</p>
    pub upfront_price: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the Dedicated Host Reservation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for HostReservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HostReservation");
        formatter.field("count", &self.count);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("end", &self.end);
        formatter.field("host_id_set", &self.host_id_set);
        formatter.field("host_reservation_id", &self.host_reservation_id);
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("instance_family", &self.instance_family);
        formatter.field("offering_id", &self.offering_id);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("start", &self.start);
        formatter.field("state", &self.state);
        formatter.field("upfront_price", &self.upfront_price);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`HostReservation`](crate::model::HostReservation)
pub mod host_reservation {
    /// A builder for [`HostReservation`](crate::model::HostReservation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) end: std::option::Option<smithy_types::Instant>,
        pub(crate) host_id_set: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) host_reservation_id: std::option::Option<std::string::String>,
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) instance_family: std::option::Option<std::string::String>,
        pub(crate) offering_id: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) start: std::option::Option<smithy_types::Instant>,
        pub(crate) state: std::option::Option<crate::model::ReservationState>,
        pub(crate) upfront_price: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The number of Dedicated Hosts the reservation is associated with.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code>
        /// amounts are specified. At this time, the only supported currency is
        /// <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The length of the reservation's term, specified in seconds. Can be <code>31536000
        /// (1 year)</code> | <code>94608000 (3 years)</code>.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The date and time that the reservation ends.</p>
        pub fn end(mut self, input: smithy_types::Instant) -> Self {
            self.end = Some(input);
            self
        }
        pub fn set_end(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end = input;
            self
        }
        pub fn host_id_set(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.host_id_set.unwrap_or_default();
            v.push(input.into());
            self.host_id_set = Some(v);
            self
        }
        pub fn set_host_id_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.host_id_set = input;
            self
        }
        /// <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
        pub fn host_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_reservation_id = Some(input.into());
            self
        }
        pub fn set_host_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_reservation_id = input;
            self
        }
        /// <p>The hourly price of the reservation.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The instance family of the Dedicated Host Reservation. The instance family on the
        /// Dedicated Host must be the same in order for it to benefit from the
        /// reservation.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_family = Some(input.into());
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The ID of the reservation. This remains the same regardless of which Dedicated
        /// Hosts are associated with it.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_id = Some(input.into());
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offering_id = input;
            self
        }
        /// <p>The payment option selected for this reservation.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The date and time that the reservation started.</p>
        pub fn start(mut self, input: smithy_types::Instant) -> Self {
            self.start = Some(input);
            self
        }
        pub fn set_start(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start = input;
            self
        }
        /// <p>The state of the reservation.</p>
        pub fn state(mut self, input: crate::model::ReservationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ReservationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The upfront price of the reservation.</p>
        pub fn upfront_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.upfront_price = Some(input.into());
            self
        }
        pub fn set_upfront_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upfront_price = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HostReservation`](crate::model::HostReservation)
        pub fn build(self) -> crate::model::HostReservation {
            crate::model::HostReservation {
                count: self.count,
                currency_code: self.currency_code,
                duration: self.duration,
                end: self.end,
                host_id_set: self.host_id_set,
                host_reservation_id: self.host_reservation_id,
                hourly_price: self.hourly_price,
                instance_family: self.instance_family,
                offering_id: self.offering_id,
                payment_option: self.payment_option,
                start: self.start,
                state: self.state,
                upfront_price: self.upfront_price,
                tags: self.tags,
            }
        }
    }
}
impl HostReservation {
    /// Creates a new builder-style object to manufacture [`HostReservation`](crate::model::HostReservation)
    pub fn builder() -> crate::model::host_reservation::Builder {
        crate::model::host_reservation::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReservationState {
    Active,
    PaymentFailed,
    PaymentPending,
    Retired,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReservationState {
    fn from(s: &str) -> Self {
        match s {
            "active" => ReservationState::Active,
            "payment-failed" => ReservationState::PaymentFailed,
            "payment-pending" => ReservationState::PaymentPending,
            "retired" => ReservationState::Retired,
            other => ReservationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReservationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReservationState::from(s))
    }
}
impl ReservationState {
    pub fn as_str(&self) -> &str {
        match self {
            ReservationState::Active => "active",
            ReservationState::PaymentFailed => "payment-failed",
            ReservationState::PaymentPending => "payment-pending",
            ReservationState::Retired => "retired",
            ReservationState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "payment-failed", "payment-pending", "retired"]
    }
}
impl AsRef<str> for ReservationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about the Dedicated Host Reservation offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HostOffering {
    /// <p>The currency of the offering.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The duration of the offering (in seconds).</p>
    pub duration: std::option::Option<i32>,
    /// <p>The hourly price of the offering.</p>
    pub hourly_price: std::option::Option<std::string::String>,
    /// <p>The instance family of the offering.</p>
    pub instance_family: std::option::Option<std::string::String>,
    /// <p>The ID of the offering.</p>
    pub offering_id: std::option::Option<std::string::String>,
    /// <p>The available payment option.</p>
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The upfront price of the offering. Does not apply to No Upfront
    /// offerings.</p>
    pub upfront_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HostOffering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HostOffering");
        formatter.field("currency_code", &self.currency_code);
        formatter.field("duration", &self.duration);
        formatter.field("hourly_price", &self.hourly_price);
        formatter.field("instance_family", &self.instance_family);
        formatter.field("offering_id", &self.offering_id);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("upfront_price", &self.upfront_price);
        formatter.finish()
    }
}
/// See [`HostOffering`](crate::model::HostOffering)
pub mod host_offering {
    /// A builder for [`HostOffering`](crate::model::HostOffering)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) hourly_price: std::option::Option<std::string::String>,
        pub(crate) instance_family: std::option::Option<std::string::String>,
        pub(crate) offering_id: std::option::Option<std::string::String>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) upfront_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The currency of the offering.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The duration of the offering (in seconds).</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The hourly price of the offering.</p>
        pub fn hourly_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_price = Some(input.into());
            self
        }
        pub fn set_hourly_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hourly_price = input;
            self
        }
        /// <p>The instance family of the offering.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_family = Some(input.into());
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The ID of the offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_id = Some(input.into());
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offering_id = input;
            self
        }
        /// <p>The available payment option.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The upfront price of the offering. Does not apply to No Upfront
        /// offerings.</p>
        pub fn upfront_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.upfront_price = Some(input.into());
            self
        }
        pub fn set_upfront_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upfront_price = input;
            self
        }
        /// Consumes the builder and constructs a [`HostOffering`](crate::model::HostOffering)
        pub fn build(self) -> crate::model::HostOffering {
            crate::model::HostOffering {
                currency_code: self.currency_code,
                duration: self.duration,
                hourly_price: self.hourly_price,
                instance_family: self.instance_family,
                offering_id: self.offering_id,
                payment_option: self.payment_option,
                upfront_price: self.upfront_price,
            }
        }
    }
}
impl HostOffering {
    /// Creates a new builder-style object to manufacture [`HostOffering`](crate::model::HostOffering)
    pub fn builder() -> crate::model::host_offering::Builder {
        crate::model::host_offering::Builder::default()
    }
}

/// <p>Describes an Amazon FPGA image (AFI).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaImage {
    /// <p>The FPGA image identifier (AFI ID).</p>
    pub fpga_image_id: std::option::Option<std::string::String>,
    /// <p>The global FPGA image identifier (AGFI ID).</p>
    pub fpga_image_global_id: std::option::Option<std::string::String>,
    /// <p>The name of the AFI.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the AFI.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The version of the AWS Shell that was used to create the bitstream.</p>
    pub shell_version: std::option::Option<std::string::String>,
    /// <p>Information about the PCI bus.</p>
    pub pci_id: std::option::Option<crate::model::PciId>,
    /// <p>Information about the state of the AFI.</p>
    pub state: std::option::Option<crate::model::FpgaImageState>,
    /// <p>The date and time the AFI was created.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time of the most recent update to the AFI.</p>
    pub update_time: std::option::Option<smithy_types::Instant>,
    /// <p>The AWS account ID of the AFI owner.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
    pub owner_alias: std::option::Option<std::string::String>,
    /// <p>The product codes for the AFI.</p>
    pub product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
    /// <p>Any tags assigned to the AFI.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Indicates whether the AFI is public.</p>
    pub public: std::option::Option<bool>,
    /// <p>Indicates whether data retention support is enabled for the AFI.</p>
    pub data_retention_support: std::option::Option<bool>,
}
impl std::fmt::Debug for FpgaImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaImage");
        formatter.field("fpga_image_id", &self.fpga_image_id);
        formatter.field("fpga_image_global_id", &self.fpga_image_global_id);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("shell_version", &self.shell_version);
        formatter.field("pci_id", &self.pci_id);
        formatter.field("state", &self.state);
        formatter.field("create_time", &self.create_time);
        formatter.field("update_time", &self.update_time);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.field("product_codes", &self.product_codes);
        formatter.field("tags", &self.tags);
        formatter.field("public", &self.public);
        formatter.field("data_retention_support", &self.data_retention_support);
        formatter.finish()
    }
}
/// See [`FpgaImage`](crate::model::FpgaImage)
pub mod fpga_image {
    /// A builder for [`FpgaImage`](crate::model::FpgaImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpga_image_id: std::option::Option<std::string::String>,
        pub(crate) fpga_image_global_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) shell_version: std::option::Option<std::string::String>,
        pub(crate) pci_id: std::option::Option<crate::model::PciId>,
        pub(crate) state: std::option::Option<crate::model::FpgaImageState>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
        pub(crate) product_codes: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) public: std::option::Option<bool>,
        pub(crate) data_retention_support: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The FPGA image identifier (AFI ID).</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fpga_image_id = Some(input.into());
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fpga_image_id = input;
            self
        }
        /// <p>The global FPGA image identifier (AGFI ID).</p>
        pub fn fpga_image_global_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fpga_image_global_id = Some(input.into());
            self
        }
        pub fn set_fpga_image_global_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fpga_image_global_id = input;
            self
        }
        /// <p>The name of the AFI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the AFI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The version of the AWS Shell that was used to create the bitstream.</p>
        pub fn shell_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.shell_version = Some(input.into());
            self
        }
        pub fn set_shell_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shell_version = input;
            self
        }
        /// <p>Information about the PCI bus.</p>
        pub fn pci_id(mut self, input: crate::model::PciId) -> Self {
            self.pci_id = Some(input);
            self
        }
        pub fn set_pci_id(mut self, input: std::option::Option<crate::model::PciId>) -> Self {
            self.pci_id = input;
            self
        }
        /// <p>Information about the state of the AFI.</p>
        pub fn state(mut self, input: crate::model::FpgaImageState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::FpgaImageState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time the AFI was created.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The time of the most recent update to the AFI.</p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// <p>The AWS account ID of the AFI owner.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        pub fn product_codes(mut self, input: impl Into<crate::model::ProductCode>) -> Self {
            let mut v = self.product_codes.unwrap_or_default();
            v.push(input.into());
            self.product_codes = Some(v);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductCode>>,
        ) -> Self {
            self.product_codes = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Indicates whether the AFI is public.</p>
        pub fn public(mut self, input: bool) -> Self {
            self.public = Some(input);
            self
        }
        pub fn set_public(mut self, input: std::option::Option<bool>) -> Self {
            self.public = input;
            self
        }
        /// <p>Indicates whether data retention support is enabled for the AFI.</p>
        pub fn data_retention_support(mut self, input: bool) -> Self {
            self.data_retention_support = Some(input);
            self
        }
        pub fn set_data_retention_support(mut self, input: std::option::Option<bool>) -> Self {
            self.data_retention_support = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaImage`](crate::model::FpgaImage)
        pub fn build(self) -> crate::model::FpgaImage {
            crate::model::FpgaImage {
                fpga_image_id: self.fpga_image_id,
                fpga_image_global_id: self.fpga_image_global_id,
                name: self.name,
                description: self.description,
                shell_version: self.shell_version,
                pci_id: self.pci_id,
                state: self.state,
                create_time: self.create_time,
                update_time: self.update_time,
                owner_id: self.owner_id,
                owner_alias: self.owner_alias,
                product_codes: self.product_codes,
                tags: self.tags,
                public: self.public,
                data_retention_support: self.data_retention_support,
            }
        }
    }
}
impl FpgaImage {
    /// Creates a new builder-style object to manufacture [`FpgaImage`](crate::model::FpgaImage)
    pub fn builder() -> crate::model::fpga_image::Builder {
        crate::model::fpga_image::Builder::default()
    }
}

/// <p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FpgaImageState {
    /// <p>The state. The following are the possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>pending</code> - AFI bitstream generation is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>available</code> - The AFI is available for use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failed</code> - AFI bitstream generation failed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>unavailable</code> - The AFI is no longer available for use.</p>
    /// </li>
    /// </ul>
    pub code: std::option::Option<crate::model::FpgaImageStateCode>,
    /// <p>If the state is <code>failed</code>, this is the error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FpgaImageState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FpgaImageState");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`FpgaImageState`](crate::model::FpgaImageState)
pub mod fpga_image_state {
    /// A builder for [`FpgaImageState`](crate::model::FpgaImageState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::FpgaImageStateCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>pending</code> - AFI bitstream generation is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available</code> - The AFI is available for use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed</code> - AFI bitstream generation failed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>unavailable</code> - The AFI is no longer available for use.</p>
        /// </li>
        /// </ul>
        pub fn code(mut self, input: crate::model::FpgaImageStateCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::FpgaImageStateCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>If the state is <code>failed</code>, this is the error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FpgaImageState`](crate::model::FpgaImageState)
        pub fn build(self) -> crate::model::FpgaImageState {
            crate::model::FpgaImageState {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl FpgaImageState {
    /// Creates a new builder-style object to manufacture [`FpgaImageState`](crate::model::FpgaImageState)
    pub fn builder() -> crate::model::fpga_image_state::Builder {
        crate::model::fpga_image_state::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FpgaImageStateCode {
    Available,
    Failed,
    Pending,
    Unavailable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FpgaImageStateCode {
    fn from(s: &str) -> Self {
        match s {
            "available" => FpgaImageStateCode::Available,
            "failed" => FpgaImageStateCode::Failed,
            "pending" => FpgaImageStateCode::Pending,
            "unavailable" => FpgaImageStateCode::Unavailable,
            other => FpgaImageStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FpgaImageStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FpgaImageStateCode::from(s))
    }
}
impl FpgaImageStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            FpgaImageStateCode::Available => "available",
            FpgaImageStateCode::Failed => "failed",
            FpgaImageStateCode::Pending => "pending",
            FpgaImageStateCode::Unavailable => "unavailable",
            FpgaImageStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "failed", "pending", "unavailable"]
    }
}
impl AsRef<str> for FpgaImageStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PciId {
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the vendor.</p>
    pub vendor_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subsystem.</p>
    pub subsystem_id: std::option::Option<std::string::String>,
    /// <p>The ID of the vendor for the subsystem.</p>
    pub subsystem_vendor_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PciId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PciId");
        formatter.field("device_id", &self.device_id);
        formatter.field("vendor_id", &self.vendor_id);
        formatter.field("subsystem_id", &self.subsystem_id);
        formatter.field("subsystem_vendor_id", &self.subsystem_vendor_id);
        formatter.finish()
    }
}
/// See [`PciId`](crate::model::PciId)
pub mod pci_id {
    /// A builder for [`PciId`](crate::model::PciId)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) vendor_id: std::option::Option<std::string::String>,
        pub(crate) subsystem_id: std::option::Option<std::string::String>,
        pub(crate) subsystem_vendor_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the vendor.</p>
        pub fn vendor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor_id = Some(input.into());
            self
        }
        pub fn set_vendor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor_id = input;
            self
        }
        /// <p>The ID of the subsystem.</p>
        pub fn subsystem_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subsystem_id = Some(input.into());
            self
        }
        pub fn set_subsystem_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subsystem_id = input;
            self
        }
        /// <p>The ID of the vendor for the subsystem.</p>
        pub fn subsystem_vendor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subsystem_vendor_id = Some(input.into());
            self
        }
        pub fn set_subsystem_vendor_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subsystem_vendor_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PciId`](crate::model::PciId)
        pub fn build(self) -> crate::model::PciId {
            crate::model::PciId {
                device_id: self.device_id,
                vendor_id: self.vendor_id,
                subsystem_id: self.subsystem_id,
                subsystem_vendor_id: self.subsystem_vendor_id,
            }
        }
    }
}
impl PciId {
    /// Creates a new builder-style object to manufacture [`PciId`](crate::model::PciId)
    pub fn builder() -> crate::model::pci_id::Builder {
        crate::model::pci_id::Builder::default()
    }
}

/// <p>Describes a flow log.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlowLog {
    /// <p>The date and time the flow log was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the error that occurred. <code>Rate limited</code> indicates that
    /// CloudWatch Logs throttling has been applied for one or more network interfaces, or that you've
    /// reached the limit on the number of log groups that you can create. <code>Access
    /// error</code> indicates that the IAM role associated with the flow log does not have
    /// sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an
    /// internal error.</p>
    pub deliver_logs_error_message: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
    pub deliver_logs_permission_arn: std::option::Option<std::string::String>,
    /// <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
    pub deliver_logs_status: std::option::Option<std::string::String>,
    /// <p>The flow log ID.</p>
    pub flow_log_id: std::option::Option<std::string::String>,
    /// <p>The status of the flow log (<code>ACTIVE</code>).</p>
    pub flow_log_status: std::option::Option<std::string::String>,
    /// <p>The name of the flow log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the resource on which the flow log was created.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of traffic captured for the flow log.</p>
    pub traffic_type: std::option::Option<crate::model::TrafficType>,
    /// <p>Specifies the type of destination to which the flow log data is published. Flow log data can be
    /// published to CloudWatch Logs or Amazon S3.</p>
    pub log_destination_type: std::option::Option<crate::model::LogDestinationType>,
    /// <p>Specifies the destination to which the flow log data is published. Flow log data can be
    /// published to an CloudWatch Logs log group or an Amazon S3 bucket. If the flow log publishes to CloudWatch Logs,
    /// this element indicates the Amazon Resource Name (ARN) of the CloudWatch Logs log group to which
    /// the data is published. If the flow log publishes to Amazon S3, this element indicates the ARN
    /// of the Amazon S3 bucket to which the data is published.</p>
    pub log_destination: std::option::Option<std::string::String>,
    /// <p>The format of the flow log record.</p>
    pub log_format: std::option::Option<std::string::String>,
    /// <p>The tags for the flow log.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record.</p>
    /// <p>When a network interface is attached to a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Nitro-based
    /// instance</a>, the aggregation interval is always 60 seconds (1 minute) or less,
    /// regardless of the specified value.</p>
    /// <p>Valid Values: <code>60</code> | <code>600</code>
    /// </p>
    pub max_aggregation_interval: std::option::Option<i32>,
}
impl std::fmt::Debug for FlowLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlowLog");
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "deliver_logs_error_message",
            &self.deliver_logs_error_message,
        );
        formatter.field(
            "deliver_logs_permission_arn",
            &self.deliver_logs_permission_arn,
        );
        formatter.field("deliver_logs_status", &self.deliver_logs_status);
        formatter.field("flow_log_id", &self.flow_log_id);
        formatter.field("flow_log_status", &self.flow_log_status);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("traffic_type", &self.traffic_type);
        formatter.field("log_destination_type", &self.log_destination_type);
        formatter.field("log_destination", &self.log_destination);
        formatter.field("log_format", &self.log_format);
        formatter.field("tags", &self.tags);
        formatter.field("max_aggregation_interval", &self.max_aggregation_interval);
        formatter.finish()
    }
}
/// See [`FlowLog`](crate::model::FlowLog)
pub mod flow_log {
    /// A builder for [`FlowLog`](crate::model::FlowLog)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) deliver_logs_error_message: std::option::Option<std::string::String>,
        pub(crate) deliver_logs_permission_arn: std::option::Option<std::string::String>,
        pub(crate) deliver_logs_status: std::option::Option<std::string::String>,
        pub(crate) flow_log_id: std::option::Option<std::string::String>,
        pub(crate) flow_log_status: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) traffic_type: std::option::Option<crate::model::TrafficType>,
        pub(crate) log_destination_type: std::option::Option<crate::model::LogDestinationType>,
        pub(crate) log_destination: std::option::Option<std::string::String>,
        pub(crate) log_format: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) max_aggregation_interval: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The date and time the flow log was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the error that occurred. <code>Rate limited</code> indicates that
        /// CloudWatch Logs throttling has been applied for one or more network interfaces, or that you've
        /// reached the limit on the number of log groups that you can create. <code>Access
        /// error</code> indicates that the IAM role associated with the flow log does not have
        /// sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an
        /// internal error.</p>
        pub fn deliver_logs_error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.deliver_logs_error_message = Some(input.into());
            self
        }
        pub fn set_deliver_logs_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deliver_logs_error_message = input;
            self
        }
        /// <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
        pub fn deliver_logs_permission_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.deliver_logs_permission_arn = Some(input.into());
            self
        }
        pub fn set_deliver_logs_permission_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deliver_logs_permission_arn = input;
            self
        }
        /// <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
        pub fn deliver_logs_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.deliver_logs_status = Some(input.into());
            self
        }
        pub fn set_deliver_logs_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deliver_logs_status = input;
            self
        }
        /// <p>The flow log ID.</p>
        pub fn flow_log_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_log_id = Some(input.into());
            self
        }
        pub fn set_flow_log_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.flow_log_id = input;
            self
        }
        /// <p>The status of the flow log (<code>ACTIVE</code>).</p>
        pub fn flow_log_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_log_status = Some(input.into());
            self
        }
        pub fn set_flow_log_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.flow_log_status = input;
            self
        }
        /// <p>The name of the flow log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The ID of the resource on which the flow log was created.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of traffic captured for the flow log.</p>
        pub fn traffic_type(mut self, input: crate::model::TrafficType) -> Self {
            self.traffic_type = Some(input);
            self
        }
        pub fn set_traffic_type(
            mut self,
            input: std::option::Option<crate::model::TrafficType>,
        ) -> Self {
            self.traffic_type = input;
            self
        }
        /// <p>Specifies the type of destination to which the flow log data is published. Flow log data can be
        /// published to CloudWatch Logs or Amazon S3.</p>
        pub fn log_destination_type(mut self, input: crate::model::LogDestinationType) -> Self {
            self.log_destination_type = Some(input);
            self
        }
        pub fn set_log_destination_type(
            mut self,
            input: std::option::Option<crate::model::LogDestinationType>,
        ) -> Self {
            self.log_destination_type = input;
            self
        }
        /// <p>Specifies the destination to which the flow log data is published. Flow log data can be
        /// published to an CloudWatch Logs log group or an Amazon S3 bucket. If the flow log publishes to CloudWatch Logs,
        /// this element indicates the Amazon Resource Name (ARN) of the CloudWatch Logs log group to which
        /// the data is published. If the flow log publishes to Amazon S3, this element indicates the ARN
        /// of the Amazon S3 bucket to which the data is published.</p>
        pub fn log_destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_destination = Some(input.into());
            self
        }
        pub fn set_log_destination(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_destination = input;
            self
        }
        /// <p>The format of the flow log record.</p>
        pub fn log_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_format = Some(input.into());
            self
        }
        pub fn set_log_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_format = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record.</p>
        /// <p>When a network interface is attached to a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Nitro-based
        /// instance</a>, the aggregation interval is always 60 seconds (1 minute) or less,
        /// regardless of the specified value.</p>
        /// <p>Valid Values: <code>60</code> | <code>600</code>
        /// </p>
        pub fn max_aggregation_interval(mut self, input: i32) -> Self {
            self.max_aggregation_interval = Some(input);
            self
        }
        pub fn set_max_aggregation_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.max_aggregation_interval = input;
            self
        }
        /// Consumes the builder and constructs a [`FlowLog`](crate::model::FlowLog)
        pub fn build(self) -> crate::model::FlowLog {
            crate::model::FlowLog {
                creation_time: self.creation_time,
                deliver_logs_error_message: self.deliver_logs_error_message,
                deliver_logs_permission_arn: self.deliver_logs_permission_arn,
                deliver_logs_status: self.deliver_logs_status,
                flow_log_id: self.flow_log_id,
                flow_log_status: self.flow_log_status,
                log_group_name: self.log_group_name,
                resource_id: self.resource_id,
                traffic_type: self.traffic_type,
                log_destination_type: self.log_destination_type,
                log_destination: self.log_destination,
                log_format: self.log_format,
                tags: self.tags,
                max_aggregation_interval: self.max_aggregation_interval,
            }
        }
    }
}
impl FlowLog {
    /// Creates a new builder-style object to manufacture [`FlowLog`](crate::model::FlowLog)
    pub fn builder() -> crate::model::flow_log::Builder {
        crate::model::flow_log::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogDestinationType {
    CloudWatchLogs,
    S3,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LogDestinationType {
    fn from(s: &str) -> Self {
        match s {
            "cloud-watch-logs" => LogDestinationType::CloudWatchLogs,
            "s3" => LogDestinationType::S3,
            other => LogDestinationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LogDestinationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogDestinationType::from(s))
    }
}
impl LogDestinationType {
    pub fn as_str(&self) -> &str {
        match self {
            LogDestinationType::CloudWatchLogs => "cloud-watch-logs",
            LogDestinationType::S3 => "s3",
            LogDestinationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["cloud-watch-logs", "s3"]
    }
}
impl AsRef<str> for LogDestinationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficType {
    Accept,
    All,
    Reject,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficType {
    fn from(s: &str) -> Self {
        match s {
            "ACCEPT" => TrafficType::Accept,
            "ALL" => TrafficType::All,
            "REJECT" => TrafficType::Reject,
            other => TrafficType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficType::from(s))
    }
}
impl TrafficType {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficType::Accept => "ACCEPT",
            TrafficType::All => "ALL",
            TrafficType::Reject => "REJECT",
            TrafficType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ACCEPT", "ALL", "REJECT"]
    }
}
impl AsRef<str> for TrafficType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an EC2 Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetData {
    /// <p>The progress of the EC2 Fleet. If there is an error, the status is <code>error</code>. After
    /// all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the
    /// EC2 Fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>.
    /// If the size of the EC2 Fleet is decreased, the status is <code>pending_termination</code> while
    /// instances are terminating.</p>
    pub activity_status: std::option::Option<crate::model::FleetActivityStatus>,
    /// <p>The creation date and time of the EC2 Fleet.</p>
    pub create_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the EC2 Fleet.</p>
    pub fleet_id: std::option::Option<std::string::String>,
    /// <p>The state of the EC2 Fleet.</p>
    pub fleet_state: std::option::Option<crate::model::FleetStateCode>,
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
    /// Idempotency</a>.</p>
    /// <p>Constraints: Maximum 64 ASCII characters</p>
    pub client_token: std::option::Option<std::string::String>,
    /// <p>Indicates whether running instances should be terminated if the target capacity of the
    /// EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
    pub excess_capacity_termination_policy:
        std::option::Option<crate::model::FleetExcessCapacityTerminationPolicy>,
    /// <p>The number of units fulfilled by this request compared to the set target
    /// capacity.</p>
    pub fulfilled_capacity: std::option::Option<f64>,
    /// <p>The number of units fulfilled by this request compared to the set target On-Demand
    /// capacity.</p>
    pub fulfilled_on_demand_capacity: std::option::Option<f64>,
    /// <p>The launch template and overrides.</p>
    pub launch_template_configs:
        std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateConfig>>,
    /// <p>The number of units to request. You can choose to set the target capacity in terms of
    /// instances or a performance characteristic that is important to your application workload,
    /// such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can
    /// specify a target capacity of 0 and add capacity later.</p>
    pub target_capacity_specification:
        std::option::Option<crate::model::TargetCapacitySpecification>,
    /// <p>Indicates whether running instances should be terminated when the EC2 Fleet expires. </p>
    pub terminate_instances_with_expiration: std::option::Option<bool>,
    /// <p>The type of request. Indicates whether the EC2 Fleet only <code>requests</code> the target
    /// capacity, or also attempts to <code>maintain</code> it. If you request a certain target
    /// capacity, EC2 Fleet only places the required requests; it does not attempt to replenish
    /// instances if capacity is diminished, and it does not submit requests in alternative
    /// capacity pools if capacity is unavailable. To maintain a certain target capacity, EC2 Fleet
    /// places the required requests to meet this target capacity. It also automatically
    /// replenishes any interrupted Spot Instances. Default: <code>maintain</code>.</p>
    pub r#type: std::option::Option<crate::model::FleetType>,
    /// <p>The start date and time of the request, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// The default is to start fulfilling the request immediately. </p>
    pub valid_from: std::option::Option<smithy_types::Instant>,
    /// <p>The end date and time of the request, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
    /// At this point, no new instance requests are placed or able to fulfill the request. The
    /// default end date is 7 days from the current date. </p>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for
    /// fleets of type <code>maintain</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks">EC2 Fleet
    /// health checks</a> in the <i>Amazon EC2 User Guide</i>.</p>
    pub replace_unhealthy_instances: std::option::Option<bool>,
    /// <p>The configuration of Spot Instances in an EC2 Fleet.</p>
    pub spot_options: std::option::Option<crate::model::SpotOptions>,
    /// <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
    pub on_demand_options: std::option::Option<crate::model::OnDemandOptions>,
    /// <p>The tags for an EC2 Fleet resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Information about the instances that could not be launched by the fleet. Valid only when
    /// <b>Type</b> is set to <code>instant</code>.</p>
    pub errors: std::option::Option<std::vec::Vec<crate::model::DescribeFleetError>>,
    /// <p>Information about the instances that were launched by the fleet. Valid only when
    /// <b>Type</b> is set to <code>instant</code>.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::DescribeFleetsInstances>>,
    /// <p>Reserved.</p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FleetData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetData");
        formatter.field("activity_status", &self.activity_status);
        formatter.field("create_time", &self.create_time);
        formatter.field("fleet_id", &self.fleet_id);
        formatter.field("fleet_state", &self.fleet_state);
        formatter.field("client_token", &self.client_token);
        formatter.field(
            "excess_capacity_termination_policy",
            &self.excess_capacity_termination_policy,
        );
        formatter.field("fulfilled_capacity", &self.fulfilled_capacity);
        formatter.field(
            "fulfilled_on_demand_capacity",
            &self.fulfilled_on_demand_capacity,
        );
        formatter.field("launch_template_configs", &self.launch_template_configs);
        formatter.field(
            "target_capacity_specification",
            &self.target_capacity_specification,
        );
        formatter.field(
            "terminate_instances_with_expiration",
            &self.terminate_instances_with_expiration,
        );
        formatter.field("r#type", &self.r#type);
        formatter.field("valid_from", &self.valid_from);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "replace_unhealthy_instances",
            &self.replace_unhealthy_instances,
        );
        formatter.field("spot_options", &self.spot_options);
        formatter.field("on_demand_options", &self.on_demand_options);
        formatter.field("tags", &self.tags);
        formatter.field("errors", &self.errors);
        formatter.field("instances", &self.instances);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
/// See [`FleetData`](crate::model::FleetData)
pub mod fleet_data {
    /// A builder for [`FleetData`](crate::model::FleetData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activity_status: std::option::Option<crate::model::FleetActivityStatus>,
        pub(crate) create_time: std::option::Option<smithy_types::Instant>,
        pub(crate) fleet_id: std::option::Option<std::string::String>,
        pub(crate) fleet_state: std::option::Option<crate::model::FleetStateCode>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) excess_capacity_termination_policy:
            std::option::Option<crate::model::FleetExcessCapacityTerminationPolicy>,
        pub(crate) fulfilled_capacity: std::option::Option<f64>,
        pub(crate) fulfilled_on_demand_capacity: std::option::Option<f64>,
        pub(crate) launch_template_configs:
            std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateConfig>>,
        pub(crate) target_capacity_specification:
            std::option::Option<crate::model::TargetCapacitySpecification>,
        pub(crate) terminate_instances_with_expiration: std::option::Option<bool>,
        pub(crate) r#type: std::option::Option<crate::model::FleetType>,
        pub(crate) valid_from: std::option::Option<smithy_types::Instant>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) replace_unhealthy_instances: std::option::Option<bool>,
        pub(crate) spot_options: std::option::Option<crate::model::SpotOptions>,
        pub(crate) on_demand_options: std::option::Option<crate::model::OnDemandOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::DescribeFleetError>>,
        pub(crate) instances:
            std::option::Option<std::vec::Vec<crate::model::DescribeFleetsInstances>>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The progress of the EC2 Fleet. If there is an error, the status is <code>error</code>. After
        /// all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the
        /// EC2 Fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>.
        /// If the size of the EC2 Fleet is decreased, the status is <code>pending_termination</code> while
        /// instances are terminating.</p>
        pub fn activity_status(mut self, input: crate::model::FleetActivityStatus) -> Self {
            self.activity_status = Some(input);
            self
        }
        pub fn set_activity_status(
            mut self,
            input: std::option::Option<crate::model::FleetActivityStatus>,
        ) -> Self {
            self.activity_status = input;
            self
        }
        /// <p>The creation date and time of the EC2 Fleet.</p>
        pub fn create_time(mut self, input: smithy_types::Instant) -> Self {
            self.create_time = Some(input);
            self
        }
        pub fn set_create_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// <p>The state of the EC2 Fleet.</p>
        pub fn fleet_state(mut self, input: crate::model::FleetStateCode) -> Self {
            self.fleet_state = Some(input);
            self
        }
        pub fn set_fleet_state(
            mut self,
            input: std::option::Option<crate::model::FleetStateCode>,
        ) -> Self {
            self.fleet_state = input;
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraints: Maximum 64 ASCII characters</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>Indicates whether running instances should be terminated if the target capacity of the
        /// EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
        pub fn excess_capacity_termination_policy(
            mut self,
            input: crate::model::FleetExcessCapacityTerminationPolicy,
        ) -> Self {
            self.excess_capacity_termination_policy = Some(input);
            self
        }
        pub fn set_excess_capacity_termination_policy(
            mut self,
            input: std::option::Option<crate::model::FleetExcessCapacityTerminationPolicy>,
        ) -> Self {
            self.excess_capacity_termination_policy = input;
            self
        }
        /// <p>The number of units fulfilled by this request compared to the set target
        /// capacity.</p>
        pub fn fulfilled_capacity(mut self, input: f64) -> Self {
            self.fulfilled_capacity = Some(input);
            self
        }
        pub fn set_fulfilled_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.fulfilled_capacity = input;
            self
        }
        /// <p>The number of units fulfilled by this request compared to the set target On-Demand
        /// capacity.</p>
        pub fn fulfilled_on_demand_capacity(mut self, input: f64) -> Self {
            self.fulfilled_on_demand_capacity = Some(input);
            self
        }
        pub fn set_fulfilled_on_demand_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.fulfilled_on_demand_capacity = input;
            self
        }
        pub fn launch_template_configs(
            mut self,
            input: impl Into<crate::model::FleetLaunchTemplateConfig>,
        ) -> Self {
            let mut v = self.launch_template_configs.unwrap_or_default();
            v.push(input.into());
            self.launch_template_configs = Some(v);
            self
        }
        pub fn set_launch_template_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateConfig>>,
        ) -> Self {
            self.launch_template_configs = input;
            self
        }
        /// <p>The number of units to request. You can choose to set the target capacity in terms of
        /// instances or a performance characteristic that is important to your application workload,
        /// such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can
        /// specify a target capacity of 0 and add capacity later.</p>
        pub fn target_capacity_specification(
            mut self,
            input: crate::model::TargetCapacitySpecification,
        ) -> Self {
            self.target_capacity_specification = Some(input);
            self
        }
        pub fn set_target_capacity_specification(
            mut self,
            input: std::option::Option<crate::model::TargetCapacitySpecification>,
        ) -> Self {
            self.target_capacity_specification = input;
            self
        }
        /// <p>Indicates whether running instances should be terminated when the EC2 Fleet expires. </p>
        pub fn terminate_instances_with_expiration(mut self, input: bool) -> Self {
            self.terminate_instances_with_expiration = Some(input);
            self
        }
        pub fn set_terminate_instances_with_expiration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.terminate_instances_with_expiration = input;
            self
        }
        /// <p>The type of request. Indicates whether the EC2 Fleet only <code>requests</code> the target
        /// capacity, or also attempts to <code>maintain</code> it. If you request a certain target
        /// capacity, EC2 Fleet only places the required requests; it does not attempt to replenish
        /// instances if capacity is diminished, and it does not submit requests in alternative
        /// capacity pools if capacity is unavailable. To maintain a certain target capacity, EC2 Fleet
        /// places the required requests to meet this target capacity. It also automatically
        /// replenishes any interrupted Spot Instances. Default: <code>maintain</code>.</p>
        pub fn r#type(mut self, input: crate::model::FleetType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::FleetType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The start date and time of the request, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// The default is to start fulfilling the request immediately. </p>
        pub fn valid_from(mut self, input: smithy_types::Instant) -> Self {
            self.valid_from = Some(input);
            self
        }
        pub fn set_valid_from(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.valid_from = input;
            self
        }
        /// <p>The end date and time of the request, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// At this point, no new instance requests are placed or able to fulfill the request. The
        /// default end date is 7 days from the current date. </p>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for
        /// fleets of type <code>maintain</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks">EC2 Fleet
        /// health checks</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn replace_unhealthy_instances(mut self, input: bool) -> Self {
            self.replace_unhealthy_instances = Some(input);
            self
        }
        pub fn set_replace_unhealthy_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.replace_unhealthy_instances = input;
            self
        }
        /// <p>The configuration of Spot Instances in an EC2 Fleet.</p>
        pub fn spot_options(mut self, input: crate::model::SpotOptions) -> Self {
            self.spot_options = Some(input);
            self
        }
        pub fn set_spot_options(
            mut self,
            input: std::option::Option<crate::model::SpotOptions>,
        ) -> Self {
            self.spot_options = input;
            self
        }
        /// <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
        pub fn on_demand_options(mut self, input: crate::model::OnDemandOptions) -> Self {
            self.on_demand_options = Some(input);
            self
        }
        pub fn set_on_demand_options(
            mut self,
            input: std::option::Option<crate::model::OnDemandOptions>,
        ) -> Self {
            self.on_demand_options = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn errors(mut self, input: impl Into<crate::model::DescribeFleetError>) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input.into());
            self.errors = Some(v);
            self
        }
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DescribeFleetError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        pub fn instances(
            mut self,
            input: impl Into<crate::model::DescribeFleetsInstances>,
        ) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DescribeFleetsInstances>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetData`](crate::model::FleetData)
        pub fn build(self) -> crate::model::FleetData {
            crate::model::FleetData {
                activity_status: self.activity_status,
                create_time: self.create_time,
                fleet_id: self.fleet_id,
                fleet_state: self.fleet_state,
                client_token: self.client_token,
                excess_capacity_termination_policy: self.excess_capacity_termination_policy,
                fulfilled_capacity: self.fulfilled_capacity,
                fulfilled_on_demand_capacity: self.fulfilled_on_demand_capacity,
                launch_template_configs: self.launch_template_configs,
                target_capacity_specification: self.target_capacity_specification,
                terminate_instances_with_expiration: self.terminate_instances_with_expiration,
                r#type: self.r#type,
                valid_from: self.valid_from,
                valid_until: self.valid_until,
                replace_unhealthy_instances: self.replace_unhealthy_instances,
                spot_options: self.spot_options,
                on_demand_options: self.on_demand_options,
                tags: self.tags,
                errors: self.errors,
                instances: self.instances,
                context: self.context,
            }
        }
    }
}
impl FleetData {
    /// Creates a new builder-style object to manufacture [`FleetData`](crate::model::FleetData)
    pub fn builder() -> crate::model::fleet_data::Builder {
        crate::model::fleet_data::Builder::default()
    }
}

/// <p>Describes the instances that were launched by the fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFleetsInstances {
    /// <p>The launch templates and overrides that were used for launching the instances. The
    /// values that you specify in the Overrides replace the values in the launch template.</p>
    pub launch_template_and_overrides:
        std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
    /// <p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>
    pub lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
    /// <p>The IDs of the instances.</p>
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is
    /// blank.</p>
    pub platform: std::option::Option<crate::model::PlatformValues>,
}
impl std::fmt::Debug for DescribeFleetsInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFleetsInstances");
        formatter.field(
            "launch_template_and_overrides",
            &self.launch_template_and_overrides,
        );
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("platform", &self.platform);
        formatter.finish()
    }
}
/// See [`DescribeFleetsInstances`](crate::model::DescribeFleetsInstances)
pub mod describe_fleets_instances {
    /// A builder for [`DescribeFleetsInstances`](crate::model::DescribeFleetsInstances)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_and_overrides:
            std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        pub(crate) lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) platform: std::option::Option<crate::model::PlatformValues>,
    }
    impl Builder {
        /// <p>The launch templates and overrides that were used for launching the instances. The
        /// values that you specify in the Overrides replace the values in the launch template.</p>
        pub fn launch_template_and_overrides(
            mut self,
            input: crate::model::LaunchTemplateAndOverridesResponse,
        ) -> Self {
            self.launch_template_and_overrides = Some(input);
            self
        }
        pub fn set_launch_template_and_overrides(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        ) -> Self {
            self.launch_template_and_overrides = input;
            self
        }
        /// <p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>
        pub fn lifecycle(mut self, input: crate::model::InstanceLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::InstanceLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is
        /// blank.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFleetsInstances`](crate::model::DescribeFleetsInstances)
        pub fn build(self) -> crate::model::DescribeFleetsInstances {
            crate::model::DescribeFleetsInstances {
                launch_template_and_overrides: self.launch_template_and_overrides,
                lifecycle: self.lifecycle,
                instance_ids: self.instance_ids,
                instance_type: self.instance_type,
                platform: self.platform,
            }
        }
    }
}
impl DescribeFleetsInstances {
    /// Creates a new builder-style object to manufacture [`DescribeFleetsInstances`](crate::model::DescribeFleetsInstances)
    pub fn builder() -> crate::model::describe_fleets_instances::Builder {
        crate::model::describe_fleets_instances::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceLifecycle {
    OnDemand,
    Spot,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "on-demand" => InstanceLifecycle::OnDemand,
            "spot" => InstanceLifecycle::Spot,
            other => InstanceLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceLifecycle::from(s))
    }
}
impl InstanceLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceLifecycle::OnDemand => "on-demand",
            InstanceLifecycle::Spot => "spot",
            InstanceLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["on-demand", "spot"]
    }
}
impl AsRef<str> for InstanceLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a launch template and overrides.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateAndOverridesResponse {
    /// <p>The launch template.</p>
    pub launch_template_specification:
        std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
    /// <p>Any parameters that you specify override the same parameters in the launch
    /// template.</p>
    pub overrides: std::option::Option<crate::model::FleetLaunchTemplateOverrides>,
}
impl std::fmt::Debug for LaunchTemplateAndOverridesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateAndOverridesResponse");
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`LaunchTemplateAndOverridesResponse`](crate::model::LaunchTemplateAndOverridesResponse)
pub mod launch_template_and_overrides_response {
    /// A builder for [`LaunchTemplateAndOverridesResponse`](crate::model::LaunchTemplateAndOverridesResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        pub(crate) overrides: std::option::Option<crate::model::FleetLaunchTemplateOverrides>,
    }
    impl Builder {
        /// <p>The launch template.</p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::FleetLaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        /// <p>Any parameters that you specify override the same parameters in the launch
        /// template.</p>
        pub fn overrides(mut self, input: crate::model::FleetLaunchTemplateOverrides) -> Self {
            self.overrides = Some(input);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<crate::model::FleetLaunchTemplateOverrides>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateAndOverridesResponse`](crate::model::LaunchTemplateAndOverridesResponse)
        pub fn build(self) -> crate::model::LaunchTemplateAndOverridesResponse {
            crate::model::LaunchTemplateAndOverridesResponse {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl LaunchTemplateAndOverridesResponse {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateAndOverridesResponse`](crate::model::LaunchTemplateAndOverridesResponse)
    pub fn builder() -> crate::model::launch_template_and_overrides_response::Builder {
        crate::model::launch_template_and_overrides_response::Builder::default()
    }
}

/// <p>Describes overrides for a launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateOverrides {
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
    pub max_price: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet in which to launch the instances.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which to launch the instances.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The number of units provided by the specified instance type.</p>
    pub weighted_capacity: std::option::Option<f64>,
    /// <p>The priority for the launch template override. The highest priority is launched
    /// first.</p>
    /// <p>If the On-Demand <code>AllocationStrategy</code> is set to <code>prioritized</code>,
    /// EC2 Fleet uses priority to determine which launch template override to use first in fulfilling
    /// On-Demand capacity.</p>
    /// <p>If the Spot <code>AllocationStrategy</code> is set to
    /// <code>capacity-optimized-prioritized</code>, EC2 Fleet uses priority on a best-effort basis
    /// to determine which launch template override to use in fulfilling Spot capacity, but
    /// optimizes for capacity first.</p>
    /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
    /// higher the priority. If no number is set, the override has the lowest priority. You can set
    /// the same priority for different launch template overrides.</p>
    pub priority: std::option::Option<f64>,
    /// <p>The location where the instance launched, if applicable.</p>
    pub placement: std::option::Option<crate::model::PlacementResponse>,
}
impl std::fmt::Debug for FleetLaunchTemplateOverrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateOverrides");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("max_price", &self.max_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("priority", &self.priority);
        formatter.field("placement", &self.placement);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateOverrides`](crate::model::FleetLaunchTemplateOverrides)
pub mod fleet_launch_template_overrides {
    /// A builder for [`FleetLaunchTemplateOverrides`](crate::model::FleetLaunchTemplateOverrides)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) max_price: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<f64>,
        pub(crate) priority: std::option::Option<f64>,
        pub(crate) placement: std::option::Option<crate::model::PlacementResponse>,
    }
    impl Builder {
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
        pub fn max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_price = Some(input.into());
            self
        }
        pub fn set_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_price = input;
            self
        }
        /// <p>The ID of the subnet in which to launch the instances.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The Availability Zone in which to launch the instances.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The number of units provided by the specified instance type.</p>
        pub fn weighted_capacity(mut self, input: f64) -> Self {
            self.weighted_capacity = Some(input);
            self
        }
        pub fn set_weighted_capacity(mut self, input: std::option::Option<f64>) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// <p>The priority for the launch template override. The highest priority is launched
        /// first.</p>
        /// <p>If the On-Demand <code>AllocationStrategy</code> is set to <code>prioritized</code>,
        /// EC2 Fleet uses priority to determine which launch template override to use first in fulfilling
        /// On-Demand capacity.</p>
        /// <p>If the Spot <code>AllocationStrategy</code> is set to
        /// <code>capacity-optimized-prioritized</code>, EC2 Fleet uses priority on a best-effort basis
        /// to determine which launch template override to use in fulfilling Spot capacity, but
        /// optimizes for capacity first.</p>
        /// <p>Valid values are whole numbers starting at <code>0</code>. The lower the number, the
        /// higher the priority. If no number is set, the override has the lowest priority. You can set
        /// the same priority for different launch template overrides.</p>
        pub fn priority(mut self, input: f64) -> Self {
            self.priority = Some(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<f64>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The location where the instance launched, if applicable.</p>
        pub fn placement(mut self, input: crate::model::PlacementResponse) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::PlacementResponse>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateOverrides`](crate::model::FleetLaunchTemplateOverrides)
        pub fn build(self) -> crate::model::FleetLaunchTemplateOverrides {
            crate::model::FleetLaunchTemplateOverrides {
                instance_type: self.instance_type,
                max_price: self.max_price,
                subnet_id: self.subnet_id,
                availability_zone: self.availability_zone,
                weighted_capacity: self.weighted_capacity,
                priority: self.priority,
                placement: self.placement,
            }
        }
    }
}
impl FleetLaunchTemplateOverrides {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateOverrides`](crate::model::FleetLaunchTemplateOverrides)
    pub fn builder() -> crate::model::fleet_launch_template_overrides::Builder {
        crate::model::fleet_launch_template_overrides::Builder::default()
    }
}

/// <p>Describes the placement of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlacementResponse {
    /// <p>The name of the placement group that the instance is in.</p>
    pub group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PlacementResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PlacementResponse");
        formatter.field("group_name", &self.group_name);
        formatter.finish()
    }
}
/// See [`PlacementResponse`](crate::model::PlacementResponse)
pub mod placement_response {
    /// A builder for [`PlacementResponse`](crate::model::PlacementResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the placement group that the instance is in.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementResponse`](crate::model::PlacementResponse)
        pub fn build(self) -> crate::model::PlacementResponse {
            crate::model::PlacementResponse {
                group_name: self.group_name,
            }
        }
    }
}
impl PlacementResponse {
    /// Creates a new builder-style object to manufacture [`PlacementResponse`](crate::model::PlacementResponse)
    pub fn builder() -> crate::model::placement_response::Builder {
        crate::model::placement_response::Builder::default()
    }
}

/// <p>Describes the instances that could not be launched by the fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFleetError {
    /// <p>The launch templates and overrides that were used for launching the instances. The
    /// values that you specify in the Overrides replace the values in the launch template.</p>
    pub launch_template_and_overrides:
        std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
    /// <p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>
    pub lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
    /// <p>The error code that indicates why the instance could not be launched. For more
    /// information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message that describes why the instance could not be launched. For more
    /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFleetError");
        formatter.field(
            "launch_template_and_overrides",
            &self.launch_template_and_overrides,
        );
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`DescribeFleetError`](crate::model::DescribeFleetError)
pub mod describe_fleet_error {
    /// A builder for [`DescribeFleetError`](crate::model::DescribeFleetError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_and_overrides:
            std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        pub(crate) lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The launch templates and overrides that were used for launching the instances. The
        /// values that you specify in the Overrides replace the values in the launch template.</p>
        pub fn launch_template_and_overrides(
            mut self,
            input: crate::model::LaunchTemplateAndOverridesResponse,
        ) -> Self {
            self.launch_template_and_overrides = Some(input);
            self
        }
        pub fn set_launch_template_and_overrides(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        ) -> Self {
            self.launch_template_and_overrides = input;
            self
        }
        /// <p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>
        pub fn lifecycle(mut self, input: crate::model::InstanceLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::InstanceLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>The error code that indicates why the instance could not be launched. For more
        /// information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message that describes why the instance could not be launched. For more
        /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFleetError`](crate::model::DescribeFleetError)
        pub fn build(self) -> crate::model::DescribeFleetError {
            crate::model::DescribeFleetError {
                launch_template_and_overrides: self.launch_template_and_overrides,
                lifecycle: self.lifecycle,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl DescribeFleetError {
    /// Creates a new builder-style object to manufacture [`DescribeFleetError`](crate::model::DescribeFleetError)
    pub fn builder() -> crate::model::describe_fleet_error::Builder {
        crate::model::describe_fleet_error::Builder::default()
    }
}

/// <p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnDemandOptions {
    /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
    /// you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching
    /// the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority
    /// that you assigned to each launch template override, launching the highest priority first.
    /// If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
    pub allocation_strategy: std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
    /// <p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub capacity_reservation_options: std::option::Option<crate::model::CapacityReservationOptions>,
    /// <p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub single_instance_type: std::option::Option<bool>,
    /// <p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported
    /// only for fleets of type <code>instant</code>.</p>
    pub single_availability_zone: std::option::Option<bool>,
    /// <p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is
    /// not reached, the fleet launches no instances.</p>
    pub min_target_capacity: std::option::Option<i32>,
    /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>
    pub max_total_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OnDemandOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnDemandOptions");
        formatter.field("allocation_strategy", &self.allocation_strategy);
        formatter.field(
            "capacity_reservation_options",
            &self.capacity_reservation_options,
        );
        formatter.field("single_instance_type", &self.single_instance_type);
        formatter.field("single_availability_zone", &self.single_availability_zone);
        formatter.field("min_target_capacity", &self.min_target_capacity);
        formatter.field("max_total_price", &self.max_total_price);
        formatter.finish()
    }
}
/// See [`OnDemandOptions`](crate::model::OnDemandOptions)
pub mod on_demand_options {
    /// A builder for [`OnDemandOptions`](crate::model::OnDemandOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_strategy:
            std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
        pub(crate) capacity_reservation_options:
            std::option::Option<crate::model::CapacityReservationOptions>,
        pub(crate) single_instance_type: std::option::Option<bool>,
        pub(crate) single_availability_zone: std::option::Option<bool>,
        pub(crate) min_target_capacity: std::option::Option<i32>,
        pub(crate) max_total_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
        /// you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching
        /// the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority
        /// that you assigned to each launch template override, launching the highest priority first.
        /// If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
        pub fn allocation_strategy(
            mut self,
            input: crate::model::FleetOnDemandAllocationStrategy,
        ) -> Self {
            self.allocation_strategy = Some(input);
            self
        }
        pub fn set_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
        ) -> Self {
            self.allocation_strategy = input;
            self
        }
        /// <p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn capacity_reservation_options(
            mut self,
            input: crate::model::CapacityReservationOptions,
        ) -> Self {
            self.capacity_reservation_options = Some(input);
            self
        }
        pub fn set_capacity_reservation_options(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationOptions>,
        ) -> Self {
            self.capacity_reservation_options = input;
            self
        }
        /// <p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn single_instance_type(mut self, input: bool) -> Self {
            self.single_instance_type = Some(input);
            self
        }
        pub fn set_single_instance_type(mut self, input: std::option::Option<bool>) -> Self {
            self.single_instance_type = input;
            self
        }
        /// <p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported
        /// only for fleets of type <code>instant</code>.</p>
        pub fn single_availability_zone(mut self, input: bool) -> Self {
            self.single_availability_zone = Some(input);
            self
        }
        pub fn set_single_availability_zone(mut self, input: std::option::Option<bool>) -> Self {
            self.single_availability_zone = input;
            self
        }
        /// <p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is
        /// not reached, the fleet launches no instances.</p>
        pub fn min_target_capacity(mut self, input: i32) -> Self {
            self.min_target_capacity = Some(input);
            self
        }
        pub fn set_min_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_target_capacity = input;
            self
        }
        /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>
        pub fn max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_total_price = Some(input.into());
            self
        }
        pub fn set_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_total_price = input;
            self
        }
        /// Consumes the builder and constructs a [`OnDemandOptions`](crate::model::OnDemandOptions)
        pub fn build(self) -> crate::model::OnDemandOptions {
            crate::model::OnDemandOptions {
                allocation_strategy: self.allocation_strategy,
                capacity_reservation_options: self.capacity_reservation_options,
                single_instance_type: self.single_instance_type,
                single_availability_zone: self.single_availability_zone,
                min_target_capacity: self.min_target_capacity,
                max_total_price: self.max_total_price,
            }
        }
    }
}
impl OnDemandOptions {
    /// Creates a new builder-style object to manufacture [`OnDemandOptions`](crate::model::OnDemandOptions)
    pub fn builder() -> crate::model::on_demand_options::Builder {
        crate::model::on_demand_options::Builder::default()
    }
}

/// <p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand
/// capacity.</p>
/// <note>
/// <p>This strategy can only be used if the EC2 Fleet is of type
/// <code>instant</code>.</p>
/// </note>
/// <p>For more information about Capacity Reservations, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html">On-Demand Capacity
/// Reservations</a> in the <i>Amazon EC2 User Guide</i>. For examples of using
/// Capacity Reservations in an EC2 Fleet, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html">EC2 Fleet example
/// configurations</a> in the <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationOptions {
    /// <p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p>
    /// <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused
    /// Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If
    /// multiple instance pools have unused Capacity Reservations, the On-Demand allocation
    /// strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number
    /// of unused Capacity Reservations is less than the On-Demand target capacity, the remaining
    /// On-Demand target capacity is launched according to the On-Demand allocation strategy
    /// (<code>lowest-price</code> or <code>prioritized</code>).</p>
    /// <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the
    /// chosen On-Demand allocation strategy.</p>
    pub usage_strategy: std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
}
impl std::fmt::Debug for CapacityReservationOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationOptions");
        formatter.field("usage_strategy", &self.usage_strategy);
        formatter.finish()
    }
}
/// See [`CapacityReservationOptions`](crate::model::CapacityReservationOptions)
pub mod capacity_reservation_options {
    /// A builder for [`CapacityReservationOptions`](crate::model::CapacityReservationOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) usage_strategy:
            std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
    }
    impl Builder {
        /// <p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p>
        /// <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused
        /// Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If
        /// multiple instance pools have unused Capacity Reservations, the On-Demand allocation
        /// strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number
        /// of unused Capacity Reservations is less than the On-Demand target capacity, the remaining
        /// On-Demand target capacity is launched according to the On-Demand allocation strategy
        /// (<code>lowest-price</code> or <code>prioritized</code>).</p>
        /// <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the
        /// chosen On-Demand allocation strategy.</p>
        pub fn usage_strategy(
            mut self,
            input: crate::model::FleetCapacityReservationUsageStrategy,
        ) -> Self {
            self.usage_strategy = Some(input);
            self
        }
        pub fn set_usage_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
        ) -> Self {
            self.usage_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationOptions`](crate::model::CapacityReservationOptions)
        pub fn build(self) -> crate::model::CapacityReservationOptions {
            crate::model::CapacityReservationOptions {
                usage_strategy: self.usage_strategy,
            }
        }
    }
}
impl CapacityReservationOptions {
    /// Creates a new builder-style object to manufacture [`CapacityReservationOptions`](crate::model::CapacityReservationOptions)
    pub fn builder() -> crate::model::capacity_reservation_options::Builder {
        crate::model::capacity_reservation_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetCapacityReservationUsageStrategy {
    UseCapacityReservationsFirst,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetCapacityReservationUsageStrategy {
    fn from(s: &str) -> Self {
        match s {
            "use-capacity-reservations-first" => {
                FleetCapacityReservationUsageStrategy::UseCapacityReservationsFirst
            }
            other => FleetCapacityReservationUsageStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetCapacityReservationUsageStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetCapacityReservationUsageStrategy::from(s))
    }
}
impl FleetCapacityReservationUsageStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            FleetCapacityReservationUsageStrategy::UseCapacityReservationsFirst => {
                "use-capacity-reservations-first"
            }
            FleetCapacityReservationUsageStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["use-capacity-reservations-first"]
    }
}
impl AsRef<str> for FleetCapacityReservationUsageStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetOnDemandAllocationStrategy {
    LowestPrice,
    Prioritized,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetOnDemandAllocationStrategy {
    fn from(s: &str) -> Self {
        match s {
            "lowest-price" => FleetOnDemandAllocationStrategy::LowestPrice,
            "prioritized" => FleetOnDemandAllocationStrategy::Prioritized,
            other => FleetOnDemandAllocationStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetOnDemandAllocationStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetOnDemandAllocationStrategy::from(s))
    }
}
impl FleetOnDemandAllocationStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            FleetOnDemandAllocationStrategy::LowestPrice => "lowest-price",
            FleetOnDemandAllocationStrategy::Prioritized => "prioritized",
            FleetOnDemandAllocationStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["lowest-price", "prioritized"]
    }
}
impl AsRef<str> for FleetOnDemandAllocationStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotOptions {
    /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
    /// the EC2 Fleet.</p>
    /// <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from
    /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
    /// <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all
    /// of the Spot Instance pools that you specify.</p>
    /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), EC2 Fleet
    /// launches instances from Spot Instance pools with optimal capacity for the number of instances that
    /// are launching. To give certain instance types a higher chance of launching first, use
    /// <code>capacity-optimized-prioritized</code>. Set a priority for each instance type by
    /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You can
    /// assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2 implements
    /// the priorities on a best-effort basis, but optimizes for capacity first.
    /// <code>capacity-optimized-prioritized</code> is supported only if your fleet uses a
    /// launch template. Note that if the On-Demand <code>AllocationStrategy</code> is set to
    /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
    /// capacity.</p>
    pub allocation_strategy: std::option::Option<crate::model::SpotAllocationStrategy>,
    /// <p>The strategies for managing your workloads on your Spot Instances that will be
    /// interrupted. Currently only the capacity rebalance strategy is available.</p>
    pub maintenance_strategies: std::option::Option<crate::model::FleetSpotMaintenanceStrategies>,
    /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
    /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only
    /// when <b>AllocationStrategy</b> is set to
    /// <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates
    /// your target Spot capacity across the number of Spot pools that you specify.</p>
    /// <p>Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a
    /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
    /// capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest
    /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
    /// the number of pools that you specified. Similarly, if most of the pools have no Spot
    /// capacity, you might receive your full target capacity from fewer than the number of pools
    /// that you specified.</p>
    pub instance_pools_to_use_count: std::option::Option<i32>,
    /// <p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub single_instance_type: std::option::Option<bool>,
    /// <p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported
    /// only for fleets of type <code>instant</code>.</p>
    pub single_availability_zone: std::option::Option<bool>,
    /// <p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is
    /// not reached, the fleet launches no instances.</p>
    pub min_target_capacity: std::option::Option<i32>,
    /// <p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>
    pub max_total_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SpotOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotOptions");
        formatter.field("allocation_strategy", &self.allocation_strategy);
        formatter.field("maintenance_strategies", &self.maintenance_strategies);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.field(
            "instance_pools_to_use_count",
            &self.instance_pools_to_use_count,
        );
        formatter.field("single_instance_type", &self.single_instance_type);
        formatter.field("single_availability_zone", &self.single_availability_zone);
        formatter.field("min_target_capacity", &self.min_target_capacity);
        formatter.field("max_total_price", &self.max_total_price);
        formatter.finish()
    }
}
/// See [`SpotOptions`](crate::model::SpotOptions)
pub mod spot_options {
    /// A builder for [`SpotOptions`](crate::model::SpotOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_strategy: std::option::Option<crate::model::SpotAllocationStrategy>,
        pub(crate) maintenance_strategies:
            std::option::Option<crate::model::FleetSpotMaintenanceStrategies>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
        pub(crate) instance_pools_to_use_count: std::option::Option<i32>,
        pub(crate) single_instance_type: std::option::Option<bool>,
        pub(crate) single_availability_zone: std::option::Option<bool>,
        pub(crate) min_target_capacity: std::option::Option<i32>,
        pub(crate) max_total_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
        /// the EC2 Fleet.</p>
        /// <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from
        /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
        /// <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all
        /// of the Spot Instance pools that you specify.</p>
        /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), EC2 Fleet
        /// launches instances from Spot Instance pools with optimal capacity for the number of instances that
        /// are launching. To give certain instance types a higher chance of launching first, use
        /// <code>capacity-optimized-prioritized</code>. Set a priority for each instance type by
        /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You can
        /// assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2 implements
        /// the priorities on a best-effort basis, but optimizes for capacity first.
        /// <code>capacity-optimized-prioritized</code> is supported only if your fleet uses a
        /// launch template. Note that if the On-Demand <code>AllocationStrategy</code> is set to
        /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
        /// capacity.</p>
        pub fn allocation_strategy(mut self, input: crate::model::SpotAllocationStrategy) -> Self {
            self.allocation_strategy = Some(input);
            self
        }
        pub fn set_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::SpotAllocationStrategy>,
        ) -> Self {
            self.allocation_strategy = input;
            self
        }
        /// <p>The strategies for managing your workloads on your Spot Instances that will be
        /// interrupted. Currently only the capacity rebalance strategy is available.</p>
        pub fn maintenance_strategies(
            mut self,
            input: crate::model::FleetSpotMaintenanceStrategies,
        ) -> Self {
            self.maintenance_strategies = Some(input);
            self
        }
        pub fn set_maintenance_strategies(
            mut self,
            input: std::option::Option<crate::model::FleetSpotMaintenanceStrategies>,
        ) -> Self {
            self.maintenance_strategies = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::SpotInstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only
        /// when <b>AllocationStrategy</b> is set to
        /// <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates
        /// your target Spot capacity across the number of Spot pools that you specify.</p>
        /// <p>Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a
        /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
        /// capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest
        /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
        /// the number of pools that you specified. Similarly, if most of the pools have no Spot
        /// capacity, you might receive your full target capacity from fewer than the number of pools
        /// that you specified.</p>
        pub fn instance_pools_to_use_count(mut self, input: i32) -> Self {
            self.instance_pools_to_use_count = Some(input);
            self
        }
        pub fn set_instance_pools_to_use_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_pools_to_use_count = input;
            self
        }
        /// <p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn single_instance_type(mut self, input: bool) -> Self {
            self.single_instance_type = Some(input);
            self
        }
        pub fn set_single_instance_type(mut self, input: std::option::Option<bool>) -> Self {
            self.single_instance_type = input;
            self
        }
        /// <p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported
        /// only for fleets of type <code>instant</code>.</p>
        pub fn single_availability_zone(mut self, input: bool) -> Self {
            self.single_availability_zone = Some(input);
            self
        }
        pub fn set_single_availability_zone(mut self, input: std::option::Option<bool>) -> Self {
            self.single_availability_zone = input;
            self
        }
        /// <p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is
        /// not reached, the fleet launches no instances.</p>
        pub fn min_target_capacity(mut self, input: i32) -> Self {
            self.min_target_capacity = Some(input);
            self
        }
        pub fn set_min_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_target_capacity = input;
            self
        }
        /// <p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>
        pub fn max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_total_price = Some(input.into());
            self
        }
        pub fn set_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_total_price = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotOptions`](crate::model::SpotOptions)
        pub fn build(self) -> crate::model::SpotOptions {
            crate::model::SpotOptions {
                allocation_strategy: self.allocation_strategy,
                maintenance_strategies: self.maintenance_strategies,
                instance_interruption_behavior: self.instance_interruption_behavior,
                instance_pools_to_use_count: self.instance_pools_to_use_count,
                single_instance_type: self.single_instance_type,
                single_availability_zone: self.single_availability_zone,
                min_target_capacity: self.min_target_capacity,
                max_total_price: self.max_total_price,
            }
        }
    }
}
impl SpotOptions {
    /// Creates a new builder-style object to manufacture [`SpotOptions`](crate::model::SpotOptions)
    pub fn builder() -> crate::model::spot_options::Builder {
        crate::model::spot_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpotInstanceInterruptionBehavior {
    Hibernate,
    Stop,
    Terminate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpotInstanceInterruptionBehavior {
    fn from(s: &str) -> Self {
        match s {
            "hibernate" => SpotInstanceInterruptionBehavior::Hibernate,
            "stop" => SpotInstanceInterruptionBehavior::Stop,
            "terminate" => SpotInstanceInterruptionBehavior::Terminate,
            other => SpotInstanceInterruptionBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpotInstanceInterruptionBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpotInstanceInterruptionBehavior::from(s))
    }
}
impl SpotInstanceInterruptionBehavior {
    pub fn as_str(&self) -> &str {
        match self {
            SpotInstanceInterruptionBehavior::Hibernate => "hibernate",
            SpotInstanceInterruptionBehavior::Stop => "stop",
            SpotInstanceInterruptionBehavior::Terminate => "terminate",
            SpotInstanceInterruptionBehavior::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["hibernate", "stop", "terminate"]
    }
}
impl AsRef<str> for SpotInstanceInterruptionBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
/// interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetSpotMaintenanceStrategies {
    /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
    /// elevated risk of being interrupted.</p>
    pub capacity_rebalance: std::option::Option<crate::model::FleetSpotCapacityRebalance>,
}
impl std::fmt::Debug for FleetSpotMaintenanceStrategies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetSpotMaintenanceStrategies");
        formatter.field("capacity_rebalance", &self.capacity_rebalance);
        formatter.finish()
    }
}
/// See [`FleetSpotMaintenanceStrategies`](crate::model::FleetSpotMaintenanceStrategies)
pub mod fleet_spot_maintenance_strategies {
    /// A builder for [`FleetSpotMaintenanceStrategies`](crate::model::FleetSpotMaintenanceStrategies)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_rebalance:
            std::option::Option<crate::model::FleetSpotCapacityRebalance>,
    }
    impl Builder {
        /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
        /// elevated risk of being interrupted.</p>
        pub fn capacity_rebalance(
            mut self,
            input: crate::model::FleetSpotCapacityRebalance,
        ) -> Self {
            self.capacity_rebalance = Some(input);
            self
        }
        pub fn set_capacity_rebalance(
            mut self,
            input: std::option::Option<crate::model::FleetSpotCapacityRebalance>,
        ) -> Self {
            self.capacity_rebalance = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSpotMaintenanceStrategies`](crate::model::FleetSpotMaintenanceStrategies)
        pub fn build(self) -> crate::model::FleetSpotMaintenanceStrategies {
            crate::model::FleetSpotMaintenanceStrategies {
                capacity_rebalance: self.capacity_rebalance,
            }
        }
    }
}
impl FleetSpotMaintenanceStrategies {
    /// Creates a new builder-style object to manufacture [`FleetSpotMaintenanceStrategies`](crate::model::FleetSpotMaintenanceStrategies)
    pub fn builder() -> crate::model::fleet_spot_maintenance_strategies::Builder {
        crate::model::fleet_spot_maintenance_strategies::Builder::default()
    }
}

/// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
/// elevated risk of being interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetSpotCapacityRebalance {
    /// <p>To allow EC2 Fleet to launch a replacement Spot Instance when an instance rebalance
    /// notification is emitted for an existing Spot Instance in the fleet, specify
    /// <code>launch</code>. Only available for fleets of type <code>maintain</code>.</p>
    /// <note>
    /// <p>When a replacement instance is launched, the instance marked for rebalance is not
    /// automatically terminated. You can terminate it, or you can leave it running. You are charged for both instances while they are running.</p>
    /// </note>
    pub replacement_strategy: std::option::Option<crate::model::FleetReplacementStrategy>,
}
impl std::fmt::Debug for FleetSpotCapacityRebalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetSpotCapacityRebalance");
        formatter.field("replacement_strategy", &self.replacement_strategy);
        formatter.finish()
    }
}
/// See [`FleetSpotCapacityRebalance`](crate::model::FleetSpotCapacityRebalance)
pub mod fleet_spot_capacity_rebalance {
    /// A builder for [`FleetSpotCapacityRebalance`](crate::model::FleetSpotCapacityRebalance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) replacement_strategy:
            std::option::Option<crate::model::FleetReplacementStrategy>,
    }
    impl Builder {
        /// <p>To allow EC2 Fleet to launch a replacement Spot Instance when an instance rebalance
        /// notification is emitted for an existing Spot Instance in the fleet, specify
        /// <code>launch</code>. Only available for fleets of type <code>maintain</code>.</p>
        /// <note>
        /// <p>When a replacement instance is launched, the instance marked for rebalance is not
        /// automatically terminated. You can terminate it, or you can leave it running. You are charged for both instances while they are running.</p>
        /// </note>
        pub fn replacement_strategy(
            mut self,
            input: crate::model::FleetReplacementStrategy,
        ) -> Self {
            self.replacement_strategy = Some(input);
            self
        }
        pub fn set_replacement_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetReplacementStrategy>,
        ) -> Self {
            self.replacement_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSpotCapacityRebalance`](crate::model::FleetSpotCapacityRebalance)
        pub fn build(self) -> crate::model::FleetSpotCapacityRebalance {
            crate::model::FleetSpotCapacityRebalance {
                replacement_strategy: self.replacement_strategy,
            }
        }
    }
}
impl FleetSpotCapacityRebalance {
    /// Creates a new builder-style object to manufacture [`FleetSpotCapacityRebalance`](crate::model::FleetSpotCapacityRebalance)
    pub fn builder() -> crate::model::fleet_spot_capacity_rebalance::Builder {
        crate::model::fleet_spot_capacity_rebalance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetReplacementStrategy {
    Launch,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetReplacementStrategy {
    fn from(s: &str) -> Self {
        match s {
            "launch" => FleetReplacementStrategy::Launch,
            other => FleetReplacementStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetReplacementStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetReplacementStrategy::from(s))
    }
}
impl FleetReplacementStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            FleetReplacementStrategy::Launch => "launch",
            FleetReplacementStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["launch"]
    }
}
impl AsRef<str> for FleetReplacementStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpotAllocationStrategy {
    CapacityOptimized,
    CapacityOptimizedPrioritized,
    Diversified,
    LowestPrice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SpotAllocationStrategy {
    fn from(s: &str) -> Self {
        match s {
            "capacity-optimized" => SpotAllocationStrategy::CapacityOptimized,
            "capacity-optimized-prioritized" => {
                SpotAllocationStrategy::CapacityOptimizedPrioritized
            }
            "diversified" => SpotAllocationStrategy::Diversified,
            "lowest-price" => SpotAllocationStrategy::LowestPrice,
            other => SpotAllocationStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SpotAllocationStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpotAllocationStrategy::from(s))
    }
}
impl SpotAllocationStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            SpotAllocationStrategy::CapacityOptimized => "capacity-optimized",
            SpotAllocationStrategy::CapacityOptimizedPrioritized => {
                "capacity-optimized-prioritized"
            }
            SpotAllocationStrategy::Diversified => "diversified",
            SpotAllocationStrategy::LowestPrice => "lowest-price",
            SpotAllocationStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "capacity-optimized",
            "capacity-optimized-prioritized",
            "diversified",
            "lowest-price",
        ]
    }
}
impl AsRef<str> for SpotAllocationStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The number of units to request. You can choose to set the target capacity in terms of
/// instances or a performance characteristic that is important to your application workload,
/// such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can
/// specify a target capacity of 0 and add capacity later.</p>
/// <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance
/// <code>MaxTotalPrice</code>, or both to ensure that your fleet cost does not exceed your
/// budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, EC2 Fleet
/// will launch instances until it reaches the maximum amount that you're willing to pay. When
/// the maximum amount you're willing to pay is reached, the fleet stops launching instances
/// even if it hasn’t met the target capacity. The <code>MaxTotalPrice</code> parameters are
/// located in <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_OnDemandOptions.html">OnDemandOptions</a>
/// and <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotOptions">SpotOptions</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetCapacitySpecification {
    /// <p>The number of units to request, filled using
    /// <code>DefaultTargetCapacityType</code>.</p>
    pub total_target_capacity: std::option::Option<i32>,
    /// <p>The number of On-Demand units to request. If you specify a target capacity for Spot units, you cannot specify a target capacity for On-Demand units.</p>
    pub on_demand_target_capacity: std::option::Option<i32>,
    /// <p>The maximum number of Spot units to launch. If you specify a target capacity for On-Demand units, you cannot specify a target capacity for Spot units.</p>
    pub spot_target_capacity: std::option::Option<i32>,
    /// <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or
    /// <code>On-Demand</code>.</p>
    pub default_target_capacity_type: std::option::Option<crate::model::DefaultTargetCapacityType>,
}
impl std::fmt::Debug for TargetCapacitySpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetCapacitySpecification");
        formatter.field("total_target_capacity", &self.total_target_capacity);
        formatter.field("on_demand_target_capacity", &self.on_demand_target_capacity);
        formatter.field("spot_target_capacity", &self.spot_target_capacity);
        formatter.field(
            "default_target_capacity_type",
            &self.default_target_capacity_type,
        );
        formatter.finish()
    }
}
/// See [`TargetCapacitySpecification`](crate::model::TargetCapacitySpecification)
pub mod target_capacity_specification {
    /// A builder for [`TargetCapacitySpecification`](crate::model::TargetCapacitySpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_target_capacity: std::option::Option<i32>,
        pub(crate) on_demand_target_capacity: std::option::Option<i32>,
        pub(crate) spot_target_capacity: std::option::Option<i32>,
        pub(crate) default_target_capacity_type:
            std::option::Option<crate::model::DefaultTargetCapacityType>,
    }
    impl Builder {
        /// <p>The number of units to request, filled using
        /// <code>DefaultTargetCapacityType</code>.</p>
        pub fn total_target_capacity(mut self, input: i32) -> Self {
            self.total_target_capacity = Some(input);
            self
        }
        pub fn set_total_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.total_target_capacity = input;
            self
        }
        /// <p>The number of On-Demand units to request. If you specify a target capacity for Spot units, you cannot specify a target capacity for On-Demand units.</p>
        pub fn on_demand_target_capacity(mut self, input: i32) -> Self {
            self.on_demand_target_capacity = Some(input);
            self
        }
        pub fn set_on_demand_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.on_demand_target_capacity = input;
            self
        }
        /// <p>The maximum number of Spot units to launch. If you specify a target capacity for On-Demand units, you cannot specify a target capacity for Spot units.</p>
        pub fn spot_target_capacity(mut self, input: i32) -> Self {
            self.spot_target_capacity = Some(input);
            self
        }
        pub fn set_spot_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.spot_target_capacity = input;
            self
        }
        /// <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or
        /// <code>On-Demand</code>.</p>
        pub fn default_target_capacity_type(
            mut self,
            input: crate::model::DefaultTargetCapacityType,
        ) -> Self {
            self.default_target_capacity_type = Some(input);
            self
        }
        pub fn set_default_target_capacity_type(
            mut self,
            input: std::option::Option<crate::model::DefaultTargetCapacityType>,
        ) -> Self {
            self.default_target_capacity_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetCapacitySpecification`](crate::model::TargetCapacitySpecification)
        pub fn build(self) -> crate::model::TargetCapacitySpecification {
            crate::model::TargetCapacitySpecification {
                total_target_capacity: self.total_target_capacity,
                on_demand_target_capacity: self.on_demand_target_capacity,
                spot_target_capacity: self.spot_target_capacity,
                default_target_capacity_type: self.default_target_capacity_type,
            }
        }
    }
}
impl TargetCapacitySpecification {
    /// Creates a new builder-style object to manufacture [`TargetCapacitySpecification`](crate::model::TargetCapacitySpecification)
    pub fn builder() -> crate::model::target_capacity_specification::Builder {
        crate::model::target_capacity_specification::Builder::default()
    }
}

/// <p>Describes a launch template and overrides.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetLaunchTemplateConfig {
    /// <p>The launch template.</p>
    pub launch_template_specification:
        std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
    /// <p>Any parameters that you specify override the same parameters in the launch
    /// template.</p>
    pub overrides: std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateOverrides>>,
}
impl std::fmt::Debug for FleetLaunchTemplateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetLaunchTemplateConfig");
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`FleetLaunchTemplateConfig`](crate::model::FleetLaunchTemplateConfig)
pub mod fleet_launch_template_config {
    /// A builder for [`FleetLaunchTemplateConfig`](crate::model::FleetLaunchTemplateConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        pub(crate) overrides:
            std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateOverrides>>,
    }
    impl Builder {
        /// <p>The launch template.</p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::FleetLaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::FleetLaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        pub fn overrides(
            mut self,
            input: impl Into<crate::model::FleetLaunchTemplateOverrides>,
        ) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input.into());
            self.overrides = Some(v);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FleetLaunchTemplateOverrides>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetLaunchTemplateConfig`](crate::model::FleetLaunchTemplateConfig)
        pub fn build(self) -> crate::model::FleetLaunchTemplateConfig {
            crate::model::FleetLaunchTemplateConfig {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl FleetLaunchTemplateConfig {
    /// Creates a new builder-style object to manufacture [`FleetLaunchTemplateConfig`](crate::model::FleetLaunchTemplateConfig)
    pub fn builder() -> crate::model::fleet_launch_template_config::Builder {
        crate::model::fleet_launch_template_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetStateCode {
    Active,
    Deleted,
    DeletedRunning,
    DeletedTerminatingInstances,
    Failed,
    Modifying,
    Submitted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetStateCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => FleetStateCode::Active,
            "deleted" => FleetStateCode::Deleted,
            "deleted_running" => FleetStateCode::DeletedRunning,
            "deleted_terminating" => FleetStateCode::DeletedTerminatingInstances,
            "failed" => FleetStateCode::Failed,
            "modifying" => FleetStateCode::Modifying,
            "submitted" => FleetStateCode::Submitted,
            other => FleetStateCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetStateCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetStateCode::from(s))
    }
}
impl FleetStateCode {
    pub fn as_str(&self) -> &str {
        match self {
            FleetStateCode::Active => "active",
            FleetStateCode::Deleted => "deleted",
            FleetStateCode::DeletedRunning => "deleted_running",
            FleetStateCode::DeletedTerminatingInstances => "deleted_terminating",
            FleetStateCode::Failed => "failed",
            FleetStateCode::Modifying => "modifying",
            FleetStateCode::Submitted => "submitted",
            FleetStateCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "active",
            "deleted",
            "deleted_running",
            "deleted_terminating",
            "failed",
            "modifying",
            "submitted",
        ]
    }
}
impl AsRef<str> for FleetStateCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetActivityStatus {
    Error,
    Fulfilled,
    PendingFulfillment,
    PendingTermination,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetActivityStatus {
    fn from(s: &str) -> Self {
        match s {
            "error" => FleetActivityStatus::Error,
            "fulfilled" => FleetActivityStatus::Fulfilled,
            "pending_fulfillment" => FleetActivityStatus::PendingFulfillment,
            "pending_termination" => FleetActivityStatus::PendingTermination,
            other => FleetActivityStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetActivityStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetActivityStatus::from(s))
    }
}
impl FleetActivityStatus {
    pub fn as_str(&self) -> &str {
        match self {
            FleetActivityStatus::Error => "error",
            FleetActivityStatus::Fulfilled => "fulfilled",
            FleetActivityStatus::PendingFulfillment => "pending_fulfillment",
            FleetActivityStatus::PendingTermination => "pending_termination",
            FleetActivityStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "error",
            "fulfilled",
            "pending_fulfillment",
            "pending_termination",
        ]
    }
}
impl AsRef<str> for FleetActivityStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an event in the history of an EC2 Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HistoryRecordEntry {
    /// <p>Information about the event.</p>
    pub event_information: std::option::Option<crate::model::EventInformation>,
    /// <p>The event type.</p>
    pub event_type: std::option::Option<crate::model::FleetEventType>,
    /// <p>The date and time of the event, in UTC format (for example,
    /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for HistoryRecordEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HistoryRecordEntry");
        formatter.field("event_information", &self.event_information);
        formatter.field("event_type", &self.event_type);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`HistoryRecordEntry`](crate::model::HistoryRecordEntry)
pub mod history_record_entry {
    /// A builder for [`HistoryRecordEntry`](crate::model::HistoryRecordEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_information: std::option::Option<crate::model::EventInformation>,
        pub(crate) event_type: std::option::Option<crate::model::FleetEventType>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Information about the event.</p>
        pub fn event_information(mut self, input: crate::model::EventInformation) -> Self {
            self.event_information = Some(input);
            self
        }
        pub fn set_event_information(
            mut self,
            input: std::option::Option<crate::model::EventInformation>,
        ) -> Self {
            self.event_information = input;
            self
        }
        /// <p>The event type.</p>
        pub fn event_type(mut self, input: crate::model::FleetEventType) -> Self {
            self.event_type = Some(input);
            self
        }
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::FleetEventType>,
        ) -> Self {
            self.event_type = input;
            self
        }
        /// <p>The date and time of the event, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`HistoryRecordEntry`](crate::model::HistoryRecordEntry)
        pub fn build(self) -> crate::model::HistoryRecordEntry {
            crate::model::HistoryRecordEntry {
                event_information: self.event_information,
                event_type: self.event_type,
                timestamp: self.timestamp,
            }
        }
    }
}
impl HistoryRecordEntry {
    /// Creates a new builder-style object to manufacture [`HistoryRecordEntry`](crate::model::HistoryRecordEntry)
    pub fn builder() -> crate::model::history_record_entry::Builder {
        crate::model::history_record_entry::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FleetEventType {
    FleetChange,
    InstanceChange,
    ServiceError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FleetEventType {
    fn from(s: &str) -> Self {
        match s {
            "fleet-change" => FleetEventType::FleetChange,
            "instance-change" => FleetEventType::InstanceChange,
            "service-error" => FleetEventType::ServiceError,
            other => FleetEventType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FleetEventType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FleetEventType::from(s))
    }
}
impl FleetEventType {
    pub fn as_str(&self) -> &str {
        match self {
            FleetEventType::FleetChange => "fleet-change",
            FleetEventType::InstanceChange => "instance-change",
            FleetEventType::ServiceError => "service-error",
            FleetEventType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["fleet-change", "instance-change", "service-error"]
    }
}
impl AsRef<str> for FleetEventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes fast snapshot restores for a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeFastSnapshotRestoreSuccessItem {
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The state of fast snapshot restores.</p>
    pub state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
    /// <p>The reason for the state transition. The possible values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
    /// <code>disabling</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
    /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
    /// </li>
    /// </ul>
    pub state_transition_reason: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
    pub owner_alias: std::option::Option<std::string::String>,
    /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
    pub enabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
    pub optimizing_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
    pub enabled_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
    pub disabling_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
    pub disabled_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DescribeFastSnapshotRestoreSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeFastSnapshotRestoreSuccessItem");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("state", &self.state);
        formatter.field("state_transition_reason", &self.state_transition_reason);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("owner_alias", &self.owner_alias);
        formatter.field("enabling_time", &self.enabling_time);
        formatter.field("optimizing_time", &self.optimizing_time);
        formatter.field("enabled_time", &self.enabled_time);
        formatter.field("disabling_time", &self.disabling_time);
        formatter.field("disabled_time", &self.disabled_time);
        formatter.finish()
    }
}
/// See [`DescribeFastSnapshotRestoreSuccessItem`](crate::model::DescribeFastSnapshotRestoreSuccessItem)
pub mod describe_fast_snapshot_restore_success_item {
    /// A builder for [`DescribeFastSnapshotRestoreSuccessItem`](crate::model::DescribeFastSnapshotRestoreSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        pub(crate) state_transition_reason: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) owner_alias: std::option::Option<std::string::String>,
        pub(crate) enabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) optimizing_time: std::option::Option<smithy_types::Instant>,
        pub(crate) enabled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabling_time: std::option::Option<smithy_types::Instant>,
        pub(crate) disabled_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The state of fast snapshot restores.</p>
        pub fn state(mut self, input: crate::model::FastSnapshotRestoreStateCode) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::FastSnapshotRestoreStateCode>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The reason for the state transition. The possible values are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or
        /// <code>disabling</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned
        /// to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p>
        /// </li>
        /// </ul>
        pub fn state_transition_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_transition_reason = Some(input.into());
            self
        }
        pub fn set_state_transition_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_transition_reason = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that enabled fast snapshot restores on the snapshot.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Amazon Web Services owner alias that enabled fast snapshot restores on the snapshot. This is intended for future use.</p>
        pub fn owner_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_alias = Some(input.into());
            self
        }
        pub fn set_owner_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_alias = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>
        pub fn enabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabling_time = Some(input);
            self
        }
        pub fn set_enabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>
        pub fn optimizing_time(mut self, input: smithy_types::Instant) -> Self {
            self.optimizing_time = Some(input);
            self
        }
        pub fn set_optimizing_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.optimizing_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>
        pub fn enabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.enabled_time = Some(input);
            self
        }
        pub fn set_enabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.enabled_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>
        pub fn disabling_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabling_time = Some(input);
            self
        }
        pub fn set_disabling_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabling_time = input;
            self
        }
        /// <p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>
        pub fn disabled_time(mut self, input: smithy_types::Instant) -> Self {
            self.disabled_time = Some(input);
            self
        }
        pub fn set_disabled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.disabled_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeFastSnapshotRestoreSuccessItem`](crate::model::DescribeFastSnapshotRestoreSuccessItem)
        pub fn build(self) -> crate::model::DescribeFastSnapshotRestoreSuccessItem {
            crate::model::DescribeFastSnapshotRestoreSuccessItem {
                snapshot_id: self.snapshot_id,
                availability_zone: self.availability_zone,
                state: self.state,
                state_transition_reason: self.state_transition_reason,
                owner_id: self.owner_id,
                owner_alias: self.owner_alias,
                enabling_time: self.enabling_time,
                optimizing_time: self.optimizing_time,
                enabled_time: self.enabled_time,
                disabling_time: self.disabling_time,
                disabled_time: self.disabled_time,
            }
        }
    }
}
impl DescribeFastSnapshotRestoreSuccessItem {
    /// Creates a new builder-style object to manufacture [`DescribeFastSnapshotRestoreSuccessItem`](crate::model::DescribeFastSnapshotRestoreSuccessItem)
    pub fn builder() -> crate::model::describe_fast_snapshot_restore_success_item::Builder {
        crate::model::describe_fast_snapshot_restore_success_item::Builder::default()
    }
}

/// <p>Describes an export instance task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTask {
    /// <p>A description of the resource being exported.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the export task.</p>
    pub export_task_id: std::option::Option<std::string::String>,
    /// <p>Information about the export task.</p>
    pub export_to_s3_task: std::option::Option<crate::model::ExportToS3Task>,
    /// <p>Information about the instance to export.</p>
    pub instance_export_details: std::option::Option<crate::model::InstanceExportDetails>,
    /// <p>The state of the export task.</p>
    pub state: std::option::Option<crate::model::ExportTaskState>,
    /// <p>The status message related to the export task.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The tags for the export task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ExportTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTask");
        formatter.field("description", &self.description);
        formatter.field("export_task_id", &self.export_task_id);
        formatter.field("export_to_s3_task", &self.export_to_s3_task);
        formatter.field("instance_export_details", &self.instance_export_details);
        formatter.field("state", &self.state);
        formatter.field("status_message", &self.status_message);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ExportTask`](crate::model::ExportTask)
pub mod export_task {
    /// A builder for [`ExportTask`](crate::model::ExportTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) export_task_id: std::option::Option<std::string::String>,
        pub(crate) export_to_s3_task: std::option::Option<crate::model::ExportToS3Task>,
        pub(crate) instance_export_details:
            std::option::Option<crate::model::InstanceExportDetails>,
        pub(crate) state: std::option::Option<crate::model::ExportTaskState>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A description of the resource being exported.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the export task.</p>
        pub fn export_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.export_task_id = Some(input.into());
            self
        }
        pub fn set_export_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.export_task_id = input;
            self
        }
        /// <p>Information about the export task.</p>
        pub fn export_to_s3_task(mut self, input: crate::model::ExportToS3Task) -> Self {
            self.export_to_s3_task = Some(input);
            self
        }
        pub fn set_export_to_s3_task(
            mut self,
            input: std::option::Option<crate::model::ExportToS3Task>,
        ) -> Self {
            self.export_to_s3_task = input;
            self
        }
        /// <p>Information about the instance to export.</p>
        pub fn instance_export_details(
            mut self,
            input: crate::model::InstanceExportDetails,
        ) -> Self {
            self.instance_export_details = Some(input);
            self
        }
        pub fn set_instance_export_details(
            mut self,
            input: std::option::Option<crate::model::InstanceExportDetails>,
        ) -> Self {
            self.instance_export_details = input;
            self
        }
        /// <p>The state of the export task.</p>
        pub fn state(mut self, input: crate::model::ExportTaskState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ExportTaskState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status message related to the export task.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTask`](crate::model::ExportTask)
        pub fn build(self) -> crate::model::ExportTask {
            crate::model::ExportTask {
                description: self.description,
                export_task_id: self.export_task_id,
                export_to_s3_task: self.export_to_s3_task,
                instance_export_details: self.instance_export_details,
                state: self.state,
                status_message: self.status_message,
                tags: self.tags,
            }
        }
    }
}
impl ExportTask {
    /// Creates a new builder-style object to manufacture [`ExportTask`](crate::model::ExportTask)
    pub fn builder() -> crate::model::export_task::Builder {
        crate::model::export_task::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportTaskState {
    Active,
    Cancelled,
    Cancelling,
    Completed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExportTaskState {
    fn from(s: &str) -> Self {
        match s {
            "active" => ExportTaskState::Active,
            "cancelled" => ExportTaskState::Cancelled,
            "cancelling" => ExportTaskState::Cancelling,
            "completed" => ExportTaskState::Completed,
            other => ExportTaskState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExportTaskState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExportTaskState::from(s))
    }
}
impl ExportTaskState {
    pub fn as_str(&self) -> &str {
        match self {
            ExportTaskState::Active => "active",
            ExportTaskState::Cancelled => "cancelled",
            ExportTaskState::Cancelling => "cancelling",
            ExportTaskState::Completed => "completed",
            ExportTaskState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "cancelling", "completed"]
    }
}
impl AsRef<str> for ExportTaskState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an instance to export.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceExportDetails {
    /// <p>The ID of the resource being exported.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The target virtualization environment.</p>
    pub target_environment: std::option::Option<crate::model::ExportEnvironment>,
}
impl std::fmt::Debug for InstanceExportDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceExportDetails");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("target_environment", &self.target_environment);
        formatter.finish()
    }
}
/// See [`InstanceExportDetails`](crate::model::InstanceExportDetails)
pub mod instance_export_details {
    /// A builder for [`InstanceExportDetails`](crate::model::InstanceExportDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) target_environment: std::option::Option<crate::model::ExportEnvironment>,
    }
    impl Builder {
        /// <p>The ID of the resource being exported.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The target virtualization environment.</p>
        pub fn target_environment(mut self, input: crate::model::ExportEnvironment) -> Self {
            self.target_environment = Some(input);
            self
        }
        pub fn set_target_environment(
            mut self,
            input: std::option::Option<crate::model::ExportEnvironment>,
        ) -> Self {
            self.target_environment = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceExportDetails`](crate::model::InstanceExportDetails)
        pub fn build(self) -> crate::model::InstanceExportDetails {
            crate::model::InstanceExportDetails {
                instance_id: self.instance_id,
                target_environment: self.target_environment,
            }
        }
    }
}
impl InstanceExportDetails {
    /// Creates a new builder-style object to manufacture [`InstanceExportDetails`](crate::model::InstanceExportDetails)
    pub fn builder() -> crate::model::instance_export_details::Builder {
        crate::model::instance_export_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportEnvironment {
    Citrix,
    Microsoft,
    Vmware,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExportEnvironment {
    fn from(s: &str) -> Self {
        match s {
            "citrix" => ExportEnvironment::Citrix,
            "microsoft" => ExportEnvironment::Microsoft,
            "vmware" => ExportEnvironment::Vmware,
            other => ExportEnvironment::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExportEnvironment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExportEnvironment::from(s))
    }
}
impl ExportEnvironment {
    pub fn as_str(&self) -> &str {
        match self {
            ExportEnvironment::Citrix => "citrix",
            ExportEnvironment::Microsoft => "microsoft",
            ExportEnvironment::Vmware => "vmware",
            ExportEnvironment::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["citrix", "microsoft", "vmware"]
    }
}
impl AsRef<str> for ExportEnvironment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the format and location for the export task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportToS3Task {
    /// <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is
    /// exported.</p>
    pub container_format: std::option::Option<crate::model::ContainerFormat>,
    /// <p>The format for the exported image.</p>
    pub disk_image_format: std::option::Option<crate::model::DiskImageFormat>,
    /// <p>The Amazon S3 bucket for the destination image. The destination bucket must exist and grant
    /// WRITE and READ_ACP permissions to the Amazon Web Services account <code>vm-import-export@amazon.com</code>.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The encryption key for your S3 bucket.</p>
    pub s3_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportToS3Task {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportToS3Task");
        formatter.field("container_format", &self.container_format);
        formatter.field("disk_image_format", &self.disk_image_format);
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_key", &self.s3_key);
        formatter.finish()
    }
}
/// See [`ExportToS3Task`](crate::model::ExportToS3Task)
pub mod export_to_s3_task {
    /// A builder for [`ExportToS3Task`](crate::model::ExportToS3Task)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_format: std::option::Option<crate::model::ContainerFormat>,
        pub(crate) disk_image_format: std::option::Option<crate::model::DiskImageFormat>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is
        /// exported.</p>
        pub fn container_format(mut self, input: crate::model::ContainerFormat) -> Self {
            self.container_format = Some(input);
            self
        }
        pub fn set_container_format(
            mut self,
            input: std::option::Option<crate::model::ContainerFormat>,
        ) -> Self {
            self.container_format = input;
            self
        }
        /// <p>The format for the exported image.</p>
        pub fn disk_image_format(mut self, input: crate::model::DiskImageFormat) -> Self {
            self.disk_image_format = Some(input);
            self
        }
        pub fn set_disk_image_format(
            mut self,
            input: std::option::Option<crate::model::DiskImageFormat>,
        ) -> Self {
            self.disk_image_format = input;
            self
        }
        /// <p>The Amazon S3 bucket for the destination image. The destination bucket must exist and grant
        /// WRITE and READ_ACP permissions to the Amazon Web Services account <code>vm-import-export@amazon.com</code>.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The encryption key for your S3 bucket.</p>
        pub fn s3_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_key = Some(input.into());
            self
        }
        pub fn set_s3_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_key = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportToS3Task`](crate::model::ExportToS3Task)
        pub fn build(self) -> crate::model::ExportToS3Task {
            crate::model::ExportToS3Task {
                container_format: self.container_format,
                disk_image_format: self.disk_image_format,
                s3_bucket: self.s3_bucket,
                s3_key: self.s3_key,
            }
        }
    }
}
impl ExportToS3Task {
    /// Creates a new builder-style object to manufacture [`ExportToS3Task`](crate::model::ExportToS3Task)
    pub fn builder() -> crate::model::export_to_s3_task::Builder {
        crate::model::export_to_s3_task::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContainerFormat {
    Ova,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContainerFormat {
    fn from(s: &str) -> Self {
        match s {
            "ova" => ContainerFormat::Ova,
            other => ContainerFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContainerFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContainerFormat::from(s))
    }
}
impl ContainerFormat {
    pub fn as_str(&self) -> &str {
        match self {
            ContainerFormat::Ova => "ova",
            ContainerFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ova"]
    }
}
impl AsRef<str> for ContainerFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an export image task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportImageTask {
    /// <p>A description of the image being exported.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the export image task.</p>
    pub export_image_task_id: std::option::Option<std::string::String>,
    /// <p>The ID of the image.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The percent complete of the export image task.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>Information about the destination Amazon S3 bucket.</p>
    pub s3_export_location: std::option::Option<crate::model::ExportTaskS3Location>,
    /// <p>The status of the export image task. The possible values are <code>active</code>, <code>completed</code>,
    /// <code>deleting</code>, and <code>deleted</code>.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The status message for the export image task.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the export image task.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ExportImageTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportImageTask");
        formatter.field("description", &self.description);
        formatter.field("export_image_task_id", &self.export_image_task_id);
        formatter.field("image_id", &self.image_id);
        formatter.field("progress", &self.progress);
        formatter.field("s3_export_location", &self.s3_export_location);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ExportImageTask`](crate::model::ExportImageTask)
pub mod export_image_task {
    /// A builder for [`ExportImageTask`](crate::model::ExportImageTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) export_image_task_id: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) s3_export_location: std::option::Option<crate::model::ExportTaskS3Location>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A description of the image being exported.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the export image task.</p>
        pub fn export_image_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.export_image_task_id = Some(input.into());
            self
        }
        pub fn set_export_image_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.export_image_task_id = input;
            self
        }
        /// <p>The ID of the image.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The percent complete of the export image task.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>Information about the destination Amazon S3 bucket.</p>
        pub fn s3_export_location(mut self, input: crate::model::ExportTaskS3Location) -> Self {
            self.s3_export_location = Some(input);
            self
        }
        pub fn set_s3_export_location(
            mut self,
            input: std::option::Option<crate::model::ExportTaskS3Location>,
        ) -> Self {
            self.s3_export_location = input;
            self
        }
        /// <p>The status of the export image task. The possible values are <code>active</code>, <code>completed</code>,
        /// <code>deleting</code>, and <code>deleted</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message for the export image task.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportImageTask`](crate::model::ExportImageTask)
        pub fn build(self) -> crate::model::ExportImageTask {
            crate::model::ExportImageTask {
                description: self.description,
                export_image_task_id: self.export_image_task_id,
                image_id: self.image_id,
                progress: self.progress,
                s3_export_location: self.s3_export_location,
                status: self.status,
                status_message: self.status_message,
                tags: self.tags,
            }
        }
    }
}
impl ExportImageTask {
    /// Creates a new builder-style object to manufacture [`ExportImageTask`](crate::model::ExportImageTask)
    pub fn builder() -> crate::model::export_image_task::Builder {
        crate::model::export_image_task::Builder::default()
    }
}

/// <p>Describes an Elastic Graphics accelerator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticGpus {
    /// <p>The ID of the Elastic Graphics accelerator.</p>
    pub elastic_gpu_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in the which the Elastic Graphics accelerator resides.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The type of Elastic Graphics accelerator.</p>
    pub elastic_gpu_type: std::option::Option<std::string::String>,
    /// <p>The status of the Elastic Graphics accelerator.</p>
    pub elastic_gpu_health: std::option::Option<crate::model::ElasticGpuHealth>,
    /// <p>The state of the Elastic Graphics accelerator.</p>
    pub elastic_gpu_state: std::option::Option<crate::model::ElasticGpuState>,
    /// <p>The ID of the instance to which the Elastic Graphics accelerator is attached.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the Elastic Graphics accelerator.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ElasticGpus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticGpus");
        formatter.field("elastic_gpu_id", &self.elastic_gpu_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("elastic_gpu_type", &self.elastic_gpu_type);
        formatter.field("elastic_gpu_health", &self.elastic_gpu_health);
        formatter.field("elastic_gpu_state", &self.elastic_gpu_state);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ElasticGpus`](crate::model::ElasticGpus)
pub mod elastic_gpus {
    /// A builder for [`ElasticGpus`](crate::model::ElasticGpus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elastic_gpu_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) elastic_gpu_type: std::option::Option<std::string::String>,
        pub(crate) elastic_gpu_health: std::option::Option<crate::model::ElasticGpuHealth>,
        pub(crate) elastic_gpu_state: std::option::Option<crate::model::ElasticGpuState>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_gpu_id = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_id = input;
            self
        }
        /// <p>The Availability Zone in the which the Elastic Graphics accelerator resides.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The type of Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_gpu_type = Some(input.into());
            self
        }
        pub fn set_elastic_gpu_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_gpu_type = input;
            self
        }
        /// <p>The status of the Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_health(mut self, input: crate::model::ElasticGpuHealth) -> Self {
            self.elastic_gpu_health = Some(input);
            self
        }
        pub fn set_elastic_gpu_health(
            mut self,
            input: std::option::Option<crate::model::ElasticGpuHealth>,
        ) -> Self {
            self.elastic_gpu_health = input;
            self
        }
        /// <p>The state of the Elastic Graphics accelerator.</p>
        pub fn elastic_gpu_state(mut self, input: crate::model::ElasticGpuState) -> Self {
            self.elastic_gpu_state = Some(input);
            self
        }
        pub fn set_elastic_gpu_state(
            mut self,
            input: std::option::Option<crate::model::ElasticGpuState>,
        ) -> Self {
            self.elastic_gpu_state = input;
            self
        }
        /// <p>The ID of the instance to which the Elastic Graphics accelerator is attached.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticGpus`](crate::model::ElasticGpus)
        pub fn build(self) -> crate::model::ElasticGpus {
            crate::model::ElasticGpus {
                elastic_gpu_id: self.elastic_gpu_id,
                availability_zone: self.availability_zone,
                elastic_gpu_type: self.elastic_gpu_type,
                elastic_gpu_health: self.elastic_gpu_health,
                elastic_gpu_state: self.elastic_gpu_state,
                instance_id: self.instance_id,
                tags: self.tags,
            }
        }
    }
}
impl ElasticGpus {
    /// Creates a new builder-style object to manufacture [`ElasticGpus`](crate::model::ElasticGpus)
    pub fn builder() -> crate::model::elastic_gpus::Builder {
        crate::model::elastic_gpus::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ElasticGpuState {
    Attached,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ElasticGpuState {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHED" => ElasticGpuState::Attached,
            other => ElasticGpuState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ElasticGpuState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ElasticGpuState::from(s))
    }
}
impl ElasticGpuState {
    pub fn as_str(&self) -> &str {
        match self {
            ElasticGpuState::Attached => "ATTACHED",
            ElasticGpuState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ATTACHED"]
    }
}
impl AsRef<str> for ElasticGpuState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the status of an Elastic Graphics accelerator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticGpuHealth {
    /// <p>The health status.</p>
    pub status: std::option::Option<crate::model::ElasticGpuStatus>,
}
impl std::fmt::Debug for ElasticGpuHealth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticGpuHealth");
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ElasticGpuHealth`](crate::model::ElasticGpuHealth)
pub mod elastic_gpu_health {
    /// A builder for [`ElasticGpuHealth`](crate::model::ElasticGpuHealth)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ElasticGpuStatus>,
    }
    impl Builder {
        /// <p>The health status.</p>
        pub fn status(mut self, input: crate::model::ElasticGpuStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ElasticGpuStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticGpuHealth`](crate::model::ElasticGpuHealth)
        pub fn build(self) -> crate::model::ElasticGpuHealth {
            crate::model::ElasticGpuHealth {
                status: self.status,
            }
        }
    }
}
impl ElasticGpuHealth {
    /// Creates a new builder-style object to manufacture [`ElasticGpuHealth`](crate::model::ElasticGpuHealth)
    pub fn builder() -> crate::model::elastic_gpu_health::Builder {
        crate::model::elastic_gpu_health::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ElasticGpuStatus {
    Impaired,
    Ok,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ElasticGpuStatus {
    fn from(s: &str) -> Self {
        match s {
            "IMPAIRED" => ElasticGpuStatus::Impaired,
            "OK" => ElasticGpuStatus::Ok,
            other => ElasticGpuStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ElasticGpuStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ElasticGpuStatus::from(s))
    }
}
impl ElasticGpuStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ElasticGpuStatus::Impaired => "IMPAIRED",
            ElasticGpuStatus::Ok => "OK",
            ElasticGpuStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["IMPAIRED", "OK"]
    }
}
impl AsRef<str> for ElasticGpuStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an egress-only internet gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EgressOnlyInternetGateway {
    /// <p>Information about the attachment of the egress-only internet gateway.</p>
    pub attachments: std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
    /// <p>The ID of the egress-only internet gateway.</p>
    pub egress_only_internet_gateway_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the egress-only internet gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for EgressOnlyInternetGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EgressOnlyInternetGateway");
        formatter.field("attachments", &self.attachments);
        formatter.field(
            "egress_only_internet_gateway_id",
            &self.egress_only_internet_gateway_id,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`EgressOnlyInternetGateway`](crate::model::EgressOnlyInternetGateway)
pub mod egress_only_internet_gateway {
    /// A builder for [`EgressOnlyInternetGateway`](crate::model::EgressOnlyInternetGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachments:
            std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
        pub(crate) egress_only_internet_gateway_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        pub fn attachments(
            mut self,
            input: impl Into<crate::model::InternetGatewayAttachment>,
        ) -> Self {
            let mut v = self.attachments.unwrap_or_default();
            v.push(input.into());
            self.attachments = Some(v);
            self
        }
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InternetGatewayAttachment>>,
        ) -> Self {
            self.attachments = input;
            self
        }
        /// <p>The ID of the egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = Some(input.into());
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.egress_only_internet_gateway_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`EgressOnlyInternetGateway`](crate::model::EgressOnlyInternetGateway)
        pub fn build(self) -> crate::model::EgressOnlyInternetGateway {
            crate::model::EgressOnlyInternetGateway {
                attachments: self.attachments,
                egress_only_internet_gateway_id: self.egress_only_internet_gateway_id,
                tags: self.tags,
            }
        }
    }
}
impl EgressOnlyInternetGateway {
    /// Creates a new builder-style object to manufacture [`EgressOnlyInternetGateway`](crate::model::EgressOnlyInternetGateway)
    pub fn builder() -> crate::model::egress_only_internet_gateway::Builder {
        crate::model::egress_only_internet_gateway::Builder::default()
    }
}

/// <p>Describes a set of DHCP options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DhcpOptions {
    /// <p>One or more DHCP options in the set.</p>
    pub dhcp_configurations: std::option::Option<std::vec::Vec<crate::model::DhcpConfiguration>>,
    /// <p>The ID of the set of DHCP options.</p>
    pub dhcp_options_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the DHCP options set.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the DHCP options set.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for DhcpOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DhcpOptions");
        formatter.field("dhcp_configurations", &self.dhcp_configurations);
        formatter.field("dhcp_options_id", &self.dhcp_options_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`DhcpOptions`](crate::model::DhcpOptions)
pub mod dhcp_options {
    /// A builder for [`DhcpOptions`](crate::model::DhcpOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dhcp_configurations:
            std::option::Option<std::vec::Vec<crate::model::DhcpConfiguration>>,
        pub(crate) dhcp_options_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        pub fn dhcp_configurations(
            mut self,
            input: impl Into<crate::model::DhcpConfiguration>,
        ) -> Self {
            let mut v = self.dhcp_configurations.unwrap_or_default();
            v.push(input.into());
            self.dhcp_configurations = Some(v);
            self
        }
        pub fn set_dhcp_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DhcpConfiguration>>,
        ) -> Self {
            self.dhcp_configurations = input;
            self
        }
        /// <p>The ID of the set of DHCP options.</p>
        pub fn dhcp_options_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dhcp_options_id = Some(input.into());
            self
        }
        pub fn set_dhcp_options_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dhcp_options_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the DHCP options set.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DhcpOptions`](crate::model::DhcpOptions)
        pub fn build(self) -> crate::model::DhcpOptions {
            crate::model::DhcpOptions {
                dhcp_configurations: self.dhcp_configurations,
                dhcp_options_id: self.dhcp_options_id,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl DhcpOptions {
    /// Creates a new builder-style object to manufacture [`DhcpOptions`](crate::model::DhcpOptions)
    pub fn builder() -> crate::model::dhcp_options::Builder {
        crate::model::dhcp_options::Builder::default()
    }
}

/// <p>Describes a DHCP configuration option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DhcpConfiguration {
    /// <p>The name of a DHCP option.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>One or more values for the DHCP option.</p>
    pub values: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
}
impl std::fmt::Debug for DhcpConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DhcpConfiguration");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`DhcpConfiguration`](crate::model::DhcpConfiguration)
pub mod dhcp_configuration {
    /// A builder for [`DhcpConfiguration`](crate::model::DhcpConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
    }
    impl Builder {
        /// <p>The name of a DHCP option.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<crate::model::AttributeValue>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`DhcpConfiguration`](crate::model::DhcpConfiguration)
        pub fn build(self) -> crate::model::DhcpConfiguration {
            crate::model::DhcpConfiguration {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl DhcpConfiguration {
    /// Creates a new builder-style object to manufacture [`DhcpConfiguration`](crate::model::DhcpConfiguration)
    pub fn builder() -> crate::model::dhcp_configuration::Builder {
        crate::model::dhcp_configuration::Builder::default()
    }
}

/// <p>Describes a customer gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomerGateway {
    /// <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
    pub bgp_asn: std::option::Option<std::string::String>,
    /// <p>The ID of the customer gateway.</p>
    pub customer_gateway_id: std::option::Option<std::string::String>,
    /// <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
    pub ip_address: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the customer gateway certificate.</p>
    pub certificate_arn: std::option::Option<std::string::String>,
    /// <p>The current state of the customer gateway (<code>pending | available | deleting |
    /// deleted</code>).</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The name of customer gateway device.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the customer gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CustomerGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomerGateway");
        formatter.field("bgp_asn", &self.bgp_asn);
        formatter.field("customer_gateway_id", &self.customer_gateway_id);
        formatter.field("ip_address", &self.ip_address);
        formatter.field("certificate_arn", &self.certificate_arn);
        formatter.field("state", &self.state);
        formatter.field("r#type", &self.r#type);
        formatter.field("device_name", &self.device_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`CustomerGateway`](crate::model::CustomerGateway)
pub mod customer_gateway {
    /// A builder for [`CustomerGateway`](crate::model::CustomerGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bgp_asn: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_id: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) certificate_arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
        pub fn bgp_asn(mut self, input: impl Into<std::string::String>) -> Self {
            self.bgp_asn = Some(input.into());
            self
        }
        pub fn set_bgp_asn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bgp_asn = input;
            self
        }
        /// <p>The ID of the customer gateway.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_id = Some(input.into());
            self
        }
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_id = input;
            self
        }
        /// <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the customer gateway certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_arn = Some(input.into());
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_arn = input;
            self
        }
        /// <p>The current state of the customer gateway (<code>pending | available | deleting |
        /// deleted</code>).</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of customer gateway device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomerGateway`](crate::model::CustomerGateway)
        pub fn build(self) -> crate::model::CustomerGateway {
            crate::model::CustomerGateway {
                bgp_asn: self.bgp_asn,
                customer_gateway_id: self.customer_gateway_id,
                ip_address: self.ip_address,
                certificate_arn: self.certificate_arn,
                state: self.state,
                r#type: self.r#type,
                device_name: self.device_name,
                tags: self.tags,
            }
        }
    }
}
impl CustomerGateway {
    /// Creates a new builder-style object to manufacture [`CustomerGateway`](crate::model::CustomerGateway)
    pub fn builder() -> crate::model::customer_gateway::Builder {
        crate::model::customer_gateway::Builder::default()
    }
}

/// <p>Describes a customer-owned address pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoipPool {
    /// <p>The ID of the address pool.</p>
    pub pool_id: std::option::Option<std::string::String>,
    /// <p>The address ranges of the address pool.</p>
    pub pool_cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the local gateway route table.</p>
    pub local_gateway_route_table_id: std::option::Option<std::string::String>,
    /// <p>The tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ARN of the address pool.</p>
    pub pool_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CoipPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoipPool");
        formatter.field("pool_id", &self.pool_id);
        formatter.field("pool_cidrs", &self.pool_cidrs);
        formatter.field(
            "local_gateway_route_table_id",
            &self.local_gateway_route_table_id,
        );
        formatter.field("tags", &self.tags);
        formatter.field("pool_arn", &self.pool_arn);
        formatter.finish()
    }
}
/// See [`CoipPool`](crate::model::CoipPool)
pub mod coip_pool {
    /// A builder for [`CoipPool`](crate::model::CoipPool)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pool_id: std::option::Option<std::string::String>,
        pub(crate) pool_cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) local_gateway_route_table_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) pool_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the address pool.</p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.pool_id = Some(input.into());
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pool_id = input;
            self
        }
        pub fn pool_cidrs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pool_cidrs.unwrap_or_default();
            v.push(input.into());
            self.pool_cidrs = Some(v);
            self
        }
        pub fn set_pool_cidrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pool_cidrs = input;
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = Some(input.into());
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_gateway_route_table_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ARN of the address pool.</p>
        pub fn pool_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pool_arn = Some(input.into());
            self
        }
        pub fn set_pool_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pool_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CoipPool`](crate::model::CoipPool)
        pub fn build(self) -> crate::model::CoipPool {
            crate::model::CoipPool {
                pool_id: self.pool_id,
                pool_cidrs: self.pool_cidrs,
                local_gateway_route_table_id: self.local_gateway_route_table_id,
                tags: self.tags,
                pool_arn: self.pool_arn,
            }
        }
    }
}
impl CoipPool {
    /// Creates a new builder-style object to manufacture [`CoipPool`](crate::model::CoipPool)
    pub fn builder() -> crate::model::coip_pool::Builder {
        crate::model::coip_pool::Builder::default()
    }
}

/// <p>Describes a target network associated with a Client VPN endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetNetwork {
    /// <p>The ID of the association.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC in which the target network (subnet) is located.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet specified as the target network.</p>
    pub target_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Client VPN endpoint with which the target network is associated.</p>
    pub client_vpn_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The current state of the target network association.</p>
    pub status: std::option::Option<crate::model::AssociationStatus>,
    /// <p>The IDs of the security groups applied to the target network association.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for TargetNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetNetwork");
        formatter.field("association_id", &self.association_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("target_network_id", &self.target_network_id);
        formatter.field("client_vpn_endpoint_id", &self.client_vpn_endpoint_id);
        formatter.field("status", &self.status);
        formatter.field("security_groups", &self.security_groups);
        formatter.finish()
    }
}
/// See [`TargetNetwork`](crate::model::TargetNetwork)
pub mod target_network {
    /// A builder for [`TargetNetwork`](crate::model::TargetNetwork)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) target_network_id: std::option::Option<std::string::String>,
        pub(crate) client_vpn_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AssociationStatus>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>The ID of the VPC in which the target network (subnet) is located.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The ID of the subnet specified as the target network.</p>
        pub fn target_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_network_id = Some(input.into());
            self
        }
        pub fn set_target_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_network_id = input;
            self
        }
        /// <p>The ID of the Client VPN endpoint with which the target network is associated.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpn_endpoint_id = Some(input.into());
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpn_endpoint_id = input;
            self
        }
        /// <p>The current state of the target network association.</p>
        pub fn status(mut self, input: crate::model::AssociationStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssociationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetNetwork`](crate::model::TargetNetwork)
        pub fn build(self) -> crate::model::TargetNetwork {
            crate::model::TargetNetwork {
                association_id: self.association_id,
                vpc_id: self.vpc_id,
                target_network_id: self.target_network_id,
                client_vpn_endpoint_id: self.client_vpn_endpoint_id,
                status: self.status,
                security_groups: self.security_groups,
            }
        }
    }
}
impl TargetNetwork {
    /// Creates a new builder-style object to manufacture [`TargetNetwork`](crate::model::TargetNetwork)
    pub fn builder() -> crate::model::target_network::Builder {
        crate::model::target_network::Builder::default()
    }
}

/// <p>Information about a Client VPN endpoint route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnRoute {
    /// <p>The ID of the Client VPN endpoint with which the route is associated.</p>
    pub client_vpn_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address range, in CIDR notation, of the route destination.</p>
    pub destination_cidr: std::option::Option<std::string::String>,
    /// <p>The ID of the subnet through which traffic is routed.</p>
    pub target_subnet: std::option::Option<std::string::String>,
    /// <p>The route type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Indicates how the route was associated with the Client VPN endpoint.
    /// <code>associate</code> indicates that the route was automatically added when the target network
    /// was associated with the Client VPN endpoint. <code>add-route</code> indicates that the route
    /// was manually added using the <b>CreateClientVpnRoute</b> action.</p>
    pub origin: std::option::Option<std::string::String>,
    /// <p>The current state of the route.</p>
    pub status: std::option::Option<crate::model::ClientVpnRouteStatus>,
    /// <p>A brief description of the route.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnRoute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnRoute");
        formatter.field("client_vpn_endpoint_id", &self.client_vpn_endpoint_id);
        formatter.field("destination_cidr", &self.destination_cidr);
        formatter.field("target_subnet", &self.target_subnet);
        formatter.field("r#type", &self.r#type);
        formatter.field("origin", &self.origin);
        formatter.field("status", &self.status);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`ClientVpnRoute`](crate::model::ClientVpnRoute)
pub mod client_vpn_route {
    /// A builder for [`ClientVpnRoute`](crate::model::ClientVpnRoute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_vpn_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) destination_cidr: std::option::Option<std::string::String>,
        pub(crate) target_subnet: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ClientVpnRouteStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Client VPN endpoint with which the route is associated.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpn_endpoint_id = Some(input.into());
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpn_endpoint_id = input;
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the route destination.</p>
        pub fn destination_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr = Some(input.into());
            self
        }
        pub fn set_destination_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr = input;
            self
        }
        /// <p>The ID of the subnet through which traffic is routed.</p>
        pub fn target_subnet(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_subnet = Some(input.into());
            self
        }
        pub fn set_target_subnet(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_subnet = input;
            self
        }
        /// <p>The route type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Indicates how the route was associated with the Client VPN endpoint.
        /// <code>associate</code> indicates that the route was automatically added when the target network
        /// was associated with the Client VPN endpoint. <code>add-route</code> indicates that the route
        /// was manually added using the <b>CreateClientVpnRoute</b> action.</p>
        pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin = Some(input.into());
            self
        }
        pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.origin = input;
            self
        }
        /// <p>The current state of the route.</p>
        pub fn status(mut self, input: crate::model::ClientVpnRouteStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnRouteStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A brief description of the route.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnRoute`](crate::model::ClientVpnRoute)
        pub fn build(self) -> crate::model::ClientVpnRoute {
            crate::model::ClientVpnRoute {
                client_vpn_endpoint_id: self.client_vpn_endpoint_id,
                destination_cidr: self.destination_cidr,
                target_subnet: self.target_subnet,
                r#type: self.r#type,
                origin: self.origin,
                status: self.status,
                description: self.description,
            }
        }
    }
}
impl ClientVpnRoute {
    /// Creates a new builder-style object to manufacture [`ClientVpnRoute`](crate::model::ClientVpnRoute)
    pub fn builder() -> crate::model::client_vpn_route::Builder {
        crate::model::client_vpn_route::Builder::default()
    }
}

/// <p>Describes the state of a Client VPN endpoint route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnRouteStatus {
    /// <p>The state of the Client VPN endpoint route.</p>
    pub code: std::option::Option<crate::model::ClientVpnRouteStatusCode>,
    /// <p>A message about the status of the Client VPN endpoint route, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnRouteStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnRouteStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientVpnRouteStatus`](crate::model::ClientVpnRouteStatus)
pub mod client_vpn_route_status {
    /// A builder for [`ClientVpnRouteStatus`](crate::model::ClientVpnRouteStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ClientVpnRouteStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the Client VPN endpoint route.</p>
        pub fn code(mut self, input: crate::model::ClientVpnRouteStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientVpnRouteStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the Client VPN endpoint route, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnRouteStatus`](crate::model::ClientVpnRouteStatus)
        pub fn build(self) -> crate::model::ClientVpnRouteStatus {
            crate::model::ClientVpnRouteStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientVpnRouteStatus {
    /// Creates a new builder-style object to manufacture [`ClientVpnRouteStatus`](crate::model::ClientVpnRouteStatus)
    pub fn builder() -> crate::model::client_vpn_route_status::Builder {
        crate::model::client_vpn_route_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnRouteStatusCode {
    Active,
    Creating,
    Deleting,
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnRouteStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "active" => ClientVpnRouteStatusCode::Active,
            "creating" => ClientVpnRouteStatusCode::Creating,
            "deleting" => ClientVpnRouteStatusCode::Deleting,
            "failed" => ClientVpnRouteStatusCode::Failed,
            other => ClientVpnRouteStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnRouteStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnRouteStatusCode::from(s))
    }
}
impl ClientVpnRouteStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnRouteStatusCode::Active => "active",
            ClientVpnRouteStatusCode::Creating => "creating",
            ClientVpnRouteStatusCode::Deleting => "deleting",
            ClientVpnRouteStatusCode::Failed => "failed",
            ClientVpnRouteStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "creating", "deleting", "failed"]
    }
}
impl AsRef<str> for ClientVpnRouteStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Client VPN endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnEndpoint {
    /// <p>The ID of the Client VPN endpoint.</p>
    pub client_vpn_endpoint_id: std::option::Option<std::string::String>,
    /// <p>A brief description of the endpoint.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The current state of the Client VPN endpoint.</p>
    pub status: std::option::Option<crate::model::ClientVpnEndpointStatus>,
    /// <p>The date and time the Client VPN endpoint was created.</p>
    pub creation_time: std::option::Option<std::string::String>,
    /// <p>The date and time the Client VPN endpoint was deleted, if applicable.</p>
    pub deletion_time: std::option::Option<std::string::String>,
    /// <p>The DNS name to be used by clients when connecting to the Client VPN endpoint.</p>
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.</p>
    pub client_cidr_block: std::option::Option<std::string::String>,
    /// <p>Information about the DNS servers to be used for DNS resolution. </p>
    pub dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether split-tunnel is enabled in the AWS Client VPN endpoint.</p>
    /// <p>For information about split-tunnel VPN endpoints, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html">Split-Tunnel AWS Client VPN Endpoint</a> in the <i>AWS
    /// Client VPN Administrator Guide</i>.</p>
    pub split_tunnel: std::option::Option<bool>,
    /// <p>The protocol used by the VPN session.</p>
    pub vpn_protocol: std::option::Option<crate::model::VpnProtocol>,
    /// <p>The transport protocol used by the Client VPN endpoint.</p>
    pub transport_protocol: std::option::Option<crate::model::TransportProtocol>,
    /// <p>The port number for the  Client VPN endpoint.</p>
    pub vpn_port: std::option::Option<i32>,
    /// <p>Information about the associated target networks. A target network is a subnet in a VPC.</p>
    pub associated_target_networks:
        std::option::Option<std::vec::Vec<crate::model::AssociatedTargetNetwork>>,
    /// <p>The ARN of the server certificate.</p>
    pub server_certificate_arn: std::option::Option<std::string::String>,
    /// <p>Information about the authentication method used by the Client VPN endpoint.</p>
    pub authentication_options:
        std::option::Option<std::vec::Vec<crate::model::ClientVpnAuthentication>>,
    /// <p>Information about the client connection logging options for the Client VPN endpoint.</p>
    pub connection_log_options: std::option::Option<crate::model::ConnectionLogResponseOptions>,
    /// <p>Any tags assigned to the Client VPN endpoint.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The IDs of the security groups for the target network.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The URL of the self-service portal.</p>
    pub self_service_portal_url: std::option::Option<std::string::String>,
    /// <p>The options for managing connection authorization for new client connections.</p>
    pub client_connect_options: std::option::Option<crate::model::ClientConnectResponseOptions>,
}
impl std::fmt::Debug for ClientVpnEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnEndpoint");
        formatter.field("client_vpn_endpoint_id", &self.client_vpn_endpoint_id);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("deletion_time", &self.deletion_time);
        formatter.field("dns_name", &self.dns_name);
        formatter.field("client_cidr_block", &self.client_cidr_block);
        formatter.field("dns_servers", &self.dns_servers);
        formatter.field("split_tunnel", &self.split_tunnel);
        formatter.field("vpn_protocol", &self.vpn_protocol);
        formatter.field("transport_protocol", &self.transport_protocol);
        formatter.field("vpn_port", &self.vpn_port);
        formatter.field(
            "associated_target_networks",
            &self.associated_target_networks,
        );
        formatter.field("server_certificate_arn", &self.server_certificate_arn);
        formatter.field("authentication_options", &self.authentication_options);
        formatter.field("connection_log_options", &self.connection_log_options);
        formatter.field("tags", &self.tags);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("self_service_portal_url", &self.self_service_portal_url);
        formatter.field("client_connect_options", &self.client_connect_options);
        formatter.finish()
    }
}
/// See [`ClientVpnEndpoint`](crate::model::ClientVpnEndpoint)
pub mod client_vpn_endpoint {
    /// A builder for [`ClientVpnEndpoint`](crate::model::ClientVpnEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_vpn_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ClientVpnEndpointStatus>,
        pub(crate) creation_time: std::option::Option<std::string::String>,
        pub(crate) deletion_time: std::option::Option<std::string::String>,
        pub(crate) dns_name: std::option::Option<std::string::String>,
        pub(crate) client_cidr_block: std::option::Option<std::string::String>,
        pub(crate) dns_servers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) split_tunnel: std::option::Option<bool>,
        pub(crate) vpn_protocol: std::option::Option<crate::model::VpnProtocol>,
        pub(crate) transport_protocol: std::option::Option<crate::model::TransportProtocol>,
        pub(crate) vpn_port: std::option::Option<i32>,
        pub(crate) associated_target_networks:
            std::option::Option<std::vec::Vec<crate::model::AssociatedTargetNetwork>>,
        pub(crate) server_certificate_arn: std::option::Option<std::string::String>,
        pub(crate) authentication_options:
            std::option::Option<std::vec::Vec<crate::model::ClientVpnAuthentication>>,
        pub(crate) connection_log_options:
            std::option::Option<crate::model::ConnectionLogResponseOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) self_service_portal_url: std::option::Option<std::string::String>,
        pub(crate) client_connect_options:
            std::option::Option<crate::model::ClientConnectResponseOptions>,
    }
    impl Builder {
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpn_endpoint_id = Some(input.into());
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpn_endpoint_id = input;
            self
        }
        /// <p>A brief description of the endpoint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The current state of the Client VPN endpoint.</p>
        pub fn status(mut self, input: crate::model::ClientVpnEndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnEndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time the Client VPN endpoint was created.</p>
        pub fn creation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_time = Some(input.into());
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time the Client VPN endpoint was deleted, if applicable.</p>
        pub fn deletion_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.deletion_time = Some(input.into());
            self
        }
        pub fn set_deletion_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deletion_time = input;
            self
        }
        /// <p>The DNS name to be used by clients when connecting to the Client VPN endpoint.</p>
        pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_name = Some(input.into());
            self
        }
        pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_name = input;
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.</p>
        pub fn client_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_cidr_block = Some(input.into());
            self
        }
        pub fn set_client_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_cidr_block = input;
            self
        }
        pub fn dns_servers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_servers.unwrap_or_default();
            v.push(input.into());
            self.dns_servers = Some(v);
            self
        }
        pub fn set_dns_servers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_servers = input;
            self
        }
        /// <p>Indicates whether split-tunnel is enabled in the AWS Client VPN endpoint.</p>
        /// <p>For information about split-tunnel VPN endpoints, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html">Split-Tunnel AWS Client VPN Endpoint</a> in the <i>AWS
        /// Client VPN Administrator Guide</i>.</p>
        pub fn split_tunnel(mut self, input: bool) -> Self {
            self.split_tunnel = Some(input);
            self
        }
        pub fn set_split_tunnel(mut self, input: std::option::Option<bool>) -> Self {
            self.split_tunnel = input;
            self
        }
        /// <p>The protocol used by the VPN session.</p>
        pub fn vpn_protocol(mut self, input: crate::model::VpnProtocol) -> Self {
            self.vpn_protocol = Some(input);
            self
        }
        pub fn set_vpn_protocol(
            mut self,
            input: std::option::Option<crate::model::VpnProtocol>,
        ) -> Self {
            self.vpn_protocol = input;
            self
        }
        /// <p>The transport protocol used by the Client VPN endpoint.</p>
        pub fn transport_protocol(mut self, input: crate::model::TransportProtocol) -> Self {
            self.transport_protocol = Some(input);
            self
        }
        pub fn set_transport_protocol(
            mut self,
            input: std::option::Option<crate::model::TransportProtocol>,
        ) -> Self {
            self.transport_protocol = input;
            self
        }
        /// <p>The port number for the  Client VPN endpoint.</p>
        pub fn vpn_port(mut self, input: i32) -> Self {
            self.vpn_port = Some(input);
            self
        }
        pub fn set_vpn_port(mut self, input: std::option::Option<i32>) -> Self {
            self.vpn_port = input;
            self
        }
        pub fn associated_target_networks(
            mut self,
            input: impl Into<crate::model::AssociatedTargetNetwork>,
        ) -> Self {
            let mut v = self.associated_target_networks.unwrap_or_default();
            v.push(input.into());
            self.associated_target_networks = Some(v);
            self
        }
        pub fn set_associated_target_networks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssociatedTargetNetwork>>,
        ) -> Self {
            self.associated_target_networks = input;
            self
        }
        /// <p>The ARN of the server certificate.</p>
        pub fn server_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_certificate_arn = Some(input.into());
            self
        }
        pub fn set_server_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.server_certificate_arn = input;
            self
        }
        pub fn authentication_options(
            mut self,
            input: impl Into<crate::model::ClientVpnAuthentication>,
        ) -> Self {
            let mut v = self.authentication_options.unwrap_or_default();
            v.push(input.into());
            self.authentication_options = Some(v);
            self
        }
        pub fn set_authentication_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClientVpnAuthentication>>,
        ) -> Self {
            self.authentication_options = input;
            self
        }
        /// <p>Information about the client connection logging options for the Client VPN endpoint.</p>
        pub fn connection_log_options(
            mut self,
            input: crate::model::ConnectionLogResponseOptions,
        ) -> Self {
            self.connection_log_options = Some(input);
            self
        }
        pub fn set_connection_log_options(
            mut self,
            input: std::option::Option<crate::model::ConnectionLogResponseOptions>,
        ) -> Self {
            self.connection_log_options = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The URL of the self-service portal.</p>
        pub fn self_service_portal_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.self_service_portal_url = Some(input.into());
            self
        }
        pub fn set_self_service_portal_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.self_service_portal_url = input;
            self
        }
        /// <p>The options for managing connection authorization for new client connections.</p>
        pub fn client_connect_options(
            mut self,
            input: crate::model::ClientConnectResponseOptions,
        ) -> Self {
            self.client_connect_options = Some(input);
            self
        }
        pub fn set_client_connect_options(
            mut self,
            input: std::option::Option<crate::model::ClientConnectResponseOptions>,
        ) -> Self {
            self.client_connect_options = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnEndpoint`](crate::model::ClientVpnEndpoint)
        pub fn build(self) -> crate::model::ClientVpnEndpoint {
            crate::model::ClientVpnEndpoint {
                client_vpn_endpoint_id: self.client_vpn_endpoint_id,
                description: self.description,
                status: self.status,
                creation_time: self.creation_time,
                deletion_time: self.deletion_time,
                dns_name: self.dns_name,
                client_cidr_block: self.client_cidr_block,
                dns_servers: self.dns_servers,
                split_tunnel: self.split_tunnel,
                vpn_protocol: self.vpn_protocol,
                transport_protocol: self.transport_protocol,
                vpn_port: self.vpn_port,
                associated_target_networks: self.associated_target_networks,
                server_certificate_arn: self.server_certificate_arn,
                authentication_options: self.authentication_options,
                connection_log_options: self.connection_log_options,
                tags: self.tags,
                security_group_ids: self.security_group_ids,
                vpc_id: self.vpc_id,
                self_service_portal_url: self.self_service_portal_url,
                client_connect_options: self.client_connect_options,
            }
        }
    }
}
impl ClientVpnEndpoint {
    /// Creates a new builder-style object to manufacture [`ClientVpnEndpoint`](crate::model::ClientVpnEndpoint)
    pub fn builder() -> crate::model::client_vpn_endpoint::Builder {
        crate::model::client_vpn_endpoint::Builder::default()
    }
}

/// <p>The options for managing connection authorization for new client connections.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientConnectResponseOptions {
    /// <p>Indicates whether client connect options are enabled.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.</p>
    pub lambda_function_arn: std::option::Option<std::string::String>,
    /// <p>The status of any updates to the client connect options.</p>
    pub status: std::option::Option<crate::model::ClientVpnEndpointAttributeStatus>,
}
impl std::fmt::Debug for ClientConnectResponseOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientConnectResponseOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("lambda_function_arn", &self.lambda_function_arn);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ClientConnectResponseOptions`](crate::model::ClientConnectResponseOptions)
pub mod client_connect_response_options {
    /// A builder for [`ClientConnectResponseOptions`](crate::model::ClientConnectResponseOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) lambda_function_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ClientVpnEndpointAttributeStatus>,
    }
    impl Builder {
        /// <p>Indicates whether client connect options are enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.</p>
        pub fn lambda_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_function_arn = Some(input.into());
            self
        }
        pub fn set_lambda_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lambda_function_arn = input;
            self
        }
        /// <p>The status of any updates to the client connect options.</p>
        pub fn status(mut self, input: crate::model::ClientVpnEndpointAttributeStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnEndpointAttributeStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientConnectResponseOptions`](crate::model::ClientConnectResponseOptions)
        pub fn build(self) -> crate::model::ClientConnectResponseOptions {
            crate::model::ClientConnectResponseOptions {
                enabled: self.enabled,
                lambda_function_arn: self.lambda_function_arn,
                status: self.status,
            }
        }
    }
}
impl ClientConnectResponseOptions {
    /// Creates a new builder-style object to manufacture [`ClientConnectResponseOptions`](crate::model::ClientConnectResponseOptions)
    pub fn builder() -> crate::model::client_connect_response_options::Builder {
        crate::model::client_connect_response_options::Builder::default()
    }
}

/// <p>Describes the status of the Client VPN endpoint attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnEndpointAttributeStatus {
    /// <p>The status code.</p>
    pub code: std::option::Option<crate::model::ClientVpnEndpointAttributeStatusCode>,
    /// <p>The status message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnEndpointAttributeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnEndpointAttributeStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientVpnEndpointAttributeStatus`](crate::model::ClientVpnEndpointAttributeStatus)
pub mod client_vpn_endpoint_attribute_status {
    /// A builder for [`ClientVpnEndpointAttributeStatus`](crate::model::ClientVpnEndpointAttributeStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ClientVpnEndpointAttributeStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status code.</p>
        pub fn code(mut self, input: crate::model::ClientVpnEndpointAttributeStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientVpnEndpointAttributeStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The status message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnEndpointAttributeStatus`](crate::model::ClientVpnEndpointAttributeStatus)
        pub fn build(self) -> crate::model::ClientVpnEndpointAttributeStatus {
            crate::model::ClientVpnEndpointAttributeStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientVpnEndpointAttributeStatus {
    /// Creates a new builder-style object to manufacture [`ClientVpnEndpointAttributeStatus`](crate::model::ClientVpnEndpointAttributeStatus)
    pub fn builder() -> crate::model::client_vpn_endpoint_attribute_status::Builder {
        crate::model::client_vpn_endpoint_attribute_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnEndpointAttributeStatusCode {
    Applied,
    Applying,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnEndpointAttributeStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "applied" => ClientVpnEndpointAttributeStatusCode::Applied,
            "applying" => ClientVpnEndpointAttributeStatusCode::Applying,
            other => ClientVpnEndpointAttributeStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnEndpointAttributeStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnEndpointAttributeStatusCode::from(s))
    }
}
impl ClientVpnEndpointAttributeStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnEndpointAttributeStatusCode::Applied => "applied",
            ClientVpnEndpointAttributeStatusCode::Applying => "applying",
            ClientVpnEndpointAttributeStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["applied", "applying"]
    }
}
impl AsRef<str> for ClientVpnEndpointAttributeStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the client connection logging options for a Client VPN endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConnectionLogResponseOptions {
    /// <p>Indicates whether client connection logging is enabled for the Client VPN endpoint.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The name of the Amazon CloudWatch Logs log group to which connection logging data is published.</p>
    pub cloudwatch_log_group: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon CloudWatch Logs log stream to which connection logging data is published.</p>
    pub cloudwatch_log_stream: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConnectionLogResponseOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConnectionLogResponseOptions");
        formatter.field("enabled", &self.enabled);
        formatter.field("cloudwatch_log_group", &self.cloudwatch_log_group);
        formatter.field("cloudwatch_log_stream", &self.cloudwatch_log_stream);
        formatter.finish()
    }
}
/// See [`ConnectionLogResponseOptions`](crate::model::ConnectionLogResponseOptions)
pub mod connection_log_response_options {
    /// A builder for [`ConnectionLogResponseOptions`](crate::model::ConnectionLogResponseOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) cloudwatch_log_group: std::option::Option<std::string::String>,
        pub(crate) cloudwatch_log_stream: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether client connection logging is enabled for the Client VPN endpoint.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The name of the Amazon CloudWatch Logs log group to which connection logging data is published.</p>
        pub fn cloudwatch_log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloudwatch_log_group = Some(input.into());
            self
        }
        pub fn set_cloudwatch_log_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloudwatch_log_group = input;
            self
        }
        /// <p>The name of the Amazon CloudWatch Logs log stream to which connection logging data is published.</p>
        pub fn cloudwatch_log_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloudwatch_log_stream = Some(input.into());
            self
        }
        pub fn set_cloudwatch_log_stream(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloudwatch_log_stream = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionLogResponseOptions`](crate::model::ConnectionLogResponseOptions)
        pub fn build(self) -> crate::model::ConnectionLogResponseOptions {
            crate::model::ConnectionLogResponseOptions {
                enabled: self.enabled,
                cloudwatch_log_group: self.cloudwatch_log_group,
                cloudwatch_log_stream: self.cloudwatch_log_stream,
            }
        }
    }
}
impl ConnectionLogResponseOptions {
    /// Creates a new builder-style object to manufacture [`ConnectionLogResponseOptions`](crate::model::ConnectionLogResponseOptions)
    pub fn builder() -> crate::model::connection_log_response_options::Builder {
        crate::model::connection_log_response_options::Builder::default()
    }
}

/// <p>Describes the authentication methods used by a Client VPN endpoint. For more information, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/client-authentication.html">Authentication</a>
/// in the <i>AWS Client VPN Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnAuthentication {
    /// <p>The authentication type used.</p>
    pub r#type: std::option::Option<crate::model::ClientVpnAuthenticationType>,
    /// <p>Information about the Active Directory, if applicable.</p>
    pub active_directory: std::option::Option<crate::model::DirectoryServiceAuthentication>,
    /// <p>Information about the authentication certificates, if applicable.</p>
    pub mutual_authentication: std::option::Option<crate::model::CertificateAuthentication>,
    /// <p>Information about the IAM SAML identity provider, if applicable.</p>
    pub federated_authentication: std::option::Option<crate::model::FederatedAuthentication>,
}
impl std::fmt::Debug for ClientVpnAuthentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnAuthentication");
        formatter.field("r#type", &self.r#type);
        formatter.field("active_directory", &self.active_directory);
        formatter.field("mutual_authentication", &self.mutual_authentication);
        formatter.field("federated_authentication", &self.federated_authentication);
        formatter.finish()
    }
}
/// See [`ClientVpnAuthentication`](crate::model::ClientVpnAuthentication)
pub mod client_vpn_authentication {
    /// A builder for [`ClientVpnAuthentication`](crate::model::ClientVpnAuthentication)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ClientVpnAuthenticationType>,
        pub(crate) active_directory:
            std::option::Option<crate::model::DirectoryServiceAuthentication>,
        pub(crate) mutual_authentication:
            std::option::Option<crate::model::CertificateAuthentication>,
        pub(crate) federated_authentication:
            std::option::Option<crate::model::FederatedAuthentication>,
    }
    impl Builder {
        /// <p>The authentication type used.</p>
        pub fn r#type(mut self, input: crate::model::ClientVpnAuthenticationType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ClientVpnAuthenticationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Information about the Active Directory, if applicable.</p>
        pub fn active_directory(
            mut self,
            input: crate::model::DirectoryServiceAuthentication,
        ) -> Self {
            self.active_directory = Some(input);
            self
        }
        pub fn set_active_directory(
            mut self,
            input: std::option::Option<crate::model::DirectoryServiceAuthentication>,
        ) -> Self {
            self.active_directory = input;
            self
        }
        /// <p>Information about the authentication certificates, if applicable.</p>
        pub fn mutual_authentication(
            mut self,
            input: crate::model::CertificateAuthentication,
        ) -> Self {
            self.mutual_authentication = Some(input);
            self
        }
        pub fn set_mutual_authentication(
            mut self,
            input: std::option::Option<crate::model::CertificateAuthentication>,
        ) -> Self {
            self.mutual_authentication = input;
            self
        }
        /// <p>Information about the IAM SAML identity provider, if applicable.</p>
        pub fn federated_authentication(
            mut self,
            input: crate::model::FederatedAuthentication,
        ) -> Self {
            self.federated_authentication = Some(input);
            self
        }
        pub fn set_federated_authentication(
            mut self,
            input: std::option::Option<crate::model::FederatedAuthentication>,
        ) -> Self {
            self.federated_authentication = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnAuthentication`](crate::model::ClientVpnAuthentication)
        pub fn build(self) -> crate::model::ClientVpnAuthentication {
            crate::model::ClientVpnAuthentication {
                r#type: self.r#type,
                active_directory: self.active_directory,
                mutual_authentication: self.mutual_authentication,
                federated_authentication: self.federated_authentication,
            }
        }
    }
}
impl ClientVpnAuthentication {
    /// Creates a new builder-style object to manufacture [`ClientVpnAuthentication`](crate::model::ClientVpnAuthentication)
    pub fn builder() -> crate::model::client_vpn_authentication::Builder {
        crate::model::client_vpn_authentication::Builder::default()
    }
}

/// <p>Describes the IAM SAML identity providers used for federated authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FederatedAuthentication {
    /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider.</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.</p>
    pub self_service_saml_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FederatedAuthentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FederatedAuthentication");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.field(
            "self_service_saml_provider_arn",
            &self.self_service_saml_provider_arn,
        );
        formatter.finish()
    }
}
/// See [`FederatedAuthentication`](crate::model::FederatedAuthentication)
pub mod federated_authentication {
    /// A builder for [`FederatedAuthentication`](crate::model::FederatedAuthentication)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
        pub(crate) self_service_saml_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider.</p>
        pub fn saml_provider_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(input.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.</p>
        pub fn self_service_saml_provider_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.self_service_saml_provider_arn = Some(input.into());
            self
        }
        pub fn set_self_service_saml_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.self_service_saml_provider_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`FederatedAuthentication`](crate::model::FederatedAuthentication)
        pub fn build(self) -> crate::model::FederatedAuthentication {
            crate::model::FederatedAuthentication {
                saml_provider_arn: self.saml_provider_arn,
                self_service_saml_provider_arn: self.self_service_saml_provider_arn,
            }
        }
    }
}
impl FederatedAuthentication {
    /// Creates a new builder-style object to manufacture [`FederatedAuthentication`](crate::model::FederatedAuthentication)
    pub fn builder() -> crate::model::federated_authentication::Builder {
        crate::model::federated_authentication::Builder::default()
    }
}

/// <p>Information about the client certificate used for authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateAuthentication {
    /// <p>The ARN of the client certificate. </p>
    pub client_root_certificate_chain: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateAuthentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateAuthentication");
        formatter.field(
            "client_root_certificate_chain",
            &self.client_root_certificate_chain,
        );
        formatter.finish()
    }
}
/// See [`CertificateAuthentication`](crate::model::CertificateAuthentication)
pub mod certificate_authentication {
    /// A builder for [`CertificateAuthentication`](crate::model::CertificateAuthentication)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_root_certificate_chain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the client certificate. </p>
        pub fn client_root_certificate_chain(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.client_root_certificate_chain = Some(input.into());
            self
        }
        pub fn set_client_root_certificate_chain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_root_certificate_chain = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateAuthentication`](crate::model::CertificateAuthentication)
        pub fn build(self) -> crate::model::CertificateAuthentication {
            crate::model::CertificateAuthentication {
                client_root_certificate_chain: self.client_root_certificate_chain,
            }
        }
    }
}
impl CertificateAuthentication {
    /// Creates a new builder-style object to manufacture [`CertificateAuthentication`](crate::model::CertificateAuthentication)
    pub fn builder() -> crate::model::certificate_authentication::Builder {
        crate::model::certificate_authentication::Builder::default()
    }
}

/// <p>Describes an Active Directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectoryServiceAuthentication {
    /// <p>The ID of the Active Directory used for authentication.</p>
    pub directory_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectoryServiceAuthentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectoryServiceAuthentication");
        formatter.field("directory_id", &self.directory_id);
        formatter.finish()
    }
}
/// See [`DirectoryServiceAuthentication`](crate::model::DirectoryServiceAuthentication)
pub mod directory_service_authentication {
    /// A builder for [`DirectoryServiceAuthentication`](crate::model::DirectoryServiceAuthentication)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) directory_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Active Directory used for authentication.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryServiceAuthentication`](crate::model::DirectoryServiceAuthentication)
        pub fn build(self) -> crate::model::DirectoryServiceAuthentication {
            crate::model::DirectoryServiceAuthentication {
                directory_id: self.directory_id,
            }
        }
    }
}
impl DirectoryServiceAuthentication {
    /// Creates a new builder-style object to manufacture [`DirectoryServiceAuthentication`](crate::model::DirectoryServiceAuthentication)
    pub fn builder() -> crate::model::directory_service_authentication::Builder {
        crate::model::directory_service_authentication::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnAuthenticationType {
    CertificateAuthentication,
    DirectoryServiceAuthentication,
    FederatedAuthentication,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnAuthenticationType {
    fn from(s: &str) -> Self {
        match s {
            "certificate-authentication" => ClientVpnAuthenticationType::CertificateAuthentication,
            "directory-service-authentication" => {
                ClientVpnAuthenticationType::DirectoryServiceAuthentication
            }
            "federated-authentication" => ClientVpnAuthenticationType::FederatedAuthentication,
            other => ClientVpnAuthenticationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnAuthenticationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnAuthenticationType::from(s))
    }
}
impl ClientVpnAuthenticationType {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnAuthenticationType::CertificateAuthentication => "certificate-authentication",
            ClientVpnAuthenticationType::DirectoryServiceAuthentication => {
                "directory-service-authentication"
            }
            ClientVpnAuthenticationType::FederatedAuthentication => "federated-authentication",
            ClientVpnAuthenticationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "certificate-authentication",
            "directory-service-authentication",
            "federated-authentication",
        ]
    }
}
impl AsRef<str> for ClientVpnAuthenticationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a target network that is associated with a Client VPN endpoint. A target network is a subnet in a VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatedTargetNetwork {
    /// <p>The ID of the subnet.</p>
    pub network_id: std::option::Option<std::string::String>,
    /// <p>The target network type.</p>
    pub network_type: std::option::Option<crate::model::AssociatedNetworkType>,
}
impl std::fmt::Debug for AssociatedTargetNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatedTargetNetwork");
        formatter.field("network_id", &self.network_id);
        formatter.field("network_type", &self.network_type);
        formatter.finish()
    }
}
/// See [`AssociatedTargetNetwork`](crate::model::AssociatedTargetNetwork)
pub mod associated_target_network {
    /// A builder for [`AssociatedTargetNetwork`](crate::model::AssociatedTargetNetwork)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_id: std::option::Option<std::string::String>,
        pub(crate) network_type: std::option::Option<crate::model::AssociatedNetworkType>,
    }
    impl Builder {
        /// <p>The ID of the subnet.</p>
        pub fn network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_id = Some(input.into());
            self
        }
        pub fn set_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.network_id = input;
            self
        }
        /// <p>The target network type.</p>
        pub fn network_type(mut self, input: crate::model::AssociatedNetworkType) -> Self {
            self.network_type = Some(input);
            self
        }
        pub fn set_network_type(
            mut self,
            input: std::option::Option<crate::model::AssociatedNetworkType>,
        ) -> Self {
            self.network_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatedTargetNetwork`](crate::model::AssociatedTargetNetwork)
        pub fn build(self) -> crate::model::AssociatedTargetNetwork {
            crate::model::AssociatedTargetNetwork {
                network_id: self.network_id,
                network_type: self.network_type,
            }
        }
    }
}
impl AssociatedTargetNetwork {
    /// Creates a new builder-style object to manufacture [`AssociatedTargetNetwork`](crate::model::AssociatedTargetNetwork)
    pub fn builder() -> crate::model::associated_target_network::Builder {
        crate::model::associated_target_network::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociatedNetworkType {
    Vpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociatedNetworkType {
    fn from(s: &str) -> Self {
        match s {
            "vpc" => AssociatedNetworkType::Vpc,
            other => AssociatedNetworkType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociatedNetworkType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociatedNetworkType::from(s))
    }
}
impl AssociatedNetworkType {
    pub fn as_str(&self) -> &str {
        match self {
            AssociatedNetworkType::Vpc => "vpc",
            AssociatedNetworkType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["vpc"]
    }
}
impl AsRef<str> for AssociatedNetworkType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransportProtocol {
    Tcp,
    Udp,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransportProtocol {
    fn from(s: &str) -> Self {
        match s {
            "tcp" => TransportProtocol::Tcp,
            "udp" => TransportProtocol::Udp,
            other => TransportProtocol::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransportProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransportProtocol::from(s))
    }
}
impl TransportProtocol {
    pub fn as_str(&self) -> &str {
        match self {
            TransportProtocol::Tcp => "tcp",
            TransportProtocol::Udp => "udp",
            TransportProtocol::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["tcp", "udp"]
    }
}
impl AsRef<str> for TransportProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VpnProtocol {
    Openvpn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VpnProtocol {
    fn from(s: &str) -> Self {
        match s {
            "openvpn" => VpnProtocol::Openvpn,
            other => VpnProtocol::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VpnProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VpnProtocol::from(s))
    }
}
impl VpnProtocol {
    pub fn as_str(&self) -> &str {
        match self {
            VpnProtocol::Openvpn => "openvpn",
            VpnProtocol::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["openvpn"]
    }
}
impl AsRef<str> for VpnProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the state of a Client VPN endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnEndpointStatus {
    /// <p>The state of the Client VPN endpoint. Possible states include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>pending-associate</code> - The Client VPN endpoint has been created but no target networks
    /// have been associated. The Client VPN endpoint cannot accept connections.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>available</code> - The Client VPN endpoint has been created and a target network has been
    /// associated. The Client VPN endpoint can accept connections.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deleting</code> - The Client VPN endpoint is being deleted. The Client VPN endpoint cannot accept
    /// connections.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deleted</code> - The Client VPN endpoint has been deleted. The Client VPN endpoint cannot accept
    /// connections.</p>
    /// </li>
    /// </ul>
    pub code: std::option::Option<crate::model::ClientVpnEndpointStatusCode>,
    /// <p>A message about the status of the Client VPN endpoint.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientVpnEndpointStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnEndpointStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ClientVpnEndpointStatus`](crate::model::ClientVpnEndpointStatus)
pub mod client_vpn_endpoint_status {
    /// A builder for [`ClientVpnEndpointStatus`](crate::model::ClientVpnEndpointStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ClientVpnEndpointStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the Client VPN endpoint. Possible states include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>pending-associate</code> - The Client VPN endpoint has been created but no target networks
        /// have been associated. The Client VPN endpoint cannot accept connections.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available</code> - The Client VPN endpoint has been created and a target network has been
        /// associated. The Client VPN endpoint can accept connections.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleting</code> - The Client VPN endpoint is being deleted. The Client VPN endpoint cannot accept
        /// connections.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleted</code> - The Client VPN endpoint has been deleted. The Client VPN endpoint cannot accept
        /// connections.</p>
        /// </li>
        /// </ul>
        pub fn code(mut self, input: crate::model::ClientVpnEndpointStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ClientVpnEndpointStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>A message about the status of the Client VPN endpoint.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnEndpointStatus`](crate::model::ClientVpnEndpointStatus)
        pub fn build(self) -> crate::model::ClientVpnEndpointStatus {
            crate::model::ClientVpnEndpointStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ClientVpnEndpointStatus {
    /// Creates a new builder-style object to manufacture [`ClientVpnEndpointStatus`](crate::model::ClientVpnEndpointStatus)
    pub fn builder() -> crate::model::client_vpn_endpoint_status::Builder {
        crate::model::client_vpn_endpoint_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientVpnEndpointStatusCode {
    Available,
    Deleted,
    Deleting,
    PendingAssociate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientVpnEndpointStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "available" => ClientVpnEndpointStatusCode::Available,
            "deleted" => ClientVpnEndpointStatusCode::Deleted,
            "deleting" => ClientVpnEndpointStatusCode::Deleting,
            "pending-associate" => ClientVpnEndpointStatusCode::PendingAssociate,
            other => ClientVpnEndpointStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientVpnEndpointStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientVpnEndpointStatusCode::from(s))
    }
}
impl ClientVpnEndpointStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ClientVpnEndpointStatusCode::Available => "available",
            ClientVpnEndpointStatusCode::Deleted => "deleted",
            ClientVpnEndpointStatusCode::Deleting => "deleting",
            ClientVpnEndpointStatusCode::PendingAssociate => "pending-associate",
            ClientVpnEndpointStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending-associate"]
    }
}
impl AsRef<str> for ClientVpnEndpointStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a client connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnConnection {
    /// <p>The ID of the Client VPN endpoint to which the client is connected.</p>
    pub client_vpn_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The current date and time.</p>
    pub timestamp: std::option::Option<std::string::String>,
    /// <p>The ID of the client connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The username of the client who established the client connection. This information is only provided
    /// if Active Directory client authentication is used.</p>
    pub username: std::option::Option<std::string::String>,
    /// <p>The date and time the client connection was established.</p>
    pub connection_established_time: std::option::Option<std::string::String>,
    /// <p>The number of bytes sent by the client.</p>
    pub ingress_bytes: std::option::Option<std::string::String>,
    /// <p>The number of bytes received by the client.</p>
    pub egress_bytes: std::option::Option<std::string::String>,
    /// <p>The number of packets sent by the client.</p>
    pub ingress_packets: std::option::Option<std::string::String>,
    /// <p>The number of packets received by the client.</p>
    pub egress_packets: std::option::Option<std::string::String>,
    /// <p>The IP address of the client.</p>
    pub client_ip: std::option::Option<std::string::String>,
    /// <p>The common name associated with the client. This is either the name of the client certificate,
    /// or the Active Directory user name.</p>
    pub common_name: std::option::Option<std::string::String>,
    /// <p>The current state of the client connection.</p>
    pub status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
    /// <p>The date and time the client connection was terminated.</p>
    pub connection_end_time: std::option::Option<std::string::String>,
    /// <p>The statuses returned by the client connect handler for posture compliance, if applicable.</p>
    pub posture_compliance_statuses: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ClientVpnConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnConnection");
        formatter.field("client_vpn_endpoint_id", &self.client_vpn_endpoint_id);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("connection_id", &self.connection_id);
        formatter.field("username", &self.username);
        formatter.field(
            "connection_established_time",
            &self.connection_established_time,
        );
        formatter.field("ingress_bytes", &self.ingress_bytes);
        formatter.field("egress_bytes", &self.egress_bytes);
        formatter.field("ingress_packets", &self.ingress_packets);
        formatter.field("egress_packets", &self.egress_packets);
        formatter.field("client_ip", &self.client_ip);
        formatter.field("common_name", &self.common_name);
        formatter.field("status", &self.status);
        formatter.field("connection_end_time", &self.connection_end_time);
        formatter.field(
            "posture_compliance_statuses",
            &self.posture_compliance_statuses,
        );
        formatter.finish()
    }
}
/// See [`ClientVpnConnection`](crate::model::ClientVpnConnection)
pub mod client_vpn_connection {
    /// A builder for [`ClientVpnConnection`](crate::model::ClientVpnConnection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_vpn_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<std::string::String>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) connection_established_time: std::option::Option<std::string::String>,
        pub(crate) ingress_bytes: std::option::Option<std::string::String>,
        pub(crate) egress_bytes: std::option::Option<std::string::String>,
        pub(crate) ingress_packets: std::option::Option<std::string::String>,
        pub(crate) egress_packets: std::option::Option<std::string::String>,
        pub(crate) client_ip: std::option::Option<std::string::String>,
        pub(crate) common_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ClientVpnConnectionStatus>,
        pub(crate) connection_end_time: std::option::Option<std::string::String>,
        pub(crate) posture_compliance_statuses:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the Client VPN endpoint to which the client is connected.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpn_endpoint_id = Some(input.into());
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpn_endpoint_id = input;
            self
        }
        /// <p>The current date and time.</p>
        pub fn timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp = Some(input.into());
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The ID of the client connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The username of the client who established the client connection. This information is only provided
        /// if Active Directory client authentication is used.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>The date and time the client connection was established.</p>
        pub fn connection_established_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.connection_established_time = Some(input.into());
            self
        }
        pub fn set_connection_established_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_established_time = input;
            self
        }
        /// <p>The number of bytes sent by the client.</p>
        pub fn ingress_bytes(mut self, input: impl Into<std::string::String>) -> Self {
            self.ingress_bytes = Some(input.into());
            self
        }
        pub fn set_ingress_bytes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ingress_bytes = input;
            self
        }
        /// <p>The number of bytes received by the client.</p>
        pub fn egress_bytes(mut self, input: impl Into<std::string::String>) -> Self {
            self.egress_bytes = Some(input.into());
            self
        }
        pub fn set_egress_bytes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.egress_bytes = input;
            self
        }
        /// <p>The number of packets sent by the client.</p>
        pub fn ingress_packets(mut self, input: impl Into<std::string::String>) -> Self {
            self.ingress_packets = Some(input.into());
            self
        }
        pub fn set_ingress_packets(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ingress_packets = input;
            self
        }
        /// <p>The number of packets received by the client.</p>
        pub fn egress_packets(mut self, input: impl Into<std::string::String>) -> Self {
            self.egress_packets = Some(input.into());
            self
        }
        pub fn set_egress_packets(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.egress_packets = input;
            self
        }
        /// <p>The IP address of the client.</p>
        pub fn client_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_ip = Some(input.into());
            self
        }
        pub fn set_client_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_ip = input;
            self
        }
        /// <p>The common name associated with the client. This is either the name of the client certificate,
        /// or the Active Directory user name.</p>
        pub fn common_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.common_name = Some(input.into());
            self
        }
        pub fn set_common_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.common_name = input;
            self
        }
        /// <p>The current state of the client connection.</p>
        pub fn status(mut self, input: crate::model::ClientVpnConnectionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnConnectionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time the client connection was terminated.</p>
        pub fn connection_end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_end_time = Some(input.into());
            self
        }
        pub fn set_connection_end_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_end_time = input;
            self
        }
        pub fn posture_compliance_statuses(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.posture_compliance_statuses.unwrap_or_default();
            v.push(input.into());
            self.posture_compliance_statuses = Some(v);
            self
        }
        pub fn set_posture_compliance_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.posture_compliance_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnConnection`](crate::model::ClientVpnConnection)
        pub fn build(self) -> crate::model::ClientVpnConnection {
            crate::model::ClientVpnConnection {
                client_vpn_endpoint_id: self.client_vpn_endpoint_id,
                timestamp: self.timestamp,
                connection_id: self.connection_id,
                username: self.username,
                connection_established_time: self.connection_established_time,
                ingress_bytes: self.ingress_bytes,
                egress_bytes: self.egress_bytes,
                ingress_packets: self.ingress_packets,
                egress_packets: self.egress_packets,
                client_ip: self.client_ip,
                common_name: self.common_name,
                status: self.status,
                connection_end_time: self.connection_end_time,
                posture_compliance_statuses: self.posture_compliance_statuses,
            }
        }
    }
}
impl ClientVpnConnection {
    /// Creates a new builder-style object to manufacture [`ClientVpnConnection`](crate::model::ClientVpnConnection)
    pub fn builder() -> crate::model::client_vpn_connection::Builder {
        crate::model::client_vpn_connection::Builder::default()
    }
}

/// <p>Information about an authorization rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationRule {
    /// <p>The ID of the Client VPN endpoint with which the authorization rule is associated.</p>
    pub client_vpn_endpoint_id: std::option::Option<std::string::String>,
    /// <p>A brief description of the authorization rule.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the Active Directory group to which the authorization rule grants access.</p>
    pub group_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the authorization rule grants access to all clients.</p>
    pub access_all: std::option::Option<bool>,
    /// <p>The IPv4 address range, in CIDR notation, of the network to which the authorization rule applies.</p>
    pub destination_cidr: std::option::Option<std::string::String>,
    /// <p>The current state of the authorization rule.</p>
    pub status: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatus>,
}
impl std::fmt::Debug for AuthorizationRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationRule");
        formatter.field("client_vpn_endpoint_id", &self.client_vpn_endpoint_id);
        formatter.field("description", &self.description);
        formatter.field("group_id", &self.group_id);
        formatter.field("access_all", &self.access_all);
        formatter.field("destination_cidr", &self.destination_cidr);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`AuthorizationRule`](crate::model::AuthorizationRule)
pub mod authorization_rule {
    /// A builder for [`AuthorizationRule`](crate::model::AuthorizationRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_vpn_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) access_all: std::option::Option<bool>,
        pub(crate) destination_cidr: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatus>,
    }
    impl Builder {
        /// <p>The ID of the Client VPN endpoint with which the authorization rule is associated.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpn_endpoint_id = Some(input.into());
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpn_endpoint_id = input;
            self
        }
        /// <p>A brief description of the authorization rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the Active Directory group to which the authorization rule grants access.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>Indicates whether the authorization rule grants access to all clients.</p>
        pub fn access_all(mut self, input: bool) -> Self {
            self.access_all = Some(input);
            self
        }
        pub fn set_access_all(mut self, input: std::option::Option<bool>) -> Self {
            self.access_all = input;
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the network to which the authorization rule applies.</p>
        pub fn destination_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr = Some(input.into());
            self
        }
        pub fn set_destination_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_cidr = input;
            self
        }
        /// <p>The current state of the authorization rule.</p>
        pub fn status(mut self, input: crate::model::ClientVpnAuthorizationRuleStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ClientVpnAuthorizationRuleStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationRule`](crate::model::AuthorizationRule)
        pub fn build(self) -> crate::model::AuthorizationRule {
            crate::model::AuthorizationRule {
                client_vpn_endpoint_id: self.client_vpn_endpoint_id,
                description: self.description,
                group_id: self.group_id,
                access_all: self.access_all,
                destination_cidr: self.destination_cidr,
                status: self.status,
            }
        }
    }
}
impl AuthorizationRule {
    /// Creates a new builder-style object to manufacture [`AuthorizationRule`](crate::model::AuthorizationRule)
    pub fn builder() -> crate::model::authorization_rule::Builder {
        crate::model::authorization_rule::Builder::default()
    }
}

/// <p>Describes a linked EC2-Classic instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassicLinkInstance {
    /// <p>A list of security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the instance.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of the VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClassicLinkInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassicLinkInstance");
        formatter.field("groups", &self.groups);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("tags", &self.tags);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.finish()
    }
}
/// See [`ClassicLinkInstance`](crate::model::ClassicLinkInstance)
pub mod classic_link_instance {
    /// A builder for [`ClassicLinkInstance`](crate::model::ClassicLinkInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn groups(mut self, input: impl Into<crate::model::GroupIdentifier>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupIdentifier>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassicLinkInstance`](crate::model::ClassicLinkInstance)
        pub fn build(self) -> crate::model::ClassicLinkInstance {
            crate::model::ClassicLinkInstance {
                groups: self.groups,
                instance_id: self.instance_id,
                tags: self.tags,
                vpc_id: self.vpc_id,
            }
        }
    }
}
impl ClassicLinkInstance {
    /// Creates a new builder-style object to manufacture [`ClassicLinkInstance`](crate::model::ClassicLinkInstance)
    pub fn builder() -> crate::model::classic_link_instance::Builder {
        crate::model::classic_link_instance::Builder::default()
    }
}

/// <p>Describes a carrier gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CarrierGateway {
    /// <p>The ID of the carrier gateway.</p>
    pub carrier_gateway_id: std::option::Option<std::string::String>,
    /// <p>The ID of the VPC associated with the carrier gateway.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The state of the carrier gateway.</p>
    pub state: std::option::Option<crate::model::CarrierGatewayState>,
    /// <p>The Amazon Web Services account ID of the owner of the carrier gateway.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The tags assigned to the carrier gateway.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CarrierGateway {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CarrierGateway");
        formatter.field("carrier_gateway_id", &self.carrier_gateway_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("state", &self.state);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`CarrierGateway`](crate::model::CarrierGateway)
pub mod carrier_gateway {
    /// A builder for [`CarrierGateway`](crate::model::CarrierGateway)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) carrier_gateway_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CarrierGatewayState>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the carrier gateway.</p>
        pub fn carrier_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier_gateway_id = Some(input.into());
            self
        }
        pub fn set_carrier_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.carrier_gateway_id = input;
            self
        }
        /// <p>The ID of the VPC associated with the carrier gateway.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The state of the carrier gateway.</p>
        pub fn state(mut self, input: crate::model::CarrierGatewayState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CarrierGatewayState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the carrier gateway.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CarrierGateway`](crate::model::CarrierGateway)
        pub fn build(self) -> crate::model::CarrierGateway {
            crate::model::CarrierGateway {
                carrier_gateway_id: self.carrier_gateway_id,
                vpc_id: self.vpc_id,
                state: self.state,
                owner_id: self.owner_id,
                tags: self.tags,
            }
        }
    }
}
impl CarrierGateway {
    /// Creates a new builder-style object to manufacture [`CarrierGateway`](crate::model::CarrierGateway)
    pub fn builder() -> crate::model::carrier_gateway::Builder {
        crate::model::carrier_gateway::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CarrierGatewayState {
    Available,
    Deleted,
    Deleting,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CarrierGatewayState {
    fn from(s: &str) -> Self {
        match s {
            "available" => CarrierGatewayState::Available,
            "deleted" => CarrierGatewayState::Deleted,
            "deleting" => CarrierGatewayState::Deleting,
            "pending" => CarrierGatewayState::Pending,
            other => CarrierGatewayState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CarrierGatewayState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CarrierGatewayState::from(s))
    }
}
impl CarrierGatewayState {
    pub fn as_str(&self) -> &str {
        match self {
            CarrierGatewayState::Available => "available",
            CarrierGatewayState::Deleted => "deleted",
            CarrierGatewayState::Deleting => "deleting",
            CarrierGatewayState::Pending => "pending",
            CarrierGatewayState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "deleted", "deleting", "pending"]
    }
}
impl AsRef<str> for CarrierGatewayState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Capacity Reservation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservation {
    /// <p>The ID of the Capacity Reservation.</p>
    pub capacity_reservation_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the Capacity Reservation.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Capacity Reservation.</p>
    pub capacity_reservation_arn: std::option::Option<std::string::String>,
    /// <p>The Availability Zone ID of the Capacity Reservation.</p>
    pub availability_zone_id: std::option::Option<std::string::String>,
    /// <p>The type of instance for which the Capacity Reservation reserves capacity.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The type of operating system for which the Capacity Reservation reserves capacity.</p>
    pub instance_platform: std::option::Option<crate::model::CapacityReservationInstancePlatform>,
    /// <p>The Availability Zone in which the capacity is reserved.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>default</code> - The Capacity Reservation is created on hardware that is shared with other Amazon Web Services accounts.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single Amazon Web Services account.</p>
    /// </li>
    /// </ul>
    pub tenancy: std::option::Option<crate::model::CapacityReservationTenancy>,
    /// <p>The total number of instances for which the Capacity Reservation reserves capacity.</p>
    pub total_instance_count: std::option::Option<i32>,
    /// <p>The remaining capacity. Indicates the number of instances that can be launched in the Capacity Reservation.</p>
    pub available_instance_count: std::option::Option<i32>,
    /// <p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides
    /// dedicated throughput to Amazon EBS and an optimized configuration stack to provide
    /// optimal I/O performance. This optimization isn't available with all instance types.
    /// Additional usage charges apply when using an EBS- optimized instance.</p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>Indicates whether the Capacity Reservation supports instances with temporary, block-level
    /// storage.</p>
    pub ephemeral_storage: std::option::Option<bool>,
    /// <p>The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>active</code> - The Capacity Reservation is active and the capacity is available for your use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>expired</code> - The Capacity Reservation expired automatically at the date and time specified
    /// in your request. The reserved capacity is no longer available for your use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cancelled</code> - The Capacity Reservation was cancelled. The reserved capacity is no
    /// longer available for your use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>pending</code> - The Capacity Reservation request was successful but the capacity
    /// provisioning is still pending.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>failed</code> - The Capacity Reservation request has failed. A request might fail
    /// due to invalid request parameters, capacity constraints, or instance limit constraints.
    /// Failed requests are retained for 60 minutes.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<crate::model::CapacityReservationState>,
    /// <p>The date and time at which the Capacity Reservation was started.</p>
    pub start_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity
    /// is released and you can no longer launch instances into it. The Capacity Reservation's state changes to
    /// <code>expired</code> when it reaches its end date and time.</p>
    pub end_date: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end
    /// types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time.</p>
    /// </li>
    /// </ul>
    pub end_date_type: std::option::Option<crate::model::EndDateType>,
    /// <p>Indicates the type of instance launches that the Capacity Reservation accepts. The options
    /// include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>open</code> - The Capacity Reservation accepts all instances that have matching attributes (instance type, platform,
    /// and Availability Zone). Instances that have matching attributes launch into the Capacity Reservation automatically without specifying
    /// any additional parameters.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes
    /// (instance type, platform, and Availability Zone), and explicitly target the
    /// Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p>
    /// </li>
    /// </ul>
    pub instance_match_criteria: std::option::Option<crate::model::InstanceMatchCriteria>,
    /// <p>The date and time at which the Capacity Reservation was created.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>Any tags assigned to the Capacity Reservation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Amazon Resource Name (ARN) of the Outpost on which the Capacity
    /// Reservation was created.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CapacityReservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservation");
        formatter.field("capacity_reservation_id", &self.capacity_reservation_id);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("capacity_reservation_arn", &self.capacity_reservation_arn);
        formatter.field("availability_zone_id", &self.availability_zone_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_platform", &self.instance_platform);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("tenancy", &self.tenancy);
        formatter.field("total_instance_count", &self.total_instance_count);
        formatter.field("available_instance_count", &self.available_instance_count);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("ephemeral_storage", &self.ephemeral_storage);
        formatter.field("state", &self.state);
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("end_date_type", &self.end_date_type);
        formatter.field("instance_match_criteria", &self.instance_match_criteria);
        formatter.field("create_date", &self.create_date);
        formatter.field("tags", &self.tags);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.finish()
    }
}
/// See [`CapacityReservation`](crate::model::CapacityReservation)
pub mod capacity_reservation {
    /// A builder for [`CapacityReservation`](crate::model::CapacityReservation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_id: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) capacity_reservation_arn: std::option::Option<std::string::String>,
        pub(crate) availability_zone_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) instance_platform:
            std::option::Option<crate::model::CapacityReservationInstancePlatform>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<crate::model::CapacityReservationTenancy>,
        pub(crate) total_instance_count: std::option::Option<i32>,
        pub(crate) available_instance_count: std::option::Option<i32>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) ephemeral_storage: std::option::Option<bool>,
        pub(crate) state: std::option::Option<crate::model::CapacityReservationState>,
        pub(crate) start_date: std::option::Option<smithy_types::Instant>,
        pub(crate) end_date: std::option::Option<smithy_types::Instant>,
        pub(crate) end_date_type: std::option::Option<crate::model::EndDateType>,
        pub(crate) instance_match_criteria:
            std::option::Option<crate::model::InstanceMatchCriteria>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_reservation_id = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the Capacity Reservation.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Capacity Reservation.</p>
        pub fn capacity_reservation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_reservation_arn = Some(input.into());
            self
        }
        pub fn set_capacity_reservation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_reservation_arn = input;
            self
        }
        /// <p>The Availability Zone ID of the Capacity Reservation.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone_id = Some(input.into());
            self
        }
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_id = input;
            self
        }
        /// <p>The type of instance for which the Capacity Reservation reserves capacity.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The type of operating system for which the Capacity Reservation reserves capacity.</p>
        pub fn instance_platform(
            mut self,
            input: crate::model::CapacityReservationInstancePlatform,
        ) -> Self {
            self.instance_platform = Some(input);
            self
        }
        pub fn set_instance_platform(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationInstancePlatform>,
        ) -> Self {
            self.instance_platform = input;
            self
        }
        /// <p>The Availability Zone in which the capacity is reserved.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>default</code> - The Capacity Reservation is created on hardware that is shared with other Amazon Web Services accounts.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single Amazon Web Services account.</p>
        /// </li>
        /// </ul>
        pub fn tenancy(mut self, input: crate::model::CapacityReservationTenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        pub fn set_tenancy(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTenancy>,
        ) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>The total number of instances for which the Capacity Reservation reserves capacity.</p>
        pub fn total_instance_count(mut self, input: i32) -> Self {
            self.total_instance_count = Some(input);
            self
        }
        pub fn set_total_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_instance_count = input;
            self
        }
        /// <p>The remaining capacity. Indicates the number of instances that can be launched in the Capacity Reservation.</p>
        pub fn available_instance_count(mut self, input: i32) -> Self {
            self.available_instance_count = Some(input);
            self
        }
        pub fn set_available_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.available_instance_count = input;
            self
        }
        /// <p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides
        /// dedicated throughput to Amazon EBS and an optimized configuration stack to provide
        /// optimal I/O performance. This optimization isn't available with all instance types.
        /// Additional usage charges apply when using an EBS- optimized instance.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>Indicates whether the Capacity Reservation supports instances with temporary, block-level
        /// storage.</p>
        pub fn ephemeral_storage(mut self, input: bool) -> Self {
            self.ephemeral_storage = Some(input);
            self
        }
        pub fn set_ephemeral_storage(mut self, input: std::option::Option<bool>) -> Self {
            self.ephemeral_storage = input;
            self
        }
        /// <p>The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>active</code> - The Capacity Reservation is active and the capacity is available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>expired</code> - The Capacity Reservation expired automatically at the date and time specified
        /// in your request. The reserved capacity is no longer available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelled</code> - The Capacity Reservation was cancelled. The reserved capacity is no
        /// longer available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pending</code> - The Capacity Reservation request was successful but the capacity
        /// provisioning is still pending.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed</code> - The Capacity Reservation request has failed. A request might fail
        /// due to invalid request parameters, capacity constraints, or instance limit constraints.
        /// Failed requests are retained for 60 minutes.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::CapacityReservationState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time at which the Capacity Reservation was started.</p>
        pub fn start_date(mut self, input: smithy_types::Instant) -> Self {
            self.start_date = Some(input);
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity
        /// is released and you can no longer launch instances into it. The Capacity Reservation's state changes to
        /// <code>expired</code> when it reaches its end date and time.</p>
        pub fn end_date(mut self, input: smithy_types::Instant) -> Self {
            self.end_date = Some(input);
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_date = input;
            self
        }
        /// <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end
        /// types:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time.</p>
        /// </li>
        /// </ul>
        pub fn end_date_type(mut self, input: crate::model::EndDateType) -> Self {
            self.end_date_type = Some(input);
            self
        }
        pub fn set_end_date_type(
            mut self,
            input: std::option::Option<crate::model::EndDateType>,
        ) -> Self {
            self.end_date_type = input;
            self
        }
        /// <p>Indicates the type of instance launches that the Capacity Reservation accepts. The options
        /// include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The Capacity Reservation accepts all instances that have matching attributes (instance type, platform,
        /// and Availability Zone). Instances that have matching attributes launch into the Capacity Reservation automatically without specifying
        /// any additional parameters.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes
        /// (instance type, platform, and Availability Zone), and explicitly target the
        /// Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p>
        /// </li>
        /// </ul>
        pub fn instance_match_criteria(
            mut self,
            input: crate::model::InstanceMatchCriteria,
        ) -> Self {
            self.instance_match_criteria = Some(input);
            self
        }
        pub fn set_instance_match_criteria(
            mut self,
            input: std::option::Option<crate::model::InstanceMatchCriteria>,
        ) -> Self {
            self.instance_match_criteria = input;
            self
        }
        /// <p>The date and time at which the Capacity Reservation was created.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost on which the Capacity
        /// Reservation was created.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservation`](crate::model::CapacityReservation)
        pub fn build(self) -> crate::model::CapacityReservation {
            crate::model::CapacityReservation {
                capacity_reservation_id: self.capacity_reservation_id,
                owner_id: self.owner_id,
                capacity_reservation_arn: self.capacity_reservation_arn,
                availability_zone_id: self.availability_zone_id,
                instance_type: self.instance_type,
                instance_platform: self.instance_platform,
                availability_zone: self.availability_zone,
                tenancy: self.tenancy,
                total_instance_count: self.total_instance_count,
                available_instance_count: self.available_instance_count,
                ebs_optimized: self.ebs_optimized,
                ephemeral_storage: self.ephemeral_storage,
                state: self.state,
                start_date: self.start_date,
                end_date: self.end_date,
                end_date_type: self.end_date_type,
                instance_match_criteria: self.instance_match_criteria,
                create_date: self.create_date,
                tags: self.tags,
                outpost_arn: self.outpost_arn,
            }
        }
    }
}
impl CapacityReservation {
    /// Creates a new builder-style object to manufacture [`CapacityReservation`](crate::model::CapacityReservation)
    pub fn builder() -> crate::model::capacity_reservation::Builder {
        crate::model::capacity_reservation::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMatchCriteria {
    Open,
    Targeted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMatchCriteria {
    fn from(s: &str) -> Self {
        match s {
            "open" => InstanceMatchCriteria::Open,
            "targeted" => InstanceMatchCriteria::Targeted,
            other => InstanceMatchCriteria::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMatchCriteria {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMatchCriteria::from(s))
    }
}
impl InstanceMatchCriteria {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMatchCriteria::Open => "open",
            InstanceMatchCriteria::Targeted => "targeted",
            InstanceMatchCriteria::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["open", "targeted"]
    }
}
impl AsRef<str> for InstanceMatchCriteria {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacityReservationTenancy {
    Dedicated,
    Default,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacityReservationTenancy {
    fn from(s: &str) -> Self {
        match s {
            "dedicated" => CapacityReservationTenancy::Dedicated,
            "default" => CapacityReservationTenancy::Default,
            other => CapacityReservationTenancy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacityReservationTenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacityReservationTenancy::from(s))
    }
}
impl CapacityReservationTenancy {
    pub fn as_str(&self) -> &str {
        match self {
            CapacityReservationTenancy::Dedicated => "dedicated",
            CapacityReservationTenancy::Default => "default",
            CapacityReservationTenancy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["dedicated", "default"]
    }
}
impl AsRef<str> for CapacityReservationTenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacityReservationInstancePlatform {
    LinuxWithSqlServerEnterprise,
    LinuxWithSqlServerStandard,
    LinuxWithSqlServerWeb,
    LinuxUnix,
    RedHatEnterpriseLinux,
    SuseLinux,
    Windows,
    WindowsWithSqlServer,
    WindowsWithSqlServerEnterprise,
    WindowsWithSqlServerStandard,
    WindowsWithSqlServerWeb,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacityReservationInstancePlatform {
    fn from(s: &str) -> Self {
        match s {
            "Linux with SQL Server Enterprise" => {
                CapacityReservationInstancePlatform::LinuxWithSqlServerEnterprise
            }
            "Linux with SQL Server Standard" => {
                CapacityReservationInstancePlatform::LinuxWithSqlServerStandard
            }
            "Linux with SQL Server Web" => {
                CapacityReservationInstancePlatform::LinuxWithSqlServerWeb
            }
            "Linux/UNIX" => CapacityReservationInstancePlatform::LinuxUnix,
            "Red Hat Enterprise Linux" => {
                CapacityReservationInstancePlatform::RedHatEnterpriseLinux
            }
            "SUSE Linux" => CapacityReservationInstancePlatform::SuseLinux,
            "Windows" => CapacityReservationInstancePlatform::Windows,
            "Windows with SQL Server" => CapacityReservationInstancePlatform::WindowsWithSqlServer,
            "Windows with SQL Server Enterprise" => {
                CapacityReservationInstancePlatform::WindowsWithSqlServerEnterprise
            }
            "Windows with SQL Server Standard" => {
                CapacityReservationInstancePlatform::WindowsWithSqlServerStandard
            }
            "Windows with SQL Server Web" => {
                CapacityReservationInstancePlatform::WindowsWithSqlServerWeb
            }
            other => CapacityReservationInstancePlatform::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacityReservationInstancePlatform {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacityReservationInstancePlatform::from(s))
    }
}
impl CapacityReservationInstancePlatform {
    pub fn as_str(&self) -> &str {
        match self {
            CapacityReservationInstancePlatform::LinuxWithSqlServerEnterprise => {
                "Linux with SQL Server Enterprise"
            }
            CapacityReservationInstancePlatform::LinuxWithSqlServerStandard => {
                "Linux with SQL Server Standard"
            }
            CapacityReservationInstancePlatform::LinuxWithSqlServerWeb => {
                "Linux with SQL Server Web"
            }
            CapacityReservationInstancePlatform::LinuxUnix => "Linux/UNIX",
            CapacityReservationInstancePlatform::RedHatEnterpriseLinux => {
                "Red Hat Enterprise Linux"
            }
            CapacityReservationInstancePlatform::SuseLinux => "SUSE Linux",
            CapacityReservationInstancePlatform::Windows => "Windows",
            CapacityReservationInstancePlatform::WindowsWithSqlServer => "Windows with SQL Server",
            CapacityReservationInstancePlatform::WindowsWithSqlServerEnterprise => {
                "Windows with SQL Server Enterprise"
            }
            CapacityReservationInstancePlatform::WindowsWithSqlServerStandard => {
                "Windows with SQL Server Standard"
            }
            CapacityReservationInstancePlatform::WindowsWithSqlServerWeb => {
                "Windows with SQL Server Web"
            }
            CapacityReservationInstancePlatform::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Linux with SQL Server Enterprise",
            "Linux with SQL Server Standard",
            "Linux with SQL Server Web",
            "Linux/UNIX",
            "Red Hat Enterprise Linux",
            "SUSE Linux",
            "Windows",
            "Windows with SQL Server",
            "Windows with SQL Server Enterprise",
            "Windows with SQL Server Standard",
            "Windows with SQL Server Web",
        ]
    }
}
impl AsRef<str> for CapacityReservationInstancePlatform {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a bundle task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BundleTask {
    /// <p>The ID of the bundle task.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>If the task fails, a description of the error.</p>
    pub bundle_task_error: std::option::Option<crate::model::BundleTaskError>,
    /// <p>The ID of the instance associated with this bundle task.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The level of task completion, as a percent (for example, 20%).</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>The time this task started.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The state of the task.</p>
    pub state: std::option::Option<crate::model::BundleTaskState>,
    /// <p>The Amazon S3 storage locations.</p>
    pub storage: std::option::Option<crate::model::Storage>,
    /// <p>The time of the most recent update for the task.</p>
    pub update_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for BundleTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BundleTask");
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("bundle_task_error", &self.bundle_task_error);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("progress", &self.progress);
        formatter.field("start_time", &self.start_time);
        formatter.field("state", &self.state);
        formatter.field("storage", &self.storage);
        formatter.field("update_time", &self.update_time);
        formatter.finish()
    }
}
/// See [`BundleTask`](crate::model::BundleTask)
pub mod bundle_task {
    /// A builder for [`BundleTask`](crate::model::BundleTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) bundle_task_error: std::option::Option<crate::model::BundleTaskError>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) state: std::option::Option<crate::model::BundleTaskState>,
        pub(crate) storage: std::option::Option<crate::model::Storage>,
        pub(crate) update_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the bundle task.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>If the task fails, a description of the error.</p>
        pub fn bundle_task_error(mut self, input: crate::model::BundleTaskError) -> Self {
            self.bundle_task_error = Some(input);
            self
        }
        pub fn set_bundle_task_error(
            mut self,
            input: std::option::Option<crate::model::BundleTaskError>,
        ) -> Self {
            self.bundle_task_error = input;
            self
        }
        /// <p>The ID of the instance associated with this bundle task.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The level of task completion, as a percent (for example, 20%).</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The time this task started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The state of the task.</p>
        pub fn state(mut self, input: crate::model::BundleTaskState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::BundleTaskState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The Amazon S3 storage locations.</p>
        pub fn storage(mut self, input: crate::model::Storage) -> Self {
            self.storage = Some(input);
            self
        }
        pub fn set_storage(mut self, input: std::option::Option<crate::model::Storage>) -> Self {
            self.storage = input;
            self
        }
        /// <p>The time of the most recent update for the task.</p>
        pub fn update_time(mut self, input: smithy_types::Instant) -> Self {
            self.update_time = Some(input);
            self
        }
        pub fn set_update_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.update_time = input;
            self
        }
        /// Consumes the builder and constructs a [`BundleTask`](crate::model::BundleTask)
        pub fn build(self) -> crate::model::BundleTask {
            crate::model::BundleTask {
                bundle_id: self.bundle_id,
                bundle_task_error: self.bundle_task_error,
                instance_id: self.instance_id,
                progress: self.progress,
                start_time: self.start_time,
                state: self.state,
                storage: self.storage,
                update_time: self.update_time,
            }
        }
    }
}
impl BundleTask {
    /// Creates a new builder-style object to manufacture [`BundleTask`](crate::model::BundleTask)
    pub fn builder() -> crate::model::bundle_task::Builder {
        crate::model::bundle_task::Builder::default()
    }
}

/// <p>Describes the storage location for an instance store-backed AMI.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Storage {
    /// <p>An Amazon S3 storage location.</p>
    pub s3: std::option::Option<crate::model::S3Storage>,
}
impl std::fmt::Debug for Storage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Storage");
        formatter.field("s3", &self.s3);
        formatter.finish()
    }
}
/// See [`Storage`](crate::model::Storage)
pub mod storage {
    /// A builder for [`Storage`](crate::model::Storage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3: std::option::Option<crate::model::S3Storage>,
    }
    impl Builder {
        /// <p>An Amazon S3 storage location.</p>
        pub fn s3(mut self, input: crate::model::S3Storage) -> Self {
            self.s3 = Some(input);
            self
        }
        pub fn set_s3(mut self, input: std::option::Option<crate::model::S3Storage>) -> Self {
            self.s3 = input;
            self
        }
        /// Consumes the builder and constructs a [`Storage`](crate::model::Storage)
        pub fn build(self) -> crate::model::Storage {
            crate::model::Storage { s3: self.s3 }
        }
    }
}
impl Storage {
    /// Creates a new builder-style object to manufacture [`Storage`](crate::model::Storage)
    pub fn builder() -> crate::model::storage::Builder {
        crate::model::storage::Builder::default()
    }
}

/// <p>Describes the storage parameters for Amazon S3 and Amazon S3 buckets for an instance store-backed AMI.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3Storage {
    /// <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance  
    /// in <a href="https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing Amazon Web Services Access Keys</a>.</p>
    pub aws_access_key_id: std::option::Option<std::string::String>,
    /// <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The beginning of the file name of the AMI.</p>
    pub prefix: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
    pub upload_policy: std::option::Option<smithy_types::Blob>,
    /// <p>The signature of the JSON document.</p>
    pub upload_policy_signature: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3Storage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3Storage");
        formatter.field("aws_access_key_id", &self.aws_access_key_id);
        formatter.field("bucket", &self.bucket);
        formatter.field("prefix", &self.prefix);
        formatter.field("upload_policy", &self.upload_policy);
        formatter.field("upload_policy_signature", &self.upload_policy_signature);
        formatter.finish()
    }
}
/// See [`S3Storage`](crate::model::S3Storage)
pub mod s3_storage {
    /// A builder for [`S3Storage`](crate::model::S3Storage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_access_key_id: std::option::Option<std::string::String>,
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
        pub(crate) upload_policy: std::option::Option<smithy_types::Blob>,
        pub(crate) upload_policy_signature: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance  
        /// in <a href="https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing Amazon Web Services Access Keys</a>.</p>
        pub fn aws_access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_access_key_id = Some(input.into());
            self
        }
        pub fn set_aws_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_access_key_id = input;
            self
        }
        /// <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The beginning of the file name of the AMI.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
        pub fn upload_policy(mut self, input: smithy_types::Blob) -> Self {
            self.upload_policy = Some(input);
            self
        }
        pub fn set_upload_policy(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.upload_policy = input;
            self
        }
        /// <p>The signature of the JSON document.</p>
        pub fn upload_policy_signature(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_policy_signature = Some(input.into());
            self
        }
        pub fn set_upload_policy_signature(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upload_policy_signature = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Storage`](crate::model::S3Storage)
        pub fn build(self) -> crate::model::S3Storage {
            crate::model::S3Storage {
                aws_access_key_id: self.aws_access_key_id,
                bucket: self.bucket,
                prefix: self.prefix,
                upload_policy: self.upload_policy,
                upload_policy_signature: self.upload_policy_signature,
            }
        }
    }
}
impl S3Storage {
    /// Creates a new builder-style object to manufacture [`S3Storage`](crate::model::S3Storage)
    pub fn builder() -> crate::model::s3_storage::Builder {
        crate::model::s3_storage::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BundleTaskState {
    Bundling,
    Cancelling,
    Complete,
    Failed,
    Pending,
    Storing,
    WaitingForShutdown,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BundleTaskState {
    fn from(s: &str) -> Self {
        match s {
            "bundling" => BundleTaskState::Bundling,
            "cancelling" => BundleTaskState::Cancelling,
            "complete" => BundleTaskState::Complete,
            "failed" => BundleTaskState::Failed,
            "pending" => BundleTaskState::Pending,
            "storing" => BundleTaskState::Storing,
            "waiting-for-shutdown" => BundleTaskState::WaitingForShutdown,
            other => BundleTaskState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BundleTaskState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BundleTaskState::from(s))
    }
}
impl BundleTaskState {
    pub fn as_str(&self) -> &str {
        match self {
            BundleTaskState::Bundling => "bundling",
            BundleTaskState::Cancelling => "cancelling",
            BundleTaskState::Complete => "complete",
            BundleTaskState::Failed => "failed",
            BundleTaskState::Pending => "pending",
            BundleTaskState::Storing => "storing",
            BundleTaskState::WaitingForShutdown => "waiting-for-shutdown",
            BundleTaskState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "bundling",
            "cancelling",
            "complete",
            "failed",
            "pending",
            "storing",
            "waiting-for-shutdown",
        ]
    }
}
impl AsRef<str> for BundleTaskState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an error for <a>BundleInstance</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BundleTaskError {
    /// <p>The error code.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BundleTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BundleTaskError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BundleTaskError`](crate::model::BundleTaskError)
pub mod bundle_task_error {
    /// A builder for [`BundleTaskError`](crate::model::BundleTaskError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BundleTaskError`](crate::model::BundleTaskError)
        pub fn build(self) -> crate::model::BundleTaskError {
            crate::model::BundleTaskError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BundleTaskError {
    /// Creates a new builder-style object to manufacture [`BundleTaskError`](crate::model::BundleTaskError)
    pub fn builder() -> crate::model::bundle_task_error::Builder {
        crate::model::bundle_task_error::Builder::default()
    }
}

/// <p>Describes Availability Zones, Local Zones, and Wavelength Zones.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailabilityZone {
    /// <p>The state of the Availability Zone, Local Zone, or Wavelength Zone.</p>
    pub state: std::option::Option<crate::model::AvailabilityZoneState>,
    /// <p>For Availability Zones, this parameter always has the value of
    /// <code>opt-in-not-required</code>.</p>
    /// <p>For Local Zones and Wavelength Zones, this parameter is the opt-in status. The possible
    /// values are <code>opted-in</code>, and <code>not-opted-in</code>.</p>
    pub opt_in_status: std::option::Option<crate::model::AvailabilityZoneOptInStatus>,
    /// <p>Any messages about the Availability Zone, Local Zone, or Wavelength Zone.</p>
    pub messages: std::option::Option<std::vec::Vec<crate::model::AvailabilityZoneMessage>>,
    /// <p>The name of the Region.</p>
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The name of the Availability Zone, Local Zone, or Wavelength Zone.</p>
    pub zone_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Availability Zone, Local Zone, or Wavelength Zone.</p>
    pub zone_id: std::option::Option<std::string::String>,
    /// <p> For Availability Zones, this parameter has the same value as the Region name.</p>
    /// <p>For Local Zones, the name of the associated group, for example
    /// <code>us-west-2-lax-1</code>.</p>
    /// <p>For Wavelength Zones, the name of the associated group, for example
    /// <code>us-east-1-wl1-bos-wlz-1</code>.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The name of the network border group.</p>
    pub network_border_group: std::option::Option<std::string::String>,
    /// <p>The type of zone. The valid values are <code>availability-zone</code>,
    /// <code>local-zone</code>, and <code>wavelength-zone</code>.</p>
    pub zone_type: std::option::Option<std::string::String>,
    /// <p>The name of the zone that handles some of the Local Zone or Wavelength Zone control plane
    /// operations, such as API calls.</p>
    pub parent_zone_name: std::option::Option<std::string::String>,
    /// <p>The ID of the zone that handles some of the Local Zone or Wavelength Zone control plane
    /// operations, such as API calls.</p>
    pub parent_zone_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AvailabilityZone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailabilityZone");
        formatter.field("state", &self.state);
        formatter.field("opt_in_status", &self.opt_in_status);
        formatter.field("messages", &self.messages);
        formatter.field("region_name", &self.region_name);
        formatter.field("zone_name", &self.zone_name);
        formatter.field("zone_id", &self.zone_id);
        formatter.field("group_name", &self.group_name);
        formatter.field("network_border_group", &self.network_border_group);
        formatter.field("zone_type", &self.zone_type);
        formatter.field("parent_zone_name", &self.parent_zone_name);
        formatter.field("parent_zone_id", &self.parent_zone_id);
        formatter.finish()
    }
}
/// See [`AvailabilityZone`](crate::model::AvailabilityZone)
pub mod availability_zone {
    /// A builder for [`AvailabilityZone`](crate::model::AvailabilityZone)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::AvailabilityZoneState>,
        pub(crate) opt_in_status: std::option::Option<crate::model::AvailabilityZoneOptInStatus>,
        pub(crate) messages:
            std::option::Option<std::vec::Vec<crate::model::AvailabilityZoneMessage>>,
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) zone_name: std::option::Option<std::string::String>,
        pub(crate) zone_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) network_border_group: std::option::Option<std::string::String>,
        pub(crate) zone_type: std::option::Option<std::string::String>,
        pub(crate) parent_zone_name: std::option::Option<std::string::String>,
        pub(crate) parent_zone_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the Availability Zone, Local Zone, or Wavelength Zone.</p>
        pub fn state(mut self, input: crate::model::AvailabilityZoneState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AvailabilityZoneState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>For Availability Zones, this parameter always has the value of
        /// <code>opt-in-not-required</code>.</p>
        /// <p>For Local Zones and Wavelength Zones, this parameter is the opt-in status. The possible
        /// values are <code>opted-in</code>, and <code>not-opted-in</code>.</p>
        pub fn opt_in_status(mut self, input: crate::model::AvailabilityZoneOptInStatus) -> Self {
            self.opt_in_status = Some(input);
            self
        }
        pub fn set_opt_in_status(
            mut self,
            input: std::option::Option<crate::model::AvailabilityZoneOptInStatus>,
        ) -> Self {
            self.opt_in_status = input;
            self
        }
        pub fn messages(mut self, input: impl Into<crate::model::AvailabilityZoneMessage>) -> Self {
            let mut v = self.messages.unwrap_or_default();
            v.push(input.into());
            self.messages = Some(v);
            self
        }
        pub fn set_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AvailabilityZoneMessage>>,
        ) -> Self {
            self.messages = input;
            self
        }
        /// <p>The name of the Region.</p>
        pub fn region_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.region_name = Some(input.into());
            self
        }
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region_name = input;
            self
        }
        /// <p>The name of the Availability Zone, Local Zone, or Wavelength Zone.</p>
        pub fn zone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone_name = Some(input.into());
            self
        }
        pub fn set_zone_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone_name = input;
            self
        }
        /// <p>The ID of the Availability Zone, Local Zone, or Wavelength Zone.</p>
        pub fn zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone_id = Some(input.into());
            self
        }
        pub fn set_zone_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone_id = input;
            self
        }
        /// <p> For Availability Zones, this parameter has the same value as the Region name.</p>
        /// <p>For Local Zones, the name of the associated group, for example
        /// <code>us-west-2-lax-1</code>.</p>
        /// <p>For Wavelength Zones, the name of the associated group, for example
        /// <code>us-east-1-wl1-bos-wlz-1</code>.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The name of the network border group.</p>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_border_group = Some(input.into());
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_border_group = input;
            self
        }
        /// <p>The type of zone. The valid values are <code>availability-zone</code>,
        /// <code>local-zone</code>, and <code>wavelength-zone</code>.</p>
        pub fn zone_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone_type = Some(input.into());
            self
        }
        pub fn set_zone_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone_type = input;
            self
        }
        /// <p>The name of the zone that handles some of the Local Zone or Wavelength Zone control plane
        /// operations, such as API calls.</p>
        pub fn parent_zone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_zone_name = Some(input.into());
            self
        }
        pub fn set_parent_zone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_zone_name = input;
            self
        }
        /// <p>The ID of the zone that handles some of the Local Zone or Wavelength Zone control plane
        /// operations, such as API calls.</p>
        pub fn parent_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.parent_zone_id = Some(input.into());
            self
        }
        pub fn set_parent_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_zone_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailabilityZone`](crate::model::AvailabilityZone)
        pub fn build(self) -> crate::model::AvailabilityZone {
            crate::model::AvailabilityZone {
                state: self.state,
                opt_in_status: self.opt_in_status,
                messages: self.messages,
                region_name: self.region_name,
                zone_name: self.zone_name,
                zone_id: self.zone_id,
                group_name: self.group_name,
                network_border_group: self.network_border_group,
                zone_type: self.zone_type,
                parent_zone_name: self.parent_zone_name,
                parent_zone_id: self.parent_zone_id,
            }
        }
    }
}
impl AvailabilityZone {
    /// Creates a new builder-style object to manufacture [`AvailabilityZone`](crate::model::AvailabilityZone)
    pub fn builder() -> crate::model::availability_zone::Builder {
        crate::model::availability_zone::Builder::default()
    }
}

/// <p>Describes a message about an Availability Zone, Local Zone, or Wavelength Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailabilityZoneMessage {
    /// <p>The message about the Availability Zone, Local Zone, or Wavelength Zone.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AvailabilityZoneMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailabilityZoneMessage");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AvailabilityZoneMessage`](crate::model::AvailabilityZoneMessage)
pub mod availability_zone_message {
    /// A builder for [`AvailabilityZoneMessage`](crate::model::AvailabilityZoneMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message about the Availability Zone, Local Zone, or Wavelength Zone.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailabilityZoneMessage`](crate::model::AvailabilityZoneMessage)
        pub fn build(self) -> crate::model::AvailabilityZoneMessage {
            crate::model::AvailabilityZoneMessage {
                message: self.message,
            }
        }
    }
}
impl AvailabilityZoneMessage {
    /// Creates a new builder-style object to manufacture [`AvailabilityZoneMessage`](crate::model::AvailabilityZoneMessage)
    pub fn builder() -> crate::model::availability_zone_message::Builder {
        crate::model::availability_zone_message::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AvailabilityZoneOptInStatus {
    NotOptedIn,
    OptInNotRequired,
    OptedIn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AvailabilityZoneOptInStatus {
    fn from(s: &str) -> Self {
        match s {
            "not-opted-in" => AvailabilityZoneOptInStatus::NotOptedIn,
            "opt-in-not-required" => AvailabilityZoneOptInStatus::OptInNotRequired,
            "opted-in" => AvailabilityZoneOptInStatus::OptedIn,
            other => AvailabilityZoneOptInStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AvailabilityZoneOptInStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AvailabilityZoneOptInStatus::from(s))
    }
}
impl AvailabilityZoneOptInStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AvailabilityZoneOptInStatus::NotOptedIn => "not-opted-in",
            AvailabilityZoneOptInStatus::OptInNotRequired => "opt-in-not-required",
            AvailabilityZoneOptInStatus::OptedIn => "opted-in",
            AvailabilityZoneOptInStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["not-opted-in", "opt-in-not-required", "opted-in"]
    }
}
impl AsRef<str> for AvailabilityZoneOptInStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AvailabilityZoneState {
    Available,
    Impaired,
    Information,
    Unavailable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AvailabilityZoneState {
    fn from(s: &str) -> Self {
        match s {
            "available" => AvailabilityZoneState::Available,
            "impaired" => AvailabilityZoneState::Impaired,
            "information" => AvailabilityZoneState::Information,
            "unavailable" => AvailabilityZoneState::Unavailable,
            other => AvailabilityZoneState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AvailabilityZoneState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AvailabilityZoneState::from(s))
    }
}
impl AvailabilityZoneState {
    pub fn as_str(&self) -> &str {
        match self {
            AvailabilityZoneState::Available => "available",
            AvailabilityZoneState::Impaired => "impaired",
            AvailabilityZoneState::Information => "information",
            AvailabilityZoneState::Unavailable => "unavailable",
            AvailabilityZoneState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["available", "impaired", "information", "unavailable"]
    }
}
impl AsRef<str> for AvailabilityZoneState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Elastic IP address, or a carrier IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Address {
    /// <p>The ID of the instance that the address is associated with (if any).</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The Elastic IP address.</p>
    pub public_ip: std::option::Option<std::string::String>,
    /// <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
    pub allocation_id: std::option::Option<std::string::String>,
    /// <p>The ID representing the association of the address with an instance in a VPC.</p>
    pub association_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether this Elastic IP address is for use with instances
    /// in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
    pub domain: std::option::Option<crate::model::DomainType>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Web Services account that owns the network interface.</p>
    pub network_interface_owner_id: std::option::Option<std::string::String>,
    /// <p>The private IP address associated with the Elastic IP address.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>Any tags assigned to the Elastic IP address.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ID of an address pool.</p>
    pub public_ipv4_pool: std::option::Option<std::string::String>,
    /// <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from
    /// which AWS advertises IP addresses. </p>
    pub network_border_group: std::option::Option<std::string::String>,
    /// <p>The customer-owned IP address.</p>
    pub customer_owned_ip: std::option::Option<std::string::String>,
    /// <p>The ID of the customer-owned address pool.</p>
    pub customer_owned_ipv4_pool: std::option::Option<std::string::String>,
    /// <p>The carrier IP address associated. This option is only available for network interfaces
    /// which  reside in a subnet in a Wavelength Zone (for example an EC2 instance). </p>
    pub carrier_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Address");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("public_ip", &self.public_ip);
        formatter.field("allocation_id", &self.allocation_id);
        formatter.field("association_id", &self.association_id);
        formatter.field("domain", &self.domain);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field(
            "network_interface_owner_id",
            &self.network_interface_owner_id,
        );
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("tags", &self.tags);
        formatter.field("public_ipv4_pool", &self.public_ipv4_pool);
        formatter.field("network_border_group", &self.network_border_group);
        formatter.field("customer_owned_ip", &self.customer_owned_ip);
        formatter.field("customer_owned_ipv4_pool", &self.customer_owned_ipv4_pool);
        formatter.field("carrier_ip", &self.carrier_ip);
        formatter.finish()
    }
}
/// See [`Address`](crate::model::Address)
pub mod address {
    /// A builder for [`Address`](crate::model::Address)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) public_ip: std::option::Option<std::string::String>,
        pub(crate) allocation_id: std::option::Option<std::string::String>,
        pub(crate) association_id: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<crate::model::DomainType>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) network_interface_owner_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) public_ipv4_pool: std::option::Option<std::string::String>,
        pub(crate) network_border_group: std::option::Option<std::string::String>,
        pub(crate) customer_owned_ip: std::option::Option<std::string::String>,
        pub(crate) customer_owned_ipv4_pool: std::option::Option<std::string::String>,
        pub(crate) carrier_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance that the address is associated with (if any).</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The Elastic IP address.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip = Some(input.into());
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.public_ip = input;
            self
        }
        /// <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.allocation_id = Some(input.into());
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allocation_id = input;
            self
        }
        /// <p>The ID representing the association of the address with an instance in a VPC.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.association_id = Some(input.into());
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.association_id = input;
            self
        }
        /// <p>Indicates whether this Elastic IP address is for use with instances
        /// in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
        pub fn domain(mut self, input: crate::model::DomainType) -> Self {
            self.domain = Some(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<crate::model::DomainType>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The ID of the Amazon Web Services account that owns the network interface.</p>
        pub fn network_interface_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_owner_id = Some(input.into());
            self
        }
        pub fn set_network_interface_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_owner_id = input;
            self
        }
        /// <p>The private IP address associated with the Elastic IP address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of an address pool.</p>
        pub fn public_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ipv4_pool = Some(input.into());
            self
        }
        pub fn set_public_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ipv4_pool = input;
            self
        }
        /// <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from
        /// which AWS advertises IP addresses. </p>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_border_group = Some(input.into());
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_border_group = input;
            self
        }
        /// <p>The customer-owned IP address.</p>
        pub fn customer_owned_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_owned_ip = Some(input.into());
            self
        }
        pub fn set_customer_owned_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_owned_ip = input;
            self
        }
        /// <p>The ID of the customer-owned address pool.</p>
        pub fn customer_owned_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_owned_ipv4_pool = Some(input.into());
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_owned_ipv4_pool = input;
            self
        }
        /// <p>The carrier IP address associated. This option is only available for network interfaces
        /// which  reside in a subnet in a Wavelength Zone (for example an EC2 instance). </p>
        pub fn carrier_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier_ip = Some(input.into());
            self
        }
        pub fn set_carrier_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.carrier_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`Address`](crate::model::Address)
        pub fn build(self) -> crate::model::Address {
            crate::model::Address {
                instance_id: self.instance_id,
                public_ip: self.public_ip,
                allocation_id: self.allocation_id,
                association_id: self.association_id,
                domain: self.domain,
                network_interface_id: self.network_interface_id,
                network_interface_owner_id: self.network_interface_owner_id,
                private_ip_address: self.private_ip_address,
                tags: self.tags,
                public_ipv4_pool: self.public_ipv4_pool,
                network_border_group: self.network_border_group,
                customer_owned_ip: self.customer_owned_ip,
                customer_owned_ipv4_pool: self.customer_owned_ipv4_pool,
                carrier_ip: self.carrier_ip,
            }
        }
    }
}
impl Address {
    /// Creates a new builder-style object to manufacture [`Address`](crate::model::Address)
    pub fn builder() -> crate::model::address::Builder {
        crate::model::address::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainType {
    Standard,
    Vpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DomainType {
    fn from(s: &str) -> Self {
        match s {
            "standard" => DomainType::Standard,
            "vpc" => DomainType::Vpc,
            other => DomainType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DomainType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainType::from(s))
    }
}
impl DomainType {
    pub fn as_str(&self) -> &str {
        match self {
            DomainType::Standard => "standard",
            DomainType::Vpc => "vpc",
            DomainType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["standard", "vpc"]
    }
}
impl AsRef<str> for DomainType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an account attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountAttribute {
    /// <p>The name of the account attribute.</p>
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The values for the account attribute.</p>
    pub attribute_values: std::option::Option<std::vec::Vec<crate::model::AccountAttributeValue>>,
}
impl std::fmt::Debug for AccountAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountAttribute");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_values", &self.attribute_values);
        formatter.finish()
    }
}
/// See [`AccountAttribute`](crate::model::AccountAttribute)
pub mod account_attribute {
    /// A builder for [`AccountAttribute`](crate::model::AccountAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_values:
            std::option::Option<std::vec::Vec<crate::model::AccountAttributeValue>>,
    }
    impl Builder {
        /// <p>The name of the account attribute.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        pub fn attribute_values(
            mut self,
            input: impl Into<crate::model::AccountAttributeValue>,
        ) -> Self {
            let mut v = self.attribute_values.unwrap_or_default();
            v.push(input.into());
            self.attribute_values = Some(v);
            self
        }
        pub fn set_attribute_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccountAttributeValue>>,
        ) -> Self {
            self.attribute_values = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountAttribute`](crate::model::AccountAttribute)
        pub fn build(self) -> crate::model::AccountAttribute {
            crate::model::AccountAttribute {
                attribute_name: self.attribute_name,
                attribute_values: self.attribute_values,
            }
        }
    }
}
impl AccountAttribute {
    /// Creates a new builder-style object to manufacture [`AccountAttribute`](crate::model::AccountAttribute)
    pub fn builder() -> crate::model::account_attribute::Builder {
        crate::model::account_attribute::Builder::default()
    }
}

/// <p>Describes a value of an account attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountAttributeValue {
    /// <p>The value of the attribute.</p>
    pub attribute_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountAttributeValue");
        formatter.field("attribute_value", &self.attribute_value);
        formatter.finish()
    }
}
/// See [`AccountAttributeValue`](crate::model::AccountAttributeValue)
pub mod account_attribute_value {
    /// A builder for [`AccountAttributeValue`](crate::model::AccountAttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value of the attribute.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountAttributeValue`](crate::model::AccountAttributeValue)
        pub fn build(self) -> crate::model::AccountAttributeValue {
            crate::model::AccountAttributeValue {
                attribute_value: self.attribute_value,
            }
        }
    }
}
impl AccountAttributeValue {
    /// Creates a new builder-style object to manufacture [`AccountAttributeValue`](crate::model::AccountAttributeValue)
    pub fn builder() -> crate::model::account_attribute_value::Builder {
        crate::model::account_attribute_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccountAttributeName {
    DefaultVpc,
    SupportedPlatforms,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AccountAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "default-vpc" => AccountAttributeName::DefaultVpc,
            "supported-platforms" => AccountAttributeName::SupportedPlatforms,
            other => AccountAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AccountAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccountAttributeName::from(s))
    }
}
impl AccountAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            AccountAttributeName::DefaultVpc => "default-vpc",
            AccountAttributeName::SupportedPlatforms => "supported-platforms",
            AccountAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["default-vpc", "supported-platforms"]
    }
}
impl AsRef<str> for AccountAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the deregistered  transit gateway multicast group sources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDeregisteredGroupSources {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The network interface IDs of the non-registered members.</p>
    pub deregistered_network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IP address assigned to the  transit gateway multicast group.</p>
    pub group_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransitGatewayMulticastDeregisteredGroupSources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDeregisteredGroupSources");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field(
            "deregistered_network_interface_ids",
            &self.deregistered_network_interface_ids,
        );
        formatter.field("group_ip_address", &self.group_ip_address);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDeregisteredGroupSources`](crate::model::TransitGatewayMulticastDeregisteredGroupSources)
pub mod transit_gateway_multicast_deregistered_group_sources {
    /// A builder for [`TransitGatewayMulticastDeregisteredGroupSources`](crate::model::TransitGatewayMulticastDeregisteredGroupSources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) deregistered_network_interface_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        pub fn deregistered_network_interface_ids(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.deregistered_network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.deregistered_network_interface_ids = Some(v);
            self
        }
        pub fn set_deregistered_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.deregistered_network_interface_ids = input;
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_ip_address = Some(input.into());
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDeregisteredGroupSources`](crate::model::TransitGatewayMulticastDeregisteredGroupSources)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDeregisteredGroupSources {
            crate::model::TransitGatewayMulticastDeregisteredGroupSources {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                deregistered_network_interface_ids: self.deregistered_network_interface_ids,
                group_ip_address: self.group_ip_address,
            }
        }
    }
}
impl TransitGatewayMulticastDeregisteredGroupSources {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDeregisteredGroupSources`](crate::model::TransitGatewayMulticastDeregisteredGroupSources)
    pub fn builder() -> crate::model::transit_gateway_multicast_deregistered_group_sources::Builder
    {
        crate::model::transit_gateway_multicast_deregistered_group_sources::Builder::default()
    }
}

/// <p>Describes the deregistered  transit gateway multicast group members.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayMulticastDeregisteredGroupMembers {
    /// <p>The ID of the transit gateway multicast domain.</p>
    pub transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
    /// <p>The network interface IDs of the deregistered members.</p>
    pub deregistered_network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IP address assigned to the  transit gateway multicast group.</p>
    pub group_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransitGatewayMulticastDeregisteredGroupMembers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayMulticastDeregisteredGroupMembers");
        formatter.field(
            "transit_gateway_multicast_domain_id",
            &self.transit_gateway_multicast_domain_id,
        );
        formatter.field(
            "deregistered_network_interface_ids",
            &self.deregistered_network_interface_ids,
        );
        formatter.field("group_ip_address", &self.group_ip_address);
        formatter.finish()
    }
}
/// See [`TransitGatewayMulticastDeregisteredGroupMembers`](crate::model::TransitGatewayMulticastDeregisteredGroupMembers)
pub mod transit_gateway_multicast_deregistered_group_members {
    /// A builder for [`TransitGatewayMulticastDeregisteredGroupMembers`](crate::model::TransitGatewayMulticastDeregisteredGroupMembers)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_multicast_domain_id: std::option::Option<std::string::String>,
        pub(crate) deregistered_network_interface_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = Some(input.into());
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_multicast_domain_id = input;
            self
        }
        pub fn deregistered_network_interface_ids(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.deregistered_network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.deregistered_network_interface_ids = Some(v);
            self
        }
        pub fn set_deregistered_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.deregistered_network_interface_ids = input;
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_ip_address = Some(input.into());
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.group_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayMulticastDeregisteredGroupMembers`](crate::model::TransitGatewayMulticastDeregisteredGroupMembers)
        pub fn build(self) -> crate::model::TransitGatewayMulticastDeregisteredGroupMembers {
            crate::model::TransitGatewayMulticastDeregisteredGroupMembers {
                transit_gateway_multicast_domain_id: self.transit_gateway_multicast_domain_id,
                deregistered_network_interface_ids: self.deregistered_network_interface_ids,
                group_ip_address: self.group_ip_address,
            }
        }
    }
}
impl TransitGatewayMulticastDeregisteredGroupMembers {
    /// Creates a new builder-style object to manufacture [`TransitGatewayMulticastDeregisteredGroupMembers`](crate::model::TransitGatewayMulticastDeregisteredGroupMembers)
    pub fn builder() -> crate::model::transit_gateway_multicast_deregistered_group_members::Builder
    {
        crate::model::transit_gateway_multicast_deregistered_group_members::Builder::default()
    }
}

/// <p>Information about the tag keys to deregister for the current Region. You can either specify
/// individual tag keys or deregister all tag keys in the current Region. You must specify either
/// <code>IncludeAllTagsOfInstance</code> or <code>InstanceTagKeys</code> in the request</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterInstanceTagAttributeRequest {
    /// <p>Indicates whether to deregister all tag keys in the current Region. Specify <code>false</code>
    /// to deregister all tag keys.</p>
    pub include_all_tags_of_instance: std::option::Option<bool>,
    /// <p>Information about the tag keys to deregister.</p>
    pub instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeregisterInstanceTagAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterInstanceTagAttributeRequest");
        formatter.field(
            "include_all_tags_of_instance",
            &self.include_all_tags_of_instance,
        );
        formatter.field("instance_tag_keys", &self.instance_tag_keys);
        formatter.finish()
    }
}
/// See [`DeregisterInstanceTagAttributeRequest`](crate::model::DeregisterInstanceTagAttributeRequest)
pub mod deregister_instance_tag_attribute_request {
    /// A builder for [`DeregisterInstanceTagAttributeRequest`](crate::model::DeregisterInstanceTagAttributeRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_all_tags_of_instance: std::option::Option<bool>,
        pub(crate) instance_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Indicates whether to deregister all tag keys in the current Region. Specify <code>false</code>
        /// to deregister all tag keys.</p>
        pub fn include_all_tags_of_instance(mut self, input: bool) -> Self {
            self.include_all_tags_of_instance = Some(input);
            self
        }
        pub fn set_include_all_tags_of_instance(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_all_tags_of_instance = input;
            self
        }
        pub fn instance_tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_tag_keys.unwrap_or_default();
            v.push(input.into());
            self.instance_tag_keys = Some(v);
            self
        }
        pub fn set_instance_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterInstanceTagAttributeRequest`](crate::model::DeregisterInstanceTagAttributeRequest)
        pub fn build(self) -> crate::model::DeregisterInstanceTagAttributeRequest {
            crate::model::DeregisterInstanceTagAttributeRequest {
                include_all_tags_of_instance: self.include_all_tags_of_instance,
                instance_tag_keys: self.instance_tag_keys,
            }
        }
    }
}
impl DeregisterInstanceTagAttributeRequest {
    /// Creates a new builder-style object to manufacture [`DeregisterInstanceTagAttributeRequest`](crate::model::DeregisterInstanceTagAttributeRequest)
    pub fn builder() -> crate::model::deregister_instance_tag_attribute_request::Builder {
        crate::model::deregister_instance_tag_attribute_request::Builder::default()
    }
}

/// <p>Describes a Reserved Instance whose queued purchase was not deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailedQueuedPurchaseDeletion {
    /// <p>The error.</p>
    pub error: std::option::Option<crate::model::DeleteQueuedReservedInstancesError>,
    /// <p>The ID of the Reserved Instance.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FailedQueuedPurchaseDeletion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailedQueuedPurchaseDeletion");
        formatter.field("error", &self.error);
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.finish()
    }
}
/// See [`FailedQueuedPurchaseDeletion`](crate::model::FailedQueuedPurchaseDeletion)
pub mod failed_queued_purchase_deletion {
    /// A builder for [`FailedQueuedPurchaseDeletion`](crate::model::FailedQueuedPurchaseDeletion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::DeleteQueuedReservedInstancesError>,
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error.</p>
        pub fn error(mut self, input: crate::model::DeleteQueuedReservedInstancesError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::DeleteQueuedReservedInstancesError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>The ID of the Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedQueuedPurchaseDeletion`](crate::model::FailedQueuedPurchaseDeletion)
        pub fn build(self) -> crate::model::FailedQueuedPurchaseDeletion {
            crate::model::FailedQueuedPurchaseDeletion {
                error: self.error,
                reserved_instances_id: self.reserved_instances_id,
            }
        }
    }
}
impl FailedQueuedPurchaseDeletion {
    /// Creates a new builder-style object to manufacture [`FailedQueuedPurchaseDeletion`](crate::model::FailedQueuedPurchaseDeletion)
    pub fn builder() -> crate::model::failed_queued_purchase_deletion::Builder {
        crate::model::failed_queued_purchase_deletion::Builder::default()
    }
}

/// <p>Describes the error for a Reserved Instance whose queued purchase could not be deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteQueuedReservedInstancesError {
    /// <p>The error code.</p>
    pub code: std::option::Option<crate::model::DeleteQueuedReservedInstancesErrorCode>,
    /// <p>The error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteQueuedReservedInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteQueuedReservedInstancesError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DeleteQueuedReservedInstancesError`](crate::model::DeleteQueuedReservedInstancesError)
pub mod delete_queued_reserved_instances_error {
    /// A builder for [`DeleteQueuedReservedInstancesError`](crate::model::DeleteQueuedReservedInstancesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::DeleteQueuedReservedInstancesErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::DeleteQueuedReservedInstancesErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::DeleteQueuedReservedInstancesErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteQueuedReservedInstancesError`](crate::model::DeleteQueuedReservedInstancesError)
        pub fn build(self) -> crate::model::DeleteQueuedReservedInstancesError {
            crate::model::DeleteQueuedReservedInstancesError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl DeleteQueuedReservedInstancesError {
    /// Creates a new builder-style object to manufacture [`DeleteQueuedReservedInstancesError`](crate::model::DeleteQueuedReservedInstancesError)
    pub fn builder() -> crate::model::delete_queued_reserved_instances_error::Builder {
        crate::model::delete_queued_reserved_instances_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeleteQueuedReservedInstancesErrorCode {
    ReservedInstancesIdInvalid,
    ReservedInstancesNotInQueuedState,
    UnexpectedError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeleteQueuedReservedInstancesErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "reserved-instances-id-invalid" => {
                DeleteQueuedReservedInstancesErrorCode::ReservedInstancesIdInvalid
            }
            "reserved-instances-not-in-queued-state" => {
                DeleteQueuedReservedInstancesErrorCode::ReservedInstancesNotInQueuedState
            }
            "unexpected-error" => DeleteQueuedReservedInstancesErrorCode::UnexpectedError,
            other => DeleteQueuedReservedInstancesErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeleteQueuedReservedInstancesErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeleteQueuedReservedInstancesErrorCode::from(s))
    }
}
impl DeleteQueuedReservedInstancesErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            DeleteQueuedReservedInstancesErrorCode::ReservedInstancesIdInvalid => {
                "reserved-instances-id-invalid"
            }
            DeleteQueuedReservedInstancesErrorCode::ReservedInstancesNotInQueuedState => {
                "reserved-instances-not-in-queued-state"
            }
            DeleteQueuedReservedInstancesErrorCode::UnexpectedError => "unexpected-error",
            DeleteQueuedReservedInstancesErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "reserved-instances-id-invalid",
            "reserved-instances-not-in-queued-state",
            "unexpected-error",
        ]
    }
}
impl AsRef<str> for DeleteQueuedReservedInstancesErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Reserved Instance whose queued purchase was successfully deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SuccessfulQueuedPurchaseDeletion {
    /// <p>The ID of the Reserved Instance.</p>
    pub reserved_instances_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SuccessfulQueuedPurchaseDeletion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SuccessfulQueuedPurchaseDeletion");
        formatter.field("reserved_instances_id", &self.reserved_instances_id);
        formatter.finish()
    }
}
/// See [`SuccessfulQueuedPurchaseDeletion`](crate::model::SuccessfulQueuedPurchaseDeletion)
pub mod successful_queued_purchase_deletion {
    /// A builder for [`SuccessfulQueuedPurchaseDeletion`](crate::model::SuccessfulQueuedPurchaseDeletion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_instances_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_instances_id = Some(input.into());
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_instances_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SuccessfulQueuedPurchaseDeletion`](crate::model::SuccessfulQueuedPurchaseDeletion)
        pub fn build(self) -> crate::model::SuccessfulQueuedPurchaseDeletion {
            crate::model::SuccessfulQueuedPurchaseDeletion {
                reserved_instances_id: self.reserved_instances_id,
            }
        }
    }
}
impl SuccessfulQueuedPurchaseDeletion {
    /// Creates a new builder-style object to manufacture [`SuccessfulQueuedPurchaseDeletion`](crate::model::SuccessfulQueuedPurchaseDeletion)
    pub fn builder() -> crate::model::successful_queued_purchase_deletion::Builder {
        crate::model::successful_queued_purchase_deletion::Builder::default()
    }
}

/// <p>Describes a launch template version that could not be deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLaunchTemplateVersionsResponseErrorItem {
    /// <p>The ID of the launch template.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The version number of the launch template.</p>
    pub version_number: std::option::Option<i64>,
    /// <p>Information about the error.</p>
    pub response_error: std::option::Option<crate::model::ResponseError>,
}
impl std::fmt::Debug for DeleteLaunchTemplateVersionsResponseErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLaunchTemplateVersionsResponseErrorItem");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version_number", &self.version_number);
        formatter.field("response_error", &self.response_error);
        formatter.finish()
    }
}
/// See [`DeleteLaunchTemplateVersionsResponseErrorItem`](crate::model::DeleteLaunchTemplateVersionsResponseErrorItem)
pub mod delete_launch_template_versions_response_error_item {
    /// A builder for [`DeleteLaunchTemplateVersionsResponseErrorItem`](crate::model::DeleteLaunchTemplateVersionsResponseErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i64>,
        pub(crate) response_error: std::option::Option<crate::model::ResponseError>,
    }
    impl Builder {
        /// <p>The ID of the launch template.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The version number of the launch template.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// <p>Information about the error.</p>
        pub fn response_error(mut self, input: crate::model::ResponseError) -> Self {
            self.response_error = Some(input);
            self
        }
        pub fn set_response_error(
            mut self,
            input: std::option::Option<crate::model::ResponseError>,
        ) -> Self {
            self.response_error = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLaunchTemplateVersionsResponseErrorItem`](crate::model::DeleteLaunchTemplateVersionsResponseErrorItem)
        pub fn build(self) -> crate::model::DeleteLaunchTemplateVersionsResponseErrorItem {
            crate::model::DeleteLaunchTemplateVersionsResponseErrorItem {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version_number: self.version_number,
                response_error: self.response_error,
            }
        }
    }
}
impl DeleteLaunchTemplateVersionsResponseErrorItem {
    /// Creates a new builder-style object to manufacture [`DeleteLaunchTemplateVersionsResponseErrorItem`](crate::model::DeleteLaunchTemplateVersionsResponseErrorItem)
    pub fn builder() -> crate::model::delete_launch_template_versions_response_error_item::Builder {
        crate::model::delete_launch_template_versions_response_error_item::Builder::default()
    }
}

/// <p>Describes the error that's returned when you cannot delete a launch template
/// version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResponseError {
    /// <p>The error code.</p>
    pub code: std::option::Option<crate::model::LaunchTemplateErrorCode>,
    /// <p>The error message, if applicable.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResponseError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ResponseError`](crate::model::ResponseError)
pub mod response_error {
    /// A builder for [`ResponseError`](crate::model::ResponseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::LaunchTemplateErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::LaunchTemplateErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message, if applicable.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResponseError`](crate::model::ResponseError)
        pub fn build(self) -> crate::model::ResponseError {
            crate::model::ResponseError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ResponseError {
    /// Creates a new builder-style object to manufacture [`ResponseError`](crate::model::ResponseError)
    pub fn builder() -> crate::model::response_error::Builder {
        crate::model::response_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchTemplateErrorCode {
    LaunchTemplateIdDoesNotExist,
    LaunchTemplateIdMalformed,
    LaunchTemplateNameDoesNotExist,
    LaunchTemplateNameMalformed,
    LaunchTemplateVersionDoesNotExist,
    UnexpectedError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchTemplateErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "launchTemplateIdDoesNotExist" => LaunchTemplateErrorCode::LaunchTemplateIdDoesNotExist,
            "launchTemplateIdMalformed" => LaunchTemplateErrorCode::LaunchTemplateIdMalformed,
            "launchTemplateNameDoesNotExist" => {
                LaunchTemplateErrorCode::LaunchTemplateNameDoesNotExist
            }
            "launchTemplateNameMalformed" => LaunchTemplateErrorCode::LaunchTemplateNameMalformed,
            "launchTemplateVersionDoesNotExist" => {
                LaunchTemplateErrorCode::LaunchTemplateVersionDoesNotExist
            }
            "unexpectedError" => LaunchTemplateErrorCode::UnexpectedError,
            other => LaunchTemplateErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchTemplateErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchTemplateErrorCode::from(s))
    }
}
impl LaunchTemplateErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchTemplateErrorCode::LaunchTemplateIdDoesNotExist => "launchTemplateIdDoesNotExist",
            LaunchTemplateErrorCode::LaunchTemplateIdMalformed => "launchTemplateIdMalformed",
            LaunchTemplateErrorCode::LaunchTemplateNameDoesNotExist => {
                "launchTemplateNameDoesNotExist"
            }
            LaunchTemplateErrorCode::LaunchTemplateNameMalformed => "launchTemplateNameMalformed",
            LaunchTemplateErrorCode::LaunchTemplateVersionDoesNotExist => {
                "launchTemplateVersionDoesNotExist"
            }
            LaunchTemplateErrorCode::UnexpectedError => "unexpectedError",
            LaunchTemplateErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "launchTemplateIdDoesNotExist",
            "launchTemplateIdMalformed",
            "launchTemplateNameDoesNotExist",
            "launchTemplateNameMalformed",
            "launchTemplateVersionDoesNotExist",
            "unexpectedError",
        ]
    }
}
impl AsRef<str> for LaunchTemplateErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a launch template version that was successfully deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLaunchTemplateVersionsResponseSuccessItem {
    /// <p>The ID of the launch template.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The version number of the launch template.</p>
    pub version_number: std::option::Option<i64>,
}
impl std::fmt::Debug for DeleteLaunchTemplateVersionsResponseSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLaunchTemplateVersionsResponseSuccessItem");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version_number", &self.version_number);
        formatter.finish()
    }
}
/// See [`DeleteLaunchTemplateVersionsResponseSuccessItem`](crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem)
pub mod delete_launch_template_versions_response_success_item {
    /// A builder for [`DeleteLaunchTemplateVersionsResponseSuccessItem`](crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version_number: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The ID of the launch template.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The version number of the launch template.</p>
        pub fn version_number(mut self, input: i64) -> Self {
            self.version_number = Some(input);
            self
        }
        pub fn set_version_number(mut self, input: std::option::Option<i64>) -> Self {
            self.version_number = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLaunchTemplateVersionsResponseSuccessItem`](crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem)
        pub fn build(self) -> crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem {
            crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version_number: self.version_number,
            }
        }
    }
}
impl DeleteLaunchTemplateVersionsResponseSuccessItem {
    /// Creates a new builder-style object to manufacture [`DeleteLaunchTemplateVersionsResponseSuccessItem`](crate::model::DeleteLaunchTemplateVersionsResponseSuccessItem)
    pub fn builder() -> crate::model::delete_launch_template_versions_response_success_item::Builder
    {
        crate::model::delete_launch_template_versions_response_success_item::Builder::default()
    }
}

/// <p>The state of the event window.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowStateChange {
    /// <p>The ID of the event window.</p>
    pub instance_event_window_id: std::option::Option<std::string::String>,
    /// <p>The current state of the event window.</p>
    pub state: std::option::Option<crate::model::InstanceEventWindowState>,
}
impl std::fmt::Debug for InstanceEventWindowStateChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowStateChange");
        formatter.field("instance_event_window_id", &self.instance_event_window_id);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowStateChange`](crate::model::InstanceEventWindowStateChange)
pub mod instance_event_window_state_change {
    /// A builder for [`InstanceEventWindowStateChange`](crate::model::InstanceEventWindowStateChange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_event_window_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::InstanceEventWindowState>,
    }
    impl Builder {
        /// <p>The ID of the event window.</p>
        pub fn instance_event_window_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_event_window_id = Some(input.into());
            self
        }
        pub fn set_instance_event_window_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_event_window_id = input;
            self
        }
        /// <p>The current state of the event window.</p>
        pub fn state(mut self, input: crate::model::InstanceEventWindowState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::InstanceEventWindowState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowStateChange`](crate::model::InstanceEventWindowStateChange)
        pub fn build(self) -> crate::model::InstanceEventWindowStateChange {
            crate::model::InstanceEventWindowStateChange {
                instance_event_window_id: self.instance_event_window_id,
                state: self.state,
            }
        }
    }
}
impl InstanceEventWindowStateChange {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowStateChange`](crate::model::InstanceEventWindowStateChange)
    pub fn builder() -> crate::model::instance_event_window_state_change::Builder {
        crate::model::instance_event_window_state_change::Builder::default()
    }
}

/// <p>Describes an EC2 Fleet that was not successfully deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFleetErrorItem {
    /// <p>The error.</p>
    pub error: std::option::Option<crate::model::DeleteFleetError>,
    /// <p>The ID of the EC2 Fleet.</p>
    pub fleet_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteFleetErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFleetErrorItem");
        formatter.field("error", &self.error);
        formatter.field("fleet_id", &self.fleet_id);
        formatter.finish()
    }
}
/// See [`DeleteFleetErrorItem`](crate::model::DeleteFleetErrorItem)
pub mod delete_fleet_error_item {
    /// A builder for [`DeleteFleetErrorItem`](crate::model::DeleteFleetErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::DeleteFleetError>,
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error.</p>
        pub fn error(mut self, input: crate::model::DeleteFleetError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::DeleteFleetError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFleetErrorItem`](crate::model::DeleteFleetErrorItem)
        pub fn build(self) -> crate::model::DeleteFleetErrorItem {
            crate::model::DeleteFleetErrorItem {
                error: self.error,
                fleet_id: self.fleet_id,
            }
        }
    }
}
impl DeleteFleetErrorItem {
    /// Creates a new builder-style object to manufacture [`DeleteFleetErrorItem`](crate::model::DeleteFleetErrorItem)
    pub fn builder() -> crate::model::delete_fleet_error_item::Builder {
        crate::model::delete_fleet_error_item::Builder::default()
    }
}

/// <p>Describes an EC2 Fleet error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFleetError {
    /// <p>The error code.</p>
    pub code: std::option::Option<crate::model::DeleteFleetErrorCode>,
    /// <p>The description for the error code.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFleetError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DeleteFleetError`](crate::model::DeleteFleetError)
pub mod delete_fleet_error {
    /// A builder for [`DeleteFleetError`](crate::model::DeleteFleetError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::DeleteFleetErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::DeleteFleetErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::DeleteFleetErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The description for the error code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFleetError`](crate::model::DeleteFleetError)
        pub fn build(self) -> crate::model::DeleteFleetError {
            crate::model::DeleteFleetError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl DeleteFleetError {
    /// Creates a new builder-style object to manufacture [`DeleteFleetError`](crate::model::DeleteFleetError)
    pub fn builder() -> crate::model::delete_fleet_error::Builder {
        crate::model::delete_fleet_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeleteFleetErrorCode {
    FleetIdDoesNotExist,
    FleetIdMalformed,
    FleetNotInDeletableState,
    UnexpectedError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeleteFleetErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "fleetIdDoesNotExist" => DeleteFleetErrorCode::FleetIdDoesNotExist,
            "fleetIdMalformed" => DeleteFleetErrorCode::FleetIdMalformed,
            "fleetNotInDeletableState" => DeleteFleetErrorCode::FleetNotInDeletableState,
            "unexpectedError" => DeleteFleetErrorCode::UnexpectedError,
            other => DeleteFleetErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeleteFleetErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeleteFleetErrorCode::from(s))
    }
}
impl DeleteFleetErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            DeleteFleetErrorCode::FleetIdDoesNotExist => "fleetIdDoesNotExist",
            DeleteFleetErrorCode::FleetIdMalformed => "fleetIdMalformed",
            DeleteFleetErrorCode::FleetNotInDeletableState => "fleetNotInDeletableState",
            DeleteFleetErrorCode::UnexpectedError => "unexpectedError",
            DeleteFleetErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "fleetIdDoesNotExist",
            "fleetIdMalformed",
            "fleetNotInDeletableState",
            "unexpectedError",
        ]
    }
}
impl AsRef<str> for DeleteFleetErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an EC2 Fleet that was successfully deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFleetSuccessItem {
    /// <p>The current state of the EC2 Fleet.</p>
    pub current_fleet_state: std::option::Option<crate::model::FleetStateCode>,
    /// <p>The previous state of the EC2 Fleet.</p>
    pub previous_fleet_state: std::option::Option<crate::model::FleetStateCode>,
    /// <p>The ID of the EC2 Fleet.</p>
    pub fleet_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteFleetSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFleetSuccessItem");
        formatter.field("current_fleet_state", &self.current_fleet_state);
        formatter.field("previous_fleet_state", &self.previous_fleet_state);
        formatter.field("fleet_id", &self.fleet_id);
        formatter.finish()
    }
}
/// See [`DeleteFleetSuccessItem`](crate::model::DeleteFleetSuccessItem)
pub mod delete_fleet_success_item {
    /// A builder for [`DeleteFleetSuccessItem`](crate::model::DeleteFleetSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_fleet_state: std::option::Option<crate::model::FleetStateCode>,
        pub(crate) previous_fleet_state: std::option::Option<crate::model::FleetStateCode>,
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of the EC2 Fleet.</p>
        pub fn current_fleet_state(mut self, input: crate::model::FleetStateCode) -> Self {
            self.current_fleet_state = Some(input);
            self
        }
        pub fn set_current_fleet_state(
            mut self,
            input: std::option::Option<crate::model::FleetStateCode>,
        ) -> Self {
            self.current_fleet_state = input;
            self
        }
        /// <p>The previous state of the EC2 Fleet.</p>
        pub fn previous_fleet_state(mut self, input: crate::model::FleetStateCode) -> Self {
            self.previous_fleet_state = Some(input);
            self
        }
        pub fn set_previous_fleet_state(
            mut self,
            input: std::option::Option<crate::model::FleetStateCode>,
        ) -> Self {
            self.previous_fleet_state = input;
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFleetSuccessItem`](crate::model::DeleteFleetSuccessItem)
        pub fn build(self) -> crate::model::DeleteFleetSuccessItem {
            crate::model::DeleteFleetSuccessItem {
                current_fleet_state: self.current_fleet_state,
                previous_fleet_state: self.previous_fleet_state,
                fleet_id: self.fleet_id,
            }
        }
    }
}
impl DeleteFleetSuccessItem {
    /// Creates a new builder-style object to manufacture [`DeleteFleetSuccessItem`](crate::model::DeleteFleetSuccessItem)
    pub fn builder() -> crate::model::delete_fleet_success_item::Builder {
        crate::model::delete_fleet_success_item::Builder::default()
    }
}

/// <p>Describes VPN connection options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnConnectionOptionsSpecification {
    /// <p>Indicate whether to enable acceleration for the VPN connection.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub enable_acceleration: std::option::Option<bool>,
    /// <p>Indicate whether the VPN connection uses static routes only. If you are creating a
    /// VPN connection for a device that does not support BGP, you must specify
    /// <code>true</code>. Use <a>CreateVpnConnectionRoute</a> to create a static route.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub static_routes_only: std::option::Option<bool>,
    /// <p>Indicate whether the VPN tunnels process IPv4 or IPv6 traffic.</p>
    /// <p>Default: <code>ipv4</code>
    /// </p>
    pub tunnel_inside_ip_version: std::option::Option<crate::model::TunnelInsideIpVersion>,
    /// <p>The tunnel options for the VPN connection.</p>
    pub tunnel_options:
        std::option::Option<std::vec::Vec<crate::model::VpnTunnelOptionsSpecification>>,
    /// <p>The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
    /// <p>Default: <code>0.0.0.0/0</code>
    /// </p>
    pub local_ipv4_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv4 CIDR on the AWS side of the VPN connection.</p>
    /// <p>Default: <code>0.0.0.0/0</code>
    /// </p>
    pub remote_ipv4_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
    /// <p>Default: <code>::/0</code>
    /// </p>
    pub local_ipv6_network_cidr: std::option::Option<std::string::String>,
    /// <p>The IPv6 CIDR on the AWS side of the VPN connection.</p>
    /// <p>Default: <code>::/0</code>
    /// </p>
    pub remote_ipv6_network_cidr: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpnConnectionOptionsSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnConnectionOptionsSpecification");
        formatter.field("enable_acceleration", &self.enable_acceleration);
        formatter.field("static_routes_only", &self.static_routes_only);
        formatter.field("tunnel_inside_ip_version", &self.tunnel_inside_ip_version);
        formatter.field("tunnel_options", &self.tunnel_options);
        formatter.field("local_ipv4_network_cidr", &self.local_ipv4_network_cidr);
        formatter.field("remote_ipv4_network_cidr", &self.remote_ipv4_network_cidr);
        formatter.field("local_ipv6_network_cidr", &self.local_ipv6_network_cidr);
        formatter.field("remote_ipv6_network_cidr", &self.remote_ipv6_network_cidr);
        formatter.finish()
    }
}
/// See [`VpnConnectionOptionsSpecification`](crate::model::VpnConnectionOptionsSpecification)
pub mod vpn_connection_options_specification {
    /// A builder for [`VpnConnectionOptionsSpecification`](crate::model::VpnConnectionOptionsSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_acceleration: std::option::Option<bool>,
        pub(crate) static_routes_only: std::option::Option<bool>,
        pub(crate) tunnel_inside_ip_version:
            std::option::Option<crate::model::TunnelInsideIpVersion>,
        pub(crate) tunnel_options:
            std::option::Option<std::vec::Vec<crate::model::VpnTunnelOptionsSpecification>>,
        pub(crate) local_ipv4_network_cidr: std::option::Option<std::string::String>,
        pub(crate) remote_ipv4_network_cidr: std::option::Option<std::string::String>,
        pub(crate) local_ipv6_network_cidr: std::option::Option<std::string::String>,
        pub(crate) remote_ipv6_network_cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicate whether to enable acceleration for the VPN connection.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn enable_acceleration(mut self, input: bool) -> Self {
            self.enable_acceleration = Some(input);
            self
        }
        pub fn set_enable_acceleration(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_acceleration = input;
            self
        }
        /// <p>Indicate whether the VPN connection uses static routes only. If you are creating a
        /// VPN connection for a device that does not support BGP, you must specify
        /// <code>true</code>. Use <a>CreateVpnConnectionRoute</a> to create a static route.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn static_routes_only(mut self, input: bool) -> Self {
            self.static_routes_only = Some(input);
            self
        }
        pub fn set_static_routes_only(mut self, input: std::option::Option<bool>) -> Self {
            self.static_routes_only = input;
            self
        }
        /// <p>Indicate whether the VPN tunnels process IPv4 or IPv6 traffic.</p>
        /// <p>Default: <code>ipv4</code>
        /// </p>
        pub fn tunnel_inside_ip_version(
            mut self,
            input: crate::model::TunnelInsideIpVersion,
        ) -> Self {
            self.tunnel_inside_ip_version = Some(input);
            self
        }
        pub fn set_tunnel_inside_ip_version(
            mut self,
            input: std::option::Option<crate::model::TunnelInsideIpVersion>,
        ) -> Self {
            self.tunnel_inside_ip_version = input;
            self
        }
        pub fn tunnel_options(
            mut self,
            input: impl Into<crate::model::VpnTunnelOptionsSpecification>,
        ) -> Self {
            let mut v = self.tunnel_options.unwrap_or_default();
            v.push(input.into());
            self.tunnel_options = Some(v);
            self
        }
        pub fn set_tunnel_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpnTunnelOptionsSpecification>>,
        ) -> Self {
            self.tunnel_options = input;
            self
        }
        /// <p>The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        /// <p>Default: <code>0.0.0.0/0</code>
        /// </p>
        pub fn local_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_ipv4_network_cidr = Some(input.into());
            self
        }
        pub fn set_local_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_ipv4_network_cidr = input;
            self
        }
        /// <p>The IPv4 CIDR on the AWS side of the VPN connection.</p>
        /// <p>Default: <code>0.0.0.0/0</code>
        /// </p>
        pub fn remote_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.remote_ipv4_network_cidr = Some(input.into());
            self
        }
        pub fn set_remote_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_ipv4_network_cidr = input;
            self
        }
        /// <p>The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        /// <p>Default: <code>::/0</code>
        /// </p>
        pub fn local_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_ipv6_network_cidr = Some(input.into());
            self
        }
        pub fn set_local_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.local_ipv6_network_cidr = input;
            self
        }
        /// <p>The IPv6 CIDR on the AWS side of the VPN connection.</p>
        /// <p>Default: <code>::/0</code>
        /// </p>
        pub fn remote_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.remote_ipv6_network_cidr = Some(input.into());
            self
        }
        pub fn set_remote_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_ipv6_network_cidr = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnConnectionOptionsSpecification`](crate::model::VpnConnectionOptionsSpecification)
        pub fn build(self) -> crate::model::VpnConnectionOptionsSpecification {
            crate::model::VpnConnectionOptionsSpecification {
                enable_acceleration: self.enable_acceleration,
                static_routes_only: self.static_routes_only,
                tunnel_inside_ip_version: self.tunnel_inside_ip_version,
                tunnel_options: self.tunnel_options,
                local_ipv4_network_cidr: self.local_ipv4_network_cidr,
                remote_ipv4_network_cidr: self.remote_ipv4_network_cidr,
                local_ipv6_network_cidr: self.local_ipv6_network_cidr,
                remote_ipv6_network_cidr: self.remote_ipv6_network_cidr,
            }
        }
    }
}
impl VpnConnectionOptionsSpecification {
    /// Creates a new builder-style object to manufacture [`VpnConnectionOptionsSpecification`](crate::model::VpnConnectionOptionsSpecification)
    pub fn builder() -> crate::model::vpn_connection_options_specification::Builder {
        crate::model::vpn_connection_options_specification::Builder::default()
    }
}

/// <p>The tunnel options for a single VPN tunnel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpnTunnelOptionsSpecification {
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique
    /// across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The
    /// following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>169.254.0.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.1.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.2.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.3.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.4.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.5.0/30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>169.254.169.252/30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub tunnel_inside_cidr: std::option::Option<std::string::String>,
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private
    /// gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores
    /// (_). Must be between 8 and 64 characters in length and cannot start with zero
    /// (0).</p>
    pub pre_shared_key: std::option::Option<std::string::String>,
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code>
    /// </p>
    pub phase1_lifetime_seconds: std::option::Option<i32>,
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code>
    /// </p>
    pub phase2_lifetime_seconds: std::option::Option<i32>,
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code>
    /// </p>
    pub rekey_margin_time_seconds: std::option::Option<i32>,
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code>
    /// </p>
    pub rekey_fuzz_percentage: std::option::Option<i32>,
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code>
    /// </p>
    pub replay_window_size: std::option::Option<i32>,
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value between 0 and 30.</p>
    /// <p>Default: <code>30</code>
    /// </p>
    pub dpd_timeout_seconds: std::option::Option<i32>,
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code>
    /// </p>
    /// <p>Default: <code>clear</code>
    /// </p>
    pub dpd_timeout_action: std::option::Option<std::string::String>,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code>
    /// </p>
    pub phase1_encryption_algorithms: std::option::Option<
        std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
    >,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code>
    /// </p>
    pub phase2_encryption_algorithms: std::option::Option<
        std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
    >,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code>
    /// </p>
    pub phase1_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code>
    /// </p>
    pub phase2_integrity_algorithms:
        std::option::Option<std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code>
    /// </p>
    pub phase1_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code>
    /// </p>
    pub phase2_dh_group_numbers:
        std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>>,
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code>
    /// </p>
    pub ike_versions: std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for AWS to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code>
    /// </p>
    /// <p>Default: <code>add</code>
    /// </p>
    pub startup_action: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpnTunnelOptionsSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpnTunnelOptionsSpecification");
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.field("tunnel_inside_ipv6_cidr", &self.tunnel_inside_ipv6_cidr);
        formatter.field("pre_shared_key", &self.pre_shared_key);
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("dpd_timeout_action", &self.dpd_timeout_action);
        formatter.field(
            "phase1_encryption_algorithms",
            &self.phase1_encryption_algorithms,
        );
        formatter.field(
            "phase2_encryption_algorithms",
            &self.phase2_encryption_algorithms,
        );
        formatter.field(
            "phase1_integrity_algorithms",
            &self.phase1_integrity_algorithms,
        );
        formatter.field(
            "phase2_integrity_algorithms",
            &self.phase2_integrity_algorithms,
        );
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("startup_action", &self.startup_action);
        formatter.finish()
    }
}
/// See [`VpnTunnelOptionsSpecification`](crate::model::VpnTunnelOptionsSpecification)
pub mod vpn_tunnel_options_specification {
    /// A builder for [`VpnTunnelOptionsSpecification`](crate::model::VpnTunnelOptionsSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tunnel_inside_cidr: std::option::Option<std::string::String>,
        pub(crate) tunnel_inside_ipv6_cidr: std::option::Option<std::string::String>,
        pub(crate) pre_shared_key: std::option::Option<std::string::String>,
        pub(crate) phase1_lifetime_seconds: std::option::Option<i32>,
        pub(crate) phase2_lifetime_seconds: std::option::Option<i32>,
        pub(crate) rekey_margin_time_seconds: std::option::Option<i32>,
        pub(crate) rekey_fuzz_percentage: std::option::Option<i32>,
        pub(crate) replay_window_size: std::option::Option<i32>,
        pub(crate) dpd_timeout_seconds: std::option::Option<i32>,
        pub(crate) dpd_timeout_action: std::option::Option<std::string::String>,
        pub(crate) phase1_encryption_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
        >,
        pub(crate) phase2_encryption_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
        >,
        pub(crate) phase1_integrity_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
        >,
        pub(crate) phase2_integrity_algorithms: std::option::Option<
            std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
        >,
        pub(crate) phase1_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>>,
        pub(crate) phase2_dh_group_numbers:
            std::option::Option<std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>>,
        pub(crate) ike_versions:
            std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
        pub(crate) startup_action: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique
        /// across all VPN connections that use the same virtual private gateway. </p>
        /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The
        /// following CIDR blocks are reserved and cannot be used:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>169.254.0.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.1.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.2.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.3.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.4.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.5.0/30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>169.254.169.252/30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn tunnel_inside_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_cidr = input;
            self
        }
        /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
        /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
        pub fn tunnel_inside_ipv6_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.tunnel_inside_ipv6_cidr = Some(input.into());
            self
        }
        pub fn set_tunnel_inside_ipv6_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tunnel_inside_ipv6_cidr = input;
            self
        }
        /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private
        /// gateway and customer gateway.</p>
        /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores
        /// (_). Must be between 8 and 64 characters in length and cannot start with zero
        /// (0).</p>
        pub fn pre_shared_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_shared_key = Some(input.into());
            self
        }
        pub fn set_pre_shared_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_shared_key = input;
            self
        }
        /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
        /// <p>Constraints: A value between 900 and 28,800.</p>
        /// <p>Default: <code>28800</code>
        /// </p>
        pub fn phase1_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase1_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase1_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase1_lifetime_seconds = input;
            self
        }
        /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
        /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
        /// <p>Default: <code>3600</code>
        /// </p>
        pub fn phase2_lifetime_seconds(mut self, input: i32) -> Self {
            self.phase2_lifetime_seconds = Some(input);
            self
        }
        pub fn set_phase2_lifetime_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.phase2_lifetime_seconds = input;
            self
        }
        /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
        /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
        /// <p>Default: <code>540</code>
        /// </p>
        pub fn rekey_margin_time_seconds(mut self, input: i32) -> Self {
            self.rekey_margin_time_seconds = Some(input);
            self
        }
        pub fn set_rekey_margin_time_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_margin_time_seconds = input;
            self
        }
        /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
        /// <p>Constraints: A value between 0 and 100.</p>
        /// <p>Default: <code>100</code>
        /// </p>
        pub fn rekey_fuzz_percentage(mut self, input: i32) -> Self {
            self.rekey_fuzz_percentage = Some(input);
            self
        }
        pub fn set_rekey_fuzz_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.rekey_fuzz_percentage = input;
            self
        }
        /// <p>The number of packets in an IKE replay window.</p>
        /// <p>Constraints: A value between 64 and 2048.</p>
        /// <p>Default: <code>1024</code>
        /// </p>
        pub fn replay_window_size(mut self, input: i32) -> Self {
            self.replay_window_size = Some(input);
            self
        }
        pub fn set_replay_window_size(mut self, input: std::option::Option<i32>) -> Self {
            self.replay_window_size = input;
            self
        }
        /// <p>The number of seconds after which a DPD timeout occurs.</p>
        /// <p>Constraints: A value between 0 and 30.</p>
        /// <p>Default: <code>30</code>
        /// </p>
        pub fn dpd_timeout_seconds(mut self, input: i32) -> Self {
            self.dpd_timeout_seconds = Some(input);
            self
        }
        pub fn set_dpd_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.dpd_timeout_seconds = input;
            self
        }
        /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
        /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code>
        /// </p>
        /// <p>Default: <code>clear</code>
        /// </p>
        pub fn dpd_timeout_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.dpd_timeout_action = Some(input.into());
            self
        }
        pub fn set_dpd_timeout_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dpd_timeout_action = input;
            self
        }
        pub fn phase1_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase1_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1EncryptionAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase1_encryption_algorithms = input;
            self
        }
        pub fn phase2_encryption_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_encryption_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_encryption_algorithms = Some(v);
            self
        }
        pub fn set_phase2_encryption_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2EncryptionAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase2_encryption_algorithms = input;
            self
        }
        pub fn phase1_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase1_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase1_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1IntegrityAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase1_integrity_algorithms = input;
            self
        }
        pub fn phase2_integrity_algorithms(
            mut self,
            input: impl Into<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_integrity_algorithms.unwrap_or_default();
            v.push(input.into());
            self.phase2_integrity_algorithms = Some(v);
            self
        }
        pub fn set_phase2_integrity_algorithms(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2IntegrityAlgorithmsRequestListValue>,
            >,
        ) -> Self {
            self.phase2_integrity_algorithms = input;
            self
        }
        pub fn phase1_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase1DhGroupNumbersRequestListValue>,
        ) -> Self {
            let mut v = self.phase1_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase1_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase1_dh_group_numbers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase1DhGroupNumbersRequestListValue>,
            >,
        ) -> Self {
            self.phase1_dh_group_numbers = input;
            self
        }
        pub fn phase2_dh_group_numbers(
            mut self,
            input: impl Into<crate::model::Phase2DhGroupNumbersRequestListValue>,
        ) -> Self {
            let mut v = self.phase2_dh_group_numbers.unwrap_or_default();
            v.push(input.into());
            self.phase2_dh_group_numbers = Some(v);
            self
        }
        pub fn set_phase2_dh_group_numbers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::Phase2DhGroupNumbersRequestListValue>,
            >,
        ) -> Self {
            self.phase2_dh_group_numbers = input;
            self
        }
        pub fn ike_versions(
            mut self,
            input: impl Into<crate::model::IkeVersionsRequestListValue>,
        ) -> Self {
            let mut v = self.ike_versions.unwrap_or_default();
            v.push(input.into());
            self.ike_versions = Some(v);
            self
        }
        pub fn set_ike_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IkeVersionsRequestListValue>>,
        ) -> Self {
            self.ike_versions = input;
            self
        }
        /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for AWS to initiate the IKE negotiation.</p>
        /// <p>Valid Values: <code>add</code> | <code>start</code>
        /// </p>
        /// <p>Default: <code>add</code>
        /// </p>
        pub fn startup_action(mut self, input: impl Into<std::string::String>) -> Self {
            self.startup_action = Some(input.into());
            self
        }
        pub fn set_startup_action(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.startup_action = input;
            self
        }
        /// Consumes the builder and constructs a [`VpnTunnelOptionsSpecification`](crate::model::VpnTunnelOptionsSpecification)
        pub fn build(self) -> crate::model::VpnTunnelOptionsSpecification {
            crate::model::VpnTunnelOptionsSpecification {
                tunnel_inside_cidr: self.tunnel_inside_cidr,
                tunnel_inside_ipv6_cidr: self.tunnel_inside_ipv6_cidr,
                pre_shared_key: self.pre_shared_key,
                phase1_lifetime_seconds: self.phase1_lifetime_seconds,
                phase2_lifetime_seconds: self.phase2_lifetime_seconds,
                rekey_margin_time_seconds: self.rekey_margin_time_seconds,
                rekey_fuzz_percentage: self.rekey_fuzz_percentage,
                replay_window_size: self.replay_window_size,
                dpd_timeout_seconds: self.dpd_timeout_seconds,
                dpd_timeout_action: self.dpd_timeout_action,
                phase1_encryption_algorithms: self.phase1_encryption_algorithms,
                phase2_encryption_algorithms: self.phase2_encryption_algorithms,
                phase1_integrity_algorithms: self.phase1_integrity_algorithms,
                phase2_integrity_algorithms: self.phase2_integrity_algorithms,
                phase1_dh_group_numbers: self.phase1_dh_group_numbers,
                phase2_dh_group_numbers: self.phase2_dh_group_numbers,
                ike_versions: self.ike_versions,
                startup_action: self.startup_action,
            }
        }
    }
}
impl VpnTunnelOptionsSpecification {
    /// Creates a new builder-style object to manufacture [`VpnTunnelOptionsSpecification`](crate::model::VpnTunnelOptionsSpecification)
    pub fn builder() -> crate::model::vpn_tunnel_options_specification::Builder {
        crate::model::vpn_tunnel_options_specification::Builder::default()
    }
}

/// <p>Describes the options for a VPC attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTransitGatewayVpcAttachmentRequestOptions {
    /// <p>Enable or disable DNS support. The default is <code>enable</code>.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Enable or disable IPv6 support.  The default is <code>disable</code>.</p>
    pub ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
    /// <p>Enable or disable support for appliance mode. If enabled, a traffic flow between a source and destination uses the same Availability Zone for the VPC attachment for the lifetime of that flow. The default is <code>disable</code>.</p>
    pub appliance_mode_support: std::option::Option<crate::model::ApplianceModeSupportValue>,
}
impl std::fmt::Debug for CreateTransitGatewayVpcAttachmentRequestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTransitGatewayVpcAttachmentRequestOptions");
        formatter.field("dns_support", &self.dns_support);
        formatter.field("ipv6_support", &self.ipv6_support);
        formatter.field("appliance_mode_support", &self.appliance_mode_support);
        formatter.finish()
    }
}
/// See [`CreateTransitGatewayVpcAttachmentRequestOptions`](crate::model::CreateTransitGatewayVpcAttachmentRequestOptions)
pub mod create_transit_gateway_vpc_attachment_request_options {
    /// A builder for [`CreateTransitGatewayVpcAttachmentRequestOptions`](crate::model::CreateTransitGatewayVpcAttachmentRequestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) ipv6_support: std::option::Option<crate::model::Ipv6SupportValue>,
        pub(crate) appliance_mode_support:
            std::option::Option<crate::model::ApplianceModeSupportValue>,
    }
    impl Builder {
        /// <p>Enable or disable DNS support. The default is <code>enable</code>.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Enable or disable IPv6 support.  The default is <code>disable</code>.</p>
        pub fn ipv6_support(mut self, input: crate::model::Ipv6SupportValue) -> Self {
            self.ipv6_support = Some(input);
            self
        }
        pub fn set_ipv6_support(
            mut self,
            input: std::option::Option<crate::model::Ipv6SupportValue>,
        ) -> Self {
            self.ipv6_support = input;
            self
        }
        /// <p>Enable or disable support for appliance mode. If enabled, a traffic flow between a source and destination uses the same Availability Zone for the VPC attachment for the lifetime of that flow. The default is <code>disable</code>.</p>
        pub fn appliance_mode_support(
            mut self,
            input: crate::model::ApplianceModeSupportValue,
        ) -> Self {
            self.appliance_mode_support = Some(input);
            self
        }
        pub fn set_appliance_mode_support(
            mut self,
            input: std::option::Option<crate::model::ApplianceModeSupportValue>,
        ) -> Self {
            self.appliance_mode_support = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTransitGatewayVpcAttachmentRequestOptions`](crate::model::CreateTransitGatewayVpcAttachmentRequestOptions)
        pub fn build(self) -> crate::model::CreateTransitGatewayVpcAttachmentRequestOptions {
            crate::model::CreateTransitGatewayVpcAttachmentRequestOptions {
                dns_support: self.dns_support,
                ipv6_support: self.ipv6_support,
                appliance_mode_support: self.appliance_mode_support,
            }
        }
    }
}
impl CreateTransitGatewayVpcAttachmentRequestOptions {
    /// Creates a new builder-style object to manufacture [`CreateTransitGatewayVpcAttachmentRequestOptions`](crate::model::CreateTransitGatewayVpcAttachmentRequestOptions)
    pub fn builder() -> crate::model::create_transit_gateway_vpc_attachment_request_options::Builder
    {
        crate::model::create_transit_gateway_vpc_attachment_request_options::Builder::default()
    }
}

/// <p>The options for the transit gateway multicast domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTransitGatewayMulticastDomainRequestOptions {
    /// <p>Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.</p>
    pub igmpv2_support: std::option::Option<crate::model::Igmpv2SupportValue>,
    /// <p>Specify whether to enable support for statically configuring multicast group sources for a domain.</p>
    pub static_sources_support: std::option::Option<crate::model::StaticSourcesSupportValue>,
    /// <p>Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.</p>
    pub auto_accept_shared_associations:
        std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
}
impl std::fmt::Debug for CreateTransitGatewayMulticastDomainRequestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTransitGatewayMulticastDomainRequestOptions");
        formatter.field("igmpv2_support", &self.igmpv2_support);
        formatter.field("static_sources_support", &self.static_sources_support);
        formatter.field(
            "auto_accept_shared_associations",
            &self.auto_accept_shared_associations,
        );
        formatter.finish()
    }
}
/// See [`CreateTransitGatewayMulticastDomainRequestOptions`](crate::model::CreateTransitGatewayMulticastDomainRequestOptions)
pub mod create_transit_gateway_multicast_domain_request_options {
    /// A builder for [`CreateTransitGatewayMulticastDomainRequestOptions`](crate::model::CreateTransitGatewayMulticastDomainRequestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) igmpv2_support: std::option::Option<crate::model::Igmpv2SupportValue>,
        pub(crate) static_sources_support:
            std::option::Option<crate::model::StaticSourcesSupportValue>,
        pub(crate) auto_accept_shared_associations:
            std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
    }
    impl Builder {
        /// <p>Specify whether to enable Internet Group Management Protocol (IGMP) version 2 for the transit gateway multicast domain.</p>
        pub fn igmpv2_support(mut self, input: crate::model::Igmpv2SupportValue) -> Self {
            self.igmpv2_support = Some(input);
            self
        }
        pub fn set_igmpv2_support(
            mut self,
            input: std::option::Option<crate::model::Igmpv2SupportValue>,
        ) -> Self {
            self.igmpv2_support = input;
            self
        }
        /// <p>Specify whether to enable support for statically configuring multicast group sources for a domain.</p>
        pub fn static_sources_support(
            mut self,
            input: crate::model::StaticSourcesSupportValue,
        ) -> Self {
            self.static_sources_support = Some(input);
            self
        }
        pub fn set_static_sources_support(
            mut self,
            input: std::option::Option<crate::model::StaticSourcesSupportValue>,
        ) -> Self {
            self.static_sources_support = input;
            self
        }
        /// <p>Indicates whether to automatically accept cross-account subnet associations that are associated with the transit gateway multicast domain.</p>
        pub fn auto_accept_shared_associations(
            mut self,
            input: crate::model::AutoAcceptSharedAssociationsValue,
        ) -> Self {
            self.auto_accept_shared_associations = Some(input);
            self
        }
        pub fn set_auto_accept_shared_associations(
            mut self,
            input: std::option::Option<crate::model::AutoAcceptSharedAssociationsValue>,
        ) -> Self {
            self.auto_accept_shared_associations = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTransitGatewayMulticastDomainRequestOptions`](crate::model::CreateTransitGatewayMulticastDomainRequestOptions)
        pub fn build(self) -> crate::model::CreateTransitGatewayMulticastDomainRequestOptions {
            crate::model::CreateTransitGatewayMulticastDomainRequestOptions {
                igmpv2_support: self.igmpv2_support,
                static_sources_support: self.static_sources_support,
                auto_accept_shared_associations: self.auto_accept_shared_associations,
            }
        }
    }
}
impl CreateTransitGatewayMulticastDomainRequestOptions {
    /// Creates a new builder-style object to manufacture [`CreateTransitGatewayMulticastDomainRequestOptions`](crate::model::CreateTransitGatewayMulticastDomainRequestOptions)
    pub fn builder(
    ) -> crate::model::create_transit_gateway_multicast_domain_request_options::Builder {
        crate::model::create_transit_gateway_multicast_domain_request_options::Builder::default()
    }
}

/// <p>The BGP options for the Connect attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayConnectRequestBgpOptions {
    /// <p>The peer Autonomous System Number (ASN).</p>
    pub peer_asn: std::option::Option<i64>,
}
impl std::fmt::Debug for TransitGatewayConnectRequestBgpOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayConnectRequestBgpOptions");
        formatter.field("peer_asn", &self.peer_asn);
        formatter.finish()
    }
}
/// See [`TransitGatewayConnectRequestBgpOptions`](crate::model::TransitGatewayConnectRequestBgpOptions)
pub mod transit_gateway_connect_request_bgp_options {
    /// A builder for [`TransitGatewayConnectRequestBgpOptions`](crate::model::TransitGatewayConnectRequestBgpOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peer_asn: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The peer Autonomous System Number (ASN).</p>
        pub fn peer_asn(mut self, input: i64) -> Self {
            self.peer_asn = Some(input);
            self
        }
        pub fn set_peer_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.peer_asn = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnectRequestBgpOptions`](crate::model::TransitGatewayConnectRequestBgpOptions)
        pub fn build(self) -> crate::model::TransitGatewayConnectRequestBgpOptions {
            crate::model::TransitGatewayConnectRequestBgpOptions {
                peer_asn: self.peer_asn,
            }
        }
    }
}
impl TransitGatewayConnectRequestBgpOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnectRequestBgpOptions`](crate::model::TransitGatewayConnectRequestBgpOptions)
    pub fn builder() -> crate::model::transit_gateway_connect_request_bgp_options::Builder {
        crate::model::transit_gateway_connect_request_bgp_options::Builder::default()
    }
}

/// <p>The options for a Connect attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTransitGatewayConnectRequestOptions {
    /// <p>The tunnel protocol.</p>
    pub protocol: std::option::Option<crate::model::ProtocolValue>,
}
impl std::fmt::Debug for CreateTransitGatewayConnectRequestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTransitGatewayConnectRequestOptions");
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}
/// See [`CreateTransitGatewayConnectRequestOptions`](crate::model::CreateTransitGatewayConnectRequestOptions)
pub mod create_transit_gateway_connect_request_options {
    /// A builder for [`CreateTransitGatewayConnectRequestOptions`](crate::model::CreateTransitGatewayConnectRequestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ProtocolValue>,
    }
    impl Builder {
        /// <p>The tunnel protocol.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolValue) -> Self {
            self.protocol = Some(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolValue>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTransitGatewayConnectRequestOptions`](crate::model::CreateTransitGatewayConnectRequestOptions)
        pub fn build(self) -> crate::model::CreateTransitGatewayConnectRequestOptions {
            crate::model::CreateTransitGatewayConnectRequestOptions {
                protocol: self.protocol,
            }
        }
    }
}
impl CreateTransitGatewayConnectRequestOptions {
    /// Creates a new builder-style object to manufacture [`CreateTransitGatewayConnectRequestOptions`](crate::model::CreateTransitGatewayConnectRequestOptions)
    pub fn builder() -> crate::model::create_transit_gateway_connect_request_options::Builder {
        crate::model::create_transit_gateway_connect_request_options::Builder::default()
    }
}

/// <p>Describes the options for a transit gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransitGatewayRequestOptions {
    /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
    /// The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs. The default is <code>64512</code>.</p>
    pub amazon_side_asn: std::option::Option<i64>,
    /// <p>Enable or disable automatic acceptance of attachment requests. Disabled by default.</p>
    pub auto_accept_shared_attachments:
        std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
    /// <p>Enable or disable automatic association with the default association route table. Enabled by default.</p>
    pub default_route_table_association:
        std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
    /// <p>Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.</p>
    pub default_route_table_propagation:
        std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
    /// <p>Enable or disable Equal Cost Multipath Protocol support. Enabled by default.</p>
    pub vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
    /// <p>Enable or disable DNS support. Enabled by default.</p>
    pub dns_support: std::option::Option<crate::model::DnsSupportValue>,
    /// <p>Indicates whether multicast is enabled on the transit gateway</p>
    pub multicast_support: std::option::Option<crate::model::MulticastSupportValue>,
    /// <p>One or more IPv4 or IPv6 CIDR blocks for the transit gateway. Must be a size /24 CIDR block or larger for IPv4, or a size /64 CIDR block or larger for IPv6.</p>
    pub transit_gateway_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for TransitGatewayRequestOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransitGatewayRequestOptions");
        formatter.field("amazon_side_asn", &self.amazon_side_asn);
        formatter.field(
            "auto_accept_shared_attachments",
            &self.auto_accept_shared_attachments,
        );
        formatter.field(
            "default_route_table_association",
            &self.default_route_table_association,
        );
        formatter.field(
            "default_route_table_propagation",
            &self.default_route_table_propagation,
        );
        formatter.field("vpn_ecmp_support", &self.vpn_ecmp_support);
        formatter.field("dns_support", &self.dns_support);
        formatter.field("multicast_support", &self.multicast_support);
        formatter.field(
            "transit_gateway_cidr_blocks",
            &self.transit_gateway_cidr_blocks,
        );
        formatter.finish()
    }
}
/// See [`TransitGatewayRequestOptions`](crate::model::TransitGatewayRequestOptions)
pub mod transit_gateway_request_options {
    /// A builder for [`TransitGatewayRequestOptions`](crate::model::TransitGatewayRequestOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amazon_side_asn: std::option::Option<i64>,
        pub(crate) auto_accept_shared_attachments:
            std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        pub(crate) default_route_table_association:
            std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        pub(crate) default_route_table_propagation:
            std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        pub(crate) vpn_ecmp_support: std::option::Option<crate::model::VpnEcmpSupportValue>,
        pub(crate) dns_support: std::option::Option<crate::model::DnsSupportValue>,
        pub(crate) multicast_support: std::option::Option<crate::model::MulticastSupportValue>,
        pub(crate) transit_gateway_cidr_blocks:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        /// The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs. The default is <code>64512</code>.</p>
        pub fn amazon_side_asn(mut self, input: i64) -> Self {
            self.amazon_side_asn = Some(input);
            self
        }
        pub fn set_amazon_side_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.amazon_side_asn = input;
            self
        }
        /// <p>Enable or disable automatic acceptance of attachment requests. Disabled by default.</p>
        pub fn auto_accept_shared_attachments(
            mut self,
            input: crate::model::AutoAcceptSharedAttachmentsValue,
        ) -> Self {
            self.auto_accept_shared_attachments = Some(input);
            self
        }
        pub fn set_auto_accept_shared_attachments(
            mut self,
            input: std::option::Option<crate::model::AutoAcceptSharedAttachmentsValue>,
        ) -> Self {
            self.auto_accept_shared_attachments = input;
            self
        }
        /// <p>Enable or disable automatic association with the default association route table. Enabled by default.</p>
        pub fn default_route_table_association(
            mut self,
            input: crate::model::DefaultRouteTableAssociationValue,
        ) -> Self {
            self.default_route_table_association = Some(input);
            self
        }
        pub fn set_default_route_table_association(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTableAssociationValue>,
        ) -> Self {
            self.default_route_table_association = input;
            self
        }
        /// <p>Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.</p>
        pub fn default_route_table_propagation(
            mut self,
            input: crate::model::DefaultRouteTablePropagationValue,
        ) -> Self {
            self.default_route_table_propagation = Some(input);
            self
        }
        pub fn set_default_route_table_propagation(
            mut self,
            input: std::option::Option<crate::model::DefaultRouteTablePropagationValue>,
        ) -> Self {
            self.default_route_table_propagation = input;
            self
        }
        /// <p>Enable or disable Equal Cost Multipath Protocol support. Enabled by default.</p>
        pub fn vpn_ecmp_support(mut self, input: crate::model::VpnEcmpSupportValue) -> Self {
            self.vpn_ecmp_support = Some(input);
            self
        }
        pub fn set_vpn_ecmp_support(
            mut self,
            input: std::option::Option<crate::model::VpnEcmpSupportValue>,
        ) -> Self {
            self.vpn_ecmp_support = input;
            self
        }
        /// <p>Enable or disable DNS support. Enabled by default.</p>
        pub fn dns_support(mut self, input: crate::model::DnsSupportValue) -> Self {
            self.dns_support = Some(input);
            self
        }
        pub fn set_dns_support(
            mut self,
            input: std::option::Option<crate::model::DnsSupportValue>,
        ) -> Self {
            self.dns_support = input;
            self
        }
        /// <p>Indicates whether multicast is enabled on the transit gateway</p>
        pub fn multicast_support(mut self, input: crate::model::MulticastSupportValue) -> Self {
            self.multicast_support = Some(input);
            self
        }
        pub fn set_multicast_support(
            mut self,
            input: std::option::Option<crate::model::MulticastSupportValue>,
        ) -> Self {
            self.multicast_support = input;
            self
        }
        pub fn transit_gateway_cidr_blocks(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.transit_gateway_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_cidr_blocks = Some(v);
            self
        }
        pub fn set_transit_gateway_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_cidr_blocks = input;
            self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRequestOptions`](crate::model::TransitGatewayRequestOptions)
        pub fn build(self) -> crate::model::TransitGatewayRequestOptions {
            crate::model::TransitGatewayRequestOptions {
                amazon_side_asn: self.amazon_side_asn,
                auto_accept_shared_attachments: self.auto_accept_shared_attachments,
                default_route_table_association: self.default_route_table_association,
                default_route_table_propagation: self.default_route_table_propagation,
                vpn_ecmp_support: self.vpn_ecmp_support,
                dns_support: self.dns_support,
                multicast_support: self.multicast_support,
                transit_gateway_cidr_blocks: self.transit_gateway_cidr_blocks,
            }
        }
    }
}
impl TransitGatewayRequestOptions {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRequestOptions`](crate::model::TransitGatewayRequestOptions)
    pub fn builder() -> crate::model::transit_gateway_request_options::Builder {
        crate::model::transit_gateway_request_options::Builder::default()
    }
}

/// <p>The tags to apply to the AMI object that will be stored in the Amazon S3 bucket. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-tagging.html">Categorizing your storage using
/// tags</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3ObjectTag {
    /// <p>The key of the tag.</p>
    /// <p>Constraints: Tag keys are case-sensitive and can be up to 128 Unicode characters in
    /// length. May not begin with <code>aws</code>:.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    /// <p>Constraints: Tag values are case-sensitive and can be up to 256 Unicode characters in
    /// length.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3ObjectTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3ObjectTag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`S3ObjectTag`](crate::model::S3ObjectTag)
pub mod s3_object_tag {
    /// A builder for [`S3ObjectTag`](crate::model::S3ObjectTag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag.</p>
        /// <p>Constraints: Tag keys are case-sensitive and can be up to 128 Unicode characters in
        /// length. May not begin with <code>aws</code>:.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        /// <p>Constraints: Tag values are case-sensitive and can be up to 256 Unicode characters in
        /// length.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`S3ObjectTag`](crate::model::S3ObjectTag)
        pub fn build(self) -> crate::model::S3ObjectTag {
            crate::model::S3ObjectTag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl S3ObjectTag {
    /// Creates a new builder-style object to manufacture [`S3ObjectTag`](crate::model::S3ObjectTag)
    pub fn builder() -> crate::model::s3_object_tag::Builder {
        crate::model::s3_object_tag::Builder::default()
    }
}

/// <p>Information about a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotInfo {
    /// <p>Description specified by the CreateSnapshotRequest that has been applied to all
    /// snapshots.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Tags associated with this snapshot.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Indicates whether the snapshot is encrypted.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>Source volume from which this snapshot was created.</p>
    pub volume_id: std::option::Option<std::string::String>,
    /// <p>Current state of the snapshot.</p>
    pub state: std::option::Option<crate::model::SnapshotState>,
    /// <p>Size of the volume from which this snapshot was created.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>Time this snapshot was started. This is the same for all snapshots initiated by the
    /// same request.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Progress this snapshot has made towards completing.</p>
    pub progress: std::option::Option<std::string::String>,
    /// <p>Account id used when creating this snapshot.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>Snapshot id that can be used to describe this snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html">Amazon EBS local snapshots on Outposts</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub outpost_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotInfo");
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("volume_id", &self.volume_id);
        formatter.field("state", &self.state);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("start_time", &self.start_time);
        formatter.field("progress", &self.progress);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("outpost_arn", &self.outpost_arn);
        formatter.finish()
    }
}
/// See [`SnapshotInfo`](crate::model::SnapshotInfo)
pub mod snapshot_info {
    /// A builder for [`SnapshotInfo`](crate::model::SnapshotInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) volume_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::SnapshotState>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) progress: std::option::Option<std::string::String>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) outpost_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Description specified by the CreateSnapshotRequest that has been applied to all
        /// snapshots.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Indicates whether the snapshot is encrypted.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>Source volume from which this snapshot was created.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_id = Some(input.into());
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_id = input;
            self
        }
        /// <p>Current state of the snapshot.</p>
        pub fn state(mut self, input: crate::model::SnapshotState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::SnapshotState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Size of the volume from which this snapshot was created.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>Time this snapshot was started. This is the same for all snapshots initiated by the
        /// same request.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Progress this snapshot has made towards completing.</p>
        pub fn progress(mut self, input: impl Into<std::string::String>) -> Self {
            self.progress = Some(input.into());
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.progress = input;
            self
        }
        /// <p>Account id used when creating this snapshot.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>Snapshot id that can be used to describe this snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html">Amazon EBS local snapshots on Outposts</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.outpost_arn = Some(input.into());
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.outpost_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotInfo`](crate::model::SnapshotInfo)
        pub fn build(self) -> crate::model::SnapshotInfo {
            crate::model::SnapshotInfo {
                description: self.description,
                tags: self.tags,
                encrypted: self.encrypted,
                volume_id: self.volume_id,
                state: self.state,
                volume_size: self.volume_size,
                start_time: self.start_time,
                progress: self.progress,
                owner_id: self.owner_id,
                snapshot_id: self.snapshot_id,
                outpost_arn: self.outpost_arn,
            }
        }
    }
}
impl SnapshotInfo {
    /// Creates a new builder-style object to manufacture [`SnapshotInfo`](crate::model::SnapshotInfo)
    pub fn builder() -> crate::model::snapshot_info::Builder {
        crate::model::snapshot_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CopyTagsFromSource {
    Volume,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CopyTagsFromSource {
    fn from(s: &str) -> Self {
        match s {
            "volume" => CopyTagsFromSource::Volume,
            other => CopyTagsFromSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CopyTagsFromSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CopyTagsFromSource::from(s))
    }
}
impl CopyTagsFromSource {
    pub fn as_str(&self) -> &str {
        match self {
            CopyTagsFromSource::Volume => "volume",
            CopyTagsFromSource::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["volume"]
    }
}
impl AsRef<str> for CopyTagsFromSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The instance details to specify which volumes should be snapshotted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceSpecification {
    /// <p>The instance to specify which volumes should be snapshotted.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>Excludes the root volume from being snapshotted.</p>
    pub exclude_boot_volume: std::option::Option<bool>,
}
impl std::fmt::Debug for InstanceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceSpecification");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("exclude_boot_volume", &self.exclude_boot_volume);
        formatter.finish()
    }
}
/// See [`InstanceSpecification`](crate::model::InstanceSpecification)
pub mod instance_specification {
    /// A builder for [`InstanceSpecification`](crate::model::InstanceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) exclude_boot_volume: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The instance to specify which volumes should be snapshotted.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>Excludes the root volume from being snapshotted.</p>
        pub fn exclude_boot_volume(mut self, input: bool) -> Self {
            self.exclude_boot_volume = Some(input);
            self
        }
        pub fn set_exclude_boot_volume(mut self, input: std::option::Option<bool>) -> Self {
            self.exclude_boot_volume = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceSpecification`](crate::model::InstanceSpecification)
        pub fn build(self) -> crate::model::InstanceSpecification {
            crate::model::InstanceSpecification {
                instance_id: self.instance_id,
                exclude_boot_volume: self.exclude_boot_volume,
            }
        }
    }
}
impl InstanceSpecification {
    /// Creates a new builder-style object to manufacture [`InstanceSpecification`](crate::model::InstanceSpecification)
    pub fn builder() -> crate::model::instance_specification::Builder {
        crate::model::instance_specification::Builder::default()
    }
}

/// <p>Describes the price for a Reserved Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PriceScheduleSpecification {
    /// <p>The currency for transacting the Reserved Instance resale.
    /// At this time, the only supported currency is <code>USD</code>.</p>
    pub currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
    /// <p>The fixed price for the term.</p>
    pub price: std::option::Option<f64>,
    /// <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
    pub term: std::option::Option<i64>,
}
impl std::fmt::Debug for PriceScheduleSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PriceScheduleSpecification");
        formatter.field("currency_code", &self.currency_code);
        formatter.field("price", &self.price);
        formatter.field("term", &self.term);
        formatter.finish()
    }
}
/// See [`PriceScheduleSpecification`](crate::model::PriceScheduleSpecification)
pub mod price_schedule_specification {
    /// A builder for [`PriceScheduleSpecification`](crate::model::PriceScheduleSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) currency_code: std::option::Option<crate::model::CurrencyCodeValues>,
        pub(crate) price: std::option::Option<f64>,
        pub(crate) term: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The currency for transacting the Reserved Instance resale.
        /// At this time, the only supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.currency_code = Some(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The fixed price for the term.</p>
        pub fn price(mut self, input: f64) -> Self {
            self.price = Some(input);
            self
        }
        pub fn set_price(mut self, input: std::option::Option<f64>) -> Self {
            self.price = input;
            self
        }
        /// <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
        pub fn term(mut self, input: i64) -> Self {
            self.term = Some(input);
            self
        }
        pub fn set_term(mut self, input: std::option::Option<i64>) -> Self {
            self.term = input;
            self
        }
        /// Consumes the builder and constructs a [`PriceScheduleSpecification`](crate::model::PriceScheduleSpecification)
        pub fn build(self) -> crate::model::PriceScheduleSpecification {
            crate::model::PriceScheduleSpecification {
                currency_code: self.currency_code,
                price: self.price,
                term: self.term,
            }
        }
    }
}
impl PriceScheduleSpecification {
    /// Creates a new builder-style object to manufacture [`PriceScheduleSpecification`](crate::model::PriceScheduleSpecification)
    pub fn builder() -> crate::model::price_schedule_specification::Builder {
        crate::model::price_schedule_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceCreationType {
    Branch,
    Efa,
    Trunk,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NetworkInterfaceCreationType {
    fn from(s: &str) -> Self {
        match s {
            "branch" => NetworkInterfaceCreationType::Branch,
            "efa" => NetworkInterfaceCreationType::Efa,
            "trunk" => NetworkInterfaceCreationType::Trunk,
            other => NetworkInterfaceCreationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NetworkInterfaceCreationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceCreationType::from(s))
    }
}
impl NetworkInterfaceCreationType {
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceCreationType::Branch => "branch",
            NetworkInterfaceCreationType::Efa => "efa",
            NetworkInterfaceCreationType::Trunk => "trunk",
            NetworkInterfaceCreationType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["branch", "efa", "trunk"]
    }
}
impl AsRef<str> for NetworkInterfaceCreationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The error codes and error messages that are returned for the parameters or parameter combinations that are not valid when a new launch template or new version of a launch template is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationWarning {
    /// <p>The error codes and error messages.</p>
    pub errors: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
}
impl std::fmt::Debug for ValidationWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationWarning");
        formatter.field("errors", &self.errors);
        formatter.finish()
    }
}
/// See [`ValidationWarning`](crate::model::ValidationWarning)
pub mod validation_warning {
    /// A builder for [`ValidationWarning`](crate::model::ValidationWarning)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) errors: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
    }
    impl Builder {
        pub fn errors(mut self, input: impl Into<crate::model::ValidationError>) -> Self {
            let mut v = self.errors.unwrap_or_default();
            v.push(input.into());
            self.errors = Some(v);
            self
        }
        pub fn set_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationError>>,
        ) -> Self {
            self.errors = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationWarning`](crate::model::ValidationWarning)
        pub fn build(self) -> crate::model::ValidationWarning {
            crate::model::ValidationWarning {
                errors: self.errors,
            }
        }
    }
}
impl ValidationWarning {
    /// Creates a new builder-style object to manufacture [`ValidationWarning`](crate::model::ValidationWarning)
    pub fn builder() -> crate::model::validation_warning::Builder {
        crate::model::validation_warning::Builder::default()
    }
}

/// <p>The error code and error message that is returned for a parameter or parameter combination that is not valid when a new launch template or new version of a launch template is created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationError {
    /// <p>The error code that indicates why the parameter or parameter combination is not valid. For more information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>The error message that describes why the parameter or parameter combination is not valid. For more
    /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ValidationError`](crate::model::ValidationError)
pub mod validation_error {
    /// A builder for [`ValidationError`](crate::model::ValidationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code that indicates why the parameter or parameter combination is not valid. For more information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message that describes why the parameter or parameter combination is not valid. For more
        /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationError`](crate::model::ValidationError)
        pub fn build(self) -> crate::model::ValidationError {
            crate::model::ValidationError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ValidationError {
    /// Creates a new builder-style object to manufacture [`ValidationError`](crate::model::ValidationError)
    pub fn builder() -> crate::model::validation_error::Builder {
        crate::model::validation_error::Builder::default()
    }
}

/// <p>The information to include in the launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestLaunchTemplateData {
    /// <p>The ID of the kernel.</p>
    /// <important>
    /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided
    /// Kernels</a> in the <i>Amazon Elastic Compute Cloud User
    /// Guide</i>.</p>
    /// </important>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization
    /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
    /// provide optimal Amazon EBS I/O performance. This optimization isn't available with all
    /// instance types. Additional usage charges apply when using an EBS-optimized
    /// instance.</p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>The name or Amazon Resource Name (ARN) of an IAM instance profile.</p>
    pub iam_instance_profile:
        std::option::Option<crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest>,
    /// <p>The block device mapping.</p>
    pub block_device_mappings:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMappingRequest>>,
    /// <p>One or more network interfaces. If you specify a network interface, you must specify
    /// any security groups and subnets as part of the network interface.</p>
    pub network_interfaces: std::option::Option<
        std::vec::Vec<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest>,
    >,
    /// <p>The ID of the AMI.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The name of the key pair. You can create a key pair using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html">CreateKeyPair</a> or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html">ImportKeyPair</a>.</p>
    /// <important>
    /// <p>If you do not specify a key pair, you can't connect to the instance unless you
    /// choose an AMI that is configured to allow users another way to log in.</p>
    /// </important>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>The monitoring for the instance.</p>
    pub monitoring: std::option::Option<crate::model::LaunchTemplatesMonitoringRequest>,
    /// <p>The placement for the instance.</p>
    pub placement: std::option::Option<crate::model::LaunchTemplatePlacementRequest>,
    /// <p>The ID of the RAM disk.</p>
    /// <important>
    /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided
    /// Kernels</a> in the <i>Amazon Elastic Compute Cloud User
    /// Guide</i>.</p>
    /// </important>
    pub ram_disk_id: std::option::Option<std::string::String>,
    /// <p>If you set this parameter to <code>true</code>, you can't terminate the instance using
    /// the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch,
    /// use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>.
    /// Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to
    /// <code>terminate</code>, you can terminate the instance by running the shutdown
    /// command from the instance.</p>
    pub disable_api_termination: std::option::Option<bool>,
    /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from
    /// the instance (using the operating system command for system shutdown).</p>
    /// <p>Default: <code>stop</code>
    /// </p>
    pub instance_initiated_shutdown_behavior: std::option::Option<crate::model::ShutdownBehavior>,
    /// <p>The user data to make available to the instance. You must provide base64-encoded text.
    /// User data is limited to 16 KB. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance
    /// at Launch</a> (Linux) or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows).</p>
    /// <p>If you are creating the launch template for use with Batch, the user data
    /// must be provided in the <a href="https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive">
    /// MIME multi-part archive format</a>.  For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html">Amazon EC2 user data in
    /// launch templates</a> in the <i>Batch User Guide</i>.</p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resources during launch. You can only tag instances and
    /// volumes on launch. The specified tags are applied to all instances or volumes that are
    /// created during launch. To tag a resource after it has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
    pub tag_specifications:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateTagSpecificationRequest>>,
    /// <p>An elastic GPU to associate with the instance.</p>
    pub elastic_gpu_specifications:
        std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecification>>,
    /// <p>
    /// The elastic inference accelerator for the instance.
    /// </p>
    pub elastic_inference_accelerators:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAccelerator>>,
    /// <p>One or more security group IDs. You can create a security group using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html">CreateSecurityGroup</a>. You cannot specify both a security group ID and
    /// security name in the same request.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC,
    /// you must use security group IDs instead. You cannot specify both a security group ID and
    /// security name in the same request.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The market (purchasing) option for the instances.</p>
    pub instance_market_options:
        std::option::Option<crate::model::LaunchTemplateInstanceMarketOptionsRequest>,
    /// <p>The credit option for CPU usage of the instance. Valid for T2, T3, or T3a instances
    /// only.</p>
    pub credit_specification: std::option::Option<crate::model::CreditSpecificationRequest>,
    /// <p>The CPU options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User
    /// Guide</i>.</p>
    pub cpu_options: std::option::Option<crate::model::LaunchTemplateCpuOptionsRequest>,
    /// <p>The Capacity Reservation targeting option. If you do not specify this parameter, the
    /// instance's Capacity Reservation preference defaults to <code>open</code>, which enables it
    /// to run in any open Capacity Reservation that has matching attributes (instance type,
    /// platform, Availability Zone).</p>
    pub capacity_reservation_specification:
        std::option::Option<crate::model::LaunchTemplateCapacityReservationSpecificationRequest>,
    /// <p>The license configurations.</p>
    pub license_specifications:
        std::option::Option<std::vec::Vec<crate::model::LaunchTemplateLicenseConfigurationRequest>>,
    /// <p>Indicates whether an instance is enabled for hibernation. This parameter is valid only
    /// if the instance meets the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites">hibernation
    /// prerequisites</a>. For
    /// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate your instance</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub hibernation_options:
        std::option::Option<crate::model::LaunchTemplateHibernationOptionsRequest>,
    /// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub metadata_options:
        std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsRequest>,
    /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information,
    /// see <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html">
    /// What is Amazon Web Services Nitro Enclaves?</a> in the <i>Amazon Web Services Nitro Enclaves User Guide</i>.</p>    
    /// <p>You can't enable Amazon Web Services Nitro Enclaves and hibernation on the same instance.</p>
    pub enclave_options: std::option::Option<crate::model::LaunchTemplateEnclaveOptionsRequest>,
}
impl std::fmt::Debug for RequestLaunchTemplateData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestLaunchTemplateData");
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("placement", &self.placement);
        formatter.field("ram_disk_id", &self.ram_disk_id);
        formatter.field("disable_api_termination", &self.disable_api_termination);
        formatter.field(
            "instance_initiated_shutdown_behavior",
            &self.instance_initiated_shutdown_behavior,
        );
        formatter.field("user_data", &self.user_data);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.field(
            "elastic_gpu_specifications",
            &self.elastic_gpu_specifications,
        );
        formatter.field(
            "elastic_inference_accelerators",
            &self.elastic_inference_accelerators,
        );
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("instance_market_options", &self.instance_market_options);
        formatter.field("credit_specification", &self.credit_specification);
        formatter.field("cpu_options", &self.cpu_options);
        formatter.field(
            "capacity_reservation_specification",
            &self.capacity_reservation_specification,
        );
        formatter.field("license_specifications", &self.license_specifications);
        formatter.field("hibernation_options", &self.hibernation_options);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.field("enclave_options", &self.enclave_options);
        formatter.finish()
    }
}
/// See [`RequestLaunchTemplateData`](crate::model::RequestLaunchTemplateData)
pub mod request_launch_template_data {
    /// A builder for [`RequestLaunchTemplateData`](crate::model::RequestLaunchTemplateData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) iam_instance_profile:
            std::option::Option<crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest>,
        pub(crate) block_device_mappings: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMappingRequest>,
        >,
        pub(crate) network_interfaces: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest>,
        >,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) monitoring: std::option::Option<crate::model::LaunchTemplatesMonitoringRequest>,
        pub(crate) placement: std::option::Option<crate::model::LaunchTemplatePlacementRequest>,
        pub(crate) ram_disk_id: std::option::Option<std::string::String>,
        pub(crate) disable_api_termination: std::option::Option<bool>,
        pub(crate) instance_initiated_shutdown_behavior:
            std::option::Option<crate::model::ShutdownBehavior>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) tag_specifications:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateTagSpecificationRequest>>,
        pub(crate) elastic_gpu_specifications:
            std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecification>>,
        pub(crate) elastic_inference_accelerators: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAccelerator>,
        >,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_market_options:
            std::option::Option<crate::model::LaunchTemplateInstanceMarketOptionsRequest>,
        pub(crate) credit_specification:
            std::option::Option<crate::model::CreditSpecificationRequest>,
        pub(crate) cpu_options: std::option::Option<crate::model::LaunchTemplateCpuOptionsRequest>,
        pub(crate) capacity_reservation_specification: std::option::Option<
            crate::model::LaunchTemplateCapacityReservationSpecificationRequest,
        >,
        pub(crate) license_specifications: std::option::Option<
            std::vec::Vec<crate::model::LaunchTemplateLicenseConfigurationRequest>,
        >,
        pub(crate) hibernation_options:
            std::option::Option<crate::model::LaunchTemplateHibernationOptionsRequest>,
        pub(crate) metadata_options:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsRequest>,
        pub(crate) enclave_options:
            std::option::Option<crate::model::LaunchTemplateEnclaveOptionsRequest>,
    }
    impl Builder {
        /// <p>The ID of the kernel.</p>
        /// <important>
        /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided
        /// Kernels</a> in the <i>Amazon Elastic Compute Cloud User
        /// Guide</i>.</p>
        /// </important>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization
        /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
        /// provide optimal Amazon EBS I/O performance. This optimization isn't available with all
        /// instance types. Additional usage charges apply when using an EBS-optimized
        /// instance.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of an IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest,
        ) -> Self {
            self.iam_instance_profile = Some(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<
                crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest,
            >,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::LaunchTemplateBlockDeviceMappingRequest>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateBlockDeviceMappingRequest>,
            >,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<
                    crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest,
                >,
            >,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The name of the key pair. You can create a key pair using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html">CreateKeyPair</a> or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html">ImportKeyPair</a>.</p>
        /// <important>
        /// <p>If you do not specify a key pair, you can't connect to the instance unless you
        /// choose an AMI that is configured to allow users another way to log in.</p>
        /// </important>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        /// <p>The monitoring for the instance.</p>
        pub fn monitoring(mut self, input: crate::model::LaunchTemplatesMonitoringRequest) -> Self {
            self.monitoring = Some(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplatesMonitoringRequest>,
        ) -> Self {
            self.monitoring = input;
            self
        }
        /// <p>The placement for the instance.</p>
        pub fn placement(mut self, input: crate::model::LaunchTemplatePlacementRequest) -> Self {
            self.placement = Some(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplatePlacementRequest>,
        ) -> Self {
            self.placement = input;
            self
        }
        /// <p>The ID of the RAM disk.</p>
        /// <important>
        /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided
        /// Kernels</a> in the <i>Amazon Elastic Compute Cloud User
        /// Guide</i>.</p>
        /// </important>
        pub fn ram_disk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ram_disk_id = Some(input.into());
            self
        }
        pub fn set_ram_disk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ram_disk_id = input;
            self
        }
        /// <p>If you set this parameter to <code>true</code>, you can't terminate the instance using
        /// the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch,
        /// use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>.
        /// Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to
        /// <code>terminate</code>, you can terminate the instance by running the shutdown
        /// command from the instance.</p>
        pub fn disable_api_termination(mut self, input: bool) -> Self {
            self.disable_api_termination = Some(input);
            self
        }
        pub fn set_disable_api_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_api_termination = input;
            self
        }
        /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from
        /// the instance (using the operating system command for system shutdown).</p>
        /// <p>Default: <code>stop</code>
        /// </p>
        pub fn instance_initiated_shutdown_behavior(
            mut self,
            input: crate::model::ShutdownBehavior,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = Some(input);
            self
        }
        pub fn set_instance_initiated_shutdown_behavior(
            mut self,
            input: std::option::Option<crate::model::ShutdownBehavior>,
        ) -> Self {
            self.instance_initiated_shutdown_behavior = input;
            self
        }
        /// <p>The user data to make available to the instance. You must provide base64-encoded text.
        /// User data is limited to 16 KB. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance
        /// at Launch</a> (Linux) or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows).</p>
        /// <p>If you are creating the launch template for use with Batch, the user data
        /// must be provided in the <a href="https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive">
        /// MIME multi-part archive format</a>.  For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html">Amazon EC2 user data in
        /// launch templates</a> in the <i>Batch User Guide</i>.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        pub fn tag_specifications(
            mut self,
            input: impl Into<crate::model::LaunchTemplateTagSpecificationRequest>,
        ) -> Self {
            let mut v = self.tag_specifications.unwrap_or_default();
            v.push(input.into());
            self.tag_specifications = Some(v);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateTagSpecificationRequest>,
            >,
        ) -> Self {
            self.tag_specifications = input;
            self
        }
        pub fn elastic_gpu_specifications(
            mut self,
            input: impl Into<crate::model::ElasticGpuSpecification>,
        ) -> Self {
            let mut v = self.elastic_gpu_specifications.unwrap_or_default();
            v.push(input.into());
            self.elastic_gpu_specifications = Some(v);
            self
        }
        pub fn set_elastic_gpu_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecification>>,
        ) -> Self {
            self.elastic_gpu_specifications = input;
            self
        }
        pub fn elastic_inference_accelerators(
            mut self,
            input: impl Into<crate::model::LaunchTemplateElasticInferenceAccelerator>,
        ) -> Self {
            let mut v = self.elastic_inference_accelerators.unwrap_or_default();
            v.push(input.into());
            self.elastic_inference_accelerators = Some(v);
            self
        }
        pub fn set_elastic_inference_accelerators(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateElasticInferenceAccelerator>,
            >,
        ) -> Self {
            self.elastic_inference_accelerators = input;
            self
        }
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The market (purchasing) option for the instances.</p>
        pub fn instance_market_options(
            mut self,
            input: crate::model::LaunchTemplateInstanceMarketOptionsRequest,
        ) -> Self {
            self.instance_market_options = Some(input);
            self
        }
        pub fn set_instance_market_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMarketOptionsRequest>,
        ) -> Self {
            self.instance_market_options = input;
            self
        }
        /// <p>The credit option for CPU usage of the instance. Valid for T2, T3, or T3a instances
        /// only.</p>
        pub fn credit_specification(
            mut self,
            input: crate::model::CreditSpecificationRequest,
        ) -> Self {
            self.credit_specification = Some(input);
            self
        }
        pub fn set_credit_specification(
            mut self,
            input: std::option::Option<crate::model::CreditSpecificationRequest>,
        ) -> Self {
            self.credit_specification = input;
            self
        }
        /// <p>The CPU options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User
        /// Guide</i>.</p>
        pub fn cpu_options(mut self, input: crate::model::LaunchTemplateCpuOptionsRequest) -> Self {
            self.cpu_options = Some(input);
            self
        }
        pub fn set_cpu_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateCpuOptionsRequest>,
        ) -> Self {
            self.cpu_options = input;
            self
        }
        /// <p>The Capacity Reservation targeting option. If you do not specify this parameter, the
        /// instance's Capacity Reservation preference defaults to <code>open</code>, which enables it
        /// to run in any open Capacity Reservation that has matching attributes (instance type,
        /// platform, Availability Zone).</p>
        pub fn capacity_reservation_specification(
            mut self,
            input: crate::model::LaunchTemplateCapacityReservationSpecificationRequest,
        ) -> Self {
            self.capacity_reservation_specification = Some(input);
            self
        }
        pub fn set_capacity_reservation_specification(
            mut self,
            input: std::option::Option<
                crate::model::LaunchTemplateCapacityReservationSpecificationRequest,
            >,
        ) -> Self {
            self.capacity_reservation_specification = input;
            self
        }
        pub fn license_specifications(
            mut self,
            input: impl Into<crate::model::LaunchTemplateLicenseConfigurationRequest>,
        ) -> Self {
            let mut v = self.license_specifications.unwrap_or_default();
            v.push(input.into());
            self.license_specifications = Some(v);
            self
        }
        pub fn set_license_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchTemplateLicenseConfigurationRequest>,
            >,
        ) -> Self {
            self.license_specifications = input;
            self
        }
        /// <p>Indicates whether an instance is enabled for hibernation. This parameter is valid only
        /// if the instance meets the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites">hibernation
        /// prerequisites</a>. For
        /// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate your instance</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn hibernation_options(
            mut self,
            input: crate::model::LaunchTemplateHibernationOptionsRequest,
        ) -> Self {
            self.hibernation_options = Some(input);
            self
        }
        pub fn set_hibernation_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateHibernationOptionsRequest>,
        ) -> Self {
            self.hibernation_options = input;
            self
        }
        /// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn metadata_options(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataOptionsRequest,
        ) -> Self {
            self.metadata_options = Some(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataOptionsRequest>,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information,
        /// see <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html">
        /// What is Amazon Web Services Nitro Enclaves?</a> in the <i>Amazon Web Services Nitro Enclaves User Guide</i>.</p>    
        /// <p>You can't enable Amazon Web Services Nitro Enclaves and hibernation on the same instance.</p>
        pub fn enclave_options(
            mut self,
            input: crate::model::LaunchTemplateEnclaveOptionsRequest,
        ) -> Self {
            self.enclave_options = Some(input);
            self
        }
        pub fn set_enclave_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateEnclaveOptionsRequest>,
        ) -> Self {
            self.enclave_options = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestLaunchTemplateData`](crate::model::RequestLaunchTemplateData)
        pub fn build(self) -> crate::model::RequestLaunchTemplateData {
            crate::model::RequestLaunchTemplateData {
                kernel_id: self.kernel_id,
                ebs_optimized: self.ebs_optimized,
                iam_instance_profile: self.iam_instance_profile,
                block_device_mappings: self.block_device_mappings,
                network_interfaces: self.network_interfaces,
                image_id: self.image_id,
                instance_type: self.instance_type,
                key_name: self.key_name,
                monitoring: self.monitoring,
                placement: self.placement,
                ram_disk_id: self.ram_disk_id,
                disable_api_termination: self.disable_api_termination,
                instance_initiated_shutdown_behavior: self.instance_initiated_shutdown_behavior,
                user_data: self.user_data,
                tag_specifications: self.tag_specifications,
                elastic_gpu_specifications: self.elastic_gpu_specifications,
                elastic_inference_accelerators: self.elastic_inference_accelerators,
                security_group_ids: self.security_group_ids,
                security_groups: self.security_groups,
                instance_market_options: self.instance_market_options,
                credit_specification: self.credit_specification,
                cpu_options: self.cpu_options,
                capacity_reservation_specification: self.capacity_reservation_specification,
                license_specifications: self.license_specifications,
                hibernation_options: self.hibernation_options,
                metadata_options: self.metadata_options,
                enclave_options: self.enclave_options,
            }
        }
    }
}
impl RequestLaunchTemplateData {
    /// Creates a new builder-style object to manufacture [`RequestLaunchTemplateData`](crate::model::RequestLaunchTemplateData)
    pub fn builder() -> crate::model::request_launch_template_data::Builder {
        crate::model::request_launch_template_data::Builder::default()
    }
}

/// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information,
/// see <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html">
/// What is Amazon Web Services Nitro Enclaves?</a> in the <i>Amazon Web Services Nitro Enclaves User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateEnclaveOptionsRequest {
    /// <p>To enable the instance for Amazon Web Services Nitro Enclaves, set this parameter to <code>true</code>.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplateEnclaveOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateEnclaveOptionsRequest");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`LaunchTemplateEnclaveOptionsRequest`](crate::model::LaunchTemplateEnclaveOptionsRequest)
pub mod launch_template_enclave_options_request {
    /// A builder for [`LaunchTemplateEnclaveOptionsRequest`](crate::model::LaunchTemplateEnclaveOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>To enable the instance for Amazon Web Services Nitro Enclaves, set this parameter to <code>true</code>.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateEnclaveOptionsRequest`](crate::model::LaunchTemplateEnclaveOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateEnclaveOptionsRequest {
            crate::model::LaunchTemplateEnclaveOptionsRequest {
                enabled: self.enabled,
            }
        }
    }
}
impl LaunchTemplateEnclaveOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateEnclaveOptionsRequest`](crate::model::LaunchTemplateEnclaveOptionsRequest)
    pub fn builder() -> crate::model::launch_template_enclave_options_request::Builder {
        crate::model::launch_template_enclave_options_request::Builder::default()
    }
}

/// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance Metadata and User Data</a> in the
/// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceMetadataOptionsRequest {
    /// <p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p>
    /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p>
    /// <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>
    pub http_tokens: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
    /// <p>Default: 1</p>
    /// <p>Possible values: Integers from 1 to 64</p>
    pub http_put_response_hop_limit: std::option::Option<i32>,
    /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p>
    /// <note>
    /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.
    /// </p>
    /// </note>
    pub http_endpoint:
        std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
    /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
    /// <p>Default: <code>disabled</code>
    /// </p>
    pub http_protocol_ipv6:
        std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
}
impl std::fmt::Debug for LaunchTemplateInstanceMetadataOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateInstanceMetadataOptionsRequest");
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.field("http_protocol_ipv6", &self.http_protocol_ipv6);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceMetadataOptionsRequest`](crate::model::LaunchTemplateInstanceMetadataOptionsRequest)
pub mod launch_template_instance_metadata_options_request {
    /// A builder for [`LaunchTemplateInstanceMetadataOptionsRequest`](crate::model::LaunchTemplateInstanceMetadataOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_tokens: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_endpoint:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
        pub(crate) http_protocol_ipv6:
            std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
    }
    impl Builder {
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>
        pub fn http_tokens(mut self, input: crate::model::LaunchTemplateHttpTokensState) -> Self {
            self.http_tokens = Some(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateHttpTokensState>,
        ) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p>
        /// <p>Default: 1</p>
        /// <p>Possible values: Integers from 1 to 64</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.
        /// </p>
        /// </note>
        pub fn http_endpoint(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataEndpointState,
        ) -> Self {
            self.http_endpoint = Some(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataEndpointState>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// <p>Enables or disables the IPv6 endpoint for the instance metadata service.</p>
        /// <p>Default: <code>disabled</code>
        /// </p>
        pub fn http_protocol_ipv6(
            mut self,
            input: crate::model::LaunchTemplateInstanceMetadataProtocolIpv6,
        ) -> Self {
            self.http_protocol_ipv6 = Some(input);
            self
        }
        pub fn set_http_protocol_ipv6(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateInstanceMetadataProtocolIpv6>,
        ) -> Self {
            self.http_protocol_ipv6 = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceMetadataOptionsRequest`](crate::model::LaunchTemplateInstanceMetadataOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateInstanceMetadataOptionsRequest {
            crate::model::LaunchTemplateInstanceMetadataOptionsRequest {
                http_tokens: self.http_tokens,
                http_put_response_hop_limit: self.http_put_response_hop_limit,
                http_endpoint: self.http_endpoint,
                http_protocol_ipv6: self.http_protocol_ipv6,
            }
        }
    }
}
impl LaunchTemplateInstanceMetadataOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceMetadataOptionsRequest`](crate::model::LaunchTemplateInstanceMetadataOptionsRequest)
    pub fn builder() -> crate::model::launch_template_instance_metadata_options_request::Builder {
        crate::model::launch_template_instance_metadata_options_request::Builder::default()
    }
}

/// <p>Indicates whether the instance is configured for hibernation. This parameter is valid only
/// if the instance meets the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites">hibernation
/// prerequisites</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateHibernationOptionsRequest {
    /// <p>If you set this parameter to <code>true</code>, the instance is enabled for hibernation.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub configured: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplateHibernationOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateHibernationOptionsRequest");
        formatter.field("configured", &self.configured);
        formatter.finish()
    }
}
/// See [`LaunchTemplateHibernationOptionsRequest`](crate::model::LaunchTemplateHibernationOptionsRequest)
pub mod launch_template_hibernation_options_request {
    /// A builder for [`LaunchTemplateHibernationOptionsRequest`](crate::model::LaunchTemplateHibernationOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configured: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If you set this parameter to <code>true</code>, the instance is enabled for hibernation.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn configured(mut self, input: bool) -> Self {
            self.configured = Some(input);
            self
        }
        pub fn set_configured(mut self, input: std::option::Option<bool>) -> Self {
            self.configured = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateHibernationOptionsRequest`](crate::model::LaunchTemplateHibernationOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateHibernationOptionsRequest {
            crate::model::LaunchTemplateHibernationOptionsRequest {
                configured: self.configured,
            }
        }
    }
}
impl LaunchTemplateHibernationOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateHibernationOptionsRequest`](crate::model::LaunchTemplateHibernationOptionsRequest)
    pub fn builder() -> crate::model::launch_template_hibernation_options_request::Builder {
        crate::model::launch_template_hibernation_options_request::Builder::default()
    }
}

/// <p>Describes a license configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateLicenseConfigurationRequest {
    /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
    pub license_configuration_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateLicenseConfigurationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateLicenseConfigurationRequest");
        formatter.field("license_configuration_arn", &self.license_configuration_arn);
        formatter.finish()
    }
}
/// See [`LaunchTemplateLicenseConfigurationRequest`](crate::model::LaunchTemplateLicenseConfigurationRequest)
pub mod launch_template_license_configuration_request {
    /// A builder for [`LaunchTemplateLicenseConfigurationRequest`](crate::model::LaunchTemplateLicenseConfigurationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) license_configuration_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_configuration_arn = Some(input.into());
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_configuration_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateLicenseConfigurationRequest`](crate::model::LaunchTemplateLicenseConfigurationRequest)
        pub fn build(self) -> crate::model::LaunchTemplateLicenseConfigurationRequest {
            crate::model::LaunchTemplateLicenseConfigurationRequest {
                license_configuration_arn: self.license_configuration_arn,
            }
        }
    }
}
impl LaunchTemplateLicenseConfigurationRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateLicenseConfigurationRequest`](crate::model::LaunchTemplateLicenseConfigurationRequest)
    pub fn builder() -> crate::model::launch_template_license_configuration_request::Builder {
        crate::model::launch_template_license_configuration_request::Builder::default()
    }
}

/// <p>Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the
/// <code>CapacityReservationPreference</code> parameter to configure the instance to run in On-Demand capacity or
/// to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
/// Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation or
/// a Capacity Reservation group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateCapacityReservationSpecificationRequest {
    /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
    /// (instance type, platform, Availability Zone).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance
    /// runs in On-Demand capacity.</p>
    /// </li>
    /// </ul>
    pub capacity_reservation_preference:
        std::option::Option<crate::model::CapacityReservationPreference>,
    /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
    pub capacity_reservation_target: std::option::Option<crate::model::CapacityReservationTarget>,
}
impl std::fmt::Debug for LaunchTemplateCapacityReservationSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateCapacityReservationSpecificationRequest");
        formatter.field(
            "capacity_reservation_preference",
            &self.capacity_reservation_preference,
        );
        formatter.field(
            "capacity_reservation_target",
            &self.capacity_reservation_target,
        );
        formatter.finish()
    }
}
/// See [`LaunchTemplateCapacityReservationSpecificationRequest`](crate::model::LaunchTemplateCapacityReservationSpecificationRequest)
pub mod launch_template_capacity_reservation_specification_request {
    /// A builder for [`LaunchTemplateCapacityReservationSpecificationRequest`](crate::model::LaunchTemplateCapacityReservationSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_reservation_preference:
            std::option::Option<crate::model::CapacityReservationPreference>,
        pub(crate) capacity_reservation_target:
            std::option::Option<crate::model::CapacityReservationTarget>,
    }
    impl Builder {
        /// <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes
        /// (instance type, platform, Availability Zone).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance
        /// runs in On-Demand capacity.</p>
        /// </li>
        /// </ul>
        pub fn capacity_reservation_preference(
            mut self,
            input: crate::model::CapacityReservationPreference,
        ) -> Self {
            self.capacity_reservation_preference = Some(input);
            self
        }
        pub fn set_capacity_reservation_preference(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationPreference>,
        ) -> Self {
            self.capacity_reservation_preference = input;
            self
        }
        /// <p>Information about the target Capacity Reservation or Capacity Reservation group.</p>
        pub fn capacity_reservation_target(
            mut self,
            input: crate::model::CapacityReservationTarget,
        ) -> Self {
            self.capacity_reservation_target = Some(input);
            self
        }
        pub fn set_capacity_reservation_target(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTarget>,
        ) -> Self {
            self.capacity_reservation_target = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateCapacityReservationSpecificationRequest`](crate::model::LaunchTemplateCapacityReservationSpecificationRequest)
        pub fn build(self) -> crate::model::LaunchTemplateCapacityReservationSpecificationRequest {
            crate::model::LaunchTemplateCapacityReservationSpecificationRequest {
                capacity_reservation_preference: self.capacity_reservation_preference,
                capacity_reservation_target: self.capacity_reservation_target,
            }
        }
    }
}
impl LaunchTemplateCapacityReservationSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateCapacityReservationSpecificationRequest`](crate::model::LaunchTemplateCapacityReservationSpecificationRequest)
    pub fn builder(
    ) -> crate::model::launch_template_capacity_reservation_specification_request::Builder {
        crate::model::launch_template_capacity_reservation_specification_request::Builder::default()
    }
}

/// <p>The CPU options for the instance. Both the core count and threads per core
/// must be specified in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateCpuOptionsRequest {
    /// <p>The number of CPU cores for the instance.</p>
    pub core_count: std::option::Option<i32>,
    /// <p>The number of threads per CPU core. To disable multithreading
    /// for the instance, specify a value of 1. Otherwise, specify the default value of 2.</p>
    pub threads_per_core: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateCpuOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateCpuOptionsRequest");
        formatter.field("core_count", &self.core_count);
        formatter.field("threads_per_core", &self.threads_per_core);
        formatter.finish()
    }
}
/// See [`LaunchTemplateCpuOptionsRequest`](crate::model::LaunchTemplateCpuOptionsRequest)
pub mod launch_template_cpu_options_request {
    /// A builder for [`LaunchTemplateCpuOptionsRequest`](crate::model::LaunchTemplateCpuOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_count: std::option::Option<i32>,
        pub(crate) threads_per_core: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of CPU cores for the instance.</p>
        pub fn core_count(mut self, input: i32) -> Self {
            self.core_count = Some(input);
            self
        }
        pub fn set_core_count(mut self, input: std::option::Option<i32>) -> Self {
            self.core_count = input;
            self
        }
        /// <p>The number of threads per CPU core. To disable multithreading
        /// for the instance, specify a value of 1. Otherwise, specify the default value of 2.</p>
        pub fn threads_per_core(mut self, input: i32) -> Self {
            self.threads_per_core = Some(input);
            self
        }
        pub fn set_threads_per_core(mut self, input: std::option::Option<i32>) -> Self {
            self.threads_per_core = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateCpuOptionsRequest`](crate::model::LaunchTemplateCpuOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateCpuOptionsRequest {
            crate::model::LaunchTemplateCpuOptionsRequest {
                core_count: self.core_count,
                threads_per_core: self.threads_per_core,
            }
        }
    }
}
impl LaunchTemplateCpuOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateCpuOptionsRequest`](crate::model::LaunchTemplateCpuOptionsRequest)
    pub fn builder() -> crate::model::launch_template_cpu_options_request::Builder {
        crate::model::launch_template_cpu_options_request::Builder::default()
    }
}

/// <p>The market (purchasing) option for the instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceMarketOptionsRequest {
    /// <p>The market type.</p>
    pub market_type: std::option::Option<crate::model::MarketType>,
    /// <p>The options for Spot Instances.</p>
    pub spot_options: std::option::Option<crate::model::LaunchTemplateSpotMarketOptionsRequest>,
}
impl std::fmt::Debug for LaunchTemplateInstanceMarketOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateInstanceMarketOptionsRequest");
        formatter.field("market_type", &self.market_type);
        formatter.field("spot_options", &self.spot_options);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceMarketOptionsRequest`](crate::model::LaunchTemplateInstanceMarketOptionsRequest)
pub mod launch_template_instance_market_options_request {
    /// A builder for [`LaunchTemplateInstanceMarketOptionsRequest`](crate::model::LaunchTemplateInstanceMarketOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) market_type: std::option::Option<crate::model::MarketType>,
        pub(crate) spot_options:
            std::option::Option<crate::model::LaunchTemplateSpotMarketOptionsRequest>,
    }
    impl Builder {
        /// <p>The market type.</p>
        pub fn market_type(mut self, input: crate::model::MarketType) -> Self {
            self.market_type = Some(input);
            self
        }
        pub fn set_market_type(
            mut self,
            input: std::option::Option<crate::model::MarketType>,
        ) -> Self {
            self.market_type = input;
            self
        }
        /// <p>The options for Spot Instances.</p>
        pub fn spot_options(
            mut self,
            input: crate::model::LaunchTemplateSpotMarketOptionsRequest,
        ) -> Self {
            self.spot_options = Some(input);
            self
        }
        pub fn set_spot_options(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpotMarketOptionsRequest>,
        ) -> Self {
            self.spot_options = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceMarketOptionsRequest`](crate::model::LaunchTemplateInstanceMarketOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateInstanceMarketOptionsRequest {
            crate::model::LaunchTemplateInstanceMarketOptionsRequest {
                market_type: self.market_type,
                spot_options: self.spot_options,
            }
        }
    }
}
impl LaunchTemplateInstanceMarketOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceMarketOptionsRequest`](crate::model::LaunchTemplateInstanceMarketOptionsRequest)
    pub fn builder() -> crate::model::launch_template_instance_market_options_request::Builder {
        crate::model::launch_template_instance_market_options_request::Builder::default()
    }
}

/// <p>The options for Spot Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateSpotMarketOptionsRequest {
    /// <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
    pub max_price: std::option::Option<std::string::String>,
    /// <p>The Spot Instance request type.</p>
    pub spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
    /// <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
    pub block_duration_minutes: std::option::Option<i32>,
    /// <p>The end date of the request.
    /// For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached.
    /// If the request is persistent, it remains active until it is canceled or this date and time is reached.
    /// The default end date is 7 days from the current date.</p>
    pub valid_until: std::option::Option<smithy_types::Instant>,
    /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::InstanceInterruptionBehavior>,
}
impl std::fmt::Debug for LaunchTemplateSpotMarketOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateSpotMarketOptionsRequest");
        formatter.field("max_price", &self.max_price);
        formatter.field("spot_instance_type", &self.spot_instance_type);
        formatter.field("block_duration_minutes", &self.block_duration_minutes);
        formatter.field("valid_until", &self.valid_until);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.finish()
    }
}
/// See [`LaunchTemplateSpotMarketOptionsRequest`](crate::model::LaunchTemplateSpotMarketOptionsRequest)
pub mod launch_template_spot_market_options_request {
    /// A builder for [`LaunchTemplateSpotMarketOptionsRequest`](crate::model::LaunchTemplateSpotMarketOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_price: std::option::Option<std::string::String>,
        pub(crate) spot_instance_type: std::option::Option<crate::model::SpotInstanceType>,
        pub(crate) block_duration_minutes: std::option::Option<i32>,
        pub(crate) valid_until: std::option::Option<smithy_types::Instant>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::InstanceInterruptionBehavior>,
    }
    impl Builder {
        /// <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
        pub fn max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_price = Some(input.into());
            self
        }
        pub fn set_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_price = input;
            self
        }
        /// <p>The Spot Instance request type.</p>
        pub fn spot_instance_type(mut self, input: crate::model::SpotInstanceType) -> Self {
            self.spot_instance_type = Some(input);
            self
        }
        pub fn set_spot_instance_type(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceType>,
        ) -> Self {
            self.spot_instance_type = input;
            self
        }
        /// <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
        pub fn block_duration_minutes(mut self, input: i32) -> Self {
            self.block_duration_minutes = Some(input);
            self
        }
        pub fn set_block_duration_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.block_duration_minutes = input;
            self
        }
        /// <p>The end date of the request.
        /// For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached.
        /// If the request is persistent, it remains active until it is canceled or this date and time is reached.
        /// The default end date is 7 days from the current date.</p>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.valid_until = Some(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.valid_until = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateSpotMarketOptionsRequest`](crate::model::LaunchTemplateSpotMarketOptionsRequest)
        pub fn build(self) -> crate::model::LaunchTemplateSpotMarketOptionsRequest {
            crate::model::LaunchTemplateSpotMarketOptionsRequest {
                max_price: self.max_price,
                spot_instance_type: self.spot_instance_type,
                block_duration_minutes: self.block_duration_minutes,
                valid_until: self.valid_until,
                instance_interruption_behavior: self.instance_interruption_behavior,
            }
        }
    }
}
impl LaunchTemplateSpotMarketOptionsRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateSpotMarketOptionsRequest`](crate::model::LaunchTemplateSpotMarketOptionsRequest)
    pub fn builder() -> crate::model::launch_template_spot_market_options_request::Builder {
        crate::model::launch_template_spot_market_options_request::Builder::default()
    }
}

/// <p>
/// Describes an elastic inference accelerator.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateElasticInferenceAccelerator {
    /// <p>
    /// The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
    /// </p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>
    /// The number of elastic inference accelerators to attach to the instance.
    /// </p>
    /// <p>Default: 1</p>
    pub count: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateElasticInferenceAccelerator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateElasticInferenceAccelerator");
        formatter.field("r#type", &self.r#type);
        formatter.field("count", &self.count);
        formatter.finish()
    }
}
/// See [`LaunchTemplateElasticInferenceAccelerator`](crate::model::LaunchTemplateElasticInferenceAccelerator)
pub mod launch_template_elastic_inference_accelerator {
    /// A builder for [`LaunchTemplateElasticInferenceAccelerator`](crate::model::LaunchTemplateElasticInferenceAccelerator)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>
        /// The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
        /// </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>
        /// The number of elastic inference accelerators to attach to the instance.
        /// </p>
        /// <p>Default: 1</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateElasticInferenceAccelerator`](crate::model::LaunchTemplateElasticInferenceAccelerator)
        pub fn build(self) -> crate::model::LaunchTemplateElasticInferenceAccelerator {
            crate::model::LaunchTemplateElasticInferenceAccelerator {
                r#type: self.r#type,
                count: self.count,
            }
        }
    }
}
impl LaunchTemplateElasticInferenceAccelerator {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateElasticInferenceAccelerator`](crate::model::LaunchTemplateElasticInferenceAccelerator)
    pub fn builder() -> crate::model::launch_template_elastic_inference_accelerator::Builder {
        crate::model::launch_template_elastic_inference_accelerator::Builder::default()
    }
}

/// <p>The tags specification for the launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateTagSpecificationRequest {
    /// <p>The type of resource to tag. Currently, the resource types that support tagging on
    /// creation are <code>instance</code> and <code>volume</code>. To tag a resource after it
    /// has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The tags to apply to the resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for LaunchTemplateTagSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateTagSpecificationRequest");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`LaunchTemplateTagSpecificationRequest`](crate::model::LaunchTemplateTagSpecificationRequest)
pub mod launch_template_tag_specification_request {
    /// A builder for [`LaunchTemplateTagSpecificationRequest`](crate::model::LaunchTemplateTagSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The type of resource to tag. Currently, the resource types that support tagging on
        /// creation are <code>instance</code> and <code>volume</code>. To tag a resource after it
        /// has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateTagSpecificationRequest`](crate::model::LaunchTemplateTagSpecificationRequest)
        pub fn build(self) -> crate::model::LaunchTemplateTagSpecificationRequest {
            crate::model::LaunchTemplateTagSpecificationRequest {
                resource_type: self.resource_type,
                tags: self.tags,
            }
        }
    }
}
impl LaunchTemplateTagSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateTagSpecificationRequest`](crate::model::LaunchTemplateTagSpecificationRequest)
    pub fn builder() -> crate::model::launch_template_tag_specification_request::Builder {
        crate::model::launch_template_tag_specification_request::Builder::default()
    }
}

/// <p>Describes the placement of an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplatePlacementRequest {
    /// <p>The Availability Zone for the instance.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The affinity setting for an instance on a Dedicated Host.</p>
    pub affinity: std::option::Option<std::string::String>,
    /// <p>The name of the placement group for the instance.</p>
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The ID of the Dedicated Host for the instance.</p>
    pub host_id: std::option::Option<std::string::String>,
    /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy
    /// of dedicated runs on single-tenant hardware.</p>
    pub tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>Reserved for future use.</p>
    pub spread_domain: std::option::Option<std::string::String>,
    /// <p>The ARN of the host resource group in which to launch the instances. If you specify a host
    /// resource group ARN, omit the <b>Tenancy</b> parameter
    /// or set it to <code>host</code>.</p>
    pub host_resource_group_arn: std::option::Option<std::string::String>,
    /// <p>The number of the partition the instance should launch in. Valid only if the placement group strategy is set to <code>partition</code>.</p>
    pub partition_number: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplatePlacementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplatePlacementRequest");
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("affinity", &self.affinity);
        formatter.field("group_name", &self.group_name);
        formatter.field("host_id", &self.host_id);
        formatter.field("tenancy", &self.tenancy);
        formatter.field("spread_domain", &self.spread_domain);
        formatter.field("host_resource_group_arn", &self.host_resource_group_arn);
        formatter.field("partition_number", &self.partition_number);
        formatter.finish()
    }
}
/// See [`LaunchTemplatePlacementRequest`](crate::model::LaunchTemplatePlacementRequest)
pub mod launch_template_placement_request {
    /// A builder for [`LaunchTemplatePlacementRequest`](crate::model::LaunchTemplatePlacementRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) affinity: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) host_id: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) spread_domain: std::option::Option<std::string::String>,
        pub(crate) host_resource_group_arn: std::option::Option<std::string::String>,
        pub(crate) partition_number: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Availability Zone for the instance.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The affinity setting for an instance on a Dedicated Host.</p>
        pub fn affinity(mut self, input: impl Into<std::string::String>) -> Self {
            self.affinity = Some(input.into());
            self
        }
        pub fn set_affinity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.affinity = input;
            self
        }
        /// <p>The name of the placement group for the instance.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The ID of the Dedicated Host for the instance.</p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_id = Some(input.into());
            self
        }
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.host_id = input;
            self
        }
        /// <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy
        /// of dedicated runs on single-tenant hardware.</p>
        pub fn tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        pub fn set_tenancy(mut self, input: std::option::Option<crate::model::Tenancy>) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn spread_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.spread_domain = Some(input.into());
            self
        }
        pub fn set_spread_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spread_domain = input;
            self
        }
        /// <p>The ARN of the host resource group in which to launch the instances. If you specify a host
        /// resource group ARN, omit the <b>Tenancy</b> parameter
        /// or set it to <code>host</code>.</p>
        pub fn host_resource_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_resource_group_arn = Some(input.into());
            self
        }
        pub fn set_host_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_resource_group_arn = input;
            self
        }
        /// <p>The number of the partition the instance should launch in. Valid only if the placement group strategy is set to <code>partition</code>.</p>
        pub fn partition_number(mut self, input: i32) -> Self {
            self.partition_number = Some(input);
            self
        }
        pub fn set_partition_number(mut self, input: std::option::Option<i32>) -> Self {
            self.partition_number = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplatePlacementRequest`](crate::model::LaunchTemplatePlacementRequest)
        pub fn build(self) -> crate::model::LaunchTemplatePlacementRequest {
            crate::model::LaunchTemplatePlacementRequest {
                availability_zone: self.availability_zone,
                affinity: self.affinity,
                group_name: self.group_name,
                host_id: self.host_id,
                tenancy: self.tenancy,
                spread_domain: self.spread_domain,
                host_resource_group_arn: self.host_resource_group_arn,
                partition_number: self.partition_number,
            }
        }
    }
}
impl LaunchTemplatePlacementRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplatePlacementRequest`](crate::model::LaunchTemplatePlacementRequest)
    pub fn builder() -> crate::model::launch_template_placement_request::Builder {
        crate::model::launch_template_placement_request::Builder::default()
    }
}

/// <p>Describes the monitoring for the instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplatesMonitoringRequest {
    /// <p>Specify <code>true</code> to enable detailed monitoring. Otherwise, basic monitoring is enabled.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for LaunchTemplatesMonitoringRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplatesMonitoringRequest");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`LaunchTemplatesMonitoringRequest`](crate::model::LaunchTemplatesMonitoringRequest)
pub mod launch_templates_monitoring_request {
    /// A builder for [`LaunchTemplatesMonitoringRequest`](crate::model::LaunchTemplatesMonitoringRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specify <code>true</code> to enable detailed monitoring. Otherwise, basic monitoring is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplatesMonitoringRequest`](crate::model::LaunchTemplatesMonitoringRequest)
        pub fn build(self) -> crate::model::LaunchTemplatesMonitoringRequest {
            crate::model::LaunchTemplatesMonitoringRequest {
                enabled: self.enabled,
            }
        }
    }
}
impl LaunchTemplatesMonitoringRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplatesMonitoringRequest`](crate::model::LaunchTemplatesMonitoringRequest)
    pub fn builder() -> crate::model::launch_templates_monitoring_request::Builder {
        crate::model::launch_templates_monitoring_request::Builder::default()
    }
}

/// <p>The parameters for a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
    /// <p>Associates a Carrier IP address with eth0 for a new network interface.</p>
    /// <p>Use this option when you launch an instance in a Wavelength Zone and want to associate
    /// a Carrier IP address with the network interface. For more information about Carrier IP
    /// addresses, see <a href="https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip">Carrier IP addresses</a> in the <i>Wavelength Developer
    /// Guide</i>.</p>
    pub associate_carrier_ip_address: std::option::Option<bool>,
    /// <p>Associates a public IPv4 address with eth0 for a new network interface.</p>
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>A description for the network interface.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The device index for the network interface attachment.</p>
    pub device_index: std::option::Option<i32>,
    /// <p>The IDs of one or more security groups.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of network interface. To create an Elastic Fabric Adapter (EFA), specify
    /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// <p>If you are not creating an EFA, specify <code>interface</code> or omit this parameter.</p>
    /// <p>Valid values: <code>interface</code> | <code>efa</code>
    /// </p>
    pub interface_type: std::option::Option<std::string::String>,
    /// <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
    pub ipv6_address_count: std::option::Option<i32>,
    /// <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
    pub ipv6_addresses:
        std::option::Option<std::vec::Vec<crate::model::InstanceIpv6AddressRequest>>,
    /// <p>The ID of the network interface.</p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The primary private IPv4 address of the network interface.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>One or more private IPv4 addresses.</p>
    pub private_ip_addresses:
        std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
    /// <p>The number of secondary private IPv4 addresses to assign to a network interface.</p>
    pub secondary_private_ip_address_count: std::option::Option<i32>,
    /// <p>The ID of the subnet for the network interface.</p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The index of the network card. Some instance types support multiple network cards.
    /// The primary network interface must be assigned to network card index 0.
    /// The default is network card index 0.</p>
    pub network_card_index: std::option::Option<i32>,
    /// <p>One or more IPv4 prefixes to be assigned to the network interface. You cannot use
    /// this option if you use the <code>Ipv4PrefixCount</code> option.</p>
    pub ipv4_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
    /// <p>The number of IPv4 prefixes to be automatically assigned to the
    /// network interface. You cannot use this option if you use the <code>Ipv4Prefix</code> option.</p>
    pub ipv4_prefix_count: std::option::Option<i32>,
    /// <p>One or more IPv6 prefixes to be assigned to the network interface. You cannot
    /// use this option if you use the <code>Ipv6PrefixCount</code> option.</p>
    pub ipv6_prefixes:
        std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
    /// <p>The number of IPv6 prefixes to be automatically assigned to the network
    /// interface. You cannot use this option if you use the <code>Ipv6Prefix</code> option.</p>
    pub ipv6_prefix_count: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("LaunchTemplateInstanceNetworkInterfaceSpecificationRequest");
        formatter.field(
            "associate_carrier_ip_address",
            &self.associate_carrier_ip_address,
        );
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("description", &self.description);
        formatter.field("device_index", &self.device_index);
        formatter.field("groups", &self.groups);
        formatter.field("interface_type", &self.interface_type);
        formatter.field("ipv6_address_count", &self.ipv6_address_count);
        formatter.field("ipv6_addresses", &self.ipv6_addresses);
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("private_ip_addresses", &self.private_ip_addresses);
        formatter.field(
            "secondary_private_ip_address_count",
            &self.secondary_private_ip_address_count,
        );
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("network_card_index", &self.network_card_index);
        formatter.field("ipv4_prefixes", &self.ipv4_prefixes);
        formatter.field("ipv4_prefix_count", &self.ipv4_prefix_count);
        formatter.field("ipv6_prefixes", &self.ipv6_prefixes);
        formatter.field("ipv6_prefix_count", &self.ipv6_prefix_count);
        formatter.finish()
    }
}
/// See [`LaunchTemplateInstanceNetworkInterfaceSpecificationRequest`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest)
pub mod launch_template_instance_network_interface_specification_request {
    /// A builder for [`LaunchTemplateInstanceNetworkInterfaceSpecificationRequest`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) associate_carrier_ip_address: std::option::Option<bool>,
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_index: std::option::Option<i32>,
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) interface_type: std::option::Option<std::string::String>,
        pub(crate) ipv6_address_count: std::option::Option<i32>,
        pub(crate) ipv6_addresses:
            std::option::Option<std::vec::Vec<crate::model::InstanceIpv6AddressRequest>>,
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) private_ip_addresses:
            std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        pub(crate) secondary_private_ip_address_count: std::option::Option<i32>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) network_card_index: std::option::Option<i32>,
        pub(crate) ipv4_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
        pub(crate) ipv4_prefix_count: std::option::Option<i32>,
        pub(crate) ipv6_prefixes:
            std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
        pub(crate) ipv6_prefix_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Associates a Carrier IP address with eth0 for a new network interface.</p>
        /// <p>Use this option when you launch an instance in a Wavelength Zone and want to associate
        /// a Carrier IP address with the network interface. For more information about Carrier IP
        /// addresses, see <a href="https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip">Carrier IP addresses</a> in the <i>Wavelength Developer
        /// Guide</i>.</p>
        pub fn associate_carrier_ip_address(mut self, input: bool) -> Self {
            self.associate_carrier_ip_address = Some(input);
            self
        }
        pub fn set_associate_carrier_ip_address(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.associate_carrier_ip_address = input;
            self
        }
        /// <p>Associates a public IPv4 address with eth0 for a new network interface.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>A description for the network interface.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The device index for the network interface attachment.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.device_index = Some(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.device_index = input;
            self
        }
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The type of network interface. To create an Elastic Fabric Adapter (EFA), specify
        /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>If you are not creating an EFA, specify <code>interface</code> or omit this parameter.</p>
        /// <p>Valid values: <code>interface</code> | <code>efa</code>
        /// </p>
        pub fn interface_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_type = Some(input.into());
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.interface_type = input;
            self
        }
        /// <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.ipv6_address_count = Some(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_address_count = input;
            self
        }
        pub fn ipv6_addresses(
            mut self,
            input: impl Into<crate::model::InstanceIpv6AddressRequest>,
        ) -> Self {
            let mut v = self.ipv6_addresses.unwrap_or_default();
            v.push(input.into());
            self.ipv6_addresses = Some(v);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6AddressRequest>>,
        ) -> Self {
            self.ipv6_addresses = input;
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The primary private IPv4 address of the network interface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        pub fn private_ip_addresses(
            mut self,
            input: impl Into<crate::model::PrivateIpAddressSpecification>,
        ) -> Self {
            let mut v = self.private_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.private_ip_addresses = Some(v);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        ) -> Self {
            self.private_ip_addresses = input;
            self
        }
        /// <p>The number of secondary private IPv4 addresses to assign to a network interface.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.secondary_private_ip_address_count = Some(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.secondary_private_ip_address_count = input;
            self
        }
        /// <p>The ID of the subnet for the network interface.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The index of the network card. Some instance types support multiple network cards.
        /// The primary network interface must be assigned to network card index 0.
        /// The default is network card index 0.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.network_card_index = Some(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.network_card_index = input;
            self
        }
        pub fn ipv4_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv4PrefixSpecificationRequest>,
        ) -> Self {
            let mut v = self.ipv4_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv4_prefixes = Some(v);
            self
        }
        pub fn set_ipv4_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv4PrefixSpecificationRequest>>,
        ) -> Self {
            self.ipv4_prefixes = input;
            self
        }
        /// <p>The number of IPv4 prefixes to be automatically assigned to the
        /// network interface. You cannot use this option if you use the <code>Ipv4Prefix</code> option.</p>
        pub fn ipv4_prefix_count(mut self, input: i32) -> Self {
            self.ipv4_prefix_count = Some(input);
            self
        }
        pub fn set_ipv4_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv4_prefix_count = input;
            self
        }
        pub fn ipv6_prefixes(
            mut self,
            input: impl Into<crate::model::Ipv6PrefixSpecificationRequest>,
        ) -> Self {
            let mut v = self.ipv6_prefixes.unwrap_or_default();
            v.push(input.into());
            self.ipv6_prefixes = Some(v);
            self
        }
        pub fn set_ipv6_prefixes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ipv6PrefixSpecificationRequest>>,
        ) -> Self {
            self.ipv6_prefixes = input;
            self
        }
        /// <p>The number of IPv6 prefixes to be automatically assigned to the network
        /// interface. You cannot use this option if you use the <code>Ipv6Prefix</code> option.</p>
        pub fn ipv6_prefix_count(mut self, input: i32) -> Self {
            self.ipv6_prefix_count = Some(input);
            self
        }
        pub fn set_ipv6_prefix_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ipv6_prefix_count = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateInstanceNetworkInterfaceSpecificationRequest`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest)
        pub fn build(
            self,
        ) -> crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
            crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
                associate_carrier_ip_address: self.associate_carrier_ip_address,
                associate_public_ip_address: self.associate_public_ip_address,
                delete_on_termination: self.delete_on_termination,
                description: self.description,
                device_index: self.device_index,
                groups: self.groups,
                interface_type: self.interface_type,
                ipv6_address_count: self.ipv6_address_count,
                ipv6_addresses: self.ipv6_addresses,
                network_interface_id: self.network_interface_id,
                private_ip_address: self.private_ip_address,
                private_ip_addresses: self.private_ip_addresses,
                secondary_private_ip_address_count: self.secondary_private_ip_address_count,
                subnet_id: self.subnet_id,
                network_card_index: self.network_card_index,
                ipv4_prefixes: self.ipv4_prefixes,
                ipv4_prefix_count: self.ipv4_prefix_count,
                ipv6_prefixes: self.ipv6_prefixes,
                ipv6_prefix_count: self.ipv6_prefix_count,
            }
        }
    }
}
impl LaunchTemplateInstanceNetworkInterfaceSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateInstanceNetworkInterfaceSpecificationRequest`](crate::model::LaunchTemplateInstanceNetworkInterfaceSpecificationRequest)
    pub fn builder(
    ) -> crate::model::launch_template_instance_network_interface_specification_request::Builder
    {
        crate::model::launch_template_instance_network_interface_specification_request::Builder::default()
    }
}

/// <p>Describes an IPv6 address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceIpv6AddressRequest {
    /// <p>The IPv6 address.</p>
    pub ipv6_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstanceIpv6AddressRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceIpv6AddressRequest");
        formatter.field("ipv6_address", &self.ipv6_address);
        formatter.finish()
    }
}
/// See [`InstanceIpv6AddressRequest`](crate::model::InstanceIpv6AddressRequest)
pub mod instance_ipv6_address_request {
    /// A builder for [`InstanceIpv6AddressRequest`](crate::model::InstanceIpv6AddressRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IPv6 address.</p>
        pub fn ipv6_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ipv6_address = Some(input.into());
            self
        }
        pub fn set_ipv6_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ipv6_address = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIpv6AddressRequest`](crate::model::InstanceIpv6AddressRequest)
        pub fn build(self) -> crate::model::InstanceIpv6AddressRequest {
            crate::model::InstanceIpv6AddressRequest {
                ipv6_address: self.ipv6_address,
            }
        }
    }
}
impl InstanceIpv6AddressRequest {
    /// Creates a new builder-style object to manufacture [`InstanceIpv6AddressRequest`](crate::model::InstanceIpv6AddressRequest)
    pub fn builder() -> crate::model::instance_ipv6_address_request::Builder {
        crate::model::instance_ipv6_address_request::Builder::default()
    }
}

/// <p>Describes a block device mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateBlockDeviceMappingRequest {
    /// <p>The device name (for example, /dev/sdh or xvdh).</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0.
    /// An instance type with 2 available instance store volumes can specify mappings for ephemeral0
    /// and ephemeral1. The number of available instance store volumes depends on the instance type.
    /// After you connect to the instance, you must mount the volume.</p>
    pub virtual_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
    pub ebs: std::option::Option<crate::model::LaunchTemplateEbsBlockDeviceRequest>,
    /// <p>To omit the device from the block device mapping, specify an empty string.</p>
    pub no_device: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateBlockDeviceMappingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateBlockDeviceMappingRequest");
        formatter.field("device_name", &self.device_name);
        formatter.field("virtual_name", &self.virtual_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.finish()
    }
}
/// See [`LaunchTemplateBlockDeviceMappingRequest`](crate::model::LaunchTemplateBlockDeviceMappingRequest)
pub mod launch_template_block_device_mapping_request {
    /// A builder for [`LaunchTemplateBlockDeviceMappingRequest`](crate::model::LaunchTemplateBlockDeviceMappingRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) virtual_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::LaunchTemplateEbsBlockDeviceRequest>,
        pub(crate) no_device: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The device name (for example, /dev/sdh or xvdh).</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0.
        /// An instance type with 2 available instance store volumes can specify mappings for ephemeral0
        /// and ephemeral1. The number of available instance store volumes depends on the instance type.
        /// After you connect to the instance, you must mount the volume.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
        pub fn ebs(mut self, input: crate::model::LaunchTemplateEbsBlockDeviceRequest) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateEbsBlockDeviceRequest>,
        ) -> Self {
            self.ebs = input;
            self
        }
        /// <p>To omit the device from the block device mapping, specify an empty string.</p>
        pub fn no_device(mut self, input: impl Into<std::string::String>) -> Self {
            self.no_device = Some(input.into());
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.no_device = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateBlockDeviceMappingRequest`](crate::model::LaunchTemplateBlockDeviceMappingRequest)
        pub fn build(self) -> crate::model::LaunchTemplateBlockDeviceMappingRequest {
            crate::model::LaunchTemplateBlockDeviceMappingRequest {
                device_name: self.device_name,
                virtual_name: self.virtual_name,
                ebs: self.ebs,
                no_device: self.no_device,
            }
        }
    }
}
impl LaunchTemplateBlockDeviceMappingRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateBlockDeviceMappingRequest`](crate::model::LaunchTemplateBlockDeviceMappingRequest)
    pub fn builder() -> crate::model::launch_template_block_device_mapping_request::Builder {
        crate::model::launch_template_block_device_mapping_request::Builder::default()
    }
}

/// <p>The parameters for a block device for an EBS volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateEbsBlockDeviceRequest {
    /// <p>Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption.
    /// If you are creating a volume from a snapshot, you can't specify an encryption value.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code>
    /// volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes,
    /// this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits
    /// for bursting.</p>
    /// <p>The following are the supported values for each volume type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp3</code>: 3,000-16,000 IOPS</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code>: 100-64,000 IOPS</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io2</code>: 100-64,000 IOPS</p>
    /// </li>
    /// </ul>
    /// <p>For <code>io1</code> and <code>io2</code> volumes, we guarantee 64,000 IOPS  
    /// only for <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a>. Other instance families guarantee performance up
    /// to 32,000 IOPS.</p>
    /// <p>This parameter is supported for <code>io1</code>, <code>io2</code>, and <code>gp3</code> volumes only. This parameter is not supported for
    /// <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
    pub iops: std::option::Option<i32>,
    /// <p>The ARN of the symmetric Key Management Service (KMS) CMK used for
    /// encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The ID of the snapshot.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following
    /// are the supported volumes sizes for each volume type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>standard</code>: 1-1,024</p>
    /// </li>
    /// </ul>
    pub volume_size: std::option::Option<i32>,
    /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
    /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    pub volume_type: std::option::Option<crate::model::VolumeType>,
    /// <p>The throughput to provision for a <code>gp3</code> volume, with a maximum of 1,000 MiB/s.</p>
    /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
    pub throughput: std::option::Option<i32>,
}
impl std::fmt::Debug for LaunchTemplateEbsBlockDeviceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateEbsBlockDeviceRequest");
        formatter.field("encrypted", &self.encrypted);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("iops", &self.iops);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("throughput", &self.throughput);
        formatter.finish()
    }
}
/// See [`LaunchTemplateEbsBlockDeviceRequest`](crate::model::LaunchTemplateEbsBlockDeviceRequest)
pub mod launch_template_ebs_block_device_request {
    /// A builder for [`LaunchTemplateEbsBlockDeviceRequest`](crate::model::LaunchTemplateEbsBlockDeviceRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<crate::model::VolumeType>,
        pub(crate) throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption.
        /// If you are creating a volume from a snapshot, you can't specify an encryption value.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>Indicates whether the EBS volume is deleted on instance termination.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code>
        /// volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes,
        /// this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits
        /// for bursting.</p>
        /// <p>The following are the supported values for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp3</code>: 3,000-16,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 100-64,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io2</code>: 100-64,000 IOPS</p>
        /// </li>
        /// </ul>
        /// <p>For <code>io1</code> and <code>io2</code> volumes, we guarantee 64,000 IOPS  
        /// only for <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a>. Other instance families guarantee performance up
        /// to 32,000 IOPS.</p>
        /// <p>This parameter is supported for <code>io1</code>, <code>io2</code>, and <code>gp3</code> volumes only. This parameter is not supported for
        /// <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The ARN of the symmetric Key Management Service (KMS) CMK used for
        /// encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following
        /// are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>standard</code>: 1-1,024</p>
        /// </li>
        /// </ul>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.volume_type = Some(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>The throughput to provision for a <code>gp3</code> volume, with a maximum of 1,000 MiB/s.</p>
        /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateEbsBlockDeviceRequest`](crate::model::LaunchTemplateEbsBlockDeviceRequest)
        pub fn build(self) -> crate::model::LaunchTemplateEbsBlockDeviceRequest {
            crate::model::LaunchTemplateEbsBlockDeviceRequest {
                encrypted: self.encrypted,
                delete_on_termination: self.delete_on_termination,
                iops: self.iops,
                kms_key_id: self.kms_key_id,
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size,
                volume_type: self.volume_type,
                throughput: self.throughput,
            }
        }
    }
}
impl LaunchTemplateEbsBlockDeviceRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateEbsBlockDeviceRequest`](crate::model::LaunchTemplateEbsBlockDeviceRequest)
    pub fn builder() -> crate::model::launch_template_ebs_block_device_request::Builder {
        crate::model::launch_template_ebs_block_device_request::Builder::default()
    }
}

/// <p>An IAM instance profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateIamInstanceProfileSpecificationRequest {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the instance profile.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateIamInstanceProfileSpecificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateIamInstanceProfileSpecificationRequest");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`LaunchTemplateIamInstanceProfileSpecificationRequest`](crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest)
pub mod launch_template_iam_instance_profile_specification_request {
    /// A builder for [`LaunchTemplateIamInstanceProfileSpecificationRequest`](crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the instance profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateIamInstanceProfileSpecificationRequest`](crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest)
        pub fn build(self) -> crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest {
            crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest {
                arn: self.arn,
                name: self.name,
            }
        }
    }
}
impl LaunchTemplateIamInstanceProfileSpecificationRequest {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateIamInstanceProfileSpecificationRequest`](crate::model::LaunchTemplateIamInstanceProfileSpecificationRequest)
    pub fn builder(
    ) -> crate::model::launch_template_iam_instance_profile_specification_request::Builder {
        crate::model::launch_template_iam_instance_profile_specification_request::Builder::default()
    }
}

/// <p>Describes an export instance task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportToS3TaskSpecification {
    /// <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is
    /// exported.</p>
    pub container_format: std::option::Option<crate::model::ContainerFormat>,
    /// <p>The format for the exported image.</p>
    pub disk_image_format: std::option::Option<crate::model::DiskImageFormat>,
    /// <p>The Amazon S3 bucket for the destination image. The destination bucket must exist and grant
    /// WRITE and READ_ACP permissions to the Amazon Web Services account <code>vm-import-export@amazon.com</code>.</p>
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The image is written to a single object in the Amazon S3 bucket at the S3 key s3prefix +
    /// exportTaskId + '.' + diskImageFormat.</p>
    pub s3_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportToS3TaskSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportToS3TaskSpecification");
        formatter.field("container_format", &self.container_format);
        formatter.field("disk_image_format", &self.disk_image_format);
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_prefix", &self.s3_prefix);
        formatter.finish()
    }
}
/// See [`ExportToS3TaskSpecification`](crate::model::ExportToS3TaskSpecification)
pub mod export_to_s3_task_specification {
    /// A builder for [`ExportToS3TaskSpecification`](crate::model::ExportToS3TaskSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_format: std::option::Option<crate::model::ContainerFormat>,
        pub(crate) disk_image_format: std::option::Option<crate::model::DiskImageFormat>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is
        /// exported.</p>
        pub fn container_format(mut self, input: crate::model::ContainerFormat) -> Self {
            self.container_format = Some(input);
            self
        }
        pub fn set_container_format(
            mut self,
            input: std::option::Option<crate::model::ContainerFormat>,
        ) -> Self {
            self.container_format = input;
            self
        }
        /// <p>The format for the exported image.</p>
        pub fn disk_image_format(mut self, input: crate::model::DiskImageFormat) -> Self {
            self.disk_image_format = Some(input);
            self
        }
        pub fn set_disk_image_format(
            mut self,
            input: std::option::Option<crate::model::DiskImageFormat>,
        ) -> Self {
            self.disk_image_format = input;
            self
        }
        /// <p>The Amazon S3 bucket for the destination image. The destination bucket must exist and grant
        /// WRITE and READ_ACP permissions to the Amazon Web Services account <code>vm-import-export@amazon.com</code>.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(input.into());
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = input;
            self
        }
        /// <p>The image is written to a single object in the Amazon S3 bucket at the S3 key s3prefix +
        /// exportTaskId + '.' + diskImageFormat.</p>
        pub fn s3_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(input.into());
            self
        }
        pub fn set_s3_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportToS3TaskSpecification`](crate::model::ExportToS3TaskSpecification)
        pub fn build(self) -> crate::model::ExportToS3TaskSpecification {
            crate::model::ExportToS3TaskSpecification {
                container_format: self.container_format,
                disk_image_format: self.disk_image_format,
                s3_bucket: self.s3_bucket,
                s3_prefix: self.s3_prefix,
            }
        }
    }
}
impl ExportToS3TaskSpecification {
    /// Creates a new builder-style object to manufacture [`ExportToS3TaskSpecification`](crate::model::ExportToS3TaskSpecification)
    pub fn builder() -> crate::model::export_to_s3_task_specification::Builder {
        crate::model::export_to_s3_task_specification::Builder::default()
    }
}

/// <p>Describes a storage location in Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageLocation {
    /// <p>The name of the S3 bucket.</p>
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The key.</p>
    pub key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StorageLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageLocation");
        formatter.field("bucket", &self.bucket);
        formatter.field("key", &self.key);
        formatter.finish()
    }
}
/// See [`StorageLocation`](crate::model::StorageLocation)
pub mod storage_location {
    /// A builder for [`StorageLocation`](crate::model::StorageLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageLocation`](crate::model::StorageLocation)
        pub fn build(self) -> crate::model::StorageLocation {
            crate::model::StorageLocation {
                bucket: self.bucket,
                key: self.key,
            }
        }
    }
}
impl StorageLocation {
    /// Creates a new builder-style object to manufacture [`StorageLocation`](crate::model::StorageLocation)
    pub fn builder() -> crate::model::storage_location::Builder {
        crate::model::storage_location::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FlowLogsResourceType {
    NetworkInterface,
    Subnet,
    Vpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FlowLogsResourceType {
    fn from(s: &str) -> Self {
        match s {
            "NetworkInterface" => FlowLogsResourceType::NetworkInterface,
            "Subnet" => FlowLogsResourceType::Subnet,
            "VPC" => FlowLogsResourceType::Vpc,
            other => FlowLogsResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FlowLogsResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FlowLogsResourceType::from(s))
    }
}
impl FlowLogsResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            FlowLogsResourceType::NetworkInterface => "NetworkInterface",
            FlowLogsResourceType::Subnet => "Subnet",
            FlowLogsResourceType::Vpc => "VPC",
            FlowLogsResourceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["NetworkInterface", "Subnet", "VPC"]
    }
}
impl AsRef<str> for FlowLogsResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the instances that were launched by the fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFleetInstance {
    /// <p>The launch templates and overrides that were used for launching the instances. The
    /// values that you specify in the Overrides replace the values in the launch template.</p>
    pub launch_template_and_overrides:
        std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
    /// <p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>
    pub lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
    /// <p>The IDs of the instances.</p>
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is
    /// blank.</p>
    pub platform: std::option::Option<crate::model::PlatformValues>,
}
impl std::fmt::Debug for CreateFleetInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFleetInstance");
        formatter.field(
            "launch_template_and_overrides",
            &self.launch_template_and_overrides,
        );
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("platform", &self.platform);
        formatter.finish()
    }
}
/// See [`CreateFleetInstance`](crate::model::CreateFleetInstance)
pub mod create_fleet_instance {
    /// A builder for [`CreateFleetInstance`](crate::model::CreateFleetInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_and_overrides:
            std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        pub(crate) lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) platform: std::option::Option<crate::model::PlatformValues>,
    }
    impl Builder {
        /// <p>The launch templates and overrides that were used for launching the instances. The
        /// values that you specify in the Overrides replace the values in the launch template.</p>
        pub fn launch_template_and_overrides(
            mut self,
            input: crate::model::LaunchTemplateAndOverridesResponse,
        ) -> Self {
            self.launch_template_and_overrides = Some(input);
            self
        }
        pub fn set_launch_template_and_overrides(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        ) -> Self {
            self.launch_template_and_overrides = input;
            self
        }
        /// <p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>
        pub fn lifecycle(mut self, input: crate::model::InstanceLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::InstanceLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is
        /// blank.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFleetInstance`](crate::model::CreateFleetInstance)
        pub fn build(self) -> crate::model::CreateFleetInstance {
            crate::model::CreateFleetInstance {
                launch_template_and_overrides: self.launch_template_and_overrides,
                lifecycle: self.lifecycle,
                instance_ids: self.instance_ids,
                instance_type: self.instance_type,
                platform: self.platform,
            }
        }
    }
}
impl CreateFleetInstance {
    /// Creates a new builder-style object to manufacture [`CreateFleetInstance`](crate::model::CreateFleetInstance)
    pub fn builder() -> crate::model::create_fleet_instance::Builder {
        crate::model::create_fleet_instance::Builder::default()
    }
}

/// <p>Describes the instances that could not be launched by the fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFleetError {
    /// <p>The launch templates and overrides that were used for launching the instances. The
    /// values that you specify in the Overrides replace the values in the launch template.</p>
    pub launch_template_and_overrides:
        std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
    /// <p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>
    pub lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
    /// <p>The error code that indicates why the instance could not be launched. For more
    /// information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message that describes why the instance could not be launched. For more
    /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateFleetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFleetError");
        formatter.field(
            "launch_template_and_overrides",
            &self.launch_template_and_overrides,
        );
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`CreateFleetError`](crate::model::CreateFleetError)
pub mod create_fleet_error {
    /// A builder for [`CreateFleetError`](crate::model::CreateFleetError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_and_overrides:
            std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        pub(crate) lifecycle: std::option::Option<crate::model::InstanceLifecycle>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The launch templates and overrides that were used for launching the instances. The
        /// values that you specify in the Overrides replace the values in the launch template.</p>
        pub fn launch_template_and_overrides(
            mut self,
            input: crate::model::LaunchTemplateAndOverridesResponse,
        ) -> Self {
            self.launch_template_and_overrides = Some(input);
            self
        }
        pub fn set_launch_template_and_overrides(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateAndOverridesResponse>,
        ) -> Self {
            self.launch_template_and_overrides = input;
            self
        }
        /// <p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>
        pub fn lifecycle(mut self, input: crate::model::InstanceLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::InstanceLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>The error code that indicates why the instance could not be launched. For more
        /// information about error codes, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message that describes why the instance could not be launched. For more
        /// information about error messages, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html">Error Codes</a>.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFleetError`](crate::model::CreateFleetError)
        pub fn build(self) -> crate::model::CreateFleetError {
            crate::model::CreateFleetError {
                launch_template_and_overrides: self.launch_template_and_overrides,
                lifecycle: self.lifecycle,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl CreateFleetError {
    /// Creates a new builder-style object to manufacture [`CreateFleetError`](crate::model::CreateFleetError)
    pub fn builder() -> crate::model::create_fleet_error::Builder {
        crate::model::create_fleet_error::Builder::default()
    }
}

/// <p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnDemandOptionsRequest {
    /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
    /// you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching
    /// the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority
    /// that you assigned to each launch template override, launching the highest priority first.
    /// If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
    pub allocation_strategy: std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
    /// <p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub capacity_reservation_options:
        std::option::Option<crate::model::CapacityReservationOptionsRequest>,
    /// <p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub single_instance_type: std::option::Option<bool>,
    /// <p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported
    /// only for fleets of type <code>instant</code>.</p>
    pub single_availability_zone: std::option::Option<bool>,
    /// <p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is
    /// not reached, the fleet launches no instances.</p>
    pub min_target_capacity: std::option::Option<i32>,
    /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>
    pub max_total_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OnDemandOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnDemandOptionsRequest");
        formatter.field("allocation_strategy", &self.allocation_strategy);
        formatter.field(
            "capacity_reservation_options",
            &self.capacity_reservation_options,
        );
        formatter.field("single_instance_type", &self.single_instance_type);
        formatter.field("single_availability_zone", &self.single_availability_zone);
        formatter.field("min_target_capacity", &self.min_target_capacity);
        formatter.field("max_total_price", &self.max_total_price);
        formatter.finish()
    }
}
/// See [`OnDemandOptionsRequest`](crate::model::OnDemandOptionsRequest)
pub mod on_demand_options_request {
    /// A builder for [`OnDemandOptionsRequest`](crate::model::OnDemandOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_strategy:
            std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
        pub(crate) capacity_reservation_options:
            std::option::Option<crate::model::CapacityReservationOptionsRequest>,
        pub(crate) single_instance_type: std::option::Option<bool>,
        pub(crate) single_availability_zone: std::option::Option<bool>,
        pub(crate) min_target_capacity: std::option::Option<i32>,
        pub(crate) max_total_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If
        /// you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching
        /// the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority
        /// that you assigned to each launch template override, launching the highest priority first.
        /// If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
        pub fn allocation_strategy(
            mut self,
            input: crate::model::FleetOnDemandAllocationStrategy,
        ) -> Self {
            self.allocation_strategy = Some(input);
            self
        }
        pub fn set_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetOnDemandAllocationStrategy>,
        ) -> Self {
            self.allocation_strategy = input;
            self
        }
        /// <p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn capacity_reservation_options(
            mut self,
            input: crate::model::CapacityReservationOptionsRequest,
        ) -> Self {
            self.capacity_reservation_options = Some(input);
            self
        }
        pub fn set_capacity_reservation_options(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationOptionsRequest>,
        ) -> Self {
            self.capacity_reservation_options = input;
            self
        }
        /// <p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn single_instance_type(mut self, input: bool) -> Self {
            self.single_instance_type = Some(input);
            self
        }
        pub fn set_single_instance_type(mut self, input: std::option::Option<bool>) -> Self {
            self.single_instance_type = input;
            self
        }
        /// <p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported
        /// only for fleets of type <code>instant</code>.</p>
        pub fn single_availability_zone(mut self, input: bool) -> Self {
            self.single_availability_zone = Some(input);
            self
        }
        pub fn set_single_availability_zone(mut self, input: std::option::Option<bool>) -> Self {
            self.single_availability_zone = input;
            self
        }
        /// <p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is
        /// not reached, the fleet launches no instances.</p>
        pub fn min_target_capacity(mut self, input: i32) -> Self {
            self.min_target_capacity = Some(input);
            self
        }
        pub fn set_min_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_target_capacity = input;
            self
        }
        /// <p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>
        pub fn max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_total_price = Some(input.into());
            self
        }
        pub fn set_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_total_price = input;
            self
        }
        /// Consumes the builder and constructs a [`OnDemandOptionsRequest`](crate::model::OnDemandOptionsRequest)
        pub fn build(self) -> crate::model::OnDemandOptionsRequest {
            crate::model::OnDemandOptionsRequest {
                allocation_strategy: self.allocation_strategy,
                capacity_reservation_options: self.capacity_reservation_options,
                single_instance_type: self.single_instance_type,
                single_availability_zone: self.single_availability_zone,
                min_target_capacity: self.min_target_capacity,
                max_total_price: self.max_total_price,
            }
        }
    }
}
impl OnDemandOptionsRequest {
    /// Creates a new builder-style object to manufacture [`OnDemandOptionsRequest`](crate::model::OnDemandOptionsRequest)
    pub fn builder() -> crate::model::on_demand_options_request::Builder {
        crate::model::on_demand_options_request::Builder::default()
    }
}

/// <p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand
/// capacity.</p>
/// <note>
/// <p>This strategy can only be used if the EC2 Fleet is of type <code>instant</code>.</p>
/// </note>
/// <p>For more information about Capacity Reservations, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html">On-Demand Capacity
/// Reservations</a> in the <i>Amazon EC2 User Guide</i>. For examples of using
/// Capacity Reservations in an EC2 Fleet, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html">EC2 Fleet example
/// configurations</a> in the <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityReservationOptionsRequest {
    /// <p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p>
    /// <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused
    /// Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If
    /// multiple instance pools have unused Capacity Reservations, the On-Demand allocation
    /// strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number
    /// of unused Capacity Reservations is less than the On-Demand target capacity, the remaining
    /// On-Demand target capacity is launched according to the On-Demand allocation strategy
    /// (<code>lowest-price</code> or <code>prioritized</code>).</p>
    /// <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the
    /// chosen On-Demand allocation strategy.</p>
    pub usage_strategy: std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
}
impl std::fmt::Debug for CapacityReservationOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityReservationOptionsRequest");
        formatter.field("usage_strategy", &self.usage_strategy);
        formatter.finish()
    }
}
/// See [`CapacityReservationOptionsRequest`](crate::model::CapacityReservationOptionsRequest)
pub mod capacity_reservation_options_request {
    /// A builder for [`CapacityReservationOptionsRequest`](crate::model::CapacityReservationOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) usage_strategy:
            std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
    }
    impl Builder {
        /// <p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p>
        /// <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused
        /// Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If
        /// multiple instance pools have unused Capacity Reservations, the On-Demand allocation
        /// strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number
        /// of unused Capacity Reservations is less than the On-Demand target capacity, the remaining
        /// On-Demand target capacity is launched according to the On-Demand allocation strategy
        /// (<code>lowest-price</code> or <code>prioritized</code>).</p>
        /// <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the
        /// chosen On-Demand allocation strategy.</p>
        pub fn usage_strategy(
            mut self,
            input: crate::model::FleetCapacityReservationUsageStrategy,
        ) -> Self {
            self.usage_strategy = Some(input);
            self
        }
        pub fn set_usage_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetCapacityReservationUsageStrategy>,
        ) -> Self {
            self.usage_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityReservationOptionsRequest`](crate::model::CapacityReservationOptionsRequest)
        pub fn build(self) -> crate::model::CapacityReservationOptionsRequest {
            crate::model::CapacityReservationOptionsRequest {
                usage_strategy: self.usage_strategy,
            }
        }
    }
}
impl CapacityReservationOptionsRequest {
    /// Creates a new builder-style object to manufacture [`CapacityReservationOptionsRequest`](crate::model::CapacityReservationOptionsRequest)
    pub fn builder() -> crate::model::capacity_reservation_options_request::Builder {
        crate::model::capacity_reservation_options_request::Builder::default()
    }
}

/// <p>Describes the configuration of Spot Instances in an EC2 Fleet request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpotOptionsRequest {
    /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
    /// the EC2 Fleet.</p>
    /// <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from
    /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
    /// <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all
    /// of the Spot Instance pools that you specify.</p>
    /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), EC2 Fleet
    /// launches instances from Spot Instance pools with optimal capacity for the number of instances that
    /// are launching. To give certain instance types a higher chance of launching first, use
    /// <code>capacity-optimized-prioritized</code>. Set a priority for each instance type by
    /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You can
    /// assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2 implements
    /// the priorities on a best-effort basis, but optimizes for capacity first.
    /// <code>capacity-optimized-prioritized</code> is supported only if your fleet uses a
    /// launch template. Note that if the On-Demand <code>AllocationStrategy</code> is set to
    /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
    /// capacity.</p>
    pub allocation_strategy: std::option::Option<crate::model::SpotAllocationStrategy>,
    /// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
    /// interrupted.</p>
    pub maintenance_strategies:
        std::option::Option<crate::model::FleetSpotMaintenanceStrategiesRequest>,
    /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
    pub instance_interruption_behavior:
        std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
    /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only
    /// when Spot <b>AllocationStrategy</b> is set to
    /// <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates
    /// your target Spot capacity across the number of Spot pools that you specify.</p>
    /// <p>Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a
    /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
    /// capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest
    /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
    /// the number of pools that you specified. Similarly, if most of the pools have no Spot
    /// capacity, you might receive your full target capacity from fewer than the number of pools
    /// that you specified.</p>
    pub instance_pools_to_use_count: std::option::Option<i32>,
    /// <p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
    /// Supported only for fleets of type <code>instant</code>.</p>
    pub single_instance_type: std::option::Option<bool>,
    /// <p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported
    /// only for fleets of type <code>instant</code>.</p>
    pub single_availability_zone: std::option::Option<bool>,
    /// <p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is
    /// not reached, the fleet launches no instances.</p>
    pub min_target_capacity: std::option::Option<i32>,
    /// <p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>
    pub max_total_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SpotOptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpotOptionsRequest");
        formatter.field("allocation_strategy", &self.allocation_strategy);
        formatter.field("maintenance_strategies", &self.maintenance_strategies);
        formatter.field(
            "instance_interruption_behavior",
            &self.instance_interruption_behavior,
        );
        formatter.field(
            "instance_pools_to_use_count",
            &self.instance_pools_to_use_count,
        );
        formatter.field("single_instance_type", &self.single_instance_type);
        formatter.field("single_availability_zone", &self.single_availability_zone);
        formatter.field("min_target_capacity", &self.min_target_capacity);
        formatter.field("max_total_price", &self.max_total_price);
        formatter.finish()
    }
}
/// See [`SpotOptionsRequest`](crate::model::SpotOptionsRequest)
pub mod spot_options_request {
    /// A builder for [`SpotOptionsRequest`](crate::model::SpotOptionsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allocation_strategy: std::option::Option<crate::model::SpotAllocationStrategy>,
        pub(crate) maintenance_strategies:
            std::option::Option<crate::model::FleetSpotMaintenanceStrategiesRequest>,
        pub(crate) instance_interruption_behavior:
            std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
        pub(crate) instance_pools_to_use_count: std::option::Option<i32>,
        pub(crate) single_instance_type: std::option::Option<bool>,
        pub(crate) single_availability_zone: std::option::Option<bool>,
        pub(crate) min_target_capacity: std::option::Option<i32>,
        pub(crate) max_total_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by
        /// the EC2 Fleet.</p>
        /// <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from
        /// the Spot Instance pools with the lowest price. This is the default allocation strategy.</p>
        /// <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all
        /// of the Spot Instance pools that you specify.</p>
        /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), EC2 Fleet
        /// launches instances from Spot Instance pools with optimal capacity for the number of instances that
        /// are launching. To give certain instance types a higher chance of launching first, use
        /// <code>capacity-optimized-prioritized</code>. Set a priority for each instance type by
        /// using the <code>Priority</code> parameter for <code>LaunchTemplateOverrides</code>. You can
        /// assign the same priority to different <code>LaunchTemplateOverrides</code>. EC2 implements
        /// the priorities on a best-effort basis, but optimizes for capacity first.
        /// <code>capacity-optimized-prioritized</code> is supported only if your fleet uses a
        /// launch template. Note that if the On-Demand <code>AllocationStrategy</code> is set to
        /// <code>prioritized</code>, the same priority is applied when fulfilling On-Demand
        /// capacity.</p>
        pub fn allocation_strategy(mut self, input: crate::model::SpotAllocationStrategy) -> Self {
            self.allocation_strategy = Some(input);
            self
        }
        pub fn set_allocation_strategy(
            mut self,
            input: std::option::Option<crate::model::SpotAllocationStrategy>,
        ) -> Self {
            self.allocation_strategy = input;
            self
        }
        /// <p>The strategies for managing your Spot Instances that are at an elevated risk of being
        /// interrupted.</p>
        pub fn maintenance_strategies(
            mut self,
            input: crate::model::FleetSpotMaintenanceStrategiesRequest,
        ) -> Self {
            self.maintenance_strategies = Some(input);
            self
        }
        pub fn set_maintenance_strategies(
            mut self,
            input: std::option::Option<crate::model::FleetSpotMaintenanceStrategiesRequest>,
        ) -> Self {
            self.maintenance_strategies = input;
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::SpotInstanceInterruptionBehavior,
        ) -> Self {
            self.instance_interruption_behavior = Some(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceInterruptionBehavior>,
        ) -> Self {
            self.instance_interruption_behavior = input;
            self
        }
        /// <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only
        /// when Spot <b>AllocationStrategy</b> is set to
        /// <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates
        /// your target Spot capacity across the number of Spot pools that you specify.</p>
        /// <p>Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a
        /// best effort basis. If a pool runs out of Spot capacity before fulfilling your target
        /// capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest
        /// pool. To ensure that your target capacity is met, you might receive Spot Instances from more than
        /// the number of pools that you specified. Similarly, if most of the pools have no Spot
        /// capacity, you might receive your full target capacity from fewer than the number of pools
        /// that you specified.</p>
        pub fn instance_pools_to_use_count(mut self, input: i32) -> Self {
            self.instance_pools_to_use_count = Some(input);
            self
        }
        pub fn set_instance_pools_to_use_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_pools_to_use_count = input;
            self
        }
        /// <p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
        /// Supported only for fleets of type <code>instant</code>.</p>
        pub fn single_instance_type(mut self, input: bool) -> Self {
            self.single_instance_type = Some(input);
            self
        }
        pub fn set_single_instance_type(mut self, input: std::option::Option<bool>) -> Self {
            self.single_instance_type = input;
            self
        }
        /// <p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported
        /// only for fleets of type <code>instant</code>.</p>
        pub fn single_availability_zone(mut self, input: bool) -> Self {
            self.single_availability_zone = Some(input);
            self
        }
        pub fn set_single_availability_zone(mut self, input: std::option::Option<bool>) -> Self {
            self.single_availability_zone = input;
            self
        }
        /// <p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is
        /// not reached, the fleet launches no instances.</p>
        pub fn min_target_capacity(mut self, input: i32) -> Self {
            self.min_target_capacity = Some(input);
            self
        }
        pub fn set_min_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_target_capacity = input;
            self
        }
        /// <p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>
        pub fn max_total_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_total_price = Some(input.into());
            self
        }
        pub fn set_max_total_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_total_price = input;
            self
        }
        /// Consumes the builder and constructs a [`SpotOptionsRequest`](crate::model::SpotOptionsRequest)
        pub fn build(self) -> crate::model::SpotOptionsRequest {
            crate::model::SpotOptionsRequest {
                allocation_strategy: self.allocation_strategy,
                maintenance_strategies: self.maintenance_strategies,
                instance_interruption_behavior: self.instance_interruption_behavior,
                instance_pools_to_use_count: self.instance_pools_to_use_count,
                single_instance_type: self.single_instance_type,
                single_availability_zone: self.single_availability_zone,
                min_target_capacity: self.min_target_capacity,
                max_total_price: self.max_total_price,
            }
        }
    }
}
impl SpotOptionsRequest {
    /// Creates a new builder-style object to manufacture [`SpotOptionsRequest`](crate::model::SpotOptionsRequest)
    pub fn builder() -> crate::model::spot_options_request::Builder {
        crate::model::spot_options_request::Builder::default()
    }
}

/// <p>The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetSpotMaintenanceStrategiesRequest {
    /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
    /// elevated risk of being interrupted.</p>
    pub capacity_rebalance: std::option::Option<crate::model::FleetSpotCapacityRebalanceRequest>,
}
impl std::fmt::Debug for FleetSpotMaintenanceStrategiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetSpotMaintenanceStrategiesRequest");
        formatter.field("capacity_rebalance", &self.capacity_rebalance);
        formatter.finish()
    }
}
/// See [`FleetSpotMaintenanceStrategiesRequest`](crate::model::FleetSpotMaintenanceStrategiesRequest)
pub mod fleet_spot_maintenance_strategies_request {
    /// A builder for [`FleetSpotMaintenanceStrategiesRequest`](crate::model::FleetSpotMaintenanceStrategiesRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_rebalance:
            std::option::Option<crate::model::FleetSpotCapacityRebalanceRequest>,
    }
    impl Builder {
        /// <p>The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an
        /// elevated risk of being interrupted.</p>
        pub fn capacity_rebalance(
            mut self,
            input: crate::model::FleetSpotCapacityRebalanceRequest,
        ) -> Self {
            self.capacity_rebalance = Some(input);
            self
        }
        pub fn set_capacity_rebalance(
            mut self,
            input: std::option::Option<crate::model::FleetSpotCapacityRebalanceRequest>,
        ) -> Self {
            self.capacity_rebalance = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSpotMaintenanceStrategiesRequest`](crate::model::FleetSpotMaintenanceStrategiesRequest)
        pub fn build(self) -> crate::model::FleetSpotMaintenanceStrategiesRequest {
            crate::model::FleetSpotMaintenanceStrategiesRequest {
                capacity_rebalance: self.capacity_rebalance,
            }
        }
    }
}
impl FleetSpotMaintenanceStrategiesRequest {
    /// Creates a new builder-style object to manufacture [`FleetSpotMaintenanceStrategiesRequest`](crate::model::FleetSpotMaintenanceStrategiesRequest)
    pub fn builder() -> crate::model::fleet_spot_maintenance_strategies_request::Builder {
        crate::model::fleet_spot_maintenance_strategies_request::Builder::default()
    }
}

/// <p>The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your
/// Spot Instance is at an elevated risk of being interrupted. For more information, see
/// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-configuration-strategies.html#ec2-fleet-capacity-rebalance">Capacity rebalancing</a> in the <i>Amazon EC2 User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FleetSpotCapacityRebalanceRequest {
    /// <p>The replacement strategy to use. Only available for fleets of type
    /// <code>maintain</code>.</p>
    /// <p>To allow EC2 Fleet to launch a replacement Spot Instance when an instance rebalance
    /// notification is emitted for an existing Spot Instance in the fleet, specify
    /// <code>launch</code>. You must specify a value, otherwise you get an error.</p>
    /// <note>
    /// <p>When a replacement instance is launched, the instance marked for rebalance is not
    /// automatically terminated. You can terminate it, or you can leave it running. You are charged for all instances while they are running.</p>
    /// </note>
    pub replacement_strategy: std::option::Option<crate::model::FleetReplacementStrategy>,
}
impl std::fmt::Debug for FleetSpotCapacityRebalanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FleetSpotCapacityRebalanceRequest");
        formatter.field("replacement_strategy", &self.replacement_strategy);
        formatter.finish()
    }
}
/// See [`FleetSpotCapacityRebalanceRequest`](crate::model::FleetSpotCapacityRebalanceRequest)
pub mod fleet_spot_capacity_rebalance_request {
    /// A builder for [`FleetSpotCapacityRebalanceRequest`](crate::model::FleetSpotCapacityRebalanceRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) replacement_strategy:
            std::option::Option<crate::model::FleetReplacementStrategy>,
    }
    impl Builder {
        /// <p>The replacement strategy to use. Only available for fleets of type
        /// <code>maintain</code>.</p>
        /// <p>To allow EC2 Fleet to launch a replacement Spot Instance when an instance rebalance
        /// notification is emitted for an existing Spot Instance in the fleet, specify
        /// <code>launch</code>. You must specify a value, otherwise you get an error.</p>
        /// <note>
        /// <p>When a replacement instance is launched, the instance marked for rebalance is not
        /// automatically terminated. You can terminate it, or you can leave it running. You are charged for all instances while they are running.</p>
        /// </note>
        pub fn replacement_strategy(
            mut self,
            input: crate::model::FleetReplacementStrategy,
        ) -> Self {
            self.replacement_strategy = Some(input);
            self
        }
        pub fn set_replacement_strategy(
            mut self,
            input: std::option::Option<crate::model::FleetReplacementStrategy>,
        ) -> Self {
            self.replacement_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSpotCapacityRebalanceRequest`](crate::model::FleetSpotCapacityRebalanceRequest)
        pub fn build(self) -> crate::model::FleetSpotCapacityRebalanceRequest {
            crate::model::FleetSpotCapacityRebalanceRequest {
                replacement_strategy: self.replacement_strategy,
            }
        }
    }
}
impl FleetSpotCapacityRebalanceRequest {
    /// Creates a new builder-style object to manufacture [`FleetSpotCapacityRebalanceRequest`](crate::model::FleetSpotCapacityRebalanceRequest)
    pub fn builder() -> crate::model::fleet_spot_capacity_rebalance_request::Builder {
        crate::model::fleet_spot_capacity_rebalance_request::Builder::default()
    }
}

/// <p>Describes a DHCP configuration option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NewDhcpConfiguration {
    /// <p>The name of a DHCP option.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>One or more values for the DHCP option.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for NewDhcpConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NewDhcpConfiguration");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`NewDhcpConfiguration`](crate::model::NewDhcpConfiguration)
pub mod new_dhcp_configuration {
    /// A builder for [`NewDhcpConfiguration`](crate::model::NewDhcpConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of a DHCP option.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`NewDhcpConfiguration`](crate::model::NewDhcpConfiguration)
        pub fn build(self) -> crate::model::NewDhcpConfiguration {
            crate::model::NewDhcpConfiguration {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl NewDhcpConfiguration {
    /// Creates a new builder-style object to manufacture [`NewDhcpConfiguration`](crate::model::NewDhcpConfiguration)
    pub fn builder() -> crate::model::new_dhcp_configuration::Builder {
        crate::model::new_dhcp_configuration::Builder::default()
    }
}

/// <p>Describes the authentication method to be used by a Client VPN endpoint. For more information, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication">Authentication</a>
/// in the <i>AWS Client VPN Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientVpnAuthenticationRequest {
    /// <p>The type of client authentication to be used.</p>
    pub r#type: std::option::Option<crate::model::ClientVpnAuthenticationType>,
    /// <p>Information about the Active Directory to be used, if applicable. You must provide this information if <b>Type</b> is <code>directory-service-authentication</code>.</p>
    pub active_directory: std::option::Option<crate::model::DirectoryServiceAuthenticationRequest>,
    /// <p>Information about the authentication certificates to be used, if applicable. You must provide this information if <b>Type</b> is <code>certificate-authentication</code>.</p>
    pub mutual_authentication: std::option::Option<crate::model::CertificateAuthenticationRequest>,
    /// <p>Information about the IAM SAML identity provider to be used, if applicable. You must provide this information if <b>Type</b> is <code>federated-authentication</code>.</p>
    pub federated_authentication: std::option::Option<crate::model::FederatedAuthenticationRequest>,
}
impl std::fmt::Debug for ClientVpnAuthenticationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientVpnAuthenticationRequest");
        formatter.field("r#type", &self.r#type);
        formatter.field("active_directory", &self.active_directory);
        formatter.field("mutual_authentication", &self.mutual_authentication);
        formatter.field("federated_authentication", &self.federated_authentication);
        formatter.finish()
    }
}
/// See [`ClientVpnAuthenticationRequest`](crate::model::ClientVpnAuthenticationRequest)
pub mod client_vpn_authentication_request {
    /// A builder for [`ClientVpnAuthenticationRequest`](crate::model::ClientVpnAuthenticationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ClientVpnAuthenticationType>,
        pub(crate) active_directory:
            std::option::Option<crate::model::DirectoryServiceAuthenticationRequest>,
        pub(crate) mutual_authentication:
            std::option::Option<crate::model::CertificateAuthenticationRequest>,
        pub(crate) federated_authentication:
            std::option::Option<crate::model::FederatedAuthenticationRequest>,
    }
    impl Builder {
        /// <p>The type of client authentication to be used.</p>
        pub fn r#type(mut self, input: crate::model::ClientVpnAuthenticationType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ClientVpnAuthenticationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Information about the Active Directory to be used, if applicable. You must provide this information if <b>Type</b> is <code>directory-service-authentication</code>.</p>
        pub fn active_directory(
            mut self,
            input: crate::model::DirectoryServiceAuthenticationRequest,
        ) -> Self {
            self.active_directory = Some(input);
            self
        }
        pub fn set_active_directory(
            mut self,
            input: std::option::Option<crate::model::DirectoryServiceAuthenticationRequest>,
        ) -> Self {
            self.active_directory = input;
            self
        }
        /// <p>Information about the authentication certificates to be used, if applicable. You must provide this information if <b>Type</b> is <code>certificate-authentication</code>.</p>
        pub fn mutual_authentication(
            mut self,
            input: crate::model::CertificateAuthenticationRequest,
        ) -> Self {
            self.mutual_authentication = Some(input);
            self
        }
        pub fn set_mutual_authentication(
            mut self,
            input: std::option::Option<crate::model::CertificateAuthenticationRequest>,
        ) -> Self {
            self.mutual_authentication = input;
            self
        }
        /// <p>Information about the IAM SAML identity provider to be used, if applicable. You must provide this information if <b>Type</b> is <code>federated-authentication</code>.</p>
        pub fn federated_authentication(
            mut self,
            input: crate::model::FederatedAuthenticationRequest,
        ) -> Self {
            self.federated_authentication = Some(input);
            self
        }
        pub fn set_federated_authentication(
            mut self,
            input: std::option::Option<crate::model::FederatedAuthenticationRequest>,
        ) -> Self {
            self.federated_authentication = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientVpnAuthenticationRequest`](crate::model::ClientVpnAuthenticationRequest)
        pub fn build(self) -> crate::model::ClientVpnAuthenticationRequest {
            crate::model::ClientVpnAuthenticationRequest {
                r#type: self.r#type,
                active_directory: self.active_directory,
                mutual_authentication: self.mutual_authentication,
                federated_authentication: self.federated_authentication,
            }
        }
    }
}
impl ClientVpnAuthenticationRequest {
    /// Creates a new builder-style object to manufacture [`ClientVpnAuthenticationRequest`](crate::model::ClientVpnAuthenticationRequest)
    pub fn builder() -> crate::model::client_vpn_authentication_request::Builder {
        crate::model::client_vpn_authentication_request::Builder::default()
    }
}

/// <p>The IAM SAML identity provider used for federated authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FederatedAuthenticationRequest {
    /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider.</p>
    pub saml_provider_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.</p>
    pub self_service_saml_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FederatedAuthenticationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FederatedAuthenticationRequest");
        formatter.field("saml_provider_arn", &self.saml_provider_arn);
        formatter.field(
            "self_service_saml_provider_arn",
            &self.self_service_saml_provider_arn,
        );
        formatter.finish()
    }
}
/// See [`FederatedAuthenticationRequest`](crate::model::FederatedAuthenticationRequest)
pub mod federated_authentication_request {
    /// A builder for [`FederatedAuthenticationRequest`](crate::model::FederatedAuthenticationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) saml_provider_arn: std::option::Option<std::string::String>,
        pub(crate) self_service_saml_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider.</p>
        pub fn saml_provider_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.saml_provider_arn = Some(input.into());
            self
        }
        pub fn set_saml_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_provider_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.</p>
        pub fn self_service_saml_provider_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.self_service_saml_provider_arn = Some(input.into());
            self
        }
        pub fn set_self_service_saml_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.self_service_saml_provider_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`FederatedAuthenticationRequest`](crate::model::FederatedAuthenticationRequest)
        pub fn build(self) -> crate::model::FederatedAuthenticationRequest {
            crate::model::FederatedAuthenticationRequest {
                saml_provider_arn: self.saml_provider_arn,
                self_service_saml_provider_arn: self.self_service_saml_provider_arn,
            }
        }
    }
}
impl FederatedAuthenticationRequest {
    /// Creates a new builder-style object to manufacture [`FederatedAuthenticationRequest`](crate::model::FederatedAuthenticationRequest)
    pub fn builder() -> crate::model::federated_authentication_request::Builder {
        crate::model::federated_authentication_request::Builder::default()
    }
}

/// <p>Information about the client certificate to be used for authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateAuthenticationRequest {
    /// <p>The ARN of the client certificate. The certificate must be signed by a certificate
    /// authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).</p>
    pub client_root_certificate_chain_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateAuthenticationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateAuthenticationRequest");
        formatter.field(
            "client_root_certificate_chain_arn",
            &self.client_root_certificate_chain_arn,
        );
        formatter.finish()
    }
}
/// See [`CertificateAuthenticationRequest`](crate::model::CertificateAuthenticationRequest)
pub mod certificate_authentication_request {
    /// A builder for [`CertificateAuthenticationRequest`](crate::model::CertificateAuthenticationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_root_certificate_chain_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the client certificate. The certificate must be signed by a certificate
        /// authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).</p>
        pub fn client_root_certificate_chain_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.client_root_certificate_chain_arn = Some(input.into());
            self
        }
        pub fn set_client_root_certificate_chain_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_root_certificate_chain_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateAuthenticationRequest`](crate::model::CertificateAuthenticationRequest)
        pub fn build(self) -> crate::model::CertificateAuthenticationRequest {
            crate::model::CertificateAuthenticationRequest {
                client_root_certificate_chain_arn: self.client_root_certificate_chain_arn,
            }
        }
    }
}
impl CertificateAuthenticationRequest {
    /// Creates a new builder-style object to manufacture [`CertificateAuthenticationRequest`](crate::model::CertificateAuthenticationRequest)
    pub fn builder() -> crate::model::certificate_authentication_request::Builder {
        crate::model::certificate_authentication_request::Builder::default()
    }
}

/// <p>Describes the Active Directory to be used for client authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectoryServiceAuthenticationRequest {
    /// <p>The ID of the Active Directory to be used for authentication.</p>
    pub directory_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectoryServiceAuthenticationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectoryServiceAuthenticationRequest");
        formatter.field("directory_id", &self.directory_id);
        formatter.finish()
    }
}
/// See [`DirectoryServiceAuthenticationRequest`](crate::model::DirectoryServiceAuthenticationRequest)
pub mod directory_service_authentication_request {
    /// A builder for [`DirectoryServiceAuthenticationRequest`](crate::model::DirectoryServiceAuthenticationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) directory_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Active Directory to be used for authentication.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryServiceAuthenticationRequest`](crate::model::DirectoryServiceAuthenticationRequest)
        pub fn build(self) -> crate::model::DirectoryServiceAuthenticationRequest {
            crate::model::DirectoryServiceAuthenticationRequest {
                directory_id: self.directory_id,
            }
        }
    }
}
impl DirectoryServiceAuthenticationRequest {
    /// Creates a new builder-style object to manufacture [`DirectoryServiceAuthenticationRequest`](crate::model::DirectoryServiceAuthenticationRequest)
    pub fn builder() -> crate::model::directory_service_authentication_request::Builder {
        crate::model::directory_service_authentication_request::Builder::default()
    }
}

/// <p>Describes a request to cancel a Spot Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelledSpotInstanceRequest {
    /// <p>The ID of the Spot Instance request.</p>
    pub spot_instance_request_id: std::option::Option<std::string::String>,
    /// <p>The state of the Spot Instance request.</p>
    pub state: std::option::Option<crate::model::CancelSpotInstanceRequestState>,
}
impl std::fmt::Debug for CancelledSpotInstanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelledSpotInstanceRequest");
        formatter.field("spot_instance_request_id", &self.spot_instance_request_id);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`CancelledSpotInstanceRequest`](crate::model::CancelledSpotInstanceRequest)
pub mod cancelled_spot_instance_request {
    /// A builder for [`CancelledSpotInstanceRequest`](crate::model::CancelledSpotInstanceRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) spot_instance_request_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CancelSpotInstanceRequestState>,
    }
    impl Builder {
        /// <p>The ID of the Spot Instance request.</p>
        pub fn spot_instance_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_instance_request_id = Some(input.into());
            self
        }
        pub fn set_spot_instance_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_instance_request_id = input;
            self
        }
        /// <p>The state of the Spot Instance request.</p>
        pub fn state(mut self, input: crate::model::CancelSpotInstanceRequestState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CancelSpotInstanceRequestState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelledSpotInstanceRequest`](crate::model::CancelledSpotInstanceRequest)
        pub fn build(self) -> crate::model::CancelledSpotInstanceRequest {
            crate::model::CancelledSpotInstanceRequest {
                spot_instance_request_id: self.spot_instance_request_id,
                state: self.state,
            }
        }
    }
}
impl CancelledSpotInstanceRequest {
    /// Creates a new builder-style object to manufacture [`CancelledSpotInstanceRequest`](crate::model::CancelledSpotInstanceRequest)
    pub fn builder() -> crate::model::cancelled_spot_instance_request::Builder {
        crate::model::cancelled_spot_instance_request::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CancelSpotInstanceRequestState {
    Active,
    Cancelled,
    Closed,
    Completed,
    Open,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CancelSpotInstanceRequestState {
    fn from(s: &str) -> Self {
        match s {
            "active" => CancelSpotInstanceRequestState::Active,
            "cancelled" => CancelSpotInstanceRequestState::Cancelled,
            "closed" => CancelSpotInstanceRequestState::Closed,
            "completed" => CancelSpotInstanceRequestState::Completed,
            "open" => CancelSpotInstanceRequestState::Open,
            other => CancelSpotInstanceRequestState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CancelSpotInstanceRequestState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CancelSpotInstanceRequestState::from(s))
    }
}
impl CancelSpotInstanceRequestState {
    pub fn as_str(&self) -> &str {
        match self {
            CancelSpotInstanceRequestState::Active => "active",
            CancelSpotInstanceRequestState::Cancelled => "cancelled",
            CancelSpotInstanceRequestState::Closed => "closed",
            CancelSpotInstanceRequestState::Completed => "completed",
            CancelSpotInstanceRequestState::Open => "open",
            CancelSpotInstanceRequestState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["active", "cancelled", "closed", "completed", "open"]
    }
}
impl AsRef<str> for CancelSpotInstanceRequestState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Spot Fleet request that was not successfully canceled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelSpotFleetRequestsErrorItem {
    /// <p>The error.</p>
    pub error: std::option::Option<crate::model::CancelSpotFleetRequestsError>,
    /// <p>The ID of the Spot Fleet request.</p>
    pub spot_fleet_request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelSpotFleetRequestsErrorItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelSpotFleetRequestsErrorItem");
        formatter.field("error", &self.error);
        formatter.field("spot_fleet_request_id", &self.spot_fleet_request_id);
        formatter.finish()
    }
}
/// See [`CancelSpotFleetRequestsErrorItem`](crate::model::CancelSpotFleetRequestsErrorItem)
pub mod cancel_spot_fleet_requests_error_item {
    /// A builder for [`CancelSpotFleetRequestsErrorItem`](crate::model::CancelSpotFleetRequestsErrorItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::CancelSpotFleetRequestsError>,
        pub(crate) spot_fleet_request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error.</p>
        pub fn error(mut self, input: crate::model::CancelSpotFleetRequestsError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::CancelSpotFleetRequestsError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_fleet_request_id = Some(input.into());
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_fleet_request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelSpotFleetRequestsErrorItem`](crate::model::CancelSpotFleetRequestsErrorItem)
        pub fn build(self) -> crate::model::CancelSpotFleetRequestsErrorItem {
            crate::model::CancelSpotFleetRequestsErrorItem {
                error: self.error,
                spot_fleet_request_id: self.spot_fleet_request_id,
            }
        }
    }
}
impl CancelSpotFleetRequestsErrorItem {
    /// Creates a new builder-style object to manufacture [`CancelSpotFleetRequestsErrorItem`](crate::model::CancelSpotFleetRequestsErrorItem)
    pub fn builder() -> crate::model::cancel_spot_fleet_requests_error_item::Builder {
        crate::model::cancel_spot_fleet_requests_error_item::Builder::default()
    }
}

/// <p>Describes a Spot Fleet error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelSpotFleetRequestsError {
    /// <p>The error code.</p>
    pub code: std::option::Option<crate::model::CancelBatchErrorCode>,
    /// <p>The description for the error code.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelSpotFleetRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelSpotFleetRequestsError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`CancelSpotFleetRequestsError`](crate::model::CancelSpotFleetRequestsError)
pub mod cancel_spot_fleet_requests_error {
    /// A builder for [`CancelSpotFleetRequestsError`](crate::model::CancelSpotFleetRequestsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::CancelBatchErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code.</p>
        pub fn code(mut self, input: crate::model::CancelBatchErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::CancelBatchErrorCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The description for the error code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelSpotFleetRequestsError`](crate::model::CancelSpotFleetRequestsError)
        pub fn build(self) -> crate::model::CancelSpotFleetRequestsError {
            crate::model::CancelSpotFleetRequestsError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl CancelSpotFleetRequestsError {
    /// Creates a new builder-style object to manufacture [`CancelSpotFleetRequestsError`](crate::model::CancelSpotFleetRequestsError)
    pub fn builder() -> crate::model::cancel_spot_fleet_requests_error::Builder {
        crate::model::cancel_spot_fleet_requests_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CancelBatchErrorCode {
    FleetRequestIdDoesNotExist,
    FleetRequestIdMalformed,
    FleetRequestNotInCancellableState,
    UnexpectedError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CancelBatchErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "fleetRequestIdDoesNotExist" => CancelBatchErrorCode::FleetRequestIdDoesNotExist,
            "fleetRequestIdMalformed" => CancelBatchErrorCode::FleetRequestIdMalformed,
            "fleetRequestNotInCancellableState" => {
                CancelBatchErrorCode::FleetRequestNotInCancellableState
            }
            "unexpectedError" => CancelBatchErrorCode::UnexpectedError,
            other => CancelBatchErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CancelBatchErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CancelBatchErrorCode::from(s))
    }
}
impl CancelBatchErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            CancelBatchErrorCode::FleetRequestIdDoesNotExist => "fleetRequestIdDoesNotExist",
            CancelBatchErrorCode::FleetRequestIdMalformed => "fleetRequestIdMalformed",
            CancelBatchErrorCode::FleetRequestNotInCancellableState => {
                "fleetRequestNotInCancellableState"
            }
            CancelBatchErrorCode::UnexpectedError => "unexpectedError",
            CancelBatchErrorCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "fleetRequestIdDoesNotExist",
            "fleetRequestIdMalformed",
            "fleetRequestNotInCancellableState",
            "unexpectedError",
        ]
    }
}
impl AsRef<str> for CancelBatchErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Spot Fleet request that was successfully canceled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelSpotFleetRequestsSuccessItem {
    /// <p>The current state of the Spot Fleet request.</p>
    pub current_spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
    /// <p>The previous state of the Spot Fleet request.</p>
    pub previous_spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
    /// <p>The ID of the Spot Fleet request.</p>
    pub spot_fleet_request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelSpotFleetRequestsSuccessItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelSpotFleetRequestsSuccessItem");
        formatter.field(
            "current_spot_fleet_request_state",
            &self.current_spot_fleet_request_state,
        );
        formatter.field(
            "previous_spot_fleet_request_state",
            &self.previous_spot_fleet_request_state,
        );
        formatter.field("spot_fleet_request_id", &self.spot_fleet_request_id);
        formatter.finish()
    }
}
/// See [`CancelSpotFleetRequestsSuccessItem`](crate::model::CancelSpotFleetRequestsSuccessItem)
pub mod cancel_spot_fleet_requests_success_item {
    /// A builder for [`CancelSpotFleetRequestsSuccessItem`](crate::model::CancelSpotFleetRequestsSuccessItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
        pub(crate) previous_spot_fleet_request_state: std::option::Option<crate::model::BatchState>,
        pub(crate) spot_fleet_request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of the Spot Fleet request.</p>
        pub fn current_spot_fleet_request_state(mut self, input: crate::model::BatchState) -> Self {
            self.current_spot_fleet_request_state = Some(input);
            self
        }
        pub fn set_current_spot_fleet_request_state(
            mut self,
            input: std::option::Option<crate::model::BatchState>,
        ) -> Self {
            self.current_spot_fleet_request_state = input;
            self
        }
        /// <p>The previous state of the Spot Fleet request.</p>
        pub fn previous_spot_fleet_request_state(
            mut self,
            input: crate::model::BatchState,
        ) -> Self {
            self.previous_spot_fleet_request_state = Some(input);
            self
        }
        pub fn set_previous_spot_fleet_request_state(
            mut self,
            input: std::option::Option<crate::model::BatchState>,
        ) -> Self {
            self.previous_spot_fleet_request_state = input;
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_fleet_request_id = Some(input.into());
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_fleet_request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelSpotFleetRequestsSuccessItem`](crate::model::CancelSpotFleetRequestsSuccessItem)
        pub fn build(self) -> crate::model::CancelSpotFleetRequestsSuccessItem {
            crate::model::CancelSpotFleetRequestsSuccessItem {
                current_spot_fleet_request_state: self.current_spot_fleet_request_state,
                previous_spot_fleet_request_state: self.previous_spot_fleet_request_state,
                spot_fleet_request_id: self.spot_fleet_request_id,
            }
        }
    }
}
impl CancelSpotFleetRequestsSuccessItem {
    /// Creates a new builder-style object to manufacture [`CancelSpotFleetRequestsSuccessItem`](crate::model::CancelSpotFleetRequestsSuccessItem)
    pub fn builder() -> crate::model::cancel_spot_fleet_requests_success_item::Builder {
        crate::model::cancel_spot_fleet_requests_success_item::Builder::default()
    }
}

/// <p>One or more targets associated with the specified event window. Only one
/// <i>type</i> of target (instance ID, instance tag, or Dedicated Host ID)
/// can be associated with an event window.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceEventWindowAssociationRequest {
    /// <p>The IDs of the instances to associate with the event window. If the instance is on a
    /// Dedicated Host, you can't specify the Instance ID parameter; you must use the Dedicated
    /// Host ID parameter.</p>
    pub instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance tags to associate with the event window. Any instances associated with the
    /// tags will be associated with the event window.</p>
    pub instance_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The IDs of the Dedicated Hosts to associate with the event window.</p>
    pub dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InstanceEventWindowAssociationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceEventWindowAssociationRequest");
        formatter.field("instance_ids", &self.instance_ids);
        formatter.field("instance_tags", &self.instance_tags);
        formatter.field("dedicated_host_ids", &self.dedicated_host_ids);
        formatter.finish()
    }
}
/// See [`InstanceEventWindowAssociationRequest`](crate::model::InstanceEventWindowAssociationRequest)
pub mod instance_event_window_association_request {
    /// A builder for [`InstanceEventWindowAssociationRequest`](crate::model::InstanceEventWindowAssociationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) dedicated_host_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn instance_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_ids.unwrap_or_default();
            v.push(input.into());
            self.instance_ids = Some(v);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_ids = input;
            self
        }
        pub fn instance_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.instance_tags.unwrap_or_default();
            v.push(input.into());
            self.instance_tags = Some(v);
            self
        }
        pub fn set_instance_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.instance_tags = input;
            self
        }
        pub fn dedicated_host_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dedicated_host_ids.unwrap_or_default();
            v.push(input.into());
            self.dedicated_host_ids = Some(v);
            self
        }
        pub fn set_dedicated_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dedicated_host_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceEventWindowAssociationRequest`](crate::model::InstanceEventWindowAssociationRequest)
        pub fn build(self) -> crate::model::InstanceEventWindowAssociationRequest {
            crate::model::InstanceEventWindowAssociationRequest {
                instance_ids: self.instance_ids,
                instance_tags: self.instance_tags,
                dedicated_host_ids: self.dedicated_host_ids,
            }
        }
    }
}
impl InstanceEventWindowAssociationRequest {
    /// Creates a new builder-style object to manufacture [`InstanceEventWindowAssociationRequest`](crate::model::InstanceEventWindowAssociationRequest)
    pub fn builder() -> crate::model::instance_event_window_association_request::Builder {
        crate::model::instance_event_window_association_request::Builder::default()
    }
}

/// <p>Describes the private IP addresses assigned to a network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssignedPrivateIpAddress {
    /// <p>The private IP address assigned to the network interface.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssignedPrivateIpAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssignedPrivateIpAddress");
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.finish()
    }
}
/// See [`AssignedPrivateIpAddress`](crate::model::AssignedPrivateIpAddress)
pub mod assigned_private_ip_address {
    /// A builder for [`AssignedPrivateIpAddress`](crate::model::AssignedPrivateIpAddress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The private IP address assigned to the network interface.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`AssignedPrivateIpAddress`](crate::model::AssignedPrivateIpAddress)
        pub fn build(self) -> crate::model::AssignedPrivateIpAddress {
            crate::model::AssignedPrivateIpAddress {
                private_ip_address: self.private_ip_address,
            }
        }
    }
}
impl AssignedPrivateIpAddress {
    /// Creates a new builder-style object to manufacture [`AssignedPrivateIpAddress`](crate::model::AssignedPrivateIpAddress)
    pub fn builder() -> crate::model::assigned_private_ip_address::Builder {
        crate::model::assigned_private_ip_address::Builder::default()
    }
}
