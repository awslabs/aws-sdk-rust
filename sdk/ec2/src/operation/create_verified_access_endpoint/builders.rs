// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_verified_access_endpoint::_create_verified_access_endpoint_output::CreateVerifiedAccessEndpointOutputBuilder;

pub use crate::operation::create_verified_access_endpoint::_create_verified_access_endpoint_input::CreateVerifiedAccessEndpointInputBuilder;

impl crate::operation::create_verified_access_endpoint::builders::CreateVerifiedAccessEndpointInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_verified_access_endpoint();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateVerifiedAccessEndpoint`.
///
/// <p>An Amazon Web Services Verified Access endpoint is where you define your application along with an optional endpoint-level access policy.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateVerifiedAccessEndpointFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_verified_access_endpoint::builders::CreateVerifiedAccessEndpointInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointOutput,
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointError,
    > for CreateVerifiedAccessEndpointFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointOutput,
            crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateVerifiedAccessEndpointFluentBuilder {
    /// Creates a new `CreateVerifiedAccessEndpoint`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateVerifiedAccessEndpoint as a reference.
    pub fn as_input(&self) -> &crate::operation::create_verified_access_endpoint::builders::CreateVerifiedAccessEndpointInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpoint::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpoint::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointOutput,
        crate::operation::create_verified_access_endpoint::CreateVerifiedAccessEndpointError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The ID of the Verified Access group to associate the endpoint with.</p>
    pub fn verified_access_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.verified_access_group_id(input.into());
        self
    }
    /// <p>The ID of the Verified Access group to associate the endpoint with.</p>
    pub fn set_verified_access_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_verified_access_group_id(input);
        self
    }
    /// <p>The ID of the Verified Access group to associate the endpoint with.</p>
    pub fn get_verified_access_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_verified_access_group_id()
    }
    /// <p>The type of Verified Access endpoint to create.</p>
    pub fn endpoint_type(mut self, input: crate::types::VerifiedAccessEndpointType) -> Self {
        self.inner = self.inner.endpoint_type(input);
        self
    }
    /// <p>The type of Verified Access endpoint to create.</p>
    pub fn set_endpoint_type(mut self, input: ::std::option::Option<crate::types::VerifiedAccessEndpointType>) -> Self {
        self.inner = self.inner.set_endpoint_type(input);
        self
    }
    /// <p>The type of Verified Access endpoint to create.</p>
    pub fn get_endpoint_type(&self) -> &::std::option::Option<crate::types::VerifiedAccessEndpointType> {
        self.inner.get_endpoint_type()
    }
    /// <p>The type of attachment.</p>
    pub fn attachment_type(mut self, input: crate::types::VerifiedAccessEndpointAttachmentType) -> Self {
        self.inner = self.inner.attachment_type(input);
        self
    }
    /// <p>The type of attachment.</p>
    pub fn set_attachment_type(mut self, input: ::std::option::Option<crate::types::VerifiedAccessEndpointAttachmentType>) -> Self {
        self.inner = self.inner.set_attachment_type(input);
        self
    }
    /// <p>The type of attachment.</p>
    pub fn get_attachment_type(&self) -> &::std::option::Option<crate::types::VerifiedAccessEndpointAttachmentType> {
        self.inner.get_attachment_type()
    }
    /// <p>The ARN of the public TLS/SSL certificate in Amazon Web Services Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application.</p>
    pub fn domain_certificate_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain_certificate_arn(input.into());
        self
    }
    /// <p>The ARN of the public TLS/SSL certificate in Amazon Web Services Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application.</p>
    pub fn set_domain_certificate_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain_certificate_arn(input);
        self
    }
    /// <p>The ARN of the public TLS/SSL certificate in Amazon Web Services Certificate Manager to associate with the endpoint. The CN in the certificate must match the DNS name your end users will use to reach your application.</p>
    pub fn get_domain_certificate_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain_certificate_arn()
    }
    /// <p>The DNS name for users to reach your application.</p>
    pub fn application_domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.application_domain(input.into());
        self
    }
    /// <p>The DNS name for users to reach your application.</p>
    pub fn set_application_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_application_domain(input);
        self
    }
    /// <p>The DNS name for users to reach your application.</p>
    pub fn get_application_domain(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_application_domain()
    }
    /// <p>A custom identifier that is prepended to the DNS name that is generated for the endpoint.</p>
    pub fn endpoint_domain_prefix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.endpoint_domain_prefix(input.into());
        self
    }
    /// <p>A custom identifier that is prepended to the DNS name that is generated for the endpoint.</p>
    pub fn set_endpoint_domain_prefix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_endpoint_domain_prefix(input);
        self
    }
    /// <p>A custom identifier that is prepended to the DNS name that is generated for the endpoint.</p>
    pub fn get_endpoint_domain_prefix(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_endpoint_domain_prefix()
    }
    ///
    /// Appends an item to `SecurityGroupIds`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>The IDs of the security groups to associate with the Verified Access endpoint. Required if <code>AttachmentType</code> is set to <code>vpc</code>.</p>
    pub fn security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.security_group_ids(input.into());
        self
    }
    /// <p>The IDs of the security groups to associate with the Verified Access endpoint. Required if <code>AttachmentType</code> is set to <code>vpc</code>.</p>
    pub fn set_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_security_group_ids(input);
        self
    }
    /// <p>The IDs of the security groups to associate with the Verified Access endpoint. Required if <code>AttachmentType</code> is set to <code>vpc</code>.</p>
    pub fn get_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_security_group_ids()
    }
    /// <p>The load balancer details. This parameter is required if the endpoint type is <code>load-balancer</code>.</p>
    pub fn load_balancer_options(mut self, input: crate::types::CreateVerifiedAccessEndpointLoadBalancerOptions) -> Self {
        self.inner = self.inner.load_balancer_options(input);
        self
    }
    /// <p>The load balancer details. This parameter is required if the endpoint type is <code>load-balancer</code>.</p>
    pub fn set_load_balancer_options(mut self, input: ::std::option::Option<crate::types::CreateVerifiedAccessEndpointLoadBalancerOptions>) -> Self {
        self.inner = self.inner.set_load_balancer_options(input);
        self
    }
    /// <p>The load balancer details. This parameter is required if the endpoint type is <code>load-balancer</code>.</p>
    pub fn get_load_balancer_options(&self) -> &::std::option::Option<crate::types::CreateVerifiedAccessEndpointLoadBalancerOptions> {
        self.inner.get_load_balancer_options()
    }
    /// <p>The network interface details. This parameter is required if the endpoint type is <code>network-interface</code>.</p>
    pub fn network_interface_options(mut self, input: crate::types::CreateVerifiedAccessEndpointEniOptions) -> Self {
        self.inner = self.inner.network_interface_options(input);
        self
    }
    /// <p>The network interface details. This parameter is required if the endpoint type is <code>network-interface</code>.</p>
    pub fn set_network_interface_options(mut self, input: ::std::option::Option<crate::types::CreateVerifiedAccessEndpointEniOptions>) -> Self {
        self.inner = self.inner.set_network_interface_options(input);
        self
    }
    /// <p>The network interface details. This parameter is required if the endpoint type is <code>network-interface</code>.</p>
    pub fn get_network_interface_options(&self) -> &::std::option::Option<crate::types::CreateVerifiedAccessEndpointEniOptions> {
        self.inner.get_network_interface_options()
    }
    /// <p>A description for the Verified Access endpoint.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description for the Verified Access endpoint.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A description for the Verified Access endpoint.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>The Verified Access policy document.</p>
    pub fn policy_document(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.policy_document(input.into());
        self
    }
    /// <p>The Verified Access policy document.</p>
    pub fn set_policy_document(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_policy_document(input);
        self
    }
    /// <p>The Verified Access policy document.</p>
    pub fn get_policy_document(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_policy_document()
    }
    ///
    /// Appends an item to `TagSpecifications`.
    ///
    /// To override the contents of this collection use [`set_tag_specifications`](Self::set_tag_specifications).
    ///
    /// <p>The tags to assign to the Verified Access endpoint.</p>
    pub fn tag_specifications(mut self, input: crate::types::TagSpecification) -> Self {
        self.inner = self.inner.tag_specifications(input);
        self
    }
    /// <p>The tags to assign to the Verified Access endpoint.</p>
    pub fn set_tag_specifications(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::TagSpecification>>) -> Self {
        self.inner = self.inner.set_tag_specifications(input);
        self
    }
    /// <p>The tags to assign to the Verified Access endpoint.</p>
    pub fn get_tag_specifications(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::TagSpecification>> {
        self.inner.get_tag_specifications()
    }
    /// <p>A unique, case-sensitive token that you provide to ensure idempotency of your modification request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive token that you provide to ensure idempotency of your modification request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique, case-sensitive token that you provide to ensure idempotency of your modification request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        self.inner.get_dry_run()
    }
    /// <p>The options for server side encryption.</p>
    pub fn sse_specification(mut self, input: crate::types::VerifiedAccessSseSpecificationRequest) -> Self {
        self.inner = self.inner.sse_specification(input);
        self
    }
    /// <p>The options for server side encryption.</p>
    pub fn set_sse_specification(mut self, input: ::std::option::Option<crate::types::VerifiedAccessSseSpecificationRequest>) -> Self {
        self.inner = self.inner.set_sse_specification(input);
        self
    }
    /// <p>The options for server side encryption.</p>
    pub fn get_sse_specification(&self) -> &::std::option::Option<crate::types::VerifiedAccessSseSpecificationRequest> {
        self.inner.get_sse_specification()
    }
}
