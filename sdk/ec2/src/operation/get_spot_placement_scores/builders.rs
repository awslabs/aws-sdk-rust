// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_spot_placement_scores::_get_spot_placement_scores_output::GetSpotPlacementScoresOutputBuilder;

pub use crate::operation::get_spot_placement_scores::_get_spot_placement_scores_input::GetSpotPlacementScoresInputBuilder;

impl GetSpotPlacementScoresInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_spot_placement_scores::GetSpotPlacementScoresError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.get_spot_placement_scores();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `GetSpotPlacementScores`.
///
/// <p>Calculates the Spot placement score for a Region or Availability Zone based on the specified target capacity and compute requirements.</p>
/// <p>You can specify your compute requirements either by using <code>InstanceRequirementsWithMetadata</code> and letting Amazon EC2 choose the optimal instance types to fulfill your Spot request, or you can specify the instance types by using <code>InstanceTypes</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html">Spot placement score</a> in the Amazon EC2 User Guide.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct GetSpotPlacementScoresFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_spot_placement_scores::builders::GetSpotPlacementScoresInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresOutput,
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresError,
    > for GetSpotPlacementScoresFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::get_spot_placement_scores::GetSpotPlacementScoresOutput,
            crate::operation::get_spot_placement_scores::GetSpotPlacementScoresError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl GetSpotPlacementScoresFluentBuilder {
    /// Creates a new `GetSpotPlacementScores`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the GetSpotPlacementScores as a reference.
    pub fn as_input(&self) -> &crate::operation::get_spot_placement_scores::builders::GetSpotPlacementScoresInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_spot_placement_scores::GetSpotPlacementScoresError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::get_spot_placement_scores::GetSpotPlacementScores::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::get_spot_placement_scores::GetSpotPlacementScores::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresOutput,
        crate::operation::get_spot_placement_scores::GetSpotPlacementScoresError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::get_spot_placement_scores::paginator::GetSpotPlacementScoresPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::get_spot_placement_scores::paginator::GetSpotPlacementScoresPaginator {
        crate::operation::get_spot_placement_scores::paginator::GetSpotPlacementScoresPaginator::new(self.handle, self.inner)
    }
    /// Appends an item to `InstanceTypes`.
    ///
    /// To override the contents of this collection use [`set_instance_types`](Self::set_instance_types).
    ///
    /// <p>The instance types. We recommend that you specify at least three instance types. If you specify one or two instance types, or specify variations of a single instance type (for example, an <code>m3.xlarge</code> with and without instance storage), the returned placement score will always be low.</p>
    /// <p>If you specify <code>InstanceTypes</code>, you can't specify <code>InstanceRequirementsWithMetadata</code>.</p>
    pub fn instance_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.instance_types(input.into());
        self
    }
    /// <p>The instance types. We recommend that you specify at least three instance types. If you specify one or two instance types, or specify variations of a single instance type (for example, an <code>m3.xlarge</code> with and without instance storage), the returned placement score will always be low.</p>
    /// <p>If you specify <code>InstanceTypes</code>, you can't specify <code>InstanceRequirementsWithMetadata</code>.</p>
    pub fn set_instance_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_instance_types(input);
        self
    }
    /// <p>The instance types. We recommend that you specify at least three instance types. If you specify one or two instance types, or specify variations of a single instance type (for example, an <code>m3.xlarge</code> with and without instance storage), the returned placement score will always be low.</p>
    /// <p>If you specify <code>InstanceTypes</code>, you can't specify <code>InstanceRequirementsWithMetadata</code>.</p>
    pub fn get_instance_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_instance_types()
    }
    /// <p>The target capacity.</p>
    pub fn target_capacity(mut self, input: i32) -> Self {
        self.inner = self.inner.target_capacity(input);
        self
    }
    /// <p>The target capacity.</p>
    pub fn set_target_capacity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_target_capacity(input);
        self
    }
    /// <p>The target capacity.</p>
    pub fn get_target_capacity(&self) -> &::std::option::Option<i32> {
        self.inner.get_target_capacity()
    }
    /// <p>The unit for the target capacity.</p>
    pub fn target_capacity_unit_type(mut self, input: crate::types::TargetCapacityUnitType) -> Self {
        self.inner = self.inner.target_capacity_unit_type(input);
        self
    }
    /// <p>The unit for the target capacity.</p>
    pub fn set_target_capacity_unit_type(mut self, input: ::std::option::Option<crate::types::TargetCapacityUnitType>) -> Self {
        self.inner = self.inner.set_target_capacity_unit_type(input);
        self
    }
    /// <p>The unit for the target capacity.</p>
    pub fn get_target_capacity_unit_type(&self) -> &::std::option::Option<crate::types::TargetCapacityUnitType> {
        self.inner.get_target_capacity_unit_type()
    }
    /// <p>Specify <code>true</code> so that the response returns a list of scored Availability Zones. Otherwise, the response returns a list of scored Regions.</p>
    /// <p>A list of scored Availability Zones is useful if you want to launch all of your Spot capacity into a single Availability Zone.</p>
    pub fn single_availability_zone(mut self, input: bool) -> Self {
        self.inner = self.inner.single_availability_zone(input);
        self
    }
    /// <p>Specify <code>true</code> so that the response returns a list of scored Availability Zones. Otherwise, the response returns a list of scored Regions.</p>
    /// <p>A list of scored Availability Zones is useful if you want to launch all of your Spot capacity into a single Availability Zone.</p>
    pub fn set_single_availability_zone(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_single_availability_zone(input);
        self
    }
    /// <p>Specify <code>true</code> so that the response returns a list of scored Availability Zones. Otherwise, the response returns a list of scored Regions.</p>
    /// <p>A list of scored Availability Zones is useful if you want to launch all of your Spot capacity into a single Availability Zone.</p>
    pub fn get_single_availability_zone(&self) -> &::std::option::Option<bool> {
        self.inner.get_single_availability_zone()
    }
    /// Appends an item to `RegionNames`.
    ///
    /// To override the contents of this collection use [`set_region_names`](Self::set_region_names).
    ///
    /// <p>The Regions used to narrow down the list of Regions to be scored. Enter the Region code, for example, <code>us-east-1</code>.</p>
    pub fn region_names(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.region_names(input.into());
        self
    }
    /// <p>The Regions used to narrow down the list of Regions to be scored. Enter the Region code, for example, <code>us-east-1</code>.</p>
    pub fn set_region_names(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_region_names(input);
        self
    }
    /// <p>The Regions used to narrow down the list of Regions to be scored. Enter the Region code, for example, <code>us-east-1</code>.</p>
    pub fn get_region_names(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_region_names()
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p>
    /// <p>If you specify <code>InstanceRequirementsWithMetadata</code>, you can't specify <code>InstanceTypes</code>.</p>
    pub fn instance_requirements_with_metadata(mut self, input: crate::types::InstanceRequirementsWithMetadataRequest) -> Self {
        self.inner = self.inner.instance_requirements_with_metadata(input);
        self
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p>
    /// <p>If you specify <code>InstanceRequirementsWithMetadata</code>, you can't specify <code>InstanceTypes</code>.</p>
    pub fn set_instance_requirements_with_metadata(
        mut self,
        input: ::std::option::Option<crate::types::InstanceRequirementsWithMetadataRequest>,
    ) -> Self {
        self.inner = self.inner.set_instance_requirements_with_metadata(input);
        self
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p>
    /// <p>If you specify <code>InstanceRequirementsWithMetadata</code>, you can't specify <code>InstanceTypes</code>.</p>
    pub fn get_instance_requirements_with_metadata(&self) -> &::std::option::Option<crate::types::InstanceRequirementsWithMetadataRequest> {
        self.inner.get_instance_requirements_with_metadata()
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        self.inner.get_dry_run()
    }
    /// <p>The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html#api-pagination">Pagination</a>.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html#api-pagination">Pagination</a>.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html#api-pagination">Pagination</a>.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    /// <p>The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_next_token()
    }
}
