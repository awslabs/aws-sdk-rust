// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::provision_byoip_cidr::_provision_byoip_cidr_output::ProvisionByoipCidrOutputBuilder;

pub use crate::operation::provision_byoip_cidr::_provision_byoip_cidr_input::ProvisionByoipCidrInputBuilder;

/// Fluent builder constructing a request to `ProvisionByoipCidr`.
///
/// <p>Provisions an IPv4 or IPv6 address range for use with your Amazon Web Services resources through bring your own IP addresses (BYOIP) and creates a corresponding address pool. After the address range is provisioned, it is ready to be advertised using <code>AdvertiseByoipCidr</code>.</p>
/// <p>Amazon Web Services verifies that you own the address range and are authorized to advertise it. You must ensure that the address range is registered to you and that you created an RPKI ROA to authorize Amazon ASNs 16509 and 14618 to advertise the address range. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html">Bring your own IP addresses (BYOIP)</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
/// <p>Provisioning an address range is an asynchronous operation, so the call returns immediately, but the address range is not ready to use until its status changes from <code>pending-provision</code> to <code>provisioned</code>. To monitor the status of an address range, use <code>DescribeByoipCidrs</code>. To allocate an Elastic IP address from your IPv4 address pool, use <code>AllocateAddress</code> with either the specific address from the address pool or the ID of the address pool.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct ProvisionByoipCidrFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::provision_byoip_cidr::builders::ProvisionByoipCidrInputBuilder,
}
impl ProvisionByoipCidrFluentBuilder {
    /// Creates a new `ProvisionByoipCidr`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::provision_byoip_cidr::ProvisionByoipCidr,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<
            crate::operation::provision_byoip_cidr::ProvisionByoipCidrError,
        >,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::provision_byoip_cidr::ProvisionByoipCidrOutput,
        aws_smithy_http::result::SdkError<
            crate::operation::provision_byoip_cidr::ProvisionByoipCidrError,
        >,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The public IPv4 or IPv6 address range, in CIDR notation. The most specific IPv4 prefix that you can specify is /24. The most specific IPv6 prefix you can specify is /56. The address range cannot overlap with another address range that you've brought to this or another Region.</p>
    pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.cidr(input.into());
        self
    }
    /// <p>The public IPv4 or IPv6 address range, in CIDR notation. The most specific IPv4 prefix that you can specify is /24. The most specific IPv6 prefix you can specify is /56. The address range cannot overlap with another address range that you've brought to this or another Region.</p>
    pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_cidr(input);
        self
    }
    /// <p>A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.</p>
    pub fn cidr_authorization_context(
        mut self,
        input: crate::types::CidrAuthorizationContext,
    ) -> Self {
        self.inner = self.inner.cidr_authorization_context(input);
        self
    }
    /// <p>A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.</p>
    pub fn set_cidr_authorization_context(
        mut self,
        input: std::option::Option<crate::types::CidrAuthorizationContext>,
    ) -> Self {
        self.inner = self.inner.set_cidr_authorization_context(input);
        self
    }
    /// <p>(IPv6 only) Indicate whether the address range will be publicly advertised to the internet.</p>
    /// <p>Default: true</p>
    pub fn publicly_advertisable(mut self, input: bool) -> Self {
        self.inner = self.inner.publicly_advertisable(input);
        self
    }
    /// <p>(IPv6 only) Indicate whether the address range will be publicly advertised to the internet.</p>
    /// <p>Default: true</p>
    pub fn set_publicly_advertisable(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_publicly_advertisable(input);
        self
    }
    /// <p>A description for the address range and the address pool.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description for the address range and the address pool.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// Appends an item to `PoolTagSpecifications`.
    ///
    /// To override the contents of this collection use [`set_pool_tag_specifications`](Self::set_pool_tag_specifications).
    ///
    /// <p>The tags to apply to the address pool.</p>
    pub fn pool_tag_specifications(mut self, input: crate::types::TagSpecification) -> Self {
        self.inner = self.inner.pool_tag_specifications(input);
        self
    }
    /// <p>The tags to apply to the address pool.</p>
    pub fn set_pool_tag_specifications(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::TagSpecification>>,
    ) -> Self {
        self.inner = self.inner.set_pool_tag_specifications(input);
        self
    }
    /// <p>Reserved.</p>
    pub fn multi_region(mut self, input: bool) -> Self {
        self.inner = self.inner.multi_region(input);
        self
    }
    /// <p>Reserved.</p>
    pub fn set_multi_region(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_multi_region(input);
        self
    }
}
