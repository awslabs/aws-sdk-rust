// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::allocate_ipam_pool_cidr::_allocate_ipam_pool_cidr_output::AllocateIpamPoolCidrOutputBuilder;

pub use crate::operation::allocate_ipam_pool_cidr::_allocate_ipam_pool_cidr_input::AllocateIpamPoolCidrInputBuilder;

/// Fluent builder constructing a request to `AllocateIpamPoolCidr`.
///
/// <p>Allocate a CIDR from an IPAM pool. In IPAM, an allocation is a CIDR assignment from an IPAM pool to another resource or IPAM pool. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/ipam/allocate-cidrs-ipam.html">Allocate CIDRs</a> in the <i>Amazon VPC IPAM User Guide</i>. </p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct AllocateIpamPoolCidrFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::allocate_ipam_pool_cidr::builders::AllocateIpamPoolCidrInputBuilder,
}
impl AllocateIpamPoolCidrFluentBuilder {
    /// Creates a new `AllocateIpamPoolCidr`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidr,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<
            crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrError,
        >,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrOutput,
        aws_smithy_http::result::SdkError<
            crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrError,
        >,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    pub fn ipam_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.ipam_pool_id(input.into());
        self
    }
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    pub fn set_ipam_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_ipam_pool_id(input);
        self
    }
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.cidr(input.into());
        self
    }
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_cidr(input);
        self
    }
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    pub fn netmask_length(mut self, input: i32) -> Self {
        self.inner = self.inner.netmask_length(input);
        self
    }
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    pub fn set_netmask_length(mut self, input: std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_netmask_length(input);
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A description for the allocation.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description for the allocation.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A preview of the next available CIDR in a pool.</p>
    pub fn preview_next_cidr(mut self, input: bool) -> Self {
        self.inner = self.inner.preview_next_cidr(input);
        self
    }
    /// <p>A preview of the next available CIDR in a pool.</p>
    pub fn set_preview_next_cidr(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_preview_next_cidr(input);
        self
    }
    /// Appends an item to `DisallowedCidrs`.
    ///
    /// To override the contents of this collection use [`set_disallowed_cidrs`](Self::set_disallowed_cidrs).
    ///
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    pub fn disallowed_cidrs(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.disallowed_cidrs(input.into());
        self
    }
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    pub fn set_disallowed_cidrs(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.inner = self.inner.set_disallowed_cidrs(input);
        self
    }
}
