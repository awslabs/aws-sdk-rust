// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AllocateIpamPoolCidrInput {
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    #[doc(hidden)]
    pub dry_run: std::option::Option<bool>,
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    #[doc(hidden)]
    pub ipam_pool_id: std::option::Option<std::string::String>,
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    #[doc(hidden)]
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    #[doc(hidden)]
    pub netmask_length: std::option::Option<i32>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>A description for the allocation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A preview of the next available CIDR in a pool.</p>
    #[doc(hidden)]
    pub preview_next_cidr: std::option::Option<bool>,
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    #[doc(hidden)]
    pub disallowed_cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AllocateIpamPoolCidrInput {
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(&self) -> std::option::Option<bool> {
        self.dry_run
    }
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    pub fn ipam_pool_id(&self) -> std::option::Option<&str> {
        self.ipam_pool_id.as_deref()
    }
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    pub fn cidr(&self) -> std::option::Option<&str> {
        self.cidr.as_deref()
    }
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    pub fn netmask_length(&self) -> std::option::Option<i32> {
        self.netmask_length
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>A description for the allocation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>A preview of the next available CIDR in a pool.</p>
    pub fn preview_next_cidr(&self) -> std::option::Option<bool> {
        self.preview_next_cidr
    }
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    pub fn disallowed_cidrs(&self) -> std::option::Option<&[std::string::String]> {
        self.disallowed_cidrs.as_deref()
    }
}
impl AllocateIpamPoolCidrInput {
    /// Creates a new builder-style object to manufacture [`AllocateIpamPoolCidrInput`](crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrInput).
    pub fn builder(
    ) -> crate::operation::allocate_ipam_pool_cidr::builders::AllocateIpamPoolCidrInputBuilder {
        crate::operation::allocate_ipam_pool_cidr::builders::AllocateIpamPoolCidrInputBuilder::default()
    }
}

/// A builder for [`AllocateIpamPoolCidrInput`](crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AllocateIpamPoolCidrInputBuilder {
    pub(crate) dry_run: std::option::Option<bool>,
    pub(crate) ipam_pool_id: std::option::Option<std::string::String>,
    pub(crate) cidr: std::option::Option<std::string::String>,
    pub(crate) netmask_length: std::option::Option<i32>,
    pub(crate) client_token: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) preview_next_cidr: std::option::Option<bool>,
    pub(crate) disallowed_cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AllocateIpamPoolCidrInputBuilder {
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.dry_run = Some(input);
        self
    }
    /// <p>A check for whether you have the required permissions for the action without actually making the request and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
        self.dry_run = input;
        self
    }
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    pub fn ipam_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.ipam_pool_id = Some(input.into());
        self
    }
    /// <p>The ID of the IPAM pool from which you would like to allocate a CIDR.</p>
    pub fn set_ipam_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ipam_pool_id = input;
        self
    }
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
        self.cidr = Some(input.into());
        self
    }
    /// <p>The CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible values: Any available IPv4 or IPv6 CIDR.</p>
    pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cidr = input;
        self
    }
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    pub fn netmask_length(mut self, input: i32) -> Self {
        self.netmask_length = Some(input);
        self
    }
    /// <p>The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:</p>
    /// <ul>
    /// <li> <p>If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.</p> </li>
    /// <li> <p>If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.</p> </li>
    /// </ul>
    /// <p>Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.</p>
    pub fn set_netmask_length(mut self, input: std::option::Option<i32>) -> Self {
        self.netmask_length = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.client_token = Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
    pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A description for the allocation.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>A description for the allocation.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A preview of the next available CIDR in a pool.</p>
    pub fn preview_next_cidr(mut self, input: bool) -> Self {
        self.preview_next_cidr = Some(input);
        self
    }
    /// <p>A preview of the next available CIDR in a pool.</p>
    pub fn set_preview_next_cidr(mut self, input: std::option::Option<bool>) -> Self {
        self.preview_next_cidr = input;
        self
    }
    /// Appends an item to `disallowed_cidrs`.
    ///
    /// To override the contents of this collection use [`set_disallowed_cidrs`](Self::set_disallowed_cidrs).
    ///
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    pub fn disallowed_cidrs(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.disallowed_cidrs.unwrap_or_default();
        v.push(input.into());
        self.disallowed_cidrs = Some(v);
        self
    }
    /// <p>Exclude a particular CIDR range from being returned by the pool. Disallowed CIDRs are only allowed if using netmask length for allocation.</p>
    pub fn set_disallowed_cidrs(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.disallowed_cidrs = input;
        self
    }
    /// Consumes the builder and constructs a [`AllocateIpamPoolCidrInput`](crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::allocate_ipam_pool_cidr::AllocateIpamPoolCidrInput {
                dry_run: self.dry_run,
                ipam_pool_id: self.ipam_pool_id,
                cidr: self.cidr,
                netmask_length: self.netmask_length,
                client_token: self.client_token,
                description: self.description,
                preview_next_cidr: self.preview_next_cidr,
                disallowed_cidrs: self.disallowed_cidrs,
            },
        )
    }
}
