// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::lock_snapshot::_lock_snapshot_output::LockSnapshotOutputBuilder;

pub use crate::operation::lock_snapshot::_lock_snapshot_input::LockSnapshotInputBuilder;

impl LockSnapshotInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::lock_snapshot::LockSnapshotOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::lock_snapshot::LockSnapshotError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.lock_snapshot();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `LockSnapshot`.
///
/// <p>Locks an Amazon EBS snapshot in either <i>governance</i> or <i>compliance</i> mode to protect it against accidental or malicious deletions for a specific duration. A locked snapshot can't be deleted.</p>
/// <p>You can also use this action to modify the lock settings for a snapshot that is already locked. The allowed modifications depend on the lock mode and lock state:</p>
/// <ul>
/// <li>
/// <p>If the snapshot is locked in governance mode, you can modify the lock mode and the lock duration or lock expiration date.</p></li>
/// <li>
/// <p>If the snapshot is locked in compliance mode and it is in the cooling-off period, you can modify the lock mode and the lock duration or lock expiration date.</p></li>
/// <li>
/// <p>If the snapshot is locked in compliance mode and the cooling-off period has lapsed, you can only increase the lock duration or extend the lock expiration date.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct LockSnapshotFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::lock_snapshot::builders::LockSnapshotInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::lock_snapshot::LockSnapshotOutput,
        crate::operation::lock_snapshot::LockSnapshotError,
    > for LockSnapshotFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::lock_snapshot::LockSnapshotOutput,
            crate::operation::lock_snapshot::LockSnapshotError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl LockSnapshotFluentBuilder {
    /// Creates a new `LockSnapshot`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the LockSnapshot as a reference.
    pub fn as_input(&self) -> &crate::operation::lock_snapshot::builders::LockSnapshotInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::lock_snapshot::LockSnapshotOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::lock_snapshot::LockSnapshotError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::lock_snapshot::LockSnapshot::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::lock_snapshot::LockSnapshot::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::lock_snapshot::LockSnapshotOutput,
        crate::operation::lock_snapshot::LockSnapshotError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The ID of the snapshot to lock.</p>
    pub fn snapshot_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.snapshot_id(input.into());
        self
    }
    /// <p>The ID of the snapshot to lock.</p>
    pub fn set_snapshot_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_snapshot_id(input);
        self
    }
    /// <p>The ID of the snapshot to lock.</p>
    pub fn get_snapshot_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_snapshot_id()
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        self.inner.get_dry_run()
    }
    /// <p>The mode in which to lock the snapshot. Specify one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>governance</code> - Locks the snapshot in governance mode. Snapshots locked in governance mode can't be deleted until one of the following conditions are met:</p>
    /// <ul>
    /// <li>
    /// <p>The lock duration expires.</p></li>
    /// <li>
    /// <p>The snapshot is unlocked by a user with the appropriate permissions.</p></li>
    /// </ul>
    /// <p>Users with the appropriate IAM permissions can unlock the snapshot, increase or decrease the lock duration, and change the lock mode to <code>compliance</code> at any time.</p>
    /// <p>If you lock a snapshot in <code>governance</code> mode, omit <b> CoolOffPeriod</b>.</p></li>
    /// <li>
    /// <p><code>compliance</code> - Locks the snapshot in compliance mode. Snapshots locked in compliance mode can't be unlocked by any user. They can be deleted only after the lock duration expires. Users can't decrease the lock duration or change the lock mode to <code>governance</code>. However, users with appropriate IAM permissions can increase the lock duration at any time.</p>
    /// <p>If you lock a snapshot in <code>compliance</code> mode, you can optionally specify <b>CoolOffPeriod</b>.</p></li>
    /// </ul>
    pub fn lock_mode(mut self, input: crate::types::LockMode) -> Self {
        self.inner = self.inner.lock_mode(input);
        self
    }
    /// <p>The mode in which to lock the snapshot. Specify one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>governance</code> - Locks the snapshot in governance mode. Snapshots locked in governance mode can't be deleted until one of the following conditions are met:</p>
    /// <ul>
    /// <li>
    /// <p>The lock duration expires.</p></li>
    /// <li>
    /// <p>The snapshot is unlocked by a user with the appropriate permissions.</p></li>
    /// </ul>
    /// <p>Users with the appropriate IAM permissions can unlock the snapshot, increase or decrease the lock duration, and change the lock mode to <code>compliance</code> at any time.</p>
    /// <p>If you lock a snapshot in <code>governance</code> mode, omit <b> CoolOffPeriod</b>.</p></li>
    /// <li>
    /// <p><code>compliance</code> - Locks the snapshot in compliance mode. Snapshots locked in compliance mode can't be unlocked by any user. They can be deleted only after the lock duration expires. Users can't decrease the lock duration or change the lock mode to <code>governance</code>. However, users with appropriate IAM permissions can increase the lock duration at any time.</p>
    /// <p>If you lock a snapshot in <code>compliance</code> mode, you can optionally specify <b>CoolOffPeriod</b>.</p></li>
    /// </ul>
    pub fn set_lock_mode(mut self, input: ::std::option::Option<crate::types::LockMode>) -> Self {
        self.inner = self.inner.set_lock_mode(input);
        self
    }
    /// <p>The mode in which to lock the snapshot. Specify one of the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>governance</code> - Locks the snapshot in governance mode. Snapshots locked in governance mode can't be deleted until one of the following conditions are met:</p>
    /// <ul>
    /// <li>
    /// <p>The lock duration expires.</p></li>
    /// <li>
    /// <p>The snapshot is unlocked by a user with the appropriate permissions.</p></li>
    /// </ul>
    /// <p>Users with the appropriate IAM permissions can unlock the snapshot, increase or decrease the lock duration, and change the lock mode to <code>compliance</code> at any time.</p>
    /// <p>If you lock a snapshot in <code>governance</code> mode, omit <b> CoolOffPeriod</b>.</p></li>
    /// <li>
    /// <p><code>compliance</code> - Locks the snapshot in compliance mode. Snapshots locked in compliance mode can't be unlocked by any user. They can be deleted only after the lock duration expires. Users can't decrease the lock duration or change the lock mode to <code>governance</code>. However, users with appropriate IAM permissions can increase the lock duration at any time.</p>
    /// <p>If you lock a snapshot in <code>compliance</code> mode, you can optionally specify <b>CoolOffPeriod</b>.</p></li>
    /// </ul>
    pub fn get_lock_mode(&self) -> &::std::option::Option<crate::types::LockMode> {
        self.inner.get_lock_mode()
    }
    /// <p>The cooling-off period during which you can unlock the snapshot or modify the lock settings after locking the snapshot in compliance mode, in hours. After the cooling-off period expires, you can't unlock or delete the snapshot, decrease the lock duration, or change the lock mode. You can increase the lock duration after the cooling-off period expires.</p>
    /// <p>The cooling-off period is optional when locking a snapshot in compliance mode. If you are locking the snapshot in governance mode, omit this parameter.</p>
    /// <p>To lock the snapshot in compliance mode immediately without a cooling-off period, omit this parameter.</p>
    /// <p>If you are extending the lock duration for a snapshot that is locked in compliance mode after the cooling-off period has expired, omit this parameter. If you specify a cooling-period in a such a request, the request fails.</p>
    /// <p>Allowed values: Min 1, max 72.</p>
    pub fn cool_off_period(mut self, input: i32) -> Self {
        self.inner = self.inner.cool_off_period(input);
        self
    }
    /// <p>The cooling-off period during which you can unlock the snapshot or modify the lock settings after locking the snapshot in compliance mode, in hours. After the cooling-off period expires, you can't unlock or delete the snapshot, decrease the lock duration, or change the lock mode. You can increase the lock duration after the cooling-off period expires.</p>
    /// <p>The cooling-off period is optional when locking a snapshot in compliance mode. If you are locking the snapshot in governance mode, omit this parameter.</p>
    /// <p>To lock the snapshot in compliance mode immediately without a cooling-off period, omit this parameter.</p>
    /// <p>If you are extending the lock duration for a snapshot that is locked in compliance mode after the cooling-off period has expired, omit this parameter. If you specify a cooling-period in a such a request, the request fails.</p>
    /// <p>Allowed values: Min 1, max 72.</p>
    pub fn set_cool_off_period(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_cool_off_period(input);
        self
    }
    /// <p>The cooling-off period during which you can unlock the snapshot or modify the lock settings after locking the snapshot in compliance mode, in hours. After the cooling-off period expires, you can't unlock or delete the snapshot, decrease the lock duration, or change the lock mode. You can increase the lock duration after the cooling-off period expires.</p>
    /// <p>The cooling-off period is optional when locking a snapshot in compliance mode. If you are locking the snapshot in governance mode, omit this parameter.</p>
    /// <p>To lock the snapshot in compliance mode immediately without a cooling-off period, omit this parameter.</p>
    /// <p>If you are extending the lock duration for a snapshot that is locked in compliance mode after the cooling-off period has expired, omit this parameter. If you specify a cooling-period in a such a request, the request fails.</p>
    /// <p>Allowed values: Min 1, max 72.</p>
    pub fn get_cool_off_period(&self) -> &::std::option::Option<i32> {
        self.inner.get_cool_off_period()
    }
    /// <p>The period of time for which to lock the snapshot, in days. The snapshot lock will automatically expire after this period lapses.</p>
    /// <p>You must specify either this parameter or <b>ExpirationDate</b>, but not both.</p>
    /// <p>Allowed values: Min: 1, max 36500</p>
    pub fn lock_duration(mut self, input: i32) -> Self {
        self.inner = self.inner.lock_duration(input);
        self
    }
    /// <p>The period of time for which to lock the snapshot, in days. The snapshot lock will automatically expire after this period lapses.</p>
    /// <p>You must specify either this parameter or <b>ExpirationDate</b>, but not both.</p>
    /// <p>Allowed values: Min: 1, max 36500</p>
    pub fn set_lock_duration(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_lock_duration(input);
        self
    }
    /// <p>The period of time for which to lock the snapshot, in days. The snapshot lock will automatically expire after this period lapses.</p>
    /// <p>You must specify either this parameter or <b>ExpirationDate</b>, but not both.</p>
    /// <p>Allowed values: Min: 1, max 36500</p>
    pub fn get_lock_duration(&self) -> &::std::option::Option<i32> {
        self.inner.get_lock_duration()
    }
    /// <p>The date and time at which the snapshot lock is to automatically expire, in the UTC time zone (<code>YYYY-MM-DDThh:mm:ss.sssZ</code>).</p>
    /// <p>You must specify either this parameter or <b>LockDuration</b>, but not both.</p>
    pub fn expiration_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.expiration_date(input);
        self
    }
    /// <p>The date and time at which the snapshot lock is to automatically expire, in the UTC time zone (<code>YYYY-MM-DDThh:mm:ss.sssZ</code>).</p>
    /// <p>You must specify either this parameter or <b>LockDuration</b>, but not both.</p>
    pub fn set_expiration_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_expiration_date(input);
        self
    }
    /// <p>The date and time at which the snapshot lock is to automatically expire, in the UTC time zone (<code>YYYY-MM-DDThh:mm:ss.sssZ</code>).</p>
    /// <p>You must specify either this parameter or <b>LockDuration</b>, but not both.</p>
    pub fn get_expiration_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        self.inner.get_expiration_date()
    }
}
