// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::modify_private_dns_name_options::_modify_private_dns_name_options_output::ModifyPrivateDnsNameOptionsOutputBuilder;

pub use crate::operation::modify_private_dns_name_options::_modify_private_dns_name_options_input::ModifyPrivateDnsNameOptionsInputBuilder;

impl ModifyPrivateDnsNameOptionsInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.modify_private_dns_name_options();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ModifyPrivateDnsNameOptions`.
///
/// <p>Modifies the options for instance hostnames for the specified instance.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ModifyPrivateDnsNameOptionsFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::modify_private_dns_name_options::builders::ModifyPrivateDnsNameOptionsInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsOutput,
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsError,
    > for ModifyPrivateDnsNameOptionsFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsOutput,
            crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ModifyPrivateDnsNameOptionsFluentBuilder {
    /// Creates a new `ModifyPrivateDnsNameOptions`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ModifyPrivateDnsNameOptions as a reference.
    pub fn as_input(&self) -> &crate::operation::modify_private_dns_name_options::builders::ModifyPrivateDnsNameOptionsInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptions::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptions::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsOutput,
        crate::operation::modify_private_dns_name_options::ModifyPrivateDnsNameOptionsError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        self.inner.get_dry_run()
    }
    /// <p>The ID of the instance.</p>
    pub fn instance_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.instance_id(input.into());
        self
    }
    /// <p>The ID of the instance.</p>
    pub fn set_instance_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_instance_id(input);
        self
    }
    /// <p>The ID of the instance.</p>
    pub fn get_instance_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_instance_id()
    }
    /// <p>The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.</p>
    pub fn private_dns_hostname_type(mut self, input: crate::types::HostnameType) -> Self {
        self.inner = self.inner.private_dns_hostname_type(input);
        self
    }
    /// <p>The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.</p>
    pub fn set_private_dns_hostname_type(mut self, input: ::std::option::Option<crate::types::HostnameType>) -> Self {
        self.inner = self.inner.set_private_dns_hostname_type(input);
        self
    }
    /// <p>The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.</p>
    pub fn get_private_dns_hostname_type(&self) -> &::std::option::Option<crate::types::HostnameType> {
        self.inner.get_private_dns_hostname_type()
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS A records.</p>
    pub fn enable_resource_name_dns_a_record(mut self, input: bool) -> Self {
        self.inner = self.inner.enable_resource_name_dns_a_record(input);
        self
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS A records.</p>
    pub fn set_enable_resource_name_dns_a_record(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_enable_resource_name_dns_a_record(input);
        self
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS A records.</p>
    pub fn get_enable_resource_name_dns_a_record(&self) -> &::std::option::Option<bool> {
        self.inner.get_enable_resource_name_dns_a_record()
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.</p>
    pub fn enable_resource_name_dns_aaaa_record(mut self, input: bool) -> Self {
        self.inner = self.inner.enable_resource_name_dns_aaaa_record(input);
        self
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.</p>
    pub fn set_enable_resource_name_dns_aaaa_record(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_enable_resource_name_dns_aaaa_record(input);
        self
    }
    /// <p>Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.</p>
    pub fn get_enable_resource_name_dns_aaaa_record(&self) -> &::std::option::Option<bool> {
        self.inner.get_enable_resource_name_dns_aaaa_record()
    }
}
