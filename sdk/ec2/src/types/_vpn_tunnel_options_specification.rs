// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The tunnel options for a single VPN tunnel.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct VpnTunnelOptionsSpecification {
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li> <p> <code>169.254.0.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.1.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.2.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.3.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.4.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.5.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.169.252/30</code> </p> </li>
    /// </ul>
    pub tunnel_inside_cidr: ::std::option::Option<::std::string::String>,
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub tunnel_inside_ipv6_cidr: ::std::option::Option<::std::string::String>,
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
    pub pre_shared_key: ::std::option::Option<::std::string::String>,
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code> </p>
    pub phase1_lifetime_seconds: ::std::option::Option<i32>,
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code> </p>
    pub phase2_lifetime_seconds: ::std::option::Option<i32>,
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code> </p>
    pub rekey_margin_time_seconds: ::std::option::Option<i32>,
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code> </p>
    pub rekey_fuzz_percentage: ::std::option::Option<i32>,
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code> </p>
    pub replay_window_size: ::std::option::Option<i32>,
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value greater than or equal to 30.</p>
    /// <p>Default: <code>30</code> </p>
    pub dpd_timeout_seconds: ::std::option::Option<i32>,
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code> </p>
    /// <p>Default: <code>clear</code> </p>
    pub dpd_timeout_action: ::std::option::Option<::std::string::String>,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub phase1_encryption_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase1EncryptionAlgorithmsRequestListValue>>,
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub phase2_encryption_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase2EncryptionAlgorithmsRequestListValue>>,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub phase1_integrity_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase1IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub phase2_integrity_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase2IntegrityAlgorithmsRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub phase1_dh_group_numbers: ::std::option::Option<::std::vec::Vec<crate::types::Phase1DhGroupNumbersRequestListValue>>,
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub phase2_dh_group_numbers: ::std::option::Option<::std::vec::Vec<crate::types::Phase2DhGroupNumbersRequestListValue>>,
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>
    pub ike_versions: ::std::option::Option<::std::vec::Vec<crate::types::IkeVersionsRequestListValue>>,
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for Amazon Web Services to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code> </p>
    /// <p>Default: <code>add</code> </p>
    pub startup_action: ::std::option::Option<::std::string::String>,
    /// <p>Options for logging VPN tunnel activity.</p>
    pub log_options: ::std::option::Option<crate::types::VpnTunnelLogOptionsSpecification>,
    /// <p>Turn on or off tunnel endpoint lifecycle control feature.</p>
    pub enable_tunnel_lifecycle_control: ::std::option::Option<bool>,
}
impl VpnTunnelOptionsSpecification {
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li> <p> <code>169.254.0.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.1.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.2.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.3.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.4.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.5.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.169.252/30</code> </p> </li>
    /// </ul>
    pub fn tunnel_inside_cidr(&self) -> ::std::option::Option<&str> {
        self.tunnel_inside_cidr.as_deref()
    }
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub fn tunnel_inside_ipv6_cidr(&self) -> ::std::option::Option<&str> {
        self.tunnel_inside_ipv6_cidr.as_deref()
    }
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
    pub fn pre_shared_key(&self) -> ::std::option::Option<&str> {
        self.pre_shared_key.as_deref()
    }
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code> </p>
    pub fn phase1_lifetime_seconds(&self) -> ::std::option::Option<i32> {
        self.phase1_lifetime_seconds
    }
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code> </p>
    pub fn phase2_lifetime_seconds(&self) -> ::std::option::Option<i32> {
        self.phase2_lifetime_seconds
    }
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code> </p>
    pub fn rekey_margin_time_seconds(&self) -> ::std::option::Option<i32> {
        self.rekey_margin_time_seconds
    }
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code> </p>
    pub fn rekey_fuzz_percentage(&self) -> ::std::option::Option<i32> {
        self.rekey_fuzz_percentage
    }
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code> </p>
    pub fn replay_window_size(&self) -> ::std::option::Option<i32> {
        self.replay_window_size
    }
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value greater than or equal to 30.</p>
    /// <p>Default: <code>30</code> </p>
    pub fn dpd_timeout_seconds(&self) -> ::std::option::Option<i32> {
        self.dpd_timeout_seconds
    }
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code> </p>
    /// <p>Default: <code>clear</code> </p>
    pub fn dpd_timeout_action(&self) -> ::std::option::Option<&str> {
        self.dpd_timeout_action.as_deref()
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase1_encryption_algorithms.is_none()`.
    pub fn phase1_encryption_algorithms(&self) -> &[crate::types::Phase1EncryptionAlgorithmsRequestListValue] {
        self.phase1_encryption_algorithms.as_deref().unwrap_or_default()
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase2_encryption_algorithms.is_none()`.
    pub fn phase2_encryption_algorithms(&self) -> &[crate::types::Phase2EncryptionAlgorithmsRequestListValue] {
        self.phase2_encryption_algorithms.as_deref().unwrap_or_default()
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase1_integrity_algorithms.is_none()`.
    pub fn phase1_integrity_algorithms(&self) -> &[crate::types::Phase1IntegrityAlgorithmsRequestListValue] {
        self.phase1_integrity_algorithms.as_deref().unwrap_or_default()
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase2_integrity_algorithms.is_none()`.
    pub fn phase2_integrity_algorithms(&self) -> &[crate::types::Phase2IntegrityAlgorithmsRequestListValue] {
        self.phase2_integrity_algorithms.as_deref().unwrap_or_default()
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase1_dh_group_numbers.is_none()`.
    pub fn phase1_dh_group_numbers(&self) -> &[crate::types::Phase1DhGroupNumbersRequestListValue] {
        self.phase1_dh_group_numbers.as_deref().unwrap_or_default()
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.phase2_dh_group_numbers.is_none()`.
    pub fn phase2_dh_group_numbers(&self) -> &[crate::types::Phase2DhGroupNumbersRequestListValue] {
        self.phase2_dh_group_numbers.as_deref().unwrap_or_default()
    }
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.ike_versions.is_none()`.
    pub fn ike_versions(&self) -> &[crate::types::IkeVersionsRequestListValue] {
        self.ike_versions.as_deref().unwrap_or_default()
    }
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for Amazon Web Services to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code> </p>
    /// <p>Default: <code>add</code> </p>
    pub fn startup_action(&self) -> ::std::option::Option<&str> {
        self.startup_action.as_deref()
    }
    /// <p>Options for logging VPN tunnel activity.</p>
    pub fn log_options(&self) -> ::std::option::Option<&crate::types::VpnTunnelLogOptionsSpecification> {
        self.log_options.as_ref()
    }
    /// <p>Turn on or off tunnel endpoint lifecycle control feature.</p>
    pub fn enable_tunnel_lifecycle_control(&self) -> ::std::option::Option<bool> {
        self.enable_tunnel_lifecycle_control
    }
}
impl ::std::fmt::Debug for VpnTunnelOptionsSpecification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("VpnTunnelOptionsSpecification");
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.field("tunnel_inside_ipv6_cidr", &self.tunnel_inside_ipv6_cidr);
        formatter.field("pre_shared_key", &"*** Sensitive Data Redacted ***");
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("dpd_timeout_action", &self.dpd_timeout_action);
        formatter.field("phase1_encryption_algorithms", &self.phase1_encryption_algorithms);
        formatter.field("phase2_encryption_algorithms", &self.phase2_encryption_algorithms);
        formatter.field("phase1_integrity_algorithms", &self.phase1_integrity_algorithms);
        formatter.field("phase2_integrity_algorithms", &self.phase2_integrity_algorithms);
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("startup_action", &self.startup_action);
        formatter.field("log_options", &self.log_options);
        formatter.field("enable_tunnel_lifecycle_control", &self.enable_tunnel_lifecycle_control);
        formatter.finish()
    }
}
impl VpnTunnelOptionsSpecification {
    /// Creates a new builder-style object to manufacture [`VpnTunnelOptionsSpecification`](crate::types::VpnTunnelOptionsSpecification).
    pub fn builder() -> crate::types::builders::VpnTunnelOptionsSpecificationBuilder {
        crate::types::builders::VpnTunnelOptionsSpecificationBuilder::default()
    }
}

/// A builder for [`VpnTunnelOptionsSpecification`](crate::types::VpnTunnelOptionsSpecification).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct VpnTunnelOptionsSpecificationBuilder {
    pub(crate) tunnel_inside_cidr: ::std::option::Option<::std::string::String>,
    pub(crate) tunnel_inside_ipv6_cidr: ::std::option::Option<::std::string::String>,
    pub(crate) pre_shared_key: ::std::option::Option<::std::string::String>,
    pub(crate) phase1_lifetime_seconds: ::std::option::Option<i32>,
    pub(crate) phase2_lifetime_seconds: ::std::option::Option<i32>,
    pub(crate) rekey_margin_time_seconds: ::std::option::Option<i32>,
    pub(crate) rekey_fuzz_percentage: ::std::option::Option<i32>,
    pub(crate) replay_window_size: ::std::option::Option<i32>,
    pub(crate) dpd_timeout_seconds: ::std::option::Option<i32>,
    pub(crate) dpd_timeout_action: ::std::option::Option<::std::string::String>,
    pub(crate) phase1_encryption_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase1EncryptionAlgorithmsRequestListValue>>,
    pub(crate) phase2_encryption_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase2EncryptionAlgorithmsRequestListValue>>,
    pub(crate) phase1_integrity_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase1IntegrityAlgorithmsRequestListValue>>,
    pub(crate) phase2_integrity_algorithms: ::std::option::Option<::std::vec::Vec<crate::types::Phase2IntegrityAlgorithmsRequestListValue>>,
    pub(crate) phase1_dh_group_numbers: ::std::option::Option<::std::vec::Vec<crate::types::Phase1DhGroupNumbersRequestListValue>>,
    pub(crate) phase2_dh_group_numbers: ::std::option::Option<::std::vec::Vec<crate::types::Phase2DhGroupNumbersRequestListValue>>,
    pub(crate) ike_versions: ::std::option::Option<::std::vec::Vec<crate::types::IkeVersionsRequestListValue>>,
    pub(crate) startup_action: ::std::option::Option<::std::string::String>,
    pub(crate) log_options: ::std::option::Option<crate::types::VpnTunnelLogOptionsSpecification>,
    pub(crate) enable_tunnel_lifecycle_control: ::std::option::Option<bool>,
}
impl VpnTunnelOptionsSpecificationBuilder {
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li> <p> <code>169.254.0.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.1.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.2.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.3.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.4.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.5.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.169.252/30</code> </p> </li>
    /// </ul>
    pub fn tunnel_inside_cidr(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.tunnel_inside_cidr = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li> <p> <code>169.254.0.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.1.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.2.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.3.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.4.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.5.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.169.252/30</code> </p> </li>
    /// </ul>
    pub fn set_tunnel_inside_cidr(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.tunnel_inside_cidr = input;
        self
    }
    /// <p>The range of inside IPv4 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p>
    /// <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p>
    /// <ul>
    /// <li> <p> <code>169.254.0.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.1.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.2.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.3.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.4.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.5.0/30</code> </p> </li>
    /// <li> <p> <code>169.254.169.252/30</code> </p> </li>
    /// </ul>
    pub fn get_tunnel_inside_cidr(&self) -> &::std::option::Option<::std::string::String> {
        &self.tunnel_inside_cidr
    }
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub fn tunnel_inside_ipv6_cidr(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.tunnel_inside_ipv6_cidr = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub fn set_tunnel_inside_ipv6_cidr(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.tunnel_inside_ipv6_cidr = input;
        self
    }
    /// <p>The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.</p>
    /// <p>Constraints: A size /126 CIDR block from the local <code>fd00::/8</code> range.</p>
    pub fn get_tunnel_inside_ipv6_cidr(&self) -> &::std::option::Option<::std::string::String> {
        &self.tunnel_inside_ipv6_cidr
    }
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
    pub fn pre_shared_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pre_shared_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
    pub fn set_pre_shared_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pre_shared_key = input;
        self
    }
    /// <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p>
    /// <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
    pub fn get_pre_shared_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.pre_shared_key
    }
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code> </p>
    pub fn phase1_lifetime_seconds(mut self, input: i32) -> Self {
        self.phase1_lifetime_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code> </p>
    pub fn set_phase1_lifetime_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.phase1_lifetime_seconds = input;
        self
    }
    /// <p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 28,800.</p>
    /// <p>Default: <code>28800</code> </p>
    pub fn get_phase1_lifetime_seconds(&self) -> &::std::option::Option<i32> {
        &self.phase1_lifetime_seconds
    }
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code> </p>
    pub fn phase2_lifetime_seconds(mut self, input: i32) -> Self {
        self.phase2_lifetime_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code> </p>
    pub fn set_phase2_lifetime_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.phase2_lifetime_seconds = input;
        self
    }
    /// <p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>
    /// <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p>
    /// <p>Default: <code>3600</code> </p>
    pub fn get_phase2_lifetime_seconds(&self) -> &::std::option::Option<i32> {
        &self.phase2_lifetime_seconds
    }
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code> </p>
    pub fn rekey_margin_time_seconds(mut self, input: i32) -> Self {
        self.rekey_margin_time_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code> </p>
    pub fn set_rekey_margin_time_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.rekey_margin_time_seconds = input;
        self
    }
    /// <p>The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p>
    /// <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p>
    /// <p>Default: <code>540</code> </p>
    pub fn get_rekey_margin_time_seconds(&self) -> &::std::option::Option<i32> {
        &self.rekey_margin_time_seconds
    }
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code> </p>
    pub fn rekey_fuzz_percentage(mut self, input: i32) -> Self {
        self.rekey_fuzz_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code> </p>
    pub fn set_rekey_fuzz_percentage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.rekey_fuzz_percentage = input;
        self
    }
    /// <p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p>
    /// <p>Constraints: A value between 0 and 100.</p>
    /// <p>Default: <code>100</code> </p>
    pub fn get_rekey_fuzz_percentage(&self) -> &::std::option::Option<i32> {
        &self.rekey_fuzz_percentage
    }
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code> </p>
    pub fn replay_window_size(mut self, input: i32) -> Self {
        self.replay_window_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code> </p>
    pub fn set_replay_window_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.replay_window_size = input;
        self
    }
    /// <p>The number of packets in an IKE replay window.</p>
    /// <p>Constraints: A value between 64 and 2048.</p>
    /// <p>Default: <code>1024</code> </p>
    pub fn get_replay_window_size(&self) -> &::std::option::Option<i32> {
        &self.replay_window_size
    }
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value greater than or equal to 30.</p>
    /// <p>Default: <code>30</code> </p>
    pub fn dpd_timeout_seconds(mut self, input: i32) -> Self {
        self.dpd_timeout_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value greater than or equal to 30.</p>
    /// <p>Default: <code>30</code> </p>
    pub fn set_dpd_timeout_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.dpd_timeout_seconds = input;
        self
    }
    /// <p>The number of seconds after which a DPD timeout occurs.</p>
    /// <p>Constraints: A value greater than or equal to 30.</p>
    /// <p>Default: <code>30</code> </p>
    pub fn get_dpd_timeout_seconds(&self) -> &::std::option::Option<i32> {
        &self.dpd_timeout_seconds
    }
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code> </p>
    /// <p>Default: <code>clear</code> </p>
    pub fn dpd_timeout_action(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dpd_timeout_action = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code> </p>
    /// <p>Default: <code>clear</code> </p>
    pub fn set_dpd_timeout_action(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dpd_timeout_action = input;
        self
    }
    /// <p>The action to take after DPD timeout occurs. Specify <code>restart</code> to restart the IKE initiation. Specify <code>clear</code> to end the IKE session.</p>
    /// <p>Valid Values: <code>clear</code> | <code>none</code> | <code>restart</code> </p>
    /// <p>Default: <code>clear</code> </p>
    pub fn get_dpd_timeout_action(&self) -> &::std::option::Option<::std::string::String> {
        &self.dpd_timeout_action
    }
    /// Appends an item to `phase1_encryption_algorithms`.
    ///
    /// To override the contents of this collection use [`set_phase1_encryption_algorithms`](Self::set_phase1_encryption_algorithms).
    ///
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn phase1_encryption_algorithms(mut self, input: crate::types::Phase1EncryptionAlgorithmsRequestListValue) -> Self {
        let mut v = self.phase1_encryption_algorithms.unwrap_or_default();
        v.push(input);
        self.phase1_encryption_algorithms = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn set_phase1_encryption_algorithms(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase1EncryptionAlgorithmsRequestListValue>>,
    ) -> Self {
        self.phase1_encryption_algorithms = input;
        self
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn get_phase1_encryption_algorithms(
        &self,
    ) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase1EncryptionAlgorithmsRequestListValue>> {
        &self.phase1_encryption_algorithms
    }
    /// Appends an item to `phase2_encryption_algorithms`.
    ///
    /// To override the contents of this collection use [`set_phase2_encryption_algorithms`](Self::set_phase2_encryption_algorithms).
    ///
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn phase2_encryption_algorithms(mut self, input: crate::types::Phase2EncryptionAlgorithmsRequestListValue) -> Self {
        let mut v = self.phase2_encryption_algorithms.unwrap_or_default();
        v.push(input);
        self.phase2_encryption_algorithms = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn set_phase2_encryption_algorithms(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase2EncryptionAlgorithmsRequestListValue>>,
    ) -> Self {
        self.phase2_encryption_algorithms = input;
        self
    }
    /// <p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>AES128</code> | <code>AES256</code> | <code>AES128-GCM-16</code> | <code>AES256-GCM-16</code> </p>
    pub fn get_phase2_encryption_algorithms(
        &self,
    ) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase2EncryptionAlgorithmsRequestListValue>> {
        &self.phase2_encryption_algorithms
    }
    /// Appends an item to `phase1_integrity_algorithms`.
    ///
    /// To override the contents of this collection use [`set_phase1_integrity_algorithms`](Self::set_phase1_integrity_algorithms).
    ///
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn phase1_integrity_algorithms(mut self, input: crate::types::Phase1IntegrityAlgorithmsRequestListValue) -> Self {
        let mut v = self.phase1_integrity_algorithms.unwrap_or_default();
        v.push(input);
        self.phase1_integrity_algorithms = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn set_phase1_integrity_algorithms(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase1IntegrityAlgorithmsRequestListValue>>,
    ) -> Self {
        self.phase1_integrity_algorithms = input;
        self
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn get_phase1_integrity_algorithms(
        &self,
    ) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase1IntegrityAlgorithmsRequestListValue>> {
        &self.phase1_integrity_algorithms
    }
    /// Appends an item to `phase2_integrity_algorithms`.
    ///
    /// To override the contents of this collection use [`set_phase2_integrity_algorithms`](Self::set_phase2_integrity_algorithms).
    ///
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn phase2_integrity_algorithms(mut self, input: crate::types::Phase2IntegrityAlgorithmsRequestListValue) -> Self {
        let mut v = self.phase2_integrity_algorithms.unwrap_or_default();
        v.push(input);
        self.phase2_integrity_algorithms = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn set_phase2_integrity_algorithms(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase2IntegrityAlgorithmsRequestListValue>>,
    ) -> Self {
        self.phase2_integrity_algorithms = input;
        self
    }
    /// <p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> | <code>SHA2-384</code> | <code>SHA2-512</code> </p>
    pub fn get_phase2_integrity_algorithms(
        &self,
    ) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase2IntegrityAlgorithmsRequestListValue>> {
        &self.phase2_integrity_algorithms
    }
    /// Appends an item to `phase1_dh_group_numbers`.
    ///
    /// To override the contents of this collection use [`set_phase1_dh_group_numbers`](Self::set_phase1_dh_group_numbers).
    ///
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn phase1_dh_group_numbers(mut self, input: crate::types::Phase1DhGroupNumbersRequestListValue) -> Self {
        let mut v = self.phase1_dh_group_numbers.unwrap_or_default();
        v.push(input);
        self.phase1_dh_group_numbers = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn set_phase1_dh_group_numbers(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase1DhGroupNumbersRequestListValue>>,
    ) -> Self {
        self.phase1_dh_group_numbers = input;
        self
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn get_phase1_dh_group_numbers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase1DhGroupNumbersRequestListValue>> {
        &self.phase1_dh_group_numbers
    }
    /// Appends an item to `phase2_dh_group_numbers`.
    ///
    /// To override the contents of this collection use [`set_phase2_dh_group_numbers`](Self::set_phase2_dh_group_numbers).
    ///
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn phase2_dh_group_numbers(mut self, input: crate::types::Phase2DhGroupNumbersRequestListValue) -> Self {
        let mut v = self.phase2_dh_group_numbers.unwrap_or_default();
        v.push(input);
        self.phase2_dh_group_numbers = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn set_phase2_dh_group_numbers(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::Phase2DhGroupNumbersRequestListValue>>,
    ) -> Self {
        self.phase2_dh_group_numbers = input;
        self
    }
    /// <p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p>
    /// <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>19</code> | <code>20</code> | <code>21</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>
    pub fn get_phase2_dh_group_numbers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Phase2DhGroupNumbersRequestListValue>> {
        &self.phase2_dh_group_numbers
    }
    /// Appends an item to `ike_versions`.
    ///
    /// To override the contents of this collection use [`set_ike_versions`](Self::set_ike_versions).
    ///
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>
    pub fn ike_versions(mut self, input: crate::types::IkeVersionsRequestListValue) -> Self {
        let mut v = self.ike_versions.unwrap_or_default();
        v.push(input);
        self.ike_versions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>
    pub fn set_ike_versions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::IkeVersionsRequestListValue>>) -> Self {
        self.ike_versions = input;
        self
    }
    /// <p>The IKE versions that are permitted for the VPN tunnel.</p>
    /// <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>
    pub fn get_ike_versions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::IkeVersionsRequestListValue>> {
        &self.ike_versions
    }
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for Amazon Web Services to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code> </p>
    /// <p>Default: <code>add</code> </p>
    pub fn startup_action(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.startup_action = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for Amazon Web Services to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code> </p>
    /// <p>Default: <code>add</code> </p>
    pub fn set_startup_action(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.startup_action = input;
        self
    }
    /// <p>The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify <code>start</code> for Amazon Web Services to initiate the IKE negotiation.</p>
    /// <p>Valid Values: <code>add</code> | <code>start</code> </p>
    /// <p>Default: <code>add</code> </p>
    pub fn get_startup_action(&self) -> &::std::option::Option<::std::string::String> {
        &self.startup_action
    }
    /// <p>Options for logging VPN tunnel activity.</p>
    pub fn log_options(mut self, input: crate::types::VpnTunnelLogOptionsSpecification) -> Self {
        self.log_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Options for logging VPN tunnel activity.</p>
    pub fn set_log_options(mut self, input: ::std::option::Option<crate::types::VpnTunnelLogOptionsSpecification>) -> Self {
        self.log_options = input;
        self
    }
    /// <p>Options for logging VPN tunnel activity.</p>
    pub fn get_log_options(&self) -> &::std::option::Option<crate::types::VpnTunnelLogOptionsSpecification> {
        &self.log_options
    }
    /// <p>Turn on or off tunnel endpoint lifecycle control feature.</p>
    pub fn enable_tunnel_lifecycle_control(mut self, input: bool) -> Self {
        self.enable_tunnel_lifecycle_control = ::std::option::Option::Some(input);
        self
    }
    /// <p>Turn on or off tunnel endpoint lifecycle control feature.</p>
    pub fn set_enable_tunnel_lifecycle_control(mut self, input: ::std::option::Option<bool>) -> Self {
        self.enable_tunnel_lifecycle_control = input;
        self
    }
    /// <p>Turn on or off tunnel endpoint lifecycle control feature.</p>
    pub fn get_enable_tunnel_lifecycle_control(&self) -> &::std::option::Option<bool> {
        &self.enable_tunnel_lifecycle_control
    }
    /// Consumes the builder and constructs a [`VpnTunnelOptionsSpecification`](crate::types::VpnTunnelOptionsSpecification).
    pub fn build(self) -> crate::types::VpnTunnelOptionsSpecification {
        crate::types::VpnTunnelOptionsSpecification {
            tunnel_inside_cidr: self.tunnel_inside_cidr,
            tunnel_inside_ipv6_cidr: self.tunnel_inside_ipv6_cidr,
            pre_shared_key: self.pre_shared_key,
            phase1_lifetime_seconds: self.phase1_lifetime_seconds,
            phase2_lifetime_seconds: self.phase2_lifetime_seconds,
            rekey_margin_time_seconds: self.rekey_margin_time_seconds,
            rekey_fuzz_percentage: self.rekey_fuzz_percentage,
            replay_window_size: self.replay_window_size,
            dpd_timeout_seconds: self.dpd_timeout_seconds,
            dpd_timeout_action: self.dpd_timeout_action,
            phase1_encryption_algorithms: self.phase1_encryption_algorithms,
            phase2_encryption_algorithms: self.phase2_encryption_algorithms,
            phase1_integrity_algorithms: self.phase1_integrity_algorithms,
            phase2_integrity_algorithms: self.phase2_integrity_algorithms,
            phase1_dh_group_numbers: self.phase1_dh_group_numbers,
            phase2_dh_group_numbers: self.phase2_dh_group_numbers,
            ike_versions: self.ike_versions,
            startup_action: self.startup_action,
            log_options: self.log_options,
            enable_tunnel_lifecycle_control: self.enable_tunnel_lifecycle_control,
        }
    }
}
impl ::std::fmt::Debug for VpnTunnelOptionsSpecificationBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("VpnTunnelOptionsSpecificationBuilder");
        formatter.field("tunnel_inside_cidr", &self.tunnel_inside_cidr);
        formatter.field("tunnel_inside_ipv6_cidr", &self.tunnel_inside_ipv6_cidr);
        formatter.field("pre_shared_key", &"*** Sensitive Data Redacted ***");
        formatter.field("phase1_lifetime_seconds", &self.phase1_lifetime_seconds);
        formatter.field("phase2_lifetime_seconds", &self.phase2_lifetime_seconds);
        formatter.field("rekey_margin_time_seconds", &self.rekey_margin_time_seconds);
        formatter.field("rekey_fuzz_percentage", &self.rekey_fuzz_percentage);
        formatter.field("replay_window_size", &self.replay_window_size);
        formatter.field("dpd_timeout_seconds", &self.dpd_timeout_seconds);
        formatter.field("dpd_timeout_action", &self.dpd_timeout_action);
        formatter.field("phase1_encryption_algorithms", &self.phase1_encryption_algorithms);
        formatter.field("phase2_encryption_algorithms", &self.phase2_encryption_algorithms);
        formatter.field("phase1_integrity_algorithms", &self.phase1_integrity_algorithms);
        formatter.field("phase2_integrity_algorithms", &self.phase2_integrity_algorithms);
        formatter.field("phase1_dh_group_numbers", &self.phase1_dh_group_numbers);
        formatter.field("phase2_dh_group_numbers", &self.phase2_dh_group_numbers);
        formatter.field("ike_versions", &self.ike_versions);
        formatter.field("startup_action", &self.startup_action);
        formatter.field("log_options", &self.log_options);
        formatter.field("enable_tunnel_lifecycle_control", &self.enable_tunnel_lifecycle_control);
        formatter.finish()
    }
}
