// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the launch specification for one or more Spot Instances. If you include On-Demand capacity in your fleet request or want to specify an EFA network device, you can't use <code>SpotFleetLaunchSpecification</code>; you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SpotFleetLaunchSpecification {
    /// <p>The security groups.</p>
    pub security_groups: ::std::option::Option<::std::vec::Vec<crate::types::GroupIdentifier>>,
    /// <p>Deprecated.</p>
    pub addressing_type: ::std::option::Option<::std::string::String>,
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
    pub block_device_mappings: ::std::option::Option<::std::vec::Vec<crate::types::BlockDeviceMapping>>,
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code></p>
    pub ebs_optimized: ::std::option::Option<bool>,
    /// <p>The IAM instance profile.</p>
    pub iam_instance_profile: ::std::option::Option<crate::types::IamInstanceProfileSpecification>,
    /// <p>The ID of the AMI.</p>
    pub image_id: ::std::option::Option<::std::string::String>,
    /// <p>The instance type.</p>
    pub instance_type: ::std::option::Option<crate::types::InstanceType>,
    /// <p>The ID of the kernel.</p>
    pub kernel_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the key pair.</p>
    pub key_name: ::std::option::Option<::std::string::String>,
    /// <p>Enable or disable monitoring for the instances.</p>
    pub monitoring: ::std::option::Option<crate::types::SpotFleetMonitoring>,
    /// <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p><note>
    /// <p><code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    pub network_interfaces: ::std::option::Option<::std::vec::Vec<crate::types::InstanceNetworkInterfaceSpecification>>,
    /// <p>The placement information.</p>
    pub placement: ::std::option::Option<crate::types::SpotPlacement>,
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub ramdisk_id: ::std::option::Option<::std::string::String>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.</p><important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.</p>
    /// </important>
    pub spot_price: ::std::option::Option<::std::string::String>,
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub subnet_id: ::std::option::Option<::std::string::String>,
    /// <p>The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.</p>
    pub user_data: ::std::option::Option<::std::string::String>,
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub weighted_capacity: ::std::option::Option<f64>,
    /// <p>The tags to apply during creation.</p>
    pub tag_specifications: ::std::option::Option<::std::vec::Vec<crate::types::SpotFleetTagSpecification>>,
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p><note>
    /// <p>If you specify <code>InstanceRequirements</code>, you can't specify <code>InstanceType</code>.</p>
    /// </note>
    pub instance_requirements: ::std::option::Option<crate::types::InstanceRequirements>,
}
impl SpotFleetLaunchSpecification {
    /// <p>The security groups.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.security_groups.is_none()`.
    pub fn security_groups(&self) -> &[crate::types::GroupIdentifier] {
        self.security_groups.as_deref().unwrap_or_default()
    }
    /// <p>Deprecated.</p>
    pub fn addressing_type(&self) -> ::std::option::Option<&str> {
        self.addressing_type.as_deref()
    }
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.block_device_mappings.is_none()`.
    pub fn block_device_mappings(&self) -> &[crate::types::BlockDeviceMapping] {
        self.block_device_mappings.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code></p>
    pub fn ebs_optimized(&self) -> ::std::option::Option<bool> {
        self.ebs_optimized
    }
    /// <p>The IAM instance profile.</p>
    pub fn iam_instance_profile(&self) -> ::std::option::Option<&crate::types::IamInstanceProfileSpecification> {
        self.iam_instance_profile.as_ref()
    }
    /// <p>The ID of the AMI.</p>
    pub fn image_id(&self) -> ::std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>The instance type.</p>
    pub fn instance_type(&self) -> ::std::option::Option<&crate::types::InstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The ID of the kernel.</p>
    pub fn kernel_id(&self) -> ::std::option::Option<&str> {
        self.kernel_id.as_deref()
    }
    /// <p>The name of the key pair.</p>
    pub fn key_name(&self) -> ::std::option::Option<&str> {
        self.key_name.as_deref()
    }
    /// <p>Enable or disable monitoring for the instances.</p>
    pub fn monitoring(&self) -> ::std::option::Option<&crate::types::SpotFleetMonitoring> {
        self.monitoring.as_ref()
    }
    /// <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p><note>
    /// <p><code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.network_interfaces.is_none()`.
    pub fn network_interfaces(&self) -> &[crate::types::InstanceNetworkInterfaceSpecification] {
        self.network_interfaces.as_deref().unwrap_or_default()
    }
    /// <p>The placement information.</p>
    pub fn placement(&self) -> ::std::option::Option<&crate::types::SpotPlacement> {
        self.placement.as_ref()
    }
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub fn ramdisk_id(&self) -> ::std::option::Option<&str> {
        self.ramdisk_id.as_deref()
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.</p><important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.</p>
    /// </important>
    pub fn spot_price(&self) -> ::std::option::Option<&str> {
        self.spot_price.as_deref()
    }
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub fn subnet_id(&self) -> ::std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.</p>
    pub fn user_data(&self) -> ::std::option::Option<&str> {
        self.user_data.as_deref()
    }
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub fn weighted_capacity(&self) -> ::std::option::Option<f64> {
        self.weighted_capacity
    }
    /// <p>The tags to apply during creation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tag_specifications.is_none()`.
    pub fn tag_specifications(&self) -> &[crate::types::SpotFleetTagSpecification] {
        self.tag_specifications.as_deref().unwrap_or_default()
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p><note>
    /// <p>If you specify <code>InstanceRequirements</code>, you can't specify <code>InstanceType</code>.</p>
    /// </note>
    pub fn instance_requirements(&self) -> ::std::option::Option<&crate::types::InstanceRequirements> {
        self.instance_requirements.as_ref()
    }
}
impl ::std::fmt::Debug for SpotFleetLaunchSpecification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetLaunchSpecification");
        formatter.field("security_groups", &self.security_groups);
        formatter.field("addressing_type", &self.addressing_type);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &"*** Sensitive Data Redacted ***");
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.field("instance_requirements", &self.instance_requirements);
        formatter.finish()
    }
}
impl SpotFleetLaunchSpecification {
    /// Creates a new builder-style object to manufacture [`SpotFleetLaunchSpecification`](crate::types::SpotFleetLaunchSpecification).
    pub fn builder() -> crate::types::builders::SpotFleetLaunchSpecificationBuilder {
        crate::types::builders::SpotFleetLaunchSpecificationBuilder::default()
    }
}

/// A builder for [`SpotFleetLaunchSpecification`](crate::types::SpotFleetLaunchSpecification).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct SpotFleetLaunchSpecificationBuilder {
    pub(crate) security_groups: ::std::option::Option<::std::vec::Vec<crate::types::GroupIdentifier>>,
    pub(crate) addressing_type: ::std::option::Option<::std::string::String>,
    pub(crate) block_device_mappings: ::std::option::Option<::std::vec::Vec<crate::types::BlockDeviceMapping>>,
    pub(crate) ebs_optimized: ::std::option::Option<bool>,
    pub(crate) iam_instance_profile: ::std::option::Option<crate::types::IamInstanceProfileSpecification>,
    pub(crate) image_id: ::std::option::Option<::std::string::String>,
    pub(crate) instance_type: ::std::option::Option<crate::types::InstanceType>,
    pub(crate) kernel_id: ::std::option::Option<::std::string::String>,
    pub(crate) key_name: ::std::option::Option<::std::string::String>,
    pub(crate) monitoring: ::std::option::Option<crate::types::SpotFleetMonitoring>,
    pub(crate) network_interfaces: ::std::option::Option<::std::vec::Vec<crate::types::InstanceNetworkInterfaceSpecification>>,
    pub(crate) placement: ::std::option::Option<crate::types::SpotPlacement>,
    pub(crate) ramdisk_id: ::std::option::Option<::std::string::String>,
    pub(crate) spot_price: ::std::option::Option<::std::string::String>,
    pub(crate) subnet_id: ::std::option::Option<::std::string::String>,
    pub(crate) user_data: ::std::option::Option<::std::string::String>,
    pub(crate) weighted_capacity: ::std::option::Option<f64>,
    pub(crate) tag_specifications: ::std::option::Option<::std::vec::Vec<crate::types::SpotFleetTagSpecification>>,
    pub(crate) instance_requirements: ::std::option::Option<crate::types::InstanceRequirements>,
}
impl SpotFleetLaunchSpecificationBuilder {
    /// Appends an item to `security_groups`.
    ///
    /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
    ///
    /// <p>The security groups.</p>
    pub fn security_groups(mut self, input: crate::types::GroupIdentifier) -> Self {
        let mut v = self.security_groups.unwrap_or_default();
        v.push(input);
        self.security_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>The security groups.</p>
    pub fn set_security_groups(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::GroupIdentifier>>) -> Self {
        self.security_groups = input;
        self
    }
    /// <p>The security groups.</p>
    pub fn get_security_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::GroupIdentifier>> {
        &self.security_groups
    }
    /// <p>Deprecated.</p>
    pub fn addressing_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.addressing_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Deprecated.</p>
    pub fn set_addressing_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.addressing_type = input;
        self
    }
    /// <p>Deprecated.</p>
    pub fn get_addressing_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.addressing_type
    }
    /// Appends an item to `block_device_mappings`.
    ///
    /// To override the contents of this collection use [`set_block_device_mappings`](Self::set_block_device_mappings).
    ///
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
    pub fn block_device_mappings(mut self, input: crate::types::BlockDeviceMapping) -> Self {
        let mut v = self.block_device_mappings.unwrap_or_default();
        v.push(input);
        self.block_device_mappings = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
    pub fn set_block_device_mappings(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::BlockDeviceMapping>>) -> Self {
        self.block_device_mappings = input;
        self
    }
    /// <p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
    pub fn get_block_device_mappings(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::BlockDeviceMapping>> {
        &self.block_device_mappings
    }
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code></p>
    pub fn ebs_optimized(mut self, input: bool) -> Self {
        self.ebs_optimized = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code></p>
    pub fn set_ebs_optimized(mut self, input: ::std::option::Option<bool>) -> Self {
        self.ebs_optimized = input;
        self
    }
    /// <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
    /// <p>Default: <code>false</code></p>
    pub fn get_ebs_optimized(&self) -> &::std::option::Option<bool> {
        &self.ebs_optimized
    }
    /// <p>The IAM instance profile.</p>
    pub fn iam_instance_profile(mut self, input: crate::types::IamInstanceProfileSpecification) -> Self {
        self.iam_instance_profile = ::std::option::Option::Some(input);
        self
    }
    /// <p>The IAM instance profile.</p>
    pub fn set_iam_instance_profile(mut self, input: ::std::option::Option<crate::types::IamInstanceProfileSpecification>) -> Self {
        self.iam_instance_profile = input;
        self
    }
    /// <p>The IAM instance profile.</p>
    pub fn get_iam_instance_profile(&self) -> &::std::option::Option<crate::types::IamInstanceProfileSpecification> {
        &self.iam_instance_profile
    }
    /// <p>The ID of the AMI.</p>
    pub fn image_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the AMI.</p>
    pub fn set_image_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_id = input;
        self
    }
    /// <p>The ID of the AMI.</p>
    pub fn get_image_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_id
    }
    /// <p>The instance type.</p>
    pub fn instance_type(mut self, input: crate::types::InstanceType) -> Self {
        self.instance_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The instance type.</p>
    pub fn set_instance_type(mut self, input: ::std::option::Option<crate::types::InstanceType>) -> Self {
        self.instance_type = input;
        self
    }
    /// <p>The instance type.</p>
    pub fn get_instance_type(&self) -> &::std::option::Option<crate::types::InstanceType> {
        &self.instance_type
    }
    /// <p>The ID of the kernel.</p>
    pub fn kernel_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kernel_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the kernel.</p>
    pub fn set_kernel_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kernel_id = input;
        self
    }
    /// <p>The ID of the kernel.</p>
    pub fn get_kernel_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kernel_id
    }
    /// <p>The name of the key pair.</p>
    pub fn key_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.key_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the key pair.</p>
    pub fn set_key_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.key_name = input;
        self
    }
    /// <p>The name of the key pair.</p>
    pub fn get_key_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.key_name
    }
    /// <p>Enable or disable monitoring for the instances.</p>
    pub fn monitoring(mut self, input: crate::types::SpotFleetMonitoring) -> Self {
        self.monitoring = ::std::option::Option::Some(input);
        self
    }
    /// <p>Enable or disable monitoring for the instances.</p>
    pub fn set_monitoring(mut self, input: ::std::option::Option<crate::types::SpotFleetMonitoring>) -> Self {
        self.monitoring = input;
        self
    }
    /// <p>Enable or disable monitoring for the instances.</p>
    pub fn get_monitoring(&self) -> &::std::option::Option<crate::types::SpotFleetMonitoring> {
        &self.monitoring
    }
    /// Appends an item to `network_interfaces`.
    ///
    /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
    ///
    /// <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p><note>
    /// <p><code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    pub fn network_interfaces(mut self, input: crate::types::InstanceNetworkInterfaceSpecification) -> Self {
        let mut v = self.network_interfaces.unwrap_or_default();
        v.push(input);
        self.network_interfaces = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p><note>
    /// <p><code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    pub fn set_network_interfaces(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::InstanceNetworkInterfaceSpecification>>,
    ) -> Self {
        self.network_interfaces = input;
        self
    }
    /// <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p><note>
    /// <p><code>SpotFleetLaunchSpecification</code> currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html">LaunchTemplateConfig</a>.</p>
    /// </note>
    pub fn get_network_interfaces(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::InstanceNetworkInterfaceSpecification>> {
        &self.network_interfaces
    }
    /// <p>The placement information.</p>
    pub fn placement(mut self, input: crate::types::SpotPlacement) -> Self {
        self.placement = ::std::option::Option::Some(input);
        self
    }
    /// <p>The placement information.</p>
    pub fn set_placement(mut self, input: ::std::option::Option<crate::types::SpotPlacement>) -> Self {
        self.placement = input;
        self
    }
    /// <p>The placement information.</p>
    pub fn get_placement(&self) -> &::std::option::Option<crate::types::SpotPlacement> {
        &self.placement
    }
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub fn ramdisk_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ramdisk_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub fn set_ramdisk_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ramdisk_id = input;
        self
    }
    /// <p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the Amazon Web Services Resource Center and search for the kernel ID.</p>
    pub fn get_ramdisk_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.ramdisk_id
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.</p><important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.</p>
    /// </important>
    pub fn spot_price(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.spot_price = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.</p><important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.</p>
    /// </important>
    pub fn set_spot_price(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.spot_price = input;
        self
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.</p><important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.</p>
    /// </important>
    pub fn get_spot_price(&self) -> &::std::option::Option<::std::string::String> {
        &self.spot_price
    }
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub fn subnet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.subnet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub fn set_subnet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.subnet_id = input;
        self
    }
    /// <p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".</p>
    pub fn get_subnet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.subnet_id
    }
    /// <p>The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.</p>
    pub fn user_data(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_data = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.</p>
    pub fn set_user_data(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_data = input;
        self
    }
    /// <p>The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.</p>
    pub fn get_user_data(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_data
    }
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub fn weighted_capacity(mut self, input: f64) -> Self {
        self.weighted_capacity = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub fn set_weighted_capacity(mut self, input: ::std::option::Option<f64>) -> Self {
        self.weighted_capacity = input;
        self
    }
    /// <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p>
    /// <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
    pub fn get_weighted_capacity(&self) -> &::std::option::Option<f64> {
        &self.weighted_capacity
    }
    /// Appends an item to `tag_specifications`.
    ///
    /// To override the contents of this collection use [`set_tag_specifications`](Self::set_tag_specifications).
    ///
    /// <p>The tags to apply during creation.</p>
    pub fn tag_specifications(mut self, input: crate::types::SpotFleetTagSpecification) -> Self {
        let mut v = self.tag_specifications.unwrap_or_default();
        v.push(input);
        self.tag_specifications = ::std::option::Option::Some(v);
        self
    }
    /// <p>The tags to apply during creation.</p>
    pub fn set_tag_specifications(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::SpotFleetTagSpecification>>) -> Self {
        self.tag_specifications = input;
        self
    }
    /// <p>The tags to apply during creation.</p>
    pub fn get_tag_specifications(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SpotFleetTagSpecification>> {
        &self.tag_specifications
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p><note>
    /// <p>If you specify <code>InstanceRequirements</code>, you can't specify <code>InstanceType</code>.</p>
    /// </note>
    pub fn instance_requirements(mut self, input: crate::types::InstanceRequirements) -> Self {
        self.instance_requirements = ::std::option::Option::Some(input);
        self
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p><note>
    /// <p>If you specify <code>InstanceRequirements</code>, you can't specify <code>InstanceType</code>.</p>
    /// </note>
    pub fn set_instance_requirements(mut self, input: ::std::option::Option<crate::types::InstanceRequirements>) -> Self {
        self.instance_requirements = input;
        self
    }
    /// <p>The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.</p><note>
    /// <p>If you specify <code>InstanceRequirements</code>, you can't specify <code>InstanceType</code>.</p>
    /// </note>
    pub fn get_instance_requirements(&self) -> &::std::option::Option<crate::types::InstanceRequirements> {
        &self.instance_requirements
    }
    /// Consumes the builder and constructs a [`SpotFleetLaunchSpecification`](crate::types::SpotFleetLaunchSpecification).
    pub fn build(self) -> crate::types::SpotFleetLaunchSpecification {
        crate::types::SpotFleetLaunchSpecification {
            security_groups: self.security_groups,
            addressing_type: self.addressing_type,
            block_device_mappings: self.block_device_mappings,
            ebs_optimized: self.ebs_optimized,
            iam_instance_profile: self.iam_instance_profile,
            image_id: self.image_id,
            instance_type: self.instance_type,
            kernel_id: self.kernel_id,
            key_name: self.key_name,
            monitoring: self.monitoring,
            network_interfaces: self.network_interfaces,
            placement: self.placement,
            ramdisk_id: self.ramdisk_id,
            spot_price: self.spot_price,
            subnet_id: self.subnet_id,
            user_data: self.user_data,
            weighted_capacity: self.weighted_capacity,
            tag_specifications: self.tag_specifications,
            instance_requirements: self.instance_requirements,
        }
    }
}
impl ::std::fmt::Debug for SpotFleetLaunchSpecificationBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SpotFleetLaunchSpecificationBuilder");
        formatter.field("security_groups", &self.security_groups);
        formatter.field("addressing_type", &self.addressing_type);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("image_id", &self.image_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("monitoring", &self.monitoring);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.field("placement", &self.placement);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("user_data", &"*** Sensitive Data Redacted ***");
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field("tag_specifications", &self.tag_specifications);
        formatter.field("instance_requirements", &self.instance_requirements);
        formatter.finish()
    }
}
