// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes an explanation code for an unreachable path. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html">Reachability Analyzer explanation codes</a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Explanation {
    /// <p>The network ACL.</p>
    pub acl: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The network ACL rule.</p>
    pub acl_rule: ::std::option::Option<crate::types::AnalysisAclRule>,
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub address: ::std::option::Option<::std::string::String>,
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    pub addresses: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The resource to which the component is attached.</p>
    pub attached_to: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The Availability Zones.</p>
    pub availability_zones: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The CIDR ranges.</p>
    pub cidrs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The component.</p>
    pub component: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The customer gateway.</p>
    pub customer_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The destination.</p>
    pub destination: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The destination VPC.</p>
    pub destination_vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The direction. The following are the possible values:</p>
    /// <ul>
    /// <li> <p>egress</p> </li>
    /// <li> <p>ingress</p> </li>
    /// </ul>
    pub direction: ::std::option::Option<::std::string::String>,
    /// <p>The explanation code.</p>
    pub explanation_code: ::std::option::Option<::std::string::String>,
    /// <p>The route table.</p>
    pub ingress_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The internet gateway.</p>
    pub internet_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub load_balancer_arn: ::std::option::Option<::std::string::String>,
    /// <p>The listener for a Classic Load Balancer.</p>
    pub classic_load_balancer_listener: ::std::option::Option<crate::types::AnalysisLoadBalancerListener>,
    /// <p>The listener port of the load balancer.</p>
    pub load_balancer_listener_port: ::std::option::Option<i32>,
    /// <p>The target.</p>
    pub load_balancer_target: ::std::option::Option<crate::types::AnalysisLoadBalancerTarget>,
    /// <p>The target group.</p>
    pub load_balancer_target_group: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The target groups.</p>
    pub load_balancer_target_groups: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>,
    /// <p>The target port.</p>
    pub load_balancer_target_port: ::std::option::Option<i32>,
    /// <p>The load balancer listener.</p>
    pub elastic_load_balancer_listener: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The missing component.</p>
    pub missing_component: ::std::option::Option<::std::string::String>,
    /// <p>The NAT gateway.</p>
    pub nat_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The network interface.</p>
    pub network_interface: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The packet field.</p>
    pub packet_field: ::std::option::Option<::std::string::String>,
    /// <p>The VPC peering connection.</p>
    pub vpc_peering_connection: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The port.</p>
    pub port: ::std::option::Option<i32>,
    /// <p>The port ranges.</p>
    pub port_ranges: ::std::option::Option<::std::vec::Vec<crate::types::PortRange>>,
    /// <p>The prefix list.</p>
    pub prefix_list: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The protocols.</p>
    pub protocols: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The route table route.</p>
    pub route_table_route: ::std::option::Option<crate::types::AnalysisRouteTableRoute>,
    /// <p>The route table.</p>
    pub route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The security group.</p>
    pub security_group: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The security group rule.</p>
    pub security_group_rule: ::std::option::Option<crate::types::AnalysisSecurityGroupRule>,
    /// <p>The security groups.</p>
    pub security_groups: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>,
    /// <p>The source VPC.</p>
    pub source_vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The state.</p>
    pub state: ::std::option::Option<::std::string::String>,
    /// <p>The subnet.</p>
    pub subnet: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The route table for the subnet.</p>
    pub subnet_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The component VPC.</p>
    pub vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The VPC endpoint.</p>
    pub vpc_endpoint: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The VPN connection.</p>
    pub vpn_connection: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The VPN gateway.</p>
    pub vpn_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The transit gateway.</p>
    pub transit_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The transit gateway route table.</p>
    pub transit_gateway_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The transit gateway route table route.</p>
    pub transit_gateway_route_table_route: ::std::option::Option<crate::types::TransitGatewayRouteTableRoute>,
    /// <p>The transit gateway attachment.</p>
    pub transit_gateway_attachment: ::std::option::Option<crate::types::AnalysisComponent>,
    /// <p>The Amazon Web Services account for the component.</p>
    pub component_account: ::std::option::Option<::std::string::String>,
    /// <p>The Region for the component.</p>
    pub component_region: ::std::option::Option<::std::string::String>,
    /// <p>The Network Firewall stateless rule.</p>
    pub firewall_stateless_rule: ::std::option::Option<crate::types::FirewallStatelessRule>,
    /// <p>The Network Firewall stateful rule.</p>
    pub firewall_stateful_rule: ::std::option::Option<crate::types::FirewallStatefulRule>,
}
impl Explanation {
    /// <p>The network ACL.</p>
    pub fn acl(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.acl.as_ref()
    }
    /// <p>The network ACL rule.</p>
    pub fn acl_rule(&self) -> ::std::option::Option<&crate::types::AnalysisAclRule> {
        self.acl_rule.as_ref()
    }
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub fn address(&self) -> ::std::option::Option<&str> {
        self.address.as_deref()
    }
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.addresses.is_none()`.
    pub fn addresses(&self) -> &[::std::string::String] {
        self.addresses.as_deref().unwrap_or_default()
    }
    /// <p>The resource to which the component is attached.</p>
    pub fn attached_to(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.attached_to.as_ref()
    }
    /// <p>The Availability Zones.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.availability_zones.is_none()`.
    pub fn availability_zones(&self) -> &[::std::string::String] {
        self.availability_zones.as_deref().unwrap_or_default()
    }
    /// <p>The CIDR ranges.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cidrs.is_none()`.
    pub fn cidrs(&self) -> &[::std::string::String] {
        self.cidrs.as_deref().unwrap_or_default()
    }
    /// <p>The component.</p>
    pub fn component(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.component.as_ref()
    }
    /// <p>The customer gateway.</p>
    pub fn customer_gateway(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.customer_gateway.as_ref()
    }
    /// <p>The destination.</p>
    pub fn destination(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.destination.as_ref()
    }
    /// <p>The destination VPC.</p>
    pub fn destination_vpc(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.destination_vpc.as_ref()
    }
    /// <p>The direction. The following are the possible values:</p>
    /// <ul>
    /// <li> <p>egress</p> </li>
    /// <li> <p>ingress</p> </li>
    /// </ul>
    pub fn direction(&self) -> ::std::option::Option<&str> {
        self.direction.as_deref()
    }
    /// <p>The explanation code.</p>
    pub fn explanation_code(&self) -> ::std::option::Option<&str> {
        self.explanation_code.as_deref()
    }
    /// <p>The route table.</p>
    pub fn ingress_route_table(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.ingress_route_table.as_ref()
    }
    /// <p>The internet gateway.</p>
    pub fn internet_gateway(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.internet_gateway.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn load_balancer_arn(&self) -> ::std::option::Option<&str> {
        self.load_balancer_arn.as_deref()
    }
    /// <p>The listener for a Classic Load Balancer.</p>
    pub fn classic_load_balancer_listener(&self) -> ::std::option::Option<&crate::types::AnalysisLoadBalancerListener> {
        self.classic_load_balancer_listener.as_ref()
    }
    /// <p>The listener port of the load balancer.</p>
    pub fn load_balancer_listener_port(&self) -> ::std::option::Option<i32> {
        self.load_balancer_listener_port
    }
    /// <p>The target.</p>
    pub fn load_balancer_target(&self) -> ::std::option::Option<&crate::types::AnalysisLoadBalancerTarget> {
        self.load_balancer_target.as_ref()
    }
    /// <p>The target group.</p>
    pub fn load_balancer_target_group(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.load_balancer_target_group.as_ref()
    }
    /// <p>The target groups.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.load_balancer_target_groups.is_none()`.
    pub fn load_balancer_target_groups(&self) -> &[crate::types::AnalysisComponent] {
        self.load_balancer_target_groups.as_deref().unwrap_or_default()
    }
    /// <p>The target port.</p>
    pub fn load_balancer_target_port(&self) -> ::std::option::Option<i32> {
        self.load_balancer_target_port
    }
    /// <p>The load balancer listener.</p>
    pub fn elastic_load_balancer_listener(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.elastic_load_balancer_listener.as_ref()
    }
    /// <p>The missing component.</p>
    pub fn missing_component(&self) -> ::std::option::Option<&str> {
        self.missing_component.as_deref()
    }
    /// <p>The NAT gateway.</p>
    pub fn nat_gateway(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.nat_gateway.as_ref()
    }
    /// <p>The network interface.</p>
    pub fn network_interface(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.network_interface.as_ref()
    }
    /// <p>The packet field.</p>
    pub fn packet_field(&self) -> ::std::option::Option<&str> {
        self.packet_field.as_deref()
    }
    /// <p>The VPC peering connection.</p>
    pub fn vpc_peering_connection(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.vpc_peering_connection.as_ref()
    }
    /// <p>The port.</p>
    pub fn port(&self) -> ::std::option::Option<i32> {
        self.port
    }
    /// <p>The port ranges.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.port_ranges.is_none()`.
    pub fn port_ranges(&self) -> &[crate::types::PortRange] {
        self.port_ranges.as_deref().unwrap_or_default()
    }
    /// <p>The prefix list.</p>
    pub fn prefix_list(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.prefix_list.as_ref()
    }
    /// <p>The protocols.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.protocols.is_none()`.
    pub fn protocols(&self) -> &[::std::string::String] {
        self.protocols.as_deref().unwrap_or_default()
    }
    /// <p>The route table route.</p>
    pub fn route_table_route(&self) -> ::std::option::Option<&crate::types::AnalysisRouteTableRoute> {
        self.route_table_route.as_ref()
    }
    /// <p>The route table.</p>
    pub fn route_table(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.route_table.as_ref()
    }
    /// <p>The security group.</p>
    pub fn security_group(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.security_group.as_ref()
    }
    /// <p>The security group rule.</p>
    pub fn security_group_rule(&self) -> ::std::option::Option<&crate::types::AnalysisSecurityGroupRule> {
        self.security_group_rule.as_ref()
    }
    /// <p>The security groups.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.security_groups.is_none()`.
    pub fn security_groups(&self) -> &[crate::types::AnalysisComponent] {
        self.security_groups.as_deref().unwrap_or_default()
    }
    /// <p>The source VPC.</p>
    pub fn source_vpc(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.source_vpc.as_ref()
    }
    /// <p>The state.</p>
    pub fn state(&self) -> ::std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The subnet.</p>
    pub fn subnet(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.subnet.as_ref()
    }
    /// <p>The route table for the subnet.</p>
    pub fn subnet_route_table(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.subnet_route_table.as_ref()
    }
    /// <p>The component VPC.</p>
    pub fn vpc(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.vpc.as_ref()
    }
    /// <p>The VPC endpoint.</p>
    pub fn vpc_endpoint(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.vpc_endpoint.as_ref()
    }
    /// <p>The VPN connection.</p>
    pub fn vpn_connection(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.vpn_connection.as_ref()
    }
    /// <p>The VPN gateway.</p>
    pub fn vpn_gateway(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.vpn_gateway.as_ref()
    }
    /// <p>The transit gateway.</p>
    pub fn transit_gateway(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.transit_gateway.as_ref()
    }
    /// <p>The transit gateway route table.</p>
    pub fn transit_gateway_route_table(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.transit_gateway_route_table.as_ref()
    }
    /// <p>The transit gateway route table route.</p>
    pub fn transit_gateway_route_table_route(&self) -> ::std::option::Option<&crate::types::TransitGatewayRouteTableRoute> {
        self.transit_gateway_route_table_route.as_ref()
    }
    /// <p>The transit gateway attachment.</p>
    pub fn transit_gateway_attachment(&self) -> ::std::option::Option<&crate::types::AnalysisComponent> {
        self.transit_gateway_attachment.as_ref()
    }
    /// <p>The Amazon Web Services account for the component.</p>
    pub fn component_account(&self) -> ::std::option::Option<&str> {
        self.component_account.as_deref()
    }
    /// <p>The Region for the component.</p>
    pub fn component_region(&self) -> ::std::option::Option<&str> {
        self.component_region.as_deref()
    }
    /// <p>The Network Firewall stateless rule.</p>
    pub fn firewall_stateless_rule(&self) -> ::std::option::Option<&crate::types::FirewallStatelessRule> {
        self.firewall_stateless_rule.as_ref()
    }
    /// <p>The Network Firewall stateful rule.</p>
    pub fn firewall_stateful_rule(&self) -> ::std::option::Option<&crate::types::FirewallStatefulRule> {
        self.firewall_stateful_rule.as_ref()
    }
}
impl Explanation {
    /// Creates a new builder-style object to manufacture [`Explanation`](crate::types::Explanation).
    pub fn builder() -> crate::types::builders::ExplanationBuilder {
        crate::types::builders::ExplanationBuilder::default()
    }
}

/// A builder for [`Explanation`](crate::types::Explanation).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ExplanationBuilder {
    pub(crate) acl: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) acl_rule: ::std::option::Option<crate::types::AnalysisAclRule>,
    pub(crate) address: ::std::option::Option<::std::string::String>,
    pub(crate) addresses: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) attached_to: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) availability_zones: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) cidrs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) component: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) customer_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) destination: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) destination_vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) direction: ::std::option::Option<::std::string::String>,
    pub(crate) explanation_code: ::std::option::Option<::std::string::String>,
    pub(crate) ingress_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) internet_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) load_balancer_arn: ::std::option::Option<::std::string::String>,
    pub(crate) classic_load_balancer_listener: ::std::option::Option<crate::types::AnalysisLoadBalancerListener>,
    pub(crate) load_balancer_listener_port: ::std::option::Option<i32>,
    pub(crate) load_balancer_target: ::std::option::Option<crate::types::AnalysisLoadBalancerTarget>,
    pub(crate) load_balancer_target_group: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) load_balancer_target_groups: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>,
    pub(crate) load_balancer_target_port: ::std::option::Option<i32>,
    pub(crate) elastic_load_balancer_listener: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) missing_component: ::std::option::Option<::std::string::String>,
    pub(crate) nat_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) network_interface: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) packet_field: ::std::option::Option<::std::string::String>,
    pub(crate) vpc_peering_connection: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) port: ::std::option::Option<i32>,
    pub(crate) port_ranges: ::std::option::Option<::std::vec::Vec<crate::types::PortRange>>,
    pub(crate) prefix_list: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) protocols: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) route_table_route: ::std::option::Option<crate::types::AnalysisRouteTableRoute>,
    pub(crate) route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) security_group: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) security_group_rule: ::std::option::Option<crate::types::AnalysisSecurityGroupRule>,
    pub(crate) security_groups: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>,
    pub(crate) source_vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) state: ::std::option::Option<::std::string::String>,
    pub(crate) subnet: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) subnet_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) vpc: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) vpc_endpoint: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) vpn_connection: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) vpn_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) transit_gateway: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) transit_gateway_route_table: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) transit_gateway_route_table_route: ::std::option::Option<crate::types::TransitGatewayRouteTableRoute>,
    pub(crate) transit_gateway_attachment: ::std::option::Option<crate::types::AnalysisComponent>,
    pub(crate) component_account: ::std::option::Option<::std::string::String>,
    pub(crate) component_region: ::std::option::Option<::std::string::String>,
    pub(crate) firewall_stateless_rule: ::std::option::Option<crate::types::FirewallStatelessRule>,
    pub(crate) firewall_stateful_rule: ::std::option::Option<crate::types::FirewallStatefulRule>,
}
impl ExplanationBuilder {
    /// <p>The network ACL.</p>
    pub fn acl(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.acl = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network ACL.</p>
    pub fn set_acl(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.acl = input;
        self
    }
    /// <p>The network ACL.</p>
    pub fn get_acl(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.acl
    }
    /// <p>The network ACL rule.</p>
    pub fn acl_rule(mut self, input: crate::types::AnalysisAclRule) -> Self {
        self.acl_rule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network ACL rule.</p>
    pub fn set_acl_rule(mut self, input: ::std::option::Option<crate::types::AnalysisAclRule>) -> Self {
        self.acl_rule = input;
        self
    }
    /// <p>The network ACL rule.</p>
    pub fn get_acl_rule(&self) -> &::std::option::Option<crate::types::AnalysisAclRule> {
        &self.acl_rule
    }
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub fn address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub fn set_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.address = input;
        self
    }
    /// <p>The IPv4 address, in CIDR notation.</p>
    pub fn get_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.address
    }
    /// Appends an item to `addresses`.
    ///
    /// To override the contents of this collection use [`set_addresses`](Self::set_addresses).
    ///
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    pub fn addresses(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.addresses.unwrap_or_default();
        v.push(input.into());
        self.addresses = ::std::option::Option::Some(v);
        self
    }
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    pub fn set_addresses(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.addresses = input;
        self
    }
    /// <p>The IPv4 addresses, in CIDR notation.</p>
    pub fn get_addresses(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.addresses
    }
    /// <p>The resource to which the component is attached.</p>
    pub fn attached_to(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.attached_to = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resource to which the component is attached.</p>
    pub fn set_attached_to(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.attached_to = input;
        self
    }
    /// <p>The resource to which the component is attached.</p>
    pub fn get_attached_to(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.attached_to
    }
    /// Appends an item to `availability_zones`.
    ///
    /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
    ///
    /// <p>The Availability Zones.</p>
    pub fn availability_zones(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.availability_zones.unwrap_or_default();
        v.push(input.into());
        self.availability_zones = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Availability Zones.</p>
    pub fn set_availability_zones(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.availability_zones = input;
        self
    }
    /// <p>The Availability Zones.</p>
    pub fn get_availability_zones(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.availability_zones
    }
    /// Appends an item to `cidrs`.
    ///
    /// To override the contents of this collection use [`set_cidrs`](Self::set_cidrs).
    ///
    /// <p>The CIDR ranges.</p>
    pub fn cidrs(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.cidrs.unwrap_or_default();
        v.push(input.into());
        self.cidrs = ::std::option::Option::Some(v);
        self
    }
    /// <p>The CIDR ranges.</p>
    pub fn set_cidrs(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.cidrs = input;
        self
    }
    /// <p>The CIDR ranges.</p>
    pub fn get_cidrs(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.cidrs
    }
    /// <p>The component.</p>
    pub fn component(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.component = ::std::option::Option::Some(input);
        self
    }
    /// <p>The component.</p>
    pub fn set_component(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.component = input;
        self
    }
    /// <p>The component.</p>
    pub fn get_component(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.component
    }
    /// <p>The customer gateway.</p>
    pub fn customer_gateway(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.customer_gateway = ::std::option::Option::Some(input);
        self
    }
    /// <p>The customer gateway.</p>
    pub fn set_customer_gateway(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.customer_gateway = input;
        self
    }
    /// <p>The customer gateway.</p>
    pub fn get_customer_gateway(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.customer_gateway
    }
    /// <p>The destination.</p>
    pub fn destination(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.destination = ::std::option::Option::Some(input);
        self
    }
    /// <p>The destination.</p>
    pub fn set_destination(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.destination = input;
        self
    }
    /// <p>The destination.</p>
    pub fn get_destination(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.destination
    }
    /// <p>The destination VPC.</p>
    pub fn destination_vpc(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.destination_vpc = ::std::option::Option::Some(input);
        self
    }
    /// <p>The destination VPC.</p>
    pub fn set_destination_vpc(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.destination_vpc = input;
        self
    }
    /// <p>The destination VPC.</p>
    pub fn get_destination_vpc(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.destination_vpc
    }
    /// <p>The direction. The following are the possible values:</p>
    /// <ul>
    /// <li> <p>egress</p> </li>
    /// <li> <p>ingress</p> </li>
    /// </ul>
    pub fn direction(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.direction = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The direction. The following are the possible values:</p>
    /// <ul>
    /// <li> <p>egress</p> </li>
    /// <li> <p>ingress</p> </li>
    /// </ul>
    pub fn set_direction(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.direction = input;
        self
    }
    /// <p>The direction. The following are the possible values:</p>
    /// <ul>
    /// <li> <p>egress</p> </li>
    /// <li> <p>ingress</p> </li>
    /// </ul>
    pub fn get_direction(&self) -> &::std::option::Option<::std::string::String> {
        &self.direction
    }
    /// <p>The explanation code.</p>
    pub fn explanation_code(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.explanation_code = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The explanation code.</p>
    pub fn set_explanation_code(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.explanation_code = input;
        self
    }
    /// <p>The explanation code.</p>
    pub fn get_explanation_code(&self) -> &::std::option::Option<::std::string::String> {
        &self.explanation_code
    }
    /// <p>The route table.</p>
    pub fn ingress_route_table(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.ingress_route_table = ::std::option::Option::Some(input);
        self
    }
    /// <p>The route table.</p>
    pub fn set_ingress_route_table(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.ingress_route_table = input;
        self
    }
    /// <p>The route table.</p>
    pub fn get_ingress_route_table(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.ingress_route_table
    }
    /// <p>The internet gateway.</p>
    pub fn internet_gateway(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.internet_gateway = ::std::option::Option::Some(input);
        self
    }
    /// <p>The internet gateway.</p>
    pub fn set_internet_gateway(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.internet_gateway = input;
        self
    }
    /// <p>The internet gateway.</p>
    pub fn get_internet_gateway(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.internet_gateway
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn load_balancer_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.load_balancer_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn set_load_balancer_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.load_balancer_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn get_load_balancer_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.load_balancer_arn
    }
    /// <p>The listener for a Classic Load Balancer.</p>
    pub fn classic_load_balancer_listener(mut self, input: crate::types::AnalysisLoadBalancerListener) -> Self {
        self.classic_load_balancer_listener = ::std::option::Option::Some(input);
        self
    }
    /// <p>The listener for a Classic Load Balancer.</p>
    pub fn set_classic_load_balancer_listener(mut self, input: ::std::option::Option<crate::types::AnalysisLoadBalancerListener>) -> Self {
        self.classic_load_balancer_listener = input;
        self
    }
    /// <p>The listener for a Classic Load Balancer.</p>
    pub fn get_classic_load_balancer_listener(&self) -> &::std::option::Option<crate::types::AnalysisLoadBalancerListener> {
        &self.classic_load_balancer_listener
    }
    /// <p>The listener port of the load balancer.</p>
    pub fn load_balancer_listener_port(mut self, input: i32) -> Self {
        self.load_balancer_listener_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The listener port of the load balancer.</p>
    pub fn set_load_balancer_listener_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.load_balancer_listener_port = input;
        self
    }
    /// <p>The listener port of the load balancer.</p>
    pub fn get_load_balancer_listener_port(&self) -> &::std::option::Option<i32> {
        &self.load_balancer_listener_port
    }
    /// <p>The target.</p>
    pub fn load_balancer_target(mut self, input: crate::types::AnalysisLoadBalancerTarget) -> Self {
        self.load_balancer_target = ::std::option::Option::Some(input);
        self
    }
    /// <p>The target.</p>
    pub fn set_load_balancer_target(mut self, input: ::std::option::Option<crate::types::AnalysisLoadBalancerTarget>) -> Self {
        self.load_balancer_target = input;
        self
    }
    /// <p>The target.</p>
    pub fn get_load_balancer_target(&self) -> &::std::option::Option<crate::types::AnalysisLoadBalancerTarget> {
        &self.load_balancer_target
    }
    /// <p>The target group.</p>
    pub fn load_balancer_target_group(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.load_balancer_target_group = ::std::option::Option::Some(input);
        self
    }
    /// <p>The target group.</p>
    pub fn set_load_balancer_target_group(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.load_balancer_target_group = input;
        self
    }
    /// <p>The target group.</p>
    pub fn get_load_balancer_target_group(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.load_balancer_target_group
    }
    /// Appends an item to `load_balancer_target_groups`.
    ///
    /// To override the contents of this collection use [`set_load_balancer_target_groups`](Self::set_load_balancer_target_groups).
    ///
    /// <p>The target groups.</p>
    pub fn load_balancer_target_groups(mut self, input: crate::types::AnalysisComponent) -> Self {
        let mut v = self.load_balancer_target_groups.unwrap_or_default();
        v.push(input);
        self.load_balancer_target_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>The target groups.</p>
    pub fn set_load_balancer_target_groups(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>) -> Self {
        self.load_balancer_target_groups = input;
        self
    }
    /// <p>The target groups.</p>
    pub fn get_load_balancer_target_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>> {
        &self.load_balancer_target_groups
    }
    /// <p>The target port.</p>
    pub fn load_balancer_target_port(mut self, input: i32) -> Self {
        self.load_balancer_target_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The target port.</p>
    pub fn set_load_balancer_target_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.load_balancer_target_port = input;
        self
    }
    /// <p>The target port.</p>
    pub fn get_load_balancer_target_port(&self) -> &::std::option::Option<i32> {
        &self.load_balancer_target_port
    }
    /// <p>The load balancer listener.</p>
    pub fn elastic_load_balancer_listener(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.elastic_load_balancer_listener = ::std::option::Option::Some(input);
        self
    }
    /// <p>The load balancer listener.</p>
    pub fn set_elastic_load_balancer_listener(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.elastic_load_balancer_listener = input;
        self
    }
    /// <p>The load balancer listener.</p>
    pub fn get_elastic_load_balancer_listener(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.elastic_load_balancer_listener
    }
    /// <p>The missing component.</p>
    pub fn missing_component(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.missing_component = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The missing component.</p>
    pub fn set_missing_component(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.missing_component = input;
        self
    }
    /// <p>The missing component.</p>
    pub fn get_missing_component(&self) -> &::std::option::Option<::std::string::String> {
        &self.missing_component
    }
    /// <p>The NAT gateway.</p>
    pub fn nat_gateway(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.nat_gateway = ::std::option::Option::Some(input);
        self
    }
    /// <p>The NAT gateway.</p>
    pub fn set_nat_gateway(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.nat_gateway = input;
        self
    }
    /// <p>The NAT gateway.</p>
    pub fn get_nat_gateway(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.nat_gateway
    }
    /// <p>The network interface.</p>
    pub fn network_interface(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.network_interface = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network interface.</p>
    pub fn set_network_interface(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.network_interface = input;
        self
    }
    /// <p>The network interface.</p>
    pub fn get_network_interface(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.network_interface
    }
    /// <p>The packet field.</p>
    pub fn packet_field(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.packet_field = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The packet field.</p>
    pub fn set_packet_field(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.packet_field = input;
        self
    }
    /// <p>The packet field.</p>
    pub fn get_packet_field(&self) -> &::std::option::Option<::std::string::String> {
        &self.packet_field
    }
    /// <p>The VPC peering connection.</p>
    pub fn vpc_peering_connection(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.vpc_peering_connection = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPC peering connection.</p>
    pub fn set_vpc_peering_connection(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.vpc_peering_connection = input;
        self
    }
    /// <p>The VPC peering connection.</p>
    pub fn get_vpc_peering_connection(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.vpc_peering_connection
    }
    /// <p>The port.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port.</p>
    pub fn set_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.port = input;
        self
    }
    /// <p>The port.</p>
    pub fn get_port(&self) -> &::std::option::Option<i32> {
        &self.port
    }
    /// Appends an item to `port_ranges`.
    ///
    /// To override the contents of this collection use [`set_port_ranges`](Self::set_port_ranges).
    ///
    /// <p>The port ranges.</p>
    pub fn port_ranges(mut self, input: crate::types::PortRange) -> Self {
        let mut v = self.port_ranges.unwrap_or_default();
        v.push(input);
        self.port_ranges = ::std::option::Option::Some(v);
        self
    }
    /// <p>The port ranges.</p>
    pub fn set_port_ranges(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PortRange>>) -> Self {
        self.port_ranges = input;
        self
    }
    /// <p>The port ranges.</p>
    pub fn get_port_ranges(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PortRange>> {
        &self.port_ranges
    }
    /// <p>The prefix list.</p>
    pub fn prefix_list(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.prefix_list = ::std::option::Option::Some(input);
        self
    }
    /// <p>The prefix list.</p>
    pub fn set_prefix_list(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.prefix_list = input;
        self
    }
    /// <p>The prefix list.</p>
    pub fn get_prefix_list(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.prefix_list
    }
    /// Appends an item to `protocols`.
    ///
    /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
    ///
    /// <p>The protocols.</p>
    pub fn protocols(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.protocols.unwrap_or_default();
        v.push(input.into());
        self.protocols = ::std::option::Option::Some(v);
        self
    }
    /// <p>The protocols.</p>
    pub fn set_protocols(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.protocols = input;
        self
    }
    /// <p>The protocols.</p>
    pub fn get_protocols(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.protocols
    }
    /// <p>The route table route.</p>
    pub fn route_table_route(mut self, input: crate::types::AnalysisRouteTableRoute) -> Self {
        self.route_table_route = ::std::option::Option::Some(input);
        self
    }
    /// <p>The route table route.</p>
    pub fn set_route_table_route(mut self, input: ::std::option::Option<crate::types::AnalysisRouteTableRoute>) -> Self {
        self.route_table_route = input;
        self
    }
    /// <p>The route table route.</p>
    pub fn get_route_table_route(&self) -> &::std::option::Option<crate::types::AnalysisRouteTableRoute> {
        &self.route_table_route
    }
    /// <p>The route table.</p>
    pub fn route_table(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.route_table = ::std::option::Option::Some(input);
        self
    }
    /// <p>The route table.</p>
    pub fn set_route_table(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.route_table = input;
        self
    }
    /// <p>The route table.</p>
    pub fn get_route_table(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.route_table
    }
    /// <p>The security group.</p>
    pub fn security_group(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.security_group = ::std::option::Option::Some(input);
        self
    }
    /// <p>The security group.</p>
    pub fn set_security_group(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.security_group = input;
        self
    }
    /// <p>The security group.</p>
    pub fn get_security_group(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.security_group
    }
    /// <p>The security group rule.</p>
    pub fn security_group_rule(mut self, input: crate::types::AnalysisSecurityGroupRule) -> Self {
        self.security_group_rule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The security group rule.</p>
    pub fn set_security_group_rule(mut self, input: ::std::option::Option<crate::types::AnalysisSecurityGroupRule>) -> Self {
        self.security_group_rule = input;
        self
    }
    /// <p>The security group rule.</p>
    pub fn get_security_group_rule(&self) -> &::std::option::Option<crate::types::AnalysisSecurityGroupRule> {
        &self.security_group_rule
    }
    /// Appends an item to `security_groups`.
    ///
    /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
    ///
    /// <p>The security groups.</p>
    pub fn security_groups(mut self, input: crate::types::AnalysisComponent) -> Self {
        let mut v = self.security_groups.unwrap_or_default();
        v.push(input);
        self.security_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>The security groups.</p>
    pub fn set_security_groups(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>>) -> Self {
        self.security_groups = input;
        self
    }
    /// <p>The security groups.</p>
    pub fn get_security_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AnalysisComponent>> {
        &self.security_groups
    }
    /// <p>The source VPC.</p>
    pub fn source_vpc(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.source_vpc = ::std::option::Option::Some(input);
        self
    }
    /// <p>The source VPC.</p>
    pub fn set_source_vpc(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.source_vpc = input;
        self
    }
    /// <p>The source VPC.</p>
    pub fn get_source_vpc(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.source_vpc
    }
    /// <p>The state.</p>
    pub fn state(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.state = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The state.</p>
    pub fn set_state(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.state = input;
        self
    }
    /// <p>The state.</p>
    pub fn get_state(&self) -> &::std::option::Option<::std::string::String> {
        &self.state
    }
    /// <p>The subnet.</p>
    pub fn subnet(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.subnet = ::std::option::Option::Some(input);
        self
    }
    /// <p>The subnet.</p>
    pub fn set_subnet(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.subnet = input;
        self
    }
    /// <p>The subnet.</p>
    pub fn get_subnet(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.subnet
    }
    /// <p>The route table for the subnet.</p>
    pub fn subnet_route_table(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.subnet_route_table = ::std::option::Option::Some(input);
        self
    }
    /// <p>The route table for the subnet.</p>
    pub fn set_subnet_route_table(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.subnet_route_table = input;
        self
    }
    /// <p>The route table for the subnet.</p>
    pub fn get_subnet_route_table(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.subnet_route_table
    }
    /// <p>The component VPC.</p>
    pub fn vpc(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.vpc = ::std::option::Option::Some(input);
        self
    }
    /// <p>The component VPC.</p>
    pub fn set_vpc(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.vpc = input;
        self
    }
    /// <p>The component VPC.</p>
    pub fn get_vpc(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.vpc
    }
    /// <p>The VPC endpoint.</p>
    pub fn vpc_endpoint(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.vpc_endpoint = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPC endpoint.</p>
    pub fn set_vpc_endpoint(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.vpc_endpoint = input;
        self
    }
    /// <p>The VPC endpoint.</p>
    pub fn get_vpc_endpoint(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.vpc_endpoint
    }
    /// <p>The VPN connection.</p>
    pub fn vpn_connection(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.vpn_connection = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPN connection.</p>
    pub fn set_vpn_connection(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.vpn_connection = input;
        self
    }
    /// <p>The VPN connection.</p>
    pub fn get_vpn_connection(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.vpn_connection
    }
    /// <p>The VPN gateway.</p>
    pub fn vpn_gateway(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.vpn_gateway = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPN gateway.</p>
    pub fn set_vpn_gateway(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.vpn_gateway = input;
        self
    }
    /// <p>The VPN gateway.</p>
    pub fn get_vpn_gateway(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.vpn_gateway
    }
    /// <p>The transit gateway.</p>
    pub fn transit_gateway(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.transit_gateway = ::std::option::Option::Some(input);
        self
    }
    /// <p>The transit gateway.</p>
    pub fn set_transit_gateway(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.transit_gateway = input;
        self
    }
    /// <p>The transit gateway.</p>
    pub fn get_transit_gateway(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.transit_gateway
    }
    /// <p>The transit gateway route table.</p>
    pub fn transit_gateway_route_table(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.transit_gateway_route_table = ::std::option::Option::Some(input);
        self
    }
    /// <p>The transit gateway route table.</p>
    pub fn set_transit_gateway_route_table(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.transit_gateway_route_table = input;
        self
    }
    /// <p>The transit gateway route table.</p>
    pub fn get_transit_gateway_route_table(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.transit_gateway_route_table
    }
    /// <p>The transit gateway route table route.</p>
    pub fn transit_gateway_route_table_route(mut self, input: crate::types::TransitGatewayRouteTableRoute) -> Self {
        self.transit_gateway_route_table_route = ::std::option::Option::Some(input);
        self
    }
    /// <p>The transit gateway route table route.</p>
    pub fn set_transit_gateway_route_table_route(mut self, input: ::std::option::Option<crate::types::TransitGatewayRouteTableRoute>) -> Self {
        self.transit_gateway_route_table_route = input;
        self
    }
    /// <p>The transit gateway route table route.</p>
    pub fn get_transit_gateway_route_table_route(&self) -> &::std::option::Option<crate::types::TransitGatewayRouteTableRoute> {
        &self.transit_gateway_route_table_route
    }
    /// <p>The transit gateway attachment.</p>
    pub fn transit_gateway_attachment(mut self, input: crate::types::AnalysisComponent) -> Self {
        self.transit_gateway_attachment = ::std::option::Option::Some(input);
        self
    }
    /// <p>The transit gateway attachment.</p>
    pub fn set_transit_gateway_attachment(mut self, input: ::std::option::Option<crate::types::AnalysisComponent>) -> Self {
        self.transit_gateway_attachment = input;
        self
    }
    /// <p>The transit gateway attachment.</p>
    pub fn get_transit_gateway_attachment(&self) -> &::std::option::Option<crate::types::AnalysisComponent> {
        &self.transit_gateway_attachment
    }
    /// <p>The Amazon Web Services account for the component.</p>
    pub fn component_account(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.component_account = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services account for the component.</p>
    pub fn set_component_account(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.component_account = input;
        self
    }
    /// <p>The Amazon Web Services account for the component.</p>
    pub fn get_component_account(&self) -> &::std::option::Option<::std::string::String> {
        &self.component_account
    }
    /// <p>The Region for the component.</p>
    pub fn component_region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.component_region = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Region for the component.</p>
    pub fn set_component_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.component_region = input;
        self
    }
    /// <p>The Region for the component.</p>
    pub fn get_component_region(&self) -> &::std::option::Option<::std::string::String> {
        &self.component_region
    }
    /// <p>The Network Firewall stateless rule.</p>
    pub fn firewall_stateless_rule(mut self, input: crate::types::FirewallStatelessRule) -> Self {
        self.firewall_stateless_rule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Network Firewall stateless rule.</p>
    pub fn set_firewall_stateless_rule(mut self, input: ::std::option::Option<crate::types::FirewallStatelessRule>) -> Self {
        self.firewall_stateless_rule = input;
        self
    }
    /// <p>The Network Firewall stateless rule.</p>
    pub fn get_firewall_stateless_rule(&self) -> &::std::option::Option<crate::types::FirewallStatelessRule> {
        &self.firewall_stateless_rule
    }
    /// <p>The Network Firewall stateful rule.</p>
    pub fn firewall_stateful_rule(mut self, input: crate::types::FirewallStatefulRule) -> Self {
        self.firewall_stateful_rule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Network Firewall stateful rule.</p>
    pub fn set_firewall_stateful_rule(mut self, input: ::std::option::Option<crate::types::FirewallStatefulRule>) -> Self {
        self.firewall_stateful_rule = input;
        self
    }
    /// <p>The Network Firewall stateful rule.</p>
    pub fn get_firewall_stateful_rule(&self) -> &::std::option::Option<crate::types::FirewallStatefulRule> {
        &self.firewall_stateful_rule
    }
    /// Consumes the builder and constructs a [`Explanation`](crate::types::Explanation).
    pub fn build(self) -> crate::types::Explanation {
        crate::types::Explanation {
            acl: self.acl,
            acl_rule: self.acl_rule,
            address: self.address,
            addresses: self.addresses,
            attached_to: self.attached_to,
            availability_zones: self.availability_zones,
            cidrs: self.cidrs,
            component: self.component,
            customer_gateway: self.customer_gateway,
            destination: self.destination,
            destination_vpc: self.destination_vpc,
            direction: self.direction,
            explanation_code: self.explanation_code,
            ingress_route_table: self.ingress_route_table,
            internet_gateway: self.internet_gateway,
            load_balancer_arn: self.load_balancer_arn,
            classic_load_balancer_listener: self.classic_load_balancer_listener,
            load_balancer_listener_port: self.load_balancer_listener_port,
            load_balancer_target: self.load_balancer_target,
            load_balancer_target_group: self.load_balancer_target_group,
            load_balancer_target_groups: self.load_balancer_target_groups,
            load_balancer_target_port: self.load_balancer_target_port,
            elastic_load_balancer_listener: self.elastic_load_balancer_listener,
            missing_component: self.missing_component,
            nat_gateway: self.nat_gateway,
            network_interface: self.network_interface,
            packet_field: self.packet_field,
            vpc_peering_connection: self.vpc_peering_connection,
            port: self.port,
            port_ranges: self.port_ranges,
            prefix_list: self.prefix_list,
            protocols: self.protocols,
            route_table_route: self.route_table_route,
            route_table: self.route_table,
            security_group: self.security_group,
            security_group_rule: self.security_group_rule,
            security_groups: self.security_groups,
            source_vpc: self.source_vpc,
            state: self.state,
            subnet: self.subnet,
            subnet_route_table: self.subnet_route_table,
            vpc: self.vpc,
            vpc_endpoint: self.vpc_endpoint,
            vpn_connection: self.vpn_connection,
            vpn_gateway: self.vpn_gateway,
            transit_gateway: self.transit_gateway,
            transit_gateway_route_table: self.transit_gateway_route_table,
            transit_gateway_route_table_route: self.transit_gateway_route_table_route,
            transit_gateway_attachment: self.transit_gateway_attachment,
            component_account: self.component_account,
            component_region: self.component_region,
            firewall_stateless_rule: self.firewall_stateless_rule,
            firewall_stateful_rule: self.firewall_stateful_rule,
        }
    }
}
