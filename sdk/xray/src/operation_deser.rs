// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_traces_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetTracesOutput, crate::error::BatchGetTracesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetTracesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetTracesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::BatchGetTracesError { meta: generic, kind: crate::error::BatchGetTracesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetTracesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::BatchGetTracesError { meta: generic, kind: crate::error::BatchGetTracesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetTracesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetTracesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_traces_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetTracesOutput, crate::error::BatchGetTracesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_traces_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_traces(response.body().as_ref(), output).map_err(crate::error::BatchGetTracesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::CreateGroupError { meta: generic, kind: crate::error::CreateGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::CreateGroupError { meta: generic, kind: crate::error::CreateGroupErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_group(response.body().as_ref(), output).map_err(crate::error::CreateGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_sampling_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSamplingRuleOutput, crate::error::CreateSamplingRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateSamplingRuleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateSamplingRuleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::CreateSamplingRuleError { meta: generic, kind: crate::error::CreateSamplingRuleErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RuleLimitExceededException" => crate::error::CreateSamplingRuleError { meta: generic, kind: crate::error::CreateSamplingRuleErrorKind::RuleLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::rule_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_rule_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::CreateSamplingRuleError { meta: generic, kind: crate::error::CreateSamplingRuleErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateSamplingRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_sampling_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSamplingRuleOutput, crate::error::CreateSamplingRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_sampling_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_sampling_rule(response.body().as_ref(), output).map_err(crate::error::CreateSamplingRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::DeleteGroupError { meta: generic, kind: crate::error::DeleteGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::DeleteGroupError { meta: generic, kind: crate::error::DeleteGroupErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidPolicyRevisionIdException" => crate::error::DeleteResourcePolicyError { meta: generic, kind: crate::error::DeleteResourcePolicyErrorKind::InvalidPolicyRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_policy_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteResourcePolicyError { meta: generic, kind: crate::error::DeleteResourcePolicyErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::DeleteResourcePolicyError { meta: generic, kind: crate::error::DeleteResourcePolicyErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteResourcePolicyOutput, crate::error::DeleteResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_sampling_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSamplingRuleOutput, crate::error::DeleteSamplingRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteSamplingRuleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteSamplingRuleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::DeleteSamplingRuleError { meta: generic, kind: crate::error::DeleteSamplingRuleErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::DeleteSamplingRuleError { meta: generic, kind: crate::error::DeleteSamplingRuleErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteSamplingRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_sampling_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSamplingRuleOutput, crate::error::DeleteSamplingRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_sampling_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_sampling_rule(response.body().as_ref(), output).map_err(crate::error::DeleteSamplingRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_encryption_config_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEncryptionConfigOutput, crate::error::GetEncryptionConfigError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetEncryptionConfigError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetEncryptionConfigError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetEncryptionConfigError { meta: generic, kind: crate::error::GetEncryptionConfigErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetEncryptionConfigError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetEncryptionConfigError { meta: generic, kind: crate::error::GetEncryptionConfigErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetEncryptionConfigError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetEncryptionConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_encryption_config_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetEncryptionConfigOutput, crate::error::GetEncryptionConfigError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_encryption_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_encryption_config(response.body().as_ref(), output).map_err(crate::error::GetEncryptionConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetGroupError { meta: generic, kind: crate::error::GetGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetGroupError { meta: generic, kind: crate::error::GetGroupErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_group(response.body().as_ref(), output).map_err(crate::error::GetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupsOutput, crate::error::GetGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetGroupsError { meta: generic, kind: crate::error::GetGroupsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetGroupsError { meta: generic, kind: crate::error::GetGroupsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetGroupsOutput, crate::error::GetGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_groups(response.body().as_ref(), output).map_err(crate::error::GetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightOutput, crate::error::GetInsightError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetInsightError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInsightError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetInsightError { meta: generic, kind: crate::error::GetInsightErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetInsightError { meta: generic, kind: crate::error::GetInsightErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetInsightError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightOutput, crate::error::GetInsightError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_insight_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_insight(response.body().as_ref(), output).map_err(crate::error::GetInsightError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_events_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightEventsOutput, crate::error::GetInsightEventsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetInsightEventsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInsightEventsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetInsightEventsError { meta: generic, kind: crate::error::GetInsightEventsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetInsightEventsError { meta: generic, kind: crate::error::GetInsightEventsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetInsightEventsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_events_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightEventsOutput, crate::error::GetInsightEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_insight_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_insight_events(response.body().as_ref(), output).map_err(crate::error::GetInsightEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_impact_graph_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightImpactGraphOutput, crate::error::GetInsightImpactGraphError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetInsightImpactGraphError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInsightImpactGraphError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetInsightImpactGraphError { meta: generic, kind: crate::error::GetInsightImpactGraphErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightImpactGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetInsightImpactGraphError { meta: generic, kind: crate::error::GetInsightImpactGraphErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightImpactGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetInsightImpactGraphError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_impact_graph_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightImpactGraphOutput, crate::error::GetInsightImpactGraphError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_insight_impact_graph_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_insight_impact_graph(response.body().as_ref(), output).map_err(crate::error::GetInsightImpactGraphError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_summaries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightSummariesOutput, crate::error::GetInsightSummariesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetInsightSummariesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetInsightSummariesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetInsightSummariesError { meta: generic, kind: crate::error::GetInsightSummariesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetInsightSummariesError { meta: generic, kind: crate::error::GetInsightSummariesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInsightSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetInsightSummariesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_insight_summaries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetInsightSummariesOutput, crate::error::GetInsightSummariesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_insight_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_insight_summaries(response.body().as_ref(), output).map_err(crate::error::GetInsightSummariesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingRulesOutput, crate::error::GetSamplingRulesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetSamplingRulesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetSamplingRulesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetSamplingRulesError { meta: generic, kind: crate::error::GetSamplingRulesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetSamplingRulesError { meta: generic, kind: crate::error::GetSamplingRulesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetSamplingRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingRulesOutput, crate::error::GetSamplingRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sampling_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_sampling_rules(response.body().as_ref(), output).map_err(crate::error::GetSamplingRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_statistic_summaries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingStatisticSummariesOutput, crate::error::GetSamplingStatisticSummariesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetSamplingStatisticSummariesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetSamplingStatisticSummariesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetSamplingStatisticSummariesError { meta: generic, kind: crate::error::GetSamplingStatisticSummariesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingStatisticSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetSamplingStatisticSummariesError { meta: generic, kind: crate::error::GetSamplingStatisticSummariesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingStatisticSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetSamplingStatisticSummariesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_statistic_summaries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingStatisticSummariesOutput, crate::error::GetSamplingStatisticSummariesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sampling_statistic_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_sampling_statistic_summaries(response.body().as_ref(), output).map_err(crate::error::GetSamplingStatisticSummariesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_targets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingTargetsOutput, crate::error::GetSamplingTargetsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetSamplingTargetsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetSamplingTargetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetSamplingTargetsError { meta: generic, kind: crate::error::GetSamplingTargetsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetSamplingTargetsError { meta: generic, kind: crate::error::GetSamplingTargetsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSamplingTargetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetSamplingTargetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sampling_targets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetSamplingTargetsOutput, crate::error::GetSamplingTargetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sampling_targets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_sampling_targets(response.body().as_ref(), output).map_err(crate::error::GetSamplingTargetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_graph_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetServiceGraphOutput, crate::error::GetServiceGraphError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetServiceGraphError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetServiceGraphError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetServiceGraphError { meta: generic, kind: crate::error::GetServiceGraphErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetServiceGraphError { meta: generic, kind: crate::error::GetServiceGraphErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetServiceGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetServiceGraphError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_service_graph_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetServiceGraphOutput, crate::error::GetServiceGraphError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_service_graph_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_service_graph(response.body().as_ref(), output).map_err(crate::error::GetServiceGraphError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_time_series_service_statistics_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTimeSeriesServiceStatisticsOutput, crate::error::GetTimeSeriesServiceStatisticsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetTimeSeriesServiceStatisticsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetTimeSeriesServiceStatisticsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetTimeSeriesServiceStatisticsError { meta: generic, kind: crate::error::GetTimeSeriesServiceStatisticsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTimeSeriesServiceStatisticsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetTimeSeriesServiceStatisticsError { meta: generic, kind: crate::error::GetTimeSeriesServiceStatisticsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTimeSeriesServiceStatisticsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetTimeSeriesServiceStatisticsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_time_series_service_statistics_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTimeSeriesServiceStatisticsOutput, crate::error::GetTimeSeriesServiceStatisticsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_time_series_service_statistics_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_time_series_service_statistics(response.body().as_ref(), output).map_err(crate::error::GetTimeSeriesServiceStatisticsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_trace_graph_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTraceGraphOutput, crate::error::GetTraceGraphError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetTraceGraphError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetTraceGraphError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetTraceGraphError { meta: generic, kind: crate::error::GetTraceGraphErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTraceGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetTraceGraphError { meta: generic, kind: crate::error::GetTraceGraphErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTraceGraphError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetTraceGraphError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_trace_graph_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTraceGraphOutput, crate::error::GetTraceGraphError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_trace_graph_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_trace_graph(response.body().as_ref(), output).map_err(crate::error::GetTraceGraphError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_trace_summaries_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTraceSummariesOutput, crate::error::GetTraceSummariesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetTraceSummariesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetTraceSummariesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::GetTraceSummariesError { meta: generic, kind: crate::error::GetTraceSummariesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTraceSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::GetTraceSummariesError { meta: generic, kind: crate::error::GetTraceSummariesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTraceSummariesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetTraceSummariesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_trace_summaries_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetTraceSummariesOutput, crate::error::GetTraceSummariesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_trace_summaries_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_trace_summaries(response.body().as_ref(), output).map_err(crate::error::GetTraceSummariesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_policies_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourcePoliciesOutput, crate::error::ListResourcePoliciesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListResourcePoliciesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListResourcePoliciesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::ListResourcePoliciesError { meta: generic, kind: crate::error::ListResourcePoliciesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourcePoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::ListResourcePoliciesError { meta: generic, kind: crate::error::ListResourcePoliciesErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListResourcePoliciesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListResourcePoliciesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_resource_policies_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListResourcePoliciesOutput, crate::error::ListResourcePoliciesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_resource_policies_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_resource_policies(response.body().as_ref(), output).map_err(crate::error::ListResourcePoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListTagsForResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_encryption_config_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutEncryptionConfigOutput, crate::error::PutEncryptionConfigError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutEncryptionConfigError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutEncryptionConfigError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::PutEncryptionConfigError { meta: generic, kind: crate::error::PutEncryptionConfigErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutEncryptionConfigError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::PutEncryptionConfigError { meta: generic, kind: crate::error::PutEncryptionConfigErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutEncryptionConfigError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutEncryptionConfigError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_encryption_config_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutEncryptionConfigOutput, crate::error::PutEncryptionConfigError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_encryption_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_encryption_config(response.body().as_ref(), output).map_err(crate::error::PutEncryptionConfigError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutResourcePolicyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutResourcePolicyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidPolicyRevisionIdException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::InvalidPolicyRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_policy_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_policy_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LockoutPreventionException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::LockoutPreventionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::lockout_prevention_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_lockout_prevention_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MalformedPolicyDocumentException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::MalformedPolicyDocumentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::malformed_policy_document_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_malformed_policy_document_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PolicyCountLimitExceededException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::PolicyCountLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::policy_count_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_policy_count_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PolicySizeLimitExceededException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::PolicySizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::policy_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_policy_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::PutResourcePolicyError { meta: generic, kind: crate::error::PutResourcePolicyErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutResourcePolicyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_resource_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutResourcePolicyOutput, crate::error::PutResourcePolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_resource_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_resource_policy(response.body().as_ref(), output).map_err(crate::error::PutResourcePolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_telemetry_records_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutTelemetryRecordsOutput, crate::error::PutTelemetryRecordsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutTelemetryRecordsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutTelemetryRecordsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::PutTelemetryRecordsError { meta: generic, kind: crate::error::PutTelemetryRecordsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutTelemetryRecordsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::PutTelemetryRecordsError { meta: generic, kind: crate::error::PutTelemetryRecordsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutTelemetryRecordsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutTelemetryRecordsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_telemetry_records_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutTelemetryRecordsOutput, crate::error::PutTelemetryRecordsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_telemetry_records_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_trace_segments_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutTraceSegmentsOutput, crate::error::PutTraceSegmentsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutTraceSegmentsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutTraceSegmentsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::PutTraceSegmentsError { meta: generic, kind: crate::error::PutTraceSegmentsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutTraceSegmentsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::PutTraceSegmentsError { meta: generic, kind: crate::error::PutTraceSegmentsErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutTraceSegmentsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutTraceSegmentsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_trace_segments_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutTraceSegmentsOutput, crate::error::PutTraceSegmentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_trace_segments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_trace_segments(response.body().as_ref(), output).map_err(crate::error::PutTraceSegmentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TooManyTagsException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UntagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceNotFoundException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UntagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateGroupError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateGroupError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::UpdateGroupError { meta: generic, kind: crate::error::UpdateGroupErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::UpdateGroupError { meta: generic, kind: crate::error::UpdateGroupErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_group_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_group(response.body().as_ref(), output).map_err(crate::error::UpdateGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_sampling_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSamplingRuleOutput, crate::error::UpdateSamplingRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateSamplingRuleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateSamplingRuleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRequestException" => crate::error::UpdateSamplingRuleError { meta: generic, kind: crate::error::UpdateSamplingRuleErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ThrottledException" => crate::error::UpdateSamplingRuleError { meta: generic, kind: crate::error::UpdateSamplingRuleErrorKind::ThrottledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateSamplingRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateSamplingRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_sampling_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateSamplingRuleOutput, crate::error::UpdateSamplingRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_sampling_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_sampling_rule(response.body().as_ref(), output).map_err(crate::error::UpdateSamplingRuleError::unhandled)?;
        output.build()
    })
}

