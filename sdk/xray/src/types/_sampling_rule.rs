// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A sampling rule that services use to decide whether to instrument a request. Rule fields can match properties of the service, or properties of a request. The service can ignore rules that don't match its properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SamplingRule {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    #[doc(hidden)]
    pub rule_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    #[doc(hidden)]
    pub rule_arn: std::option::Option<std::string::String>,
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The priority of the sampling rule.</p>
    #[doc(hidden)]
    pub priority: i32,
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    #[doc(hidden)]
    pub fixed_rate: f64,
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    #[doc(hidden)]
    pub reservoir_size: i32,
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    #[doc(hidden)]
    pub service_name: std::option::Option<std::string::String>,
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    #[doc(hidden)]
    pub service_type: std::option::Option<std::string::String>,
    /// <p>Matches the hostname from a request URL.</p>
    #[doc(hidden)]
    pub host: std::option::Option<std::string::String>,
    /// <p>Matches the HTTP method of a request.</p>
    #[doc(hidden)]
    pub http_method: std::option::Option<std::string::String>,
    /// <p>Matches the path from a request URL.</p>
    #[doc(hidden)]
    pub url_path: std::option::Option<std::string::String>,
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    #[doc(hidden)]
    pub version: i32,
    /// <p>Matches attributes derived from the request.</p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SamplingRule {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_name(&self) -> std::option::Option<&str> {
        self.rule_name.as_deref()
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_arn(&self) -> std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn fixed_rate(&self) -> f64 {
        self.fixed_rate
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn reservoir_size(&self) -> i32 {
        self.reservoir_size
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn service_type(&self) -> std::option::Option<&str> {
        self.service_type.as_deref()
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn host(&self) -> std::option::Option<&str> {
        self.host.as_deref()
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn http_method(&self) -> std::option::Option<&str> {
        self.http_method.as_deref()
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn url_path(&self) -> std::option::Option<&str> {
        self.url_path.as_deref()
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn version(&self) -> i32 {
        self.version
    }
    /// <p>Matches attributes derived from the request.</p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
}
impl SamplingRule {
    /// Creates a new builder-style object to manufacture [`SamplingRule`](crate::types::SamplingRule).
    pub fn builder() -> crate::types::builders::SamplingRuleBuilder {
        crate::types::builders::SamplingRuleBuilder::default()
    }
}

/// A builder for [`SamplingRule`](crate::types::SamplingRule).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct SamplingRuleBuilder {
    pub(crate) rule_name: std::option::Option<std::string::String>,
    pub(crate) rule_arn: std::option::Option<std::string::String>,
    pub(crate) resource_arn: std::option::Option<std::string::String>,
    pub(crate) priority: std::option::Option<i32>,
    pub(crate) fixed_rate: std::option::Option<f64>,
    pub(crate) reservoir_size: std::option::Option<i32>,
    pub(crate) service_name: std::option::Option<std::string::String>,
    pub(crate) service_type: std::option::Option<std::string::String>,
    pub(crate) host: std::option::Option<std::string::String>,
    pub(crate) http_method: std::option::Option<std::string::String>,
    pub(crate) url_path: std::option::Option<std::string::String>,
    pub(crate) version: std::option::Option<i32>,
    pub(crate) attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl SamplingRuleBuilder {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.rule_name = Some(input.into());
        self
    }
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.rule_name = input;
        self
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.rule_arn = Some(input.into());
        self
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.rule_arn = input;
        self
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.resource_arn = Some(input.into());
        self
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.resource_arn = input;
        self
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = Some(input);
        self
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn fixed_rate(mut self, input: f64) -> Self {
        self.fixed_rate = Some(input);
        self
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn set_fixed_rate(mut self, input: std::option::Option<f64>) -> Self {
        self.fixed_rate = input;
        self
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn reservoir_size(mut self, input: i32) -> Self {
        self.reservoir_size = Some(input);
        self
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn set_reservoir_size(mut self, input: std::option::Option<i32>) -> Self {
        self.reservoir_size = input;
        self
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_name = Some(input.into());
        self
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_name = input;
        self
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn service_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_type = Some(input.into());
        self
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn set_service_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_type = input;
        self
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn host(mut self, input: impl Into<std::string::String>) -> Self {
        self.host = Some(input.into());
        self
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn set_host(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.host = input;
        self
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn http_method(mut self, input: impl Into<std::string::String>) -> Self {
        self.http_method = Some(input.into());
        self
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn set_http_method(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.http_method = input;
        self
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn url_path(mut self, input: impl Into<std::string::String>) -> Self {
        self.url_path = Some(input.into());
        self
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn set_url_path(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.url_path = input;
        self
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn version(mut self, input: i32) -> Self {
        self.version = Some(input);
        self
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
        self.version = input;
        self
    }
    /// Adds a key-value pair to `attributes`.
    ///
    /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
    ///
    /// <p>Matches attributes derived from the request.</p>
    pub fn attributes(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.attributes.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.attributes = Some(hash_map);
        self
    }
    /// <p>Matches attributes derived from the request.</p>
    pub fn set_attributes(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.attributes = input;
        self
    }
    /// Consumes the builder and constructs a [`SamplingRule`](crate::types::SamplingRule).
    pub fn build(self) -> crate::types::SamplingRule {
        crate::types::SamplingRule {
            rule_name: self.rule_name,
            rule_arn: self.rule_arn,
            resource_arn: self.resource_arn,
            priority: self.priority.unwrap_or_default(),
            fixed_rate: self.fixed_rate.unwrap_or_default(),
            reservoir_size: self.reservoir_size.unwrap_or_default(),
            service_name: self.service_name,
            service_type: self.service_type,
            host: self.host,
            http_method: self.http_method,
            url_path: self.url_path,
            version: self.version.unwrap_or_default(),
            attributes: self.attributes,
        }
    }
}
