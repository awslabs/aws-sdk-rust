// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A sampling rule that services use to decide whether to instrument a request. Rule fields can match properties of the service, or properties of a request. The service can ignore rules that don't match its properties.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SamplingRule {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub rule_name: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub rule_arn: ::std::option::Option<::std::string::String>,
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub resource_arn: ::std::string::String,
    /// <p>The priority of the sampling rule.</p>
    pub priority: i32,
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fixed_rate: f64,
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub reservoir_size: i32,
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub service_name: ::std::string::String,
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub service_type: ::std::string::String,
    /// <p>Matches the hostname from a request URL.</p>
    pub host: ::std::string::String,
    /// <p>Matches the HTTP method of a request.</p>
    pub http_method: ::std::string::String,
    /// <p>Matches the path from a request URL.</p>
    pub url_path: ::std::string::String,
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub version: i32,
    /// <p>Matches attributes derived from the request.</p>
    pub attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl SamplingRule {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_name(&self) -> ::std::option::Option<&str> {
        self.rule_name.as_deref()
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_arn(&self) -> ::std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn resource_arn(&self) -> &str {
        use std::ops::Deref;
        self.resource_arn.deref()
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn fixed_rate(&self) -> f64 {
        self.fixed_rate
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn reservoir_size(&self) -> i32 {
        self.reservoir_size
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn service_name(&self) -> &str {
        use std::ops::Deref;
        self.service_name.deref()
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn service_type(&self) -> &str {
        use std::ops::Deref;
        self.service_type.deref()
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn host(&self) -> &str {
        use std::ops::Deref;
        self.host.deref()
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn http_method(&self) -> &str {
        use std::ops::Deref;
        self.http_method.deref()
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn url_path(&self) -> &str {
        use std::ops::Deref;
        self.url_path.deref()
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn version(&self) -> i32 {
        self.version
    }
    /// <p>Matches attributes derived from the request.</p>
    pub fn attributes(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.attributes.as_ref()
    }
}
impl SamplingRule {
    /// Creates a new builder-style object to manufacture [`SamplingRule`](crate::types::SamplingRule).
    pub fn builder() -> crate::types::builders::SamplingRuleBuilder {
        crate::types::builders::SamplingRuleBuilder::default()
    }
}

/// A builder for [`SamplingRule`](crate::types::SamplingRule).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct SamplingRuleBuilder {
    pub(crate) rule_name: ::std::option::Option<::std::string::String>,
    pub(crate) rule_arn: ::std::option::Option<::std::string::String>,
    pub(crate) resource_arn: ::std::option::Option<::std::string::String>,
    pub(crate) priority: ::std::option::Option<i32>,
    pub(crate) fixed_rate: ::std::option::Option<f64>,
    pub(crate) reservoir_size: ::std::option::Option<i32>,
    pub(crate) service_name: ::std::option::Option<::std::string::String>,
    pub(crate) service_type: ::std::option::Option<::std::string::String>,
    pub(crate) host: ::std::option::Option<::std::string::String>,
    pub(crate) http_method: ::std::option::Option<::std::string::String>,
    pub(crate) url_path: ::std::option::Option<::std::string::String>,
    pub(crate) version: ::std::option::Option<i32>,
    pub(crate) attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl SamplingRuleBuilder {
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.rule_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn set_rule_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.rule_name = input;
        self
    }
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn get_rule_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.rule_name
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn rule_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.rule_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn set_rule_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.rule_arn = input;
        self
    }
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    pub fn get_rule_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.rule_arn
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    /// This field is required.
    pub fn resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resource_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn set_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resource_arn = input;
        self
    }
    /// <p>Matches the ARN of the Amazon Web Services resource on which the service runs.</p>
    pub fn get_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.resource_arn
    }
    /// <p>The priority of the sampling rule.</p>
    /// This field is required.
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>The priority of the sampling rule.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        &self.priority
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    /// This field is required.
    pub fn fixed_rate(mut self, input: f64) -> Self {
        self.fixed_rate = ::std::option::Option::Some(input);
        self
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn set_fixed_rate(mut self, input: ::std::option::Option<f64>) -> Self {
        self.fixed_rate = input;
        self
    }
    /// <p>The percentage of matching requests to instrument, after the reservoir is exhausted.</p>
    pub fn get_fixed_rate(&self) -> &::std::option::Option<f64> {
        &self.fixed_rate
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    /// This field is required.
    pub fn reservoir_size(mut self, input: i32) -> Self {
        self.reservoir_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn set_reservoir_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.reservoir_size = input;
        self
    }
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    pub fn get_reservoir_size(&self) -> &::std::option::Option<i32> {
        &self.reservoir_size
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    /// This field is required.
    pub fn service_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn set_service_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_name = input;
        self
    }
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    pub fn get_service_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_name
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    /// This field is required.
    pub fn service_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn set_service_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_type = input;
        self
    }
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    pub fn get_service_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_type
    }
    /// <p>Matches the hostname from a request URL.</p>
    /// This field is required.
    pub fn host(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.host = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn set_host(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.host = input;
        self
    }
    /// <p>Matches the hostname from a request URL.</p>
    pub fn get_host(&self) -> &::std::option::Option<::std::string::String> {
        &self.host
    }
    /// <p>Matches the HTTP method of a request.</p>
    /// This field is required.
    pub fn http_method(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.http_method = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn set_http_method(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.http_method = input;
        self
    }
    /// <p>Matches the HTTP method of a request.</p>
    pub fn get_http_method(&self) -> &::std::option::Option<::std::string::String> {
        &self.http_method
    }
    /// <p>Matches the path from a request URL.</p>
    /// This field is required.
    pub fn url_path(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.url_path = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn set_url_path(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.url_path = input;
        self
    }
    /// <p>Matches the path from a request URL.</p>
    pub fn get_url_path(&self) -> &::std::option::Option<::std::string::String> {
        &self.url_path
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    /// This field is required.
    pub fn version(mut self, input: i32) -> Self {
        self.version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn set_version(mut self, input: ::std::option::Option<i32>) -> Self {
        self.version = input;
        self
    }
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    pub fn get_version(&self) -> &::std::option::Option<i32> {
        &self.version
    }
    /// Adds a key-value pair to `attributes`.
    ///
    /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
    ///
    /// <p>Matches attributes derived from the request.</p>
    pub fn attributes(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.attributes.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.attributes = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Matches attributes derived from the request.</p>
    pub fn set_attributes(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.attributes = input;
        self
    }
    /// <p>Matches attributes derived from the request.</p>
    pub fn get_attributes(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.attributes
    }
    /// Consumes the builder and constructs a [`SamplingRule`](crate::types::SamplingRule).
    /// This method will fail if any of the following fields are not set:
    /// - [`resource_arn`](crate::types::builders::SamplingRuleBuilder::resource_arn)
    /// - [`priority`](crate::types::builders::SamplingRuleBuilder::priority)
    /// - [`service_name`](crate::types::builders::SamplingRuleBuilder::service_name)
    /// - [`service_type`](crate::types::builders::SamplingRuleBuilder::service_type)
    /// - [`host`](crate::types::builders::SamplingRuleBuilder::host)
    /// - [`http_method`](crate::types::builders::SamplingRuleBuilder::http_method)
    /// - [`url_path`](crate::types::builders::SamplingRuleBuilder::url_path)
    /// - [`version`](crate::types::builders::SamplingRuleBuilder::version)
    pub fn build(self) -> ::std::result::Result<crate::types::SamplingRule, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::SamplingRule {
            rule_name: self.rule_name,
            rule_arn: self.rule_arn,
            resource_arn: self.resource_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "resource_arn",
                    "resource_arn was not specified but it is required when building SamplingRule",
                )
            })?,
            priority: self.priority.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "priority",
                    "priority was not specified but it is required when building SamplingRule",
                )
            })?,
            fixed_rate: self.fixed_rate.unwrap_or_default(),
            reservoir_size: self.reservoir_size.unwrap_or_default(),
            service_name: self.service_name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "service_name",
                    "service_name was not specified but it is required when building SamplingRule",
                )
            })?,
            service_type: self.service_type.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "service_type",
                    "service_type was not specified but it is required when building SamplingRule",
                )
            })?,
            host: self.host.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "host",
                    "host was not specified but it is required when building SamplingRule",
                )
            })?,
            http_method: self.http_method.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "http_method",
                    "http_method was not specified but it is required when building SamplingRule",
                )
            })?,
            url_path: self.url_path.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "url_path",
                    "url_path was not specified but it is required when building SamplingRule",
                )
            })?,
            version: self.version.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "version",
                    "version was not specified but it is required when building SamplingRule",
                )
            })?,
            attributes: self.attributes,
        })
    }
}
