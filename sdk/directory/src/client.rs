// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `DirectoryService_20150416`.
///
/// This client allows ergonomic access to a `DirectoryService_20150416`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn accept_shared_directory(&self) -> fluent_builders::AcceptSharedDirectory<C, M, R> {
        fluent_builders::AcceptSharedDirectory::new(self.handle.clone())
    }
    pub fn add_ip_routes(&self) -> fluent_builders::AddIpRoutes<C, M, R> {
        fluent_builders::AddIpRoutes::new(self.handle.clone())
    }
    pub fn add_region(&self) -> fluent_builders::AddRegion<C, M, R> {
        fluent_builders::AddRegion::new(self.handle.clone())
    }
    pub fn add_tags_to_resource(&self) -> fluent_builders::AddTagsToResource<C, M, R> {
        fluent_builders::AddTagsToResource::new(self.handle.clone())
    }
    pub fn cancel_schema_extension(&self) -> fluent_builders::CancelSchemaExtension<C, M, R> {
        fluent_builders::CancelSchemaExtension::new(self.handle.clone())
    }
    pub fn connect_directory(&self) -> fluent_builders::ConnectDirectory<C, M, R> {
        fluent_builders::ConnectDirectory::new(self.handle.clone())
    }
    pub fn create_alias(&self) -> fluent_builders::CreateAlias<C, M, R> {
        fluent_builders::CreateAlias::new(self.handle.clone())
    }
    pub fn create_computer(&self) -> fluent_builders::CreateComputer<C, M, R> {
        fluent_builders::CreateComputer::new(self.handle.clone())
    }
    pub fn create_conditional_forwarder(
        &self,
    ) -> fluent_builders::CreateConditionalForwarder<C, M, R> {
        fluent_builders::CreateConditionalForwarder::new(self.handle.clone())
    }
    pub fn create_directory(&self) -> fluent_builders::CreateDirectory<C, M, R> {
        fluent_builders::CreateDirectory::new(self.handle.clone())
    }
    pub fn create_log_subscription(&self) -> fluent_builders::CreateLogSubscription<C, M, R> {
        fluent_builders::CreateLogSubscription::new(self.handle.clone())
    }
    pub fn create_microsoft_ad(&self) -> fluent_builders::CreateMicrosoftAD<C, M, R> {
        fluent_builders::CreateMicrosoftAD::new(self.handle.clone())
    }
    pub fn create_snapshot(&self) -> fluent_builders::CreateSnapshot<C, M, R> {
        fluent_builders::CreateSnapshot::new(self.handle.clone())
    }
    pub fn create_trust(&self) -> fluent_builders::CreateTrust<C, M, R> {
        fluent_builders::CreateTrust::new(self.handle.clone())
    }
    pub fn delete_conditional_forwarder(
        &self,
    ) -> fluent_builders::DeleteConditionalForwarder<C, M, R> {
        fluent_builders::DeleteConditionalForwarder::new(self.handle.clone())
    }
    pub fn delete_directory(&self) -> fluent_builders::DeleteDirectory<C, M, R> {
        fluent_builders::DeleteDirectory::new(self.handle.clone())
    }
    pub fn delete_log_subscription(&self) -> fluent_builders::DeleteLogSubscription<C, M, R> {
        fluent_builders::DeleteLogSubscription::new(self.handle.clone())
    }
    pub fn delete_snapshot(&self) -> fluent_builders::DeleteSnapshot<C, M, R> {
        fluent_builders::DeleteSnapshot::new(self.handle.clone())
    }
    pub fn delete_trust(&self) -> fluent_builders::DeleteTrust<C, M, R> {
        fluent_builders::DeleteTrust::new(self.handle.clone())
    }
    pub fn deregister_certificate(&self) -> fluent_builders::DeregisterCertificate<C, M, R> {
        fluent_builders::DeregisterCertificate::new(self.handle.clone())
    }
    pub fn deregister_event_topic(&self) -> fluent_builders::DeregisterEventTopic<C, M, R> {
        fluent_builders::DeregisterEventTopic::new(self.handle.clone())
    }
    pub fn describe_certificate(&self) -> fluent_builders::DescribeCertificate<C, M, R> {
        fluent_builders::DescribeCertificate::new(self.handle.clone())
    }
    pub fn describe_client_authentication_settings(
        &self,
    ) -> fluent_builders::DescribeClientAuthenticationSettings<C, M, R> {
        fluent_builders::DescribeClientAuthenticationSettings::new(self.handle.clone())
    }
    pub fn describe_conditional_forwarders(
        &self,
    ) -> fluent_builders::DescribeConditionalForwarders<C, M, R> {
        fluent_builders::DescribeConditionalForwarders::new(self.handle.clone())
    }
    pub fn describe_directories(&self) -> fluent_builders::DescribeDirectories<C, M, R> {
        fluent_builders::DescribeDirectories::new(self.handle.clone())
    }
    pub fn describe_domain_controllers(
        &self,
    ) -> fluent_builders::DescribeDomainControllers<C, M, R> {
        fluent_builders::DescribeDomainControllers::new(self.handle.clone())
    }
    pub fn describe_event_topics(&self) -> fluent_builders::DescribeEventTopics<C, M, R> {
        fluent_builders::DescribeEventTopics::new(self.handle.clone())
    }
    pub fn describe_ldaps_settings(&self) -> fluent_builders::DescribeLDAPSSettings<C, M, R> {
        fluent_builders::DescribeLDAPSSettings::new(self.handle.clone())
    }
    pub fn describe_regions(&self) -> fluent_builders::DescribeRegions<C, M, R> {
        fluent_builders::DescribeRegions::new(self.handle.clone())
    }
    pub fn describe_shared_directories(
        &self,
    ) -> fluent_builders::DescribeSharedDirectories<C, M, R> {
        fluent_builders::DescribeSharedDirectories::new(self.handle.clone())
    }
    pub fn describe_snapshots(&self) -> fluent_builders::DescribeSnapshots<C, M, R> {
        fluent_builders::DescribeSnapshots::new(self.handle.clone())
    }
    pub fn describe_trusts(&self) -> fluent_builders::DescribeTrusts<C, M, R> {
        fluent_builders::DescribeTrusts::new(self.handle.clone())
    }
    pub fn disable_client_authentication(
        &self,
    ) -> fluent_builders::DisableClientAuthentication<C, M, R> {
        fluent_builders::DisableClientAuthentication::new(self.handle.clone())
    }
    pub fn disable_ldaps(&self) -> fluent_builders::DisableLDAPS<C, M, R> {
        fluent_builders::DisableLDAPS::new(self.handle.clone())
    }
    pub fn disable_radius(&self) -> fluent_builders::DisableRadius<C, M, R> {
        fluent_builders::DisableRadius::new(self.handle.clone())
    }
    pub fn disable_sso(&self) -> fluent_builders::DisableSso<C, M, R> {
        fluent_builders::DisableSso::new(self.handle.clone())
    }
    pub fn enable_client_authentication(
        &self,
    ) -> fluent_builders::EnableClientAuthentication<C, M, R> {
        fluent_builders::EnableClientAuthentication::new(self.handle.clone())
    }
    pub fn enable_ldaps(&self) -> fluent_builders::EnableLDAPS<C, M, R> {
        fluent_builders::EnableLDAPS::new(self.handle.clone())
    }
    pub fn enable_radius(&self) -> fluent_builders::EnableRadius<C, M, R> {
        fluent_builders::EnableRadius::new(self.handle.clone())
    }
    pub fn enable_sso(&self) -> fluent_builders::EnableSso<C, M, R> {
        fluent_builders::EnableSso::new(self.handle.clone())
    }
    pub fn get_directory_limits(&self) -> fluent_builders::GetDirectoryLimits<C, M, R> {
        fluent_builders::GetDirectoryLimits::new(self.handle.clone())
    }
    pub fn get_snapshot_limits(&self) -> fluent_builders::GetSnapshotLimits<C, M, R> {
        fluent_builders::GetSnapshotLimits::new(self.handle.clone())
    }
    pub fn list_certificates(&self) -> fluent_builders::ListCertificates<C, M, R> {
        fluent_builders::ListCertificates::new(self.handle.clone())
    }
    pub fn list_ip_routes(&self) -> fluent_builders::ListIpRoutes<C, M, R> {
        fluent_builders::ListIpRoutes::new(self.handle.clone())
    }
    pub fn list_log_subscriptions(&self) -> fluent_builders::ListLogSubscriptions<C, M, R> {
        fluent_builders::ListLogSubscriptions::new(self.handle.clone())
    }
    pub fn list_schema_extensions(&self) -> fluent_builders::ListSchemaExtensions<C, M, R> {
        fluent_builders::ListSchemaExtensions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn register_certificate(&self) -> fluent_builders::RegisterCertificate<C, M, R> {
        fluent_builders::RegisterCertificate::new(self.handle.clone())
    }
    pub fn register_event_topic(&self) -> fluent_builders::RegisterEventTopic<C, M, R> {
        fluent_builders::RegisterEventTopic::new(self.handle.clone())
    }
    pub fn reject_shared_directory(&self) -> fluent_builders::RejectSharedDirectory<C, M, R> {
        fluent_builders::RejectSharedDirectory::new(self.handle.clone())
    }
    pub fn remove_ip_routes(&self) -> fluent_builders::RemoveIpRoutes<C, M, R> {
        fluent_builders::RemoveIpRoutes::new(self.handle.clone())
    }
    pub fn remove_region(&self) -> fluent_builders::RemoveRegion<C, M, R> {
        fluent_builders::RemoveRegion::new(self.handle.clone())
    }
    pub fn remove_tags_from_resource(&self) -> fluent_builders::RemoveTagsFromResource<C, M, R> {
        fluent_builders::RemoveTagsFromResource::new(self.handle.clone())
    }
    pub fn reset_user_password(&self) -> fluent_builders::ResetUserPassword<C, M, R> {
        fluent_builders::ResetUserPassword::new(self.handle.clone())
    }
    pub fn restore_from_snapshot(&self) -> fluent_builders::RestoreFromSnapshot<C, M, R> {
        fluent_builders::RestoreFromSnapshot::new(self.handle.clone())
    }
    pub fn share_directory(&self) -> fluent_builders::ShareDirectory<C, M, R> {
        fluent_builders::ShareDirectory::new(self.handle.clone())
    }
    pub fn start_schema_extension(&self) -> fluent_builders::StartSchemaExtension<C, M, R> {
        fluent_builders::StartSchemaExtension::new(self.handle.clone())
    }
    pub fn unshare_directory(&self) -> fluent_builders::UnshareDirectory<C, M, R> {
        fluent_builders::UnshareDirectory::new(self.handle.clone())
    }
    pub fn update_conditional_forwarder(
        &self,
    ) -> fluent_builders::UpdateConditionalForwarder<C, M, R> {
        fluent_builders::UpdateConditionalForwarder::new(self.handle.clone())
    }
    pub fn update_number_of_domain_controllers(
        &self,
    ) -> fluent_builders::UpdateNumberOfDomainControllers<C, M, R> {
        fluent_builders::UpdateNumberOfDomainControllers::new(self.handle.clone())
    }
    pub fn update_radius(&self) -> fluent_builders::UpdateRadius<C, M, R> {
        fluent_builders::UpdateRadius::new(self.handle.clone())
    }
    pub fn update_trust(&self) -> fluent_builders::UpdateTrust<C, M, R> {
        fluent_builders::UpdateTrust::new(self.handle.clone())
    }
    pub fn verify_trust(&self) -> fluent_builders::VerifyTrust<C, M, R> {
        fluent_builders::VerifyTrust::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptSharedDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::accept_shared_directory_input::Builder,
    }
    impl<C, M, R> AcceptSharedDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptSharedDirectoryOutput,
            smithy_http::result::SdkError<crate::error::AcceptSharedDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AcceptSharedDirectoryInputOperationOutputAlias,
                crate::output::AcceptSharedDirectoryOutput,
                crate::error::AcceptSharedDirectoryError,
                crate::input::AcceptSharedDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the shared directory in the directory consumer account. This identifier is
        /// different for each directory owner account. </p>
        pub fn shared_directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shared_directory_id(inp);
            self
        }
        pub fn set_shared_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shared_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddIpRoutes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_ip_routes_input::Builder,
    }
    impl<C, M, R> AddIpRoutes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddIpRoutesOutput,
            smithy_http::result::SdkError<crate::error::AddIpRoutesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddIpRoutesInputOperationOutputAlias,
                crate::output::AddIpRoutesOutput,
                crate::error::AddIpRoutesError,
                crate::input::AddIpRoutesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) of the directory to which to add the address block.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `IpRoutes`.
        ///
        /// To override the contents of this collection use [`set_ip_routes`](Self::set_ip_routes).
        /// <p>IP address blocks, using CIDR format, of the traffic to route. This is often the IP
        /// address block of the DNS server used for your self-managed domain.</p>
        pub fn ip_routes(mut self, inp: impl Into<crate::model::IpRoute>) -> Self {
            self.inner = self.inner.ip_routes(inp);
            self
        }
        pub fn set_ip_routes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpRoute>>,
        ) -> Self {
            self.inner = self.inner.set_ip_routes(input);
            self
        }
        /// <p>If set to true, updates the inbound and outbound rules of the security group that has
        /// the description: "Amazon Web Services created security group for <i>directory ID</i>
        /// directory controllers." Following are the new rules: </p>
        /// <p>Inbound:</p>
        /// <ul>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 88, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 123, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 138, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 389, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 464, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom UDP Rule, Protocol: UDP, Range: 445, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 88, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 135, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 445, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 464, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 636, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 1024-65535, Source:
        /// 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: Custom TCP Rule, Protocol: TCP, Range: 3268-33269, Source:
        /// 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: DNS (UDP), Protocol: UDP, Range: 53, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: DNS (TCP), Protocol: TCP, Range: 53, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: LDAP, Protocol: TCP, Range: 389, Source: 0.0.0.0/0</p>
        /// </li>
        /// <li>
        /// <p>Type: All ICMP, Protocol: All, Range: N/A, Source: 0.0.0.0/0</p>
        /// </li>
        /// </ul>
        /// <p></p>
        /// <p>Outbound:</p>
        /// <ul>
        /// <li>
        /// <p>Type: All traffic, Protocol: All, Range: All, Destination: 0.0.0.0/0</p>
        /// </li>
        /// </ul>
        /// <p>These security rules impact an internal network interface that is not exposed
        /// publicly.</p>
        pub fn update_security_group_for_directory_controllers(mut self, inp: bool) -> Self {
            self.inner = self
                .inner
                .update_security_group_for_directory_controllers(inp);
            self
        }
        pub fn set_update_security_group_for_directory_controllers(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self
                .inner
                .set_update_security_group_for_directory_controllers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddRegion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_region_input::Builder,
    }
    impl<C, M, R> AddRegion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddRegionOutput,
            smithy_http::result::SdkError<crate::error::AddRegionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddRegionInputOperationOutputAlias,
                crate::output::AddRegionOutput,
                crate::error::AddRegionError,
                crate::input::AddRegionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory to which you want to add Region replication.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The name of the Region where you want to add domain controllers for replication. For
        /// example, <code>us-east-1</code>.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.region_name(inp);
            self
        }
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_region_name(input);
            self
        }
        /// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
        pub fn vpc_settings(mut self, inp: crate::model::DirectoryVpcSettings) -> Self {
            self.inner = self.inner.vpc_settings(inp);
            self
        }
        pub fn set_vpc_settings(
            mut self,
            input: std::option::Option<crate::model::DirectoryVpcSettings>,
        ) -> Self {
            self.inner = self.inner.set_vpc_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_tags_to_resource_input::Builder,
    }
    impl<C, M, R> AddTagsToResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToResourceOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddTagsToResourceInputOperationOutputAlias,
                crate::output::AddTagsToResourceOutput,
                crate::error::AddTagsToResourceError,
                crate::input::AddTagsToResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) for the directory to which to add the tag.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to be assigned to the directory.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelSchemaExtension<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_schema_extension_input::Builder,
    }
    impl<C, M, R> CancelSchemaExtension<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelSchemaExtensionOutput,
            smithy_http::result::SdkError<crate::error::CancelSchemaExtensionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelSchemaExtensionInputOperationOutputAlias,
                crate::output::CancelSchemaExtensionOutput,
                crate::error::CancelSchemaExtensionError,
                crate::input::CancelSchemaExtensionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory whose schema extension will be canceled.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The identifier of the schema extension that will be canceled.</p>
        pub fn schema_extension_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.schema_extension_id(inp);
            self
        }
        pub fn set_schema_extension_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_schema_extension_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConnectDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::connect_directory_input::Builder,
    }
    impl<C, M, R> ConnectDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConnectDirectoryOutput,
            smithy_http::result::SdkError<crate::error::ConnectDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ConnectDirectoryInputOperationOutputAlias,
                crate::output::ConnectDirectoryOutput,
                crate::error::ConnectDirectoryError,
                crate::input::ConnectDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The fully qualified name of your self-managed directory, such as
        /// <code>corp.example.com</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The NetBIOS name of your self-managed directory, such as <code>CORP</code>.</p>
        pub fn short_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.short_name(inp);
            self
        }
        pub fn set_short_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_short_name(input);
            self
        }
        /// <p>The password for your self-managed user account.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>A description for the directory.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The size of the directory.</p>
        pub fn size(mut self, inp: crate::model::DirectorySize) -> Self {
            self.inner = self.inner.size(inp);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<crate::model::DirectorySize>) -> Self {
            self.inner = self.inner.set_size(input);
            self
        }
        /// <p>A <a>DirectoryConnectSettings</a> object that contains additional information
        /// for the operation.</p>
        pub fn connect_settings(mut self, inp: crate::model::DirectoryConnectSettings) -> Self {
            self.inner = self.inner.connect_settings(inp);
            self
        }
        pub fn set_connect_settings(
            mut self,
            input: std::option::Option<crate::model::DirectoryConnectSettings>,
        ) -> Self {
            self.inner = self.inner.set_connect_settings(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to be assigned to AD Connector.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAlias<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_alias_input::Builder,
    }
    impl<C, M, R> CreateAlias<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAliasOutput,
            smithy_http::result::SdkError<crate::error::CreateAliasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAliasInputOperationOutputAlias,
                crate::output::CreateAliasOutput,
                crate::error::CreateAliasError,
                crate::input::CreateAliasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to create the alias.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The requested alias.</p>
        /// <p>The alias must be unique amongst all aliases in Amazon Web Services. This operation throws an
        /// <code>EntityAlreadyExistsException</code> error if the alias already exists.</p>
        pub fn alias(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alias(inp);
            self
        }
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alias(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateComputer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_computer_input::Builder,
    }
    impl<C, M, R> CreateComputer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateComputerOutput,
            smithy_http::result::SdkError<crate::error::CreateComputerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateComputerInputOperationOutputAlias,
                crate::output::CreateComputerOutput,
                crate::error::CreateComputerError,
                crate::input::CreateComputerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory in which to create the computer account.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The name of the computer account.</p>
        pub fn computer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.computer_name(inp);
            self
        }
        pub fn set_computer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_computer_name(input);
            self
        }
        /// <p>A one-time password that is used to join the computer to the directory. You should generate a random, strong password to use for this parameter.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>The fully-qualified distinguished name of the organizational unit to place the computer account in.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.organizational_unit_distinguished_name(inp);
            self
        }
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_organizational_unit_distinguished_name(input);
            self
        }
        /// Appends an item to `ComputerAttributes`.
        ///
        /// To override the contents of this collection use [`set_computer_attributes`](Self::set_computer_attributes).
        /// <p>An array of <a>Attribute</a> objects that contain any LDAP attributes to apply to the
        /// computer account.</p>
        pub fn computer_attributes(mut self, inp: impl Into<crate::model::Attribute>) -> Self {
            self.inner = self.inner.computer_attributes(inp);
            self
        }
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.inner = self.inner.set_computer_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConditionalForwarder<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_conditional_forwarder_input::Builder,
    }
    impl<C, M, R> CreateConditionalForwarder<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConditionalForwarderOutput,
            smithy_http::result::SdkError<crate::error::CreateConditionalForwarderError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateConditionalForwarderInputOperationOutputAlias,
                crate::output::CreateConditionalForwarderOutput,
                crate::error::CreateConditionalForwarderError,
                crate::input::CreateConditionalForwarderInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The directory ID of the Amazon Web Services directory for which you are creating the conditional
        /// forwarder.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The fully qualified domain name (FQDN) of the remote domain with which you will set up
        /// a trust relationship.</p>
        pub fn remote_domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_domain_name(inp);
            self
        }
        pub fn set_remote_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_domain_name(input);
            self
        }
        /// Appends an item to `DnsIpAddrs`.
        ///
        /// To override the contents of this collection use [`set_dns_ip_addrs`](Self::set_dns_ip_addrs).
        /// <p>The IP addresses of the remote DNS server associated with RemoteDomainName.</p>
        pub fn dns_ip_addrs(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dns_ip_addrs(inp);
            self
        }
        pub fn set_dns_ip_addrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dns_ip_addrs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_directory_input::Builder,
    }
    impl<C, M, R> CreateDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDirectoryOutput,
            smithy_http::result::SdkError<crate::error::CreateDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateDirectoryInputOperationOutputAlias,
                crate::output::CreateDirectoryOutput,
                crate::error::CreateDirectoryError,
                crate::input::CreateDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The fully qualified name for the directory, such as <code>corp.example.com</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The NetBIOS name of the directory, such as <code>CORP</code>.</p>
        pub fn short_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.short_name(inp);
            self
        }
        pub fn set_short_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_short_name(input);
            self
        }
        /// <p>The password for the directory administrator. The directory creation process creates a
        /// directory administrator account with the user name <code>Administrator</code> and this
        /// password.</p>
        /// <p>If you need to change the password for the administrator account, you can use the <a>ResetUserPassword</a> API call.</p>
        /// <p>The regex pattern for this string is made up of the following conditions:</p>
        /// <ul>
        /// <li>
        /// <p>Length (?=^.{8,64}$) â€“ Must be between 8 and 64 characters</p>
        /// </li>
        /// </ul>
        /// <p>AND any 3 of the following password complexity rules required by Active Directory:</p>
        /// <ul>
        /// <li>
        /// <p>Numbers and upper case and lowercase (?=.*\d)(?=.*[A-Z])(?=.*[a-z])</p>
        /// </li>
        /// <li>
        /// <p>Numbers and special characters and lower case
        /// (?=.*\d)(?=.*[^A-Za-z0-9\s])(?=.*[a-z])</p>
        /// </li>
        /// <li>
        /// <p>Special characters and upper case and lower case
        /// (?=.*[^A-Za-z0-9\s])(?=.*[A-Z])(?=.*[a-z])</p>
        /// </li>
        /// <li>
        /// <p>Numbers and upper case and special characters
        /// (?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9\s])</p>
        /// </li>
        /// </ul>
        /// <p>For additional information about how Active Directory passwords are enforced, see <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/password-must-meet-complexity-requirements">Password must meet complexity requirements</a> on the Microsoft website.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>A description for the directory.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The size of the directory.</p>
        pub fn size(mut self, inp: crate::model::DirectorySize) -> Self {
            self.inner = self.inner.size(inp);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<crate::model::DirectorySize>) -> Self {
            self.inner = self.inner.set_size(input);
            self
        }
        /// <p>A <a>DirectoryVpcSettings</a> object that contains additional information for
        /// the operation.</p>
        pub fn vpc_settings(mut self, inp: crate::model::DirectoryVpcSettings) -> Self {
            self.inner = self.inner.vpc_settings(inp);
            self
        }
        pub fn set_vpc_settings(
            mut self,
            input: std::option::Option<crate::model::DirectoryVpcSettings>,
        ) -> Self {
            self.inner = self.inner.set_vpc_settings(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to be assigned to the Simple AD directory.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLogSubscription<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_log_subscription_input::Builder,
    }
    impl<C, M, R> CreateLogSubscription<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLogSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateLogSubscriptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLogSubscriptionInputOperationOutputAlias,
                crate::output::CreateLogSubscriptionOutput,
                crate::error::CreateLogSubscriptionError,
                crate::input::CreateLogSubscriptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the directory to which you want to subscribe and receive real-time logs to
        /// your specified CloudWatch log group.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The name of the CloudWatch log group where the real-time domain controller logs are
        /// forwarded.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMicrosoftAD<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_microsoft_ad_input::Builder,
    }
    impl<C, M, R> CreateMicrosoftAD<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMicrosoftAdOutput,
            smithy_http::result::SdkError<crate::error::CreateMicrosoftADError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateMicrosoftAdInputOperationOutputAlias,
                crate::output::CreateMicrosoftAdOutput,
                crate::error::CreateMicrosoftADError,
                crate::input::CreateMicrosoftAdInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The fully qualified domain name for the Managed Microsoft AD directory, such as
        /// <code>corp.example.com</code>. This name will resolve inside your VPC only. It does not need
        /// to be publicly resolvable.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The NetBIOS name for your domain, such as <code>CORP</code>. If you don't specify a
        /// NetBIOS name, it will default to the first part of your directory DNS. For example,
        /// <code>CORP</code> for the directory DNS <code>corp.example.com</code>. </p>
        pub fn short_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.short_name(inp);
            self
        }
        pub fn set_short_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_short_name(input);
            self
        }
        /// <p>The password for the default administrative user named <code>Admin</code>.</p>
        /// <p>If you need to change the password for the administrator account, you can use the <a>ResetUserPassword</a> API call.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>A description for the directory. This label will appear on the Amazon Web Services console
        /// <code>Directory Details</code> page after the directory is created.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.</p>
        pub fn vpc_settings(mut self, inp: crate::model::DirectoryVpcSettings) -> Self {
            self.inner = self.inner.vpc_settings(inp);
            self
        }
        pub fn set_vpc_settings(
            mut self,
            input: std::option::Option<crate::model::DirectoryVpcSettings>,
        ) -> Self {
            self.inner = self.inner.set_vpc_settings(input);
            self
        }
        /// <p>Managed Microsoft AD is available in two editions: <code>Standard</code> and
        /// <code>Enterprise</code>. <code>Enterprise</code> is the default.</p>
        pub fn edition(mut self, inp: crate::model::DirectoryEdition) -> Self {
            self.inner = self.inner.edition(inp);
            self
        }
        pub fn set_edition(
            mut self,
            input: std::option::Option<crate::model::DirectoryEdition>,
        ) -> Self {
            self.inner = self.inner.set_edition(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to be assigned to the Managed Microsoft AD directory.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSnapshot<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_snapshot_input::Builder,
    }
    impl<C, M, R> CreateSnapshot<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateSnapshotError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateSnapshotInputOperationOutputAlias,
                crate::output::CreateSnapshotOutput,
                crate::error::CreateSnapshotError,
                crate::input::CreateSnapshotInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory of which to take a snapshot.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The descriptive name to apply to the snapshot.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrust<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_trust_input::Builder,
    }
    impl<C, M, R> CreateTrust<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrustOutput,
            smithy_http::result::SdkError<crate::error::CreateTrustError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateTrustInputOperationOutputAlias,
                crate::output::CreateTrustOutput,
                crate::error::CreateTrustError,
                crate::input::CreateTrustInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Directory ID of the Managed Microsoft AD directory for which to establish the trust
        /// relationship.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The Fully Qualified Domain Name (FQDN) of the external domain for which to create the
        /// trust relationship.</p>
        pub fn remote_domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_domain_name(inp);
            self
        }
        pub fn set_remote_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_domain_name(input);
            self
        }
        /// <p>The trust password. The must be the same password that was used when creating the trust
        /// relationship on the external domain.</p>
        pub fn trust_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_password(inp);
            self
        }
        pub fn set_trust_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_trust_password(input);
            self
        }
        /// <p>The direction of the trust relationship.</p>
        pub fn trust_direction(mut self, inp: crate::model::TrustDirection) -> Self {
            self.inner = self.inner.trust_direction(inp);
            self
        }
        pub fn set_trust_direction(
            mut self,
            input: std::option::Option<crate::model::TrustDirection>,
        ) -> Self {
            self.inner = self.inner.set_trust_direction(input);
            self
        }
        /// <p>The trust relationship type. <code>Forest</code> is the default.</p>
        pub fn trust_type(mut self, inp: crate::model::TrustType) -> Self {
            self.inner = self.inner.trust_type(inp);
            self
        }
        pub fn set_trust_type(
            mut self,
            input: std::option::Option<crate::model::TrustType>,
        ) -> Self {
            self.inner = self.inner.set_trust_type(input);
            self
        }
        /// Appends an item to `ConditionalForwarderIpAddrs`.
        ///
        /// To override the contents of this collection use [`set_conditional_forwarder_ip_addrs`](Self::set_conditional_forwarder_ip_addrs).
        /// <p>The IP addresses of the remote DNS server associated with RemoteDomainName.</p>
        pub fn conditional_forwarder_ip_addrs(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.conditional_forwarder_ip_addrs(inp);
            self
        }
        pub fn set_conditional_forwarder_ip_addrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_conditional_forwarder_ip_addrs(input);
            self
        }
        /// <p>Optional parameter to enable selective authentication for the trust.</p>
        pub fn selective_auth(mut self, inp: crate::model::SelectiveAuth) -> Self {
            self.inner = self.inner.selective_auth(inp);
            self
        }
        pub fn set_selective_auth(
            mut self,
            input: std::option::Option<crate::model::SelectiveAuth>,
        ) -> Self {
            self.inner = self.inner.set_selective_auth(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConditionalForwarder<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_conditional_forwarder_input::Builder,
    }
    impl<C, M, R> DeleteConditionalForwarder<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConditionalForwarderOutput,
            smithy_http::result::SdkError<crate::error::DeleteConditionalForwarderError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteConditionalForwarderInputOperationOutputAlias,
                crate::output::DeleteConditionalForwarderOutput,
                crate::error::DeleteConditionalForwarderError,
                crate::input::DeleteConditionalForwarderInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The directory ID for which you are deleting the conditional forwarder.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The fully qualified domain name (FQDN) of the remote domain with which you are deleting
        /// the conditional forwarder.</p>
        pub fn remote_domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_domain_name(inp);
            self
        }
        pub fn set_remote_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_directory_input::Builder,
    }
    impl<C, M, R> DeleteDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDirectoryOutput,
            smithy_http::result::SdkError<crate::error::DeleteDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteDirectoryInputOperationOutputAlias,
                crate::output::DeleteDirectoryOutput,
                crate::error::DeleteDirectoryError,
                crate::input::DeleteDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory to delete.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLogSubscription<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_log_subscription_input::Builder,
    }
    impl<C, M, R> DeleteLogSubscription<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLogSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteLogSubscriptionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLogSubscriptionInputOperationOutputAlias,
                crate::output::DeleteLogSubscriptionOutput,
                crate::error::DeleteLogSubscriptionError,
                crate::input::DeleteLogSubscriptionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the directory whose log subscription you want to delete.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSnapshot<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_snapshot_input::Builder,
    }
    impl<C, M, R> DeleteSnapshot<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteSnapshotError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteSnapshotInputOperationOutputAlias,
                crate::output::DeleteSnapshotOutput,
                crate::error::DeleteSnapshotError,
                crate::input::DeleteSnapshotInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory snapshot to be deleted.</p>
        pub fn snapshot_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(inp);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrust<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_trust_input::Builder,
    }
    impl<C, M, R> DeleteTrust<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrustOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrustError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteTrustInputOperationOutputAlias,
                crate::output::DeleteTrustOutput,
                crate::error::DeleteTrustError,
                crate::input::DeleteTrustInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Trust ID of the trust relationship to be deleted.</p>
        pub fn trust_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_id(inp);
            self
        }
        pub fn set_trust_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_trust_id(input);
            self
        }
        /// <p>Delete a conditional forwarder as part of a DeleteTrustRequest.</p>
        pub fn delete_associated_conditional_forwarder(mut self, inp: bool) -> Self {
            self.inner = self.inner.delete_associated_conditional_forwarder(inp);
            self
        }
        pub fn set_delete_associated_conditional_forwarder(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self
                .inner
                .set_delete_associated_conditional_forwarder(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_certificate_input::Builder,
    }
    impl<C, M, R> DeregisterCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeregisterCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterCertificateInputOperationOutputAlias,
                crate::output::DeregisterCertificateOutput,
                crate::error::DeregisterCertificateError,
                crate::input::DeregisterCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The identifier of the certificate.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(inp);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterEventTopic<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_event_topic_input::Builder,
    }
    impl<C, M, R> DeregisterEventTopic<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterEventTopicOutput,
            smithy_http::result::SdkError<crate::error::DeregisterEventTopicError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterEventTopicInputOperationOutputAlias,
                crate::output::DeregisterEventTopicOutput,
                crate::error::DeregisterEventTopicError,
                crate::input::DeregisterEventTopicInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Directory ID to remove as a publisher. This directory will no longer send messages
        /// to the specified Amazon SNS topic.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The name of the Amazon SNS topic from which to remove the directory as a
        /// publisher.</p>
        pub fn topic_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_name(inp);
            self
        }
        pub fn set_topic_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_certificate_input::Builder,
    }
    impl<C, M, R> DescribeCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCertificateOutput,
            smithy_http::result::SdkError<crate::error::DescribeCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeCertificateInputOperationOutputAlias,
                crate::output::DescribeCertificateOutput,
                crate::error::DescribeCertificateError,
                crate::input::DescribeCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The identifier of the certificate.</p>
        pub fn certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_id(inp);
            self
        }
        pub fn set_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientAuthenticationSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_client_authentication_settings_input::Builder,
    }
    impl<C, M, R> DescribeClientAuthenticationSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientAuthenticationSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientAuthenticationSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeClientAuthenticationSettingsInputOperationOutputAlias,
                crate::output::DescribeClientAuthenticationSettingsOutput,
                crate::error::DescribeClientAuthenticationSettingsError,
                crate::input::DescribeClientAuthenticationSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to retrieve information.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of client authentication for which to retrieve information. If no type is specified, a list of all client authentication types that are supported for the specified directory is retrieved.</p>
        pub fn r#type(mut self, inp: crate::model::ClientAuthenticationType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ClientAuthenticationType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The <i>DescribeClientAuthenticationSettingsResult.NextToken</i> value from a previous call to <a>DescribeClientAuthenticationSettings</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation. </p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConditionalForwarders<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_conditional_forwarders_input::Builder,
    }
    impl<C, M, R> DescribeConditionalForwarders<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConditionalForwardersOutput,
            smithy_http::result::SdkError<crate::error::DescribeConditionalForwardersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeConditionalForwardersInputOperationOutputAlias,
                crate::output::DescribeConditionalForwardersOutput,
                crate::error::DescribeConditionalForwardersError,
                crate::input::DescribeConditionalForwardersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The directory ID for which to get the list of associated conditional
        /// forwarders.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `RemoteDomainNames`.
        ///
        /// To override the contents of this collection use [`set_remote_domain_names`](Self::set_remote_domain_names).
        /// <p>The fully qualified domain names (FQDN) of the remote domains for which to get the list
        /// of associated conditional forwarders. If this member is null, all conditional forwarders are
        /// returned.</p>
        pub fn remote_domain_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_domain_names(inp);
            self
        }
        pub fn set_remote_domain_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remote_domain_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDirectories<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_directories_input::Builder,
    }
    impl<C, M, R> DescribeDirectories<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDirectoriesOutput,
            smithy_http::result::SdkError<crate::error::DescribeDirectoriesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeDirectoriesInputOperationOutputAlias,
                crate::output::DescribeDirectoriesOutput,
                crate::error::DescribeDirectoriesError,
                crate::input::DescribeDirectoriesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `DirectoryIds`.
        ///
        /// To override the contents of this collection use [`set_directory_ids`](Self::set_directory_ids).
        /// <p>A list of identifiers of the directories for which to obtain the information. If this
        /// member is null, all directories that belong to the current account are returned.</p>
        /// <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
        pub fn directory_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_ids(inp);
            self
        }
        pub fn set_directory_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_directory_ids(input);
            self
        }
        /// <p>The <code>DescribeDirectoriesResult.NextToken</code> value from a previous call to <a>DescribeDirectories</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return. If this value is zero, the maximum number of items
        /// is specified by the limitations of the operation.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDomainControllers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_domain_controllers_input::Builder,
    }
    impl<C, M, R> DescribeDomainControllers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDomainControllersOutput,
            smithy_http::result::SdkError<crate::error::DescribeDomainControllersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeDomainControllersInputOperationOutputAlias,
                crate::output::DescribeDomainControllersOutput,
                crate::error::DescribeDomainControllersError,
                crate::input::DescribeDomainControllersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the directory for which to retrieve the domain controller
        /// information.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `DomainControllerIds`.
        ///
        /// To override the contents of this collection use [`set_domain_controller_ids`](Self::set_domain_controller_ids).
        /// <p>A list of identifiers for the domain controllers whose information will be
        /// provided.</p>
        pub fn domain_controller_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_controller_ids(inp);
            self
        }
        pub fn set_domain_controller_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_domain_controller_ids(input);
            self
        }
        /// <p>The <i>DescribeDomainControllers.NextToken</i> value from a previous call
        /// to <a>DescribeDomainControllers</a>. Pass null if this is the first call.
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEventTopics<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_event_topics_input::Builder,
    }
    impl<C, M, R> DescribeEventTopics<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEventTopicsOutput,
            smithy_http::result::SdkError<crate::error::DescribeEventTopicsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeEventTopicsInputOperationOutputAlias,
                crate::output::DescribeEventTopicsOutput,
                crate::error::DescribeEventTopicsError,
                crate::input::DescribeEventTopicsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Directory ID for which to get the list of associated Amazon SNS topics. If this member
        /// is null, associations for all Directory IDs are returned.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `TopicNames`.
        ///
        /// To override the contents of this collection use [`set_topic_names`](Self::set_topic_names).
        /// <p>A list of Amazon SNS topic names for which to obtain the information. If this member is
        /// null, all associations for the specified Directory ID are returned.</p>
        /// <p>An empty list results in an <code>InvalidParameterException</code> being
        /// thrown.</p>
        pub fn topic_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_names(inp);
            self
        }
        pub fn set_topic_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_topic_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLDAPSSettings<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_ldaps_settings_input::Builder,
    }
    impl<C, M, R> DescribeLDAPSSettings<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLdapsSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLDAPSSettingsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLdapsSettingsInputOperationOutputAlias,
                crate::output::DescribeLdapsSettingsOutput,
                crate::error::DescribeLDAPSSettingsError,
                crate::input::DescribeLdapsSettingsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
        /// supported.</p>
        pub fn r#type(mut self, inp: crate::model::LdapsType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::LdapsType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The type of next token used for pagination.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specifies the number of items that should be displayed on one page.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRegions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_regions_input::Builder,
    }
    impl<C, M, R> DescribeRegions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRegionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeRegionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRegionsInputOperationOutputAlias,
                crate::output::DescribeRegionsOutput,
                crate::error::DescribeRegionsError,
                crate::input::DescribeRegionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The name of the Region. For example, <code>us-east-1</code>.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.region_name(inp);
            self
        }
        pub fn set_region_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_region_name(input);
            self
        }
        /// <p>The <code>DescribeRegionsResult.NextToken</code> value from a previous call to <a>DescribeRegions</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSharedDirectories<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_shared_directories_input::Builder,
    }
    impl<C, M, R> DescribeSharedDirectories<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSharedDirectoriesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSharedDirectoriesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSharedDirectoriesInputOperationOutputAlias,
                crate::output::DescribeSharedDirectoriesOutput,
                crate::error::DescribeSharedDirectoriesError,
                crate::input::DescribeSharedDirectoriesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Returns the identifier of the directory in the directory owner account. </p>
        pub fn owner_directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner_directory_id(inp);
            self
        }
        pub fn set_owner_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_owner_directory_id(input);
            self
        }
        /// Appends an item to `SharedDirectoryIds`.
        ///
        /// To override the contents of this collection use [`set_shared_directory_ids`](Self::set_shared_directory_ids).
        /// <p>A list of identifiers of all shared directories in your account. </p>
        pub fn shared_directory_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shared_directory_ids(inp);
            self
        }
        pub fn set_shared_directory_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_shared_directory_ids(input);
            self
        }
        /// <p>The <code>DescribeSharedDirectoriesResult.NextToken</code> value from a previous call to
        /// <a>DescribeSharedDirectories</a>. Pass null if this is the first call. </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The number of shared directories to return in the response object.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSnapshots<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_snapshots_input::Builder,
    }
    impl<C, M, R> DescribeSnapshots<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSnapshotsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSnapshotsInputOperationOutputAlias,
                crate::output::DescribeSnapshotsOutput,
                crate::error::DescribeSnapshotsError,
                crate::input::DescribeSnapshotsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to retrieve snapshot information.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `SnapshotIds`.
        ///
        /// To override the contents of this collection use [`set_snapshot_ids`](Self::set_snapshot_ids).
        /// <p>A list of identifiers of the snapshots to obtain the information for. If this member is
        /// null or empty, all snapshots are returned using the <i>Limit</i> and <i>NextToken</i>
        /// members.</p>
        pub fn snapshot_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_ids(inp);
            self
        }
        pub fn set_snapshot_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_ids(input);
            self
        }
        /// <p>The <i>DescribeSnapshotsResult.NextToken</i> value from a previous call to
        /// <a>DescribeSnapshots</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of objects to return.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTrusts<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_trusts_input::Builder,
    }
    impl<C, M, R> DescribeTrusts<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrustsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrustsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTrustsInputOperationOutputAlias,
                crate::output::DescribeTrustsOutput,
                crate::error::DescribeTrustsError,
                crate::input::DescribeTrustsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Directory ID of the Amazon Web Services directory that is a part of the requested trust
        /// relationship.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `TrustIds`.
        ///
        /// To override the contents of this collection use [`set_trust_ids`](Self::set_trust_ids).
        /// <p>A list of identifiers of the trust relationships for which to obtain the information. If
        /// this member is null, all trust relationships that belong to the current account are
        /// returned.</p>
        /// <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
        pub fn trust_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_ids(inp);
            self
        }
        pub fn set_trust_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_trust_ids(input);
            self
        }
        /// <p>The <i>DescribeTrustsResult.NextToken</i> value from a previous call to
        /// <a>DescribeTrusts</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of objects to return.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableClientAuthentication<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_client_authentication_input::Builder,
    }
    impl<C, M, R> DisableClientAuthentication<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableClientAuthenticationOutput,
            smithy_http::result::SdkError<crate::error::DisableClientAuthenticationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableClientAuthenticationInputOperationOutputAlias,
                crate::output::DisableClientAuthenticationOutput,
                crate::error::DisableClientAuthenticationError,
                crate::input::DisableClientAuthenticationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory </p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of client authentication to disable. Currently, only the parameter, <code>SmartCard</code> is supported.</p>
        pub fn r#type(mut self, inp: crate::model::ClientAuthenticationType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ClientAuthenticationType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableLDAPS<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_ldaps_input::Builder,
    }
    impl<C, M, R> DisableLDAPS<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableLdapsOutput,
            smithy_http::result::SdkError<crate::error::DisableLDAPSError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableLdapsInputOperationOutputAlias,
                crate::output::DisableLdapsOutput,
                crate::error::DisableLDAPSError,
                crate::input::DisableLdapsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
        /// supported.</p>
        pub fn r#type(mut self, inp: crate::model::LdapsType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::LdapsType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableRadius<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_radius_input::Builder,
    }
    impl<C, M, R> DisableRadius<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableRadiusOutput,
            smithy_http::result::SdkError<crate::error::DisableRadiusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableRadiusInputOperationOutputAlias,
                crate::output::DisableRadiusOutput,
                crate::error::DisableRadiusError,
                crate::input::DisableRadiusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to disable MFA.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableSso<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_sso_input::Builder,
    }
    impl<C, M, R> DisableSso<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableSsoOutput,
            smithy_http::result::SdkError<crate::error::DisableSsoError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableSsoInputOperationOutputAlias,
                crate::output::DisableSsoOutput,
                crate::error::DisableSsoError,
                crate::input::DisableSsoInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to disable single-sign on.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The username of an alternate account to use to disable single-sign on. This is only used
        /// for AD Connector directories. This account must have privileges to remove a service
        /// principal name.</p>
        /// <p>If the AD Connector service account does not have privileges to remove a service
        /// principal name, you can specify an alternate account with the <i>UserName</i>
        /// and <i>Password</i> parameters. These credentials are only used to disable
        /// single sign-on and are not stored by the service. The AD Connector service account is not
        /// changed.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of an alternate account to use to disable single-sign on. This is only used
        /// for AD Connector directories. For more information, see the <i>UserName</i>
        /// parameter.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableClientAuthentication<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_client_authentication_input::Builder,
    }
    impl<C, M, R> EnableClientAuthentication<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableClientAuthenticationOutput,
            smithy_http::result::SdkError<crate::error::EnableClientAuthenticationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableClientAuthenticationInputOperationOutputAlias,
                crate::output::EnableClientAuthenticationOutput,
                crate::error::EnableClientAuthenticationError,
                crate::input::EnableClientAuthenticationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the specified directory. </p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of client authentication to enable. Currently only the value <code>SmartCard</code> is
        /// supported. Smart card authentication in AD Connector requires that you enable Kerberos
        /// Constrained Delegation for the Service User to the LDAP service in your self-managed AD.
        /// </p>
        pub fn r#type(mut self, inp: crate::model::ClientAuthenticationType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ClientAuthenticationType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableLDAPS<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_ldaps_input::Builder,
    }
    impl<C, M, R> EnableLDAPS<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableLdapsOutput,
            smithy_http::result::SdkError<crate::error::EnableLDAPSError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableLdapsInputOperationOutputAlias,
                crate::output::EnableLdapsOutput,
                crate::error::EnableLDAPSError,
                crate::input::EnableLdapsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The type of LDAP security to enable. Currently only the value <code>Client</code> is
        /// supported.</p>
        pub fn r#type(mut self, inp: crate::model::LdapsType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::LdapsType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableRadius<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_radius_input::Builder,
    }
    impl<C, M, R> EnableRadius<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableRadiusOutput,
            smithy_http::result::SdkError<crate::error::EnableRadiusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableRadiusInputOperationOutputAlias,
                crate::output::EnableRadiusOutput,
                crate::error::EnableRadiusError,
                crate::input::EnableRadiusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to enable MFA.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS
        /// server.</p>
        pub fn radius_settings(mut self, inp: crate::model::RadiusSettings) -> Self {
            self.inner = self.inner.radius_settings(inp);
            self
        }
        pub fn set_radius_settings(
            mut self,
            input: std::option::Option<crate::model::RadiusSettings>,
        ) -> Self {
            self.inner = self.inner.set_radius_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableSso<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_sso_input::Builder,
    }
    impl<C, M, R> EnableSso<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableSsoOutput,
            smithy_http::result::SdkError<crate::error::EnableSsoError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableSsoInputOperationOutputAlias,
                crate::output::EnableSsoOutput,
                crate::error::EnableSsoError,
                crate::input::EnableSsoInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to enable single-sign on.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The username of an alternate account to use to enable single-sign on. This is only used
        /// for AD Connector directories. This account must have privileges to add a service principal
        /// name.</p>
        /// <p>If the AD Connector service account does not have privileges to add a service principal
        /// name, you can specify an alternate account with the <i>UserName</i> and
        /// <i>Password</i> parameters. These credentials are only used to enable single
        /// sign-on and are not stored by the service. The AD Connector service account is not
        /// changed.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of an alternate account to use to enable single-sign on. This is only used
        /// for AD Connector directories. For more information, see the <i>UserName</i>
        /// parameter.</p>
        pub fn password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(inp);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDirectoryLimits<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_directory_limits_input::Builder,
    }
    impl<C, M, R> GetDirectoryLimits<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDirectoryLimitsOutput,
            smithy_http::result::SdkError<crate::error::GetDirectoryLimitsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDirectoryLimitsInputOperationOutputAlias,
                crate::output::GetDirectoryLimitsOutput,
                crate::error::GetDirectoryLimitsError,
                crate::input::GetDirectoryLimitsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSnapshotLimits<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_snapshot_limits_input::Builder,
    }
    impl<C, M, R> GetSnapshotLimits<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSnapshotLimitsOutput,
            smithy_http::result::SdkError<crate::error::GetSnapshotLimitsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSnapshotLimitsInputOperationOutputAlias,
                crate::output::GetSnapshotLimitsOutput,
                crate::error::GetSnapshotLimitsError,
                crate::input::GetSnapshotLimitsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Contains the identifier of the directory to obtain the limits for.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCertificates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_certificates_input::Builder,
    }
    impl<C, M, R> ListCertificates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCertificatesOutput,
            smithy_http::result::SdkError<crate::error::ListCertificatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListCertificatesInputOperationOutputAlias,
                crate::output::ListCertificatesOutput,
                crate::error::ListCertificatesError,
                crate::input::ListCertificatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>A token for requesting another page of certificates if the <code>NextToken</code> response
        /// element indicates that more certificates are available. Use the value of the returned
        /// <code>NextToken</code> element in your request until the token comes back as
        /// <code>null</code>. Pass <code>null</code> if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The number of items that should show up on one page</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIpRoutes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_ip_routes_input::Builder,
    }
    impl<C, M, R> ListIpRoutes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIpRoutesOutput,
            smithy_http::result::SdkError<crate::error::ListIpRoutesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListIpRoutesInputOperationOutputAlias,
                crate::output::ListIpRoutesOutput,
                crate::error::ListIpRoutesError,
                crate::input::ListIpRoutesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) of the directory for which you want to retrieve the IP
        /// addresses.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The <i>ListIpRoutes.NextToken</i> value from a previous call to <a>ListIpRoutes</a>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of items to return. If this value is zero, the maximum number of items
        /// is specified by the limitations of the operation.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLogSubscriptions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_log_subscriptions_input::Builder,
    }
    impl<C, M, R> ListLogSubscriptions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLogSubscriptionsOutput,
            smithy_http::result::SdkError<crate::error::ListLogSubscriptionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListLogSubscriptionsInputOperationOutputAlias,
                crate::output::ListLogSubscriptionsOutput,
                crate::error::ListLogSubscriptionsError,
                crate::input::ListLogSubscriptionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If a <i>DirectoryID</i> is provided, lists only the log subscription
        /// associated with that directory. If no <i>DirectoryId</i> is provided, lists all
        /// log subscriptions associated with your Amazon Web Services account. If there are no log subscriptions for the
        /// Amazon Web Services account or the directory, an empty list will be returned.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The token for the next set of items to return.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSchemaExtensions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_schema_extensions_input::Builder,
    }
    impl<C, M, R> ListSchemaExtensions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSchemaExtensionsOutput,
            smithy_http::result::SdkError<crate::error::ListSchemaExtensionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListSchemaExtensionsInputOperationOutputAlias,
                crate::output::ListSchemaExtensionsOutput,
                crate::error::ListSchemaExtensionsError,
                crate::input::ListSchemaExtensionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory from which to retrieve the schema extension
        /// information.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The <code>ListSchemaExtensions.NextToken</code> value from a previous call to
        /// <code>ListSchemaExtensions</code>. Pass null if this is the first call.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) of the directory for which you want to retrieve tags.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_certificate_input::Builder,
    }
    impl<C, M, R> RegisterCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterCertificateOutput,
            smithy_http::result::SdkError<crate::error::RegisterCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterCertificateInputOperationOutputAlias,
                crate::output::RegisterCertificateOutput,
                crate::error::RegisterCertificateError,
                crate::input::RegisterCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The certificate PEM string that needs to be registered.</p>
        pub fn certificate_data(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_data(inp);
            self
        }
        pub fn set_certificate_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_data(input);
            self
        }
        /// <p>The function that the registered certificate performs. Valid values include <code>ClientLDAPS</code> or <code>ClientCertAuth</code>. The default value is <code>ClientLDAPS</code>.</p>
        pub fn r#type(mut self, inp: crate::model::CertificateType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CertificateType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>A <code>ClientCertAuthSettings</code> object that contains client certificate authentication settings.</p>
        pub fn client_cert_auth_settings(
            mut self,
            inp: crate::model::ClientCertAuthSettings,
        ) -> Self {
            self.inner = self.inner.client_cert_auth_settings(inp);
            self
        }
        pub fn set_client_cert_auth_settings(
            mut self,
            input: std::option::Option<crate::model::ClientCertAuthSettings>,
        ) -> Self {
            self.inner = self.inner.set_client_cert_auth_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterEventTopic<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_event_topic_input::Builder,
    }
    impl<C, M, R> RegisterEventTopic<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterEventTopicOutput,
            smithy_http::result::SdkError<crate::error::RegisterEventTopicError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterEventTopicInputOperationOutputAlias,
                crate::output::RegisterEventTopicOutput,
                crate::error::RegisterEventTopicError,
                crate::input::RegisterEventTopicInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Directory ID that will publish status messages to the Amazon SNS topic.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The Amazon SNS topic name to which the directory will publish status messages. This Amazon SNS
        /// topic must be in the same region as the specified Directory ID.</p>
        pub fn topic_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_name(inp);
            self
        }
        pub fn set_topic_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectSharedDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::reject_shared_directory_input::Builder,
    }
    impl<C, M, R> RejectSharedDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectSharedDirectoryOutput,
            smithy_http::result::SdkError<crate::error::RejectSharedDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RejectSharedDirectoryInputOperationOutputAlias,
                crate::output::RejectSharedDirectoryOutput,
                crate::error::RejectSharedDirectoryError,
                crate::input::RejectSharedDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the shared directory in the directory consumer account. This identifier is
        /// different for each directory owner account.</p>
        pub fn shared_directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shared_directory_id(inp);
            self
        }
        pub fn set_shared_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shared_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveIpRoutes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_ip_routes_input::Builder,
    }
    impl<C, M, R> RemoveIpRoutes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveIpRoutesOutput,
            smithy_http::result::SdkError<crate::error::RemoveIpRoutesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveIpRoutesInputOperationOutputAlias,
                crate::output::RemoveIpRoutesOutput,
                crate::error::RemoveIpRoutesError,
                crate::input::RemoveIpRoutesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) of the directory from which you want to remove the IP
        /// addresses.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// Appends an item to `CidrIps`.
        ///
        /// To override the contents of this collection use [`set_cidr_ips`](Self::set_cidr_ips).
        /// <p>IP address blocks that you want to remove.</p>
        pub fn cidr_ips(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_ips(inp);
            self
        }
        pub fn set_cidr_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_cidr_ips(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveRegion<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_region_input::Builder,
    }
    impl<C, M, R> RemoveRegion<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveRegionOutput,
            smithy_http::result::SdkError<crate::error::RemoveRegionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveRegionInputOperationOutputAlias,
                crate::output::RemoveRegionOutput,
                crate::error::RemoveRegionError,
                crate::input::RemoveRegionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which you want to remove Region replication.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_tags_from_resource_input::Builder,
    }
    impl<C, M, R> RemoveTagsFromResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromResourceOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveTagsFromResourceInputOperationOutputAlias,
                crate::output::RemoveTagsFromResourceOutput,
                crate::error::RemoveTagsFromResourceError,
                crate::input::RemoveTagsFromResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier (ID) of the directory from which to remove the tag.</p>
        pub fn resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(inp);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>The tag key (name) of the tag to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetUserPassword<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::reset_user_password_input::Builder,
    }
    impl<C, M, R> ResetUserPassword<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetUserPasswordOutput,
            smithy_http::result::SdkError<crate::error::ResetUserPasswordError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ResetUserPasswordInputOperationOutputAlias,
                crate::output::ResetUserPasswordOutput,
                crate::error::ResetUserPasswordError,
                crate::input::ResetUserPasswordInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the Managed Microsoft AD or Simple AD directory in which the user
        /// resides.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The user name of the user whose password will be reset.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The new password that will be reset.</p>
        pub fn new_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_password(inp);
            self
        }
        pub fn set_new_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreFromSnapshot<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::restore_from_snapshot_input::Builder,
    }
    impl<C, M, R> RestoreFromSnapshot<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RestoreFromSnapshotOutput,
            smithy_http::result::SdkError<crate::error::RestoreFromSnapshotError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RestoreFromSnapshotInputOperationOutputAlias,
                crate::output::RestoreFromSnapshotOutput,
                crate::error::RestoreFromSnapshotError,
                crate::input::RestoreFromSnapshotInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the snapshot to restore from.</p>
        pub fn snapshot_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(inp);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ShareDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::share_directory_input::Builder,
    }
    impl<C, M, R> ShareDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ShareDirectoryOutput,
            smithy_http::result::SdkError<crate::error::ShareDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ShareDirectoryInputOperationOutputAlias,
                crate::output::ShareDirectoryOutput,
                crate::error::ShareDirectoryError,
                crate::input::ShareDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the Managed Microsoft AD directory that you want to share with other Amazon Web Services accounts.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>A directory share request that is sent by the directory owner to the directory consumer.
        /// The request includes a typed message to help the directory consumer administrator determine
        /// whether to approve or reject the share invitation.</p>
        pub fn share_notes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.share_notes(inp);
            self
        }
        pub fn set_share_notes(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_share_notes(input);
            self
        }
        /// <p>Identifier for the directory consumer account with whom the directory is to be
        /// shared.</p>
        pub fn share_target(mut self, inp: crate::model::ShareTarget) -> Self {
            self.inner = self.inner.share_target(inp);
            self
        }
        pub fn set_share_target(
            mut self,
            input: std::option::Option<crate::model::ShareTarget>,
        ) -> Self {
            self.inner = self.inner.set_share_target(input);
            self
        }
        /// <p>The method used when sharing a directory to determine whether the directory should be
        /// shared within your Amazon Web Services organization (<code>ORGANIZATIONS</code>) or with any Amazon Web Services account by
        /// sending a directory sharing request (<code>HANDSHAKE</code>).</p>
        pub fn share_method(mut self, inp: crate::model::ShareMethod) -> Self {
            self.inner = self.inner.share_method(inp);
            self
        }
        pub fn set_share_method(
            mut self,
            input: std::option::Option<crate::model::ShareMethod>,
        ) -> Self {
            self.inner = self.inner.set_share_method(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartSchemaExtension<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_schema_extension_input::Builder,
    }
    impl<C, M, R> StartSchemaExtension<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartSchemaExtensionOutput,
            smithy_http::result::SdkError<crate::error::StartSchemaExtensionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartSchemaExtensionInputOperationOutputAlias,
                crate::output::StartSchemaExtensionOutput,
                crate::error::StartSchemaExtensionError,
                crate::input::StartSchemaExtensionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which the schema extension will be applied
        /// to.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>If true, creates a snapshot of the directory before applying the schema
        /// extension.</p>
        pub fn create_snapshot_before_schema_extension(mut self, inp: bool) -> Self {
            self.inner = self.inner.create_snapshot_before_schema_extension(inp);
            self
        }
        pub fn set_create_snapshot_before_schema_extension(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self
                .inner
                .set_create_snapshot_before_schema_extension(input);
            self
        }
        /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede
        /// each line as it would be formatted in an ldif file with \n. See the example request below for
        /// more details. The file size can be no larger than 1MB.</p>
        pub fn ldif_content(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ldif_content(inp);
            self
        }
        pub fn set_ldif_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ldif_content(input);
            self
        }
        /// <p>A description of the schema extension.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UnshareDirectory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::unshare_directory_input::Builder,
    }
    impl<C, M, R> UnshareDirectory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnshareDirectoryOutput,
            smithy_http::result::SdkError<crate::error::UnshareDirectoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UnshareDirectoryInputOperationOutputAlias,
                crate::output::UnshareDirectoryOutput,
                crate::error::UnshareDirectoryError,
                crate::input::UnshareDirectoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the Managed Microsoft AD directory that you want to stop
        /// sharing.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>Identifier for the directory consumer account with whom the directory has to be
        /// unshared.</p>
        pub fn unshare_target(mut self, inp: crate::model::UnshareTarget) -> Self {
            self.inner = self.inner.unshare_target(inp);
            self
        }
        pub fn set_unshare_target(
            mut self,
            input: std::option::Option<crate::model::UnshareTarget>,
        ) -> Self {
            self.inner = self.inner.set_unshare_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConditionalForwarder<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_conditional_forwarder_input::Builder,
    }
    impl<C, M, R> UpdateConditionalForwarder<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConditionalForwarderOutput,
            smithy_http::result::SdkError<crate::error::UpdateConditionalForwarderError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateConditionalForwarderInputOperationOutputAlias,
                crate::output::UpdateConditionalForwarderOutput,
                crate::error::UpdateConditionalForwarderError,
                crate::input::UpdateConditionalForwarderInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The directory ID of the Amazon Web Services directory for which to update the conditional
        /// forwarder.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The fully qualified domain name (FQDN) of the remote domain with which you will set up
        /// a trust relationship.</p>
        pub fn remote_domain_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_domain_name(inp);
            self
        }
        pub fn set_remote_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_domain_name(input);
            self
        }
        /// Appends an item to `DnsIpAddrs`.
        ///
        /// To override the contents of this collection use [`set_dns_ip_addrs`](Self::set_dns_ip_addrs).
        /// <p>The updated IP addresses of the remote DNS server associated with the conditional
        /// forwarder.</p>
        pub fn dns_ip_addrs(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dns_ip_addrs(inp);
            self
        }
        pub fn set_dns_ip_addrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dns_ip_addrs(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNumberOfDomainControllers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_number_of_domain_controllers_input::Builder,
    }
    impl<C, M, R> UpdateNumberOfDomainControllers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNumberOfDomainControllersOutput,
            smithy_http::result::SdkError<crate::error::UpdateNumberOfDomainControllersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateNumberOfDomainControllersInputOperationOutputAlias,
                crate::output::UpdateNumberOfDomainControllersOutput,
                crate::error::UpdateNumberOfDomainControllersError,
                crate::input::UpdateNumberOfDomainControllersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the directory to which the domain controllers will be added or
        /// removed.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>The number of domain controllers desired in the directory.</p>
        pub fn desired_number(mut self, inp: i32) -> Self {
            self.inner = self.inner.desired_number(inp);
            self
        }
        pub fn set_desired_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRadius<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_radius_input::Builder,
    }
    impl<C, M, R> UpdateRadius<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRadiusOutput,
            smithy_http::result::SdkError<crate::error::UpdateRadiusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateRadiusInputOperationOutputAlias,
                crate::output::UpdateRadiusOutput,
                crate::error::UpdateRadiusError,
                crate::input::UpdateRadiusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the directory for which to update the RADIUS server
        /// information.</p>
        pub fn directory_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.directory_id(inp);
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_directory_id(input);
            self
        }
        /// <p>A <a>RadiusSettings</a> object that contains information about the RADIUS
        /// server.</p>
        pub fn radius_settings(mut self, inp: crate::model::RadiusSettings) -> Self {
            self.inner = self.inner.radius_settings(inp);
            self
        }
        pub fn set_radius_settings(
            mut self,
            input: std::option::Option<crate::model::RadiusSettings>,
        ) -> Self {
            self.inner = self.inner.set_radius_settings(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTrust<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_trust_input::Builder,
    }
    impl<C, M, R> UpdateTrust<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTrustOutput,
            smithy_http::result::SdkError<crate::error::UpdateTrustError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateTrustInputOperationOutputAlias,
                crate::output::UpdateTrustOutput,
                crate::error::UpdateTrustError,
                crate::input::UpdateTrustInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Identifier of the trust relationship.</p>
        pub fn trust_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_id(inp);
            self
        }
        pub fn set_trust_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_trust_id(input);
            self
        }
        /// <p>Updates selective authentication for the trust.</p>
        pub fn selective_auth(mut self, inp: crate::model::SelectiveAuth) -> Self {
            self.inner = self.inner.selective_auth(inp);
            self
        }
        pub fn set_selective_auth(
            mut self,
            input: std::option::Option<crate::model::SelectiveAuth>,
        ) -> Self {
            self.inner = self.inner.set_selective_auth(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct VerifyTrust<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::verify_trust_input::Builder,
    }
    impl<C, M, R> VerifyTrust<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::VerifyTrustOutput,
            smithy_http::result::SdkError<crate::error::VerifyTrustError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::VerifyTrustInputOperationOutputAlias,
                crate::output::VerifyTrustOutput,
                crate::error::VerifyTrustError,
                crate::input::VerifyTrustInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Trust ID of the trust relationship to verify.</p>
        pub fn trust_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trust_id(inp);
            self
        }
        pub fn set_trust_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_trust_id(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
