// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type VerifyTrustErrorKind = VerifyTrustError;
/// Error type for the `VerifyTrustError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum VerifyTrustError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for VerifyTrustError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for VerifyTrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for VerifyTrustError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::VerifyTrustError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for VerifyTrustError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl VerifyTrustError {
    /// Creates the `VerifyTrustError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `VerifyTrustError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `VerifyTrustError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `VerifyTrustError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `VerifyTrustError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `VerifyTrustError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `VerifyTrustError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for VerifyTrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The operation is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedOperationException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedOperationException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl UnsupportedOperationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationException`](crate::error::UnsupportedOperationException).
    pub fn builder() -> crate::error::unsupported_operation_exception::Builder {
        crate::error::unsupported_operation_exception::Builder::default()
    }
}
/// See [`UnsupportedOperationException`](crate::error::UnsupportedOperationException).
pub mod unsupported_operation_exception {

    /// A builder for [`UnsupportedOperationException`](crate::error::UnsupportedOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationException`](crate::error::UnsupportedOperationException).
        pub fn build(self) -> crate::error::UnsupportedOperationException {
            crate::error::UnsupportedOperationException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl UnsupportedOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationException {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An exception has occurred in Directory Service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl ServiceException {
    /// Creates a new builder-style object to manufacture [`ServiceException`](crate::error::ServiceException).
    pub fn builder() -> crate::error::service_exception::Builder {
        crate::error::service_exception::Builder::default()
    }
}
/// See [`ServiceException`](crate::error::ServiceException).
pub mod service_exception {

    /// A builder for [`ServiceException`](crate::error::ServiceException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ServiceException`](crate::error::ServiceException).
        pub fn build(self) -> crate::error::ServiceException {
            crate::error::ServiceException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ServiceException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceException {}
impl aws_http::request_id::RequestId for crate::error::ServiceException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>One or more parameters are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidParameterException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidParameterException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException).
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException).
pub mod invalid_parameter_exception {

    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException).
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidParameterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidParameterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidParameterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified entity could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityDoesNotExistException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EntityDoesNotExistException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl EntityDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`EntityDoesNotExistException`](crate::error::EntityDoesNotExistException).
    pub fn builder() -> crate::error::entity_does_not_exist_exception::Builder {
        crate::error::entity_does_not_exist_exception::Builder::default()
    }
}
/// See [`EntityDoesNotExistException`](crate::error::EntityDoesNotExistException).
pub mod entity_does_not_exist_exception {

    /// A builder for [`EntityDoesNotExistException`](crate::error::EntityDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EntityDoesNotExistException`](crate::error::EntityDoesNotExistException).
        pub fn build(self) -> crate::error::EntityDoesNotExistException {
            crate::error::EntityDoesNotExistException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EntityDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityDoesNotExistException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EntityDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::EntityDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EntityDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A client exception has occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClientException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClientException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl ClientException {
    /// Creates a new builder-style object to manufacture [`ClientException`](crate::error::ClientException).
    pub fn builder() -> crate::error::client_exception::Builder {
        crate::error::client_exception::Builder::default()
    }
}
/// See [`ClientException`](crate::error::ClientException).
pub mod client_exception {

    /// A builder for [`ClientException`](crate::error::ClientException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClientException`](crate::error::ClientException).
        pub fn build(self) -> crate::error::ClientException {
            crate::error::ClientException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ClientException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClientException {}
impl aws_http::request_id::RequestId for crate::error::ClientException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClientException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateTrustErrorKind = UpdateTrustError;
/// Error type for the `UpdateTrustError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTrustError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateTrustError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateTrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateTrustError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateTrustError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateTrustError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTrustError {
    /// Creates the `UpdateTrustError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateTrustError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateTrustError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateTrustError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateTrustError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateTrustError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for UpdateTrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateSettingsErrorKind = UpdateSettingsError;
/// Error type for the `UpdateSettingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSettingsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified directory setting is not compatible with other settings.</p>
    IncompatibleSettingsException(crate::error::IncompatibleSettingsException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// <p>The specified directory setting is not supported.</p>
    UnsupportedSettingsException(crate::error::UnsupportedSettingsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSettingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::IncompatibleSettingsException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::UnsupportedSettingsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateSettingsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleSettingsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedSettingsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateSettingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSettingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSettingsError {
    /// Creates the `UpdateSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateSettingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::IncompatibleSettingsException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::UnsupportedSettingsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::IncompatibleSettingsException`.
    pub fn is_incompatible_settings_exception(&self) -> bool {
        matches!(self, Self::IncompatibleSettingsException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateSettingsError::UnsupportedSettingsException`.
    pub fn is_unsupported_settings_exception(&self) -> bool {
        matches!(self, Self::UnsupportedSettingsException(_))
    }
}
impl std::error::Error for UpdateSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::IncompatibleSettingsException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::UnsupportedSettingsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified directory setting is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedSettingsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedSettingsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl UnsupportedSettingsException {
    /// Creates a new builder-style object to manufacture [`UnsupportedSettingsException`](crate::error::UnsupportedSettingsException).
    pub fn builder() -> crate::error::unsupported_settings_exception::Builder {
        crate::error::unsupported_settings_exception::Builder::default()
    }
}
/// See [`UnsupportedSettingsException`](crate::error::UnsupportedSettingsException).
pub mod unsupported_settings_exception {

    /// A builder for [`UnsupportedSettingsException`](crate::error::UnsupportedSettingsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedSettingsException`](crate::error::UnsupportedSettingsException).
        pub fn build(self) -> crate::error::UnsupportedSettingsException {
            crate::error::UnsupportedSettingsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl UnsupportedSettingsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedSettingsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedSettingsException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedSettingsException {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedSettingsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedSettingsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified directory setting is not compatible with other settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncompatibleSettingsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IncompatibleSettingsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl IncompatibleSettingsException {
    /// Creates a new builder-style object to manufacture [`IncompatibleSettingsException`](crate::error::IncompatibleSettingsException).
    pub fn builder() -> crate::error::incompatible_settings_exception::Builder {
        crate::error::incompatible_settings_exception::Builder::default()
    }
}
/// See [`IncompatibleSettingsException`](crate::error::IncompatibleSettingsException).
pub mod incompatible_settings_exception {

    /// A builder for [`IncompatibleSettingsException`](crate::error::IncompatibleSettingsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleSettingsException`](crate::error::IncompatibleSettingsException).
        pub fn build(self) -> crate::error::IncompatibleSettingsException {
            crate::error::IncompatibleSettingsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IncompatibleSettingsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleSettingsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncompatibleSettingsException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleSettingsException {}
impl aws_http::request_id::RequestId for crate::error::IncompatibleSettingsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IncompatibleSettingsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified directory is unavailable or could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryUnavailableException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryUnavailableException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryUnavailableException {
    /// Creates a new builder-style object to manufacture [`DirectoryUnavailableException`](crate::error::DirectoryUnavailableException).
    pub fn builder() -> crate::error::directory_unavailable_exception::Builder {
        crate::error::directory_unavailable_exception::Builder::default()
    }
}
/// See [`DirectoryUnavailableException`](crate::error::DirectoryUnavailableException).
pub mod directory_unavailable_exception {

    /// A builder for [`DirectoryUnavailableException`](crate::error::DirectoryUnavailableException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryUnavailableException`](crate::error::DirectoryUnavailableException).
        pub fn build(self) -> crate::error::DirectoryUnavailableException {
            crate::error::DirectoryUnavailableException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryUnavailableException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryUnavailableException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryUnavailableException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryUnavailableException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified directory does not exist in the system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryDoesNotExistException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryDoesNotExistException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`DirectoryDoesNotExistException`](crate::error::DirectoryDoesNotExistException).
    pub fn builder() -> crate::error::directory_does_not_exist_exception::Builder {
        crate::error::directory_does_not_exist_exception::Builder::default()
    }
}
/// See [`DirectoryDoesNotExistException`](crate::error::DirectoryDoesNotExistException).
pub mod directory_does_not_exist_exception {

    /// A builder for [`DirectoryDoesNotExistException`](crate::error::DirectoryDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryDoesNotExistException`](crate::error::DirectoryDoesNotExistException).
        pub fn build(self) -> crate::error::DirectoryDoesNotExistException {
            crate::error::DirectoryDoesNotExistException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryDoesNotExistException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRadiusErrorKind = UpdateRadiusError;
/// Error type for the `UpdateRadiusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRadiusError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRadiusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRadiusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRadiusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRadiusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRadiusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRadiusError {
    /// Creates the `UpdateRadiusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRadiusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRadiusError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateRadiusError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateRadiusError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateRadiusError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for UpdateRadiusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateNumberOfDomainControllersErrorKind = UpdateNumberOfDomainControllersError;
/// Error type for the `UpdateNumberOfDomainControllersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNumberOfDomainControllersError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.</p>
    DomainControllerLimitExceededException(crate::error::DomainControllerLimitExceededException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateNumberOfDomainControllersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateNumberOfDomainControllersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::DomainControllerLimitExceededException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateNumberOfDomainControllersError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DomainControllerLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateNumberOfDomainControllersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateNumberOfDomainControllersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateNumberOfDomainControllersError {
    /// Creates the `UpdateNumberOfDomainControllersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateNumberOfDomainControllersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::DomainControllerLimitExceededException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::DomainControllerLimitExceededException`.
    pub fn is_domain_controller_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DomainControllerLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `UpdateNumberOfDomainControllersError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for UpdateNumberOfDomainControllersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::DomainControllerLimitExceededException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainControllerLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DomainControllerLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DomainControllerLimitExceededException {
    /// Creates a new builder-style object to manufacture [`DomainControllerLimitExceededException`](crate::error::DomainControllerLimitExceededException).
    pub fn builder() -> crate::error::domain_controller_limit_exceeded_exception::Builder {
        crate::error::domain_controller_limit_exceeded_exception::Builder::default()
    }
}
/// See [`DomainControllerLimitExceededException`](crate::error::DomainControllerLimitExceededException).
pub mod domain_controller_limit_exceeded_exception {

    /// A builder for [`DomainControllerLimitExceededException`](crate::error::DomainControllerLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DomainControllerLimitExceededException`](crate::error::DomainControllerLimitExceededException).
        pub fn build(self) -> crate::error::DomainControllerLimitExceededException {
            crate::error::DomainControllerLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DomainControllerLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainControllerLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainControllerLimitExceededException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DomainControllerLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::DomainControllerLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DomainControllerLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDirectorySetupErrorKind = UpdateDirectorySetupError;
/// Error type for the `UpdateDirectorySetupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDirectorySetupError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p> The directory is already updated to desired update type settings. </p>
    DirectoryInDesiredStateException(crate::error::DirectoryInDesiredStateException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
    SnapshotLimitExceededException(crate::error::SnapshotLimitExceededException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDirectorySetupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDirectorySetupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryInDesiredStateException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::SnapshotLimitExceededException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDirectorySetupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryInDesiredStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDirectorySetupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDirectorySetupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDirectorySetupError {
    /// Creates the `UpdateDirectorySetupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDirectorySetupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryInDesiredStateException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::SnapshotLimitExceededException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::DirectoryInDesiredStateException`.
    pub fn is_directory_in_desired_state_exception(&self) -> bool {
        matches!(self, Self::DirectoryInDesiredStateException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::SnapshotLimitExceededException`.
    pub fn is_snapshot_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::SnapshotLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDirectorySetupError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for UpdateDirectorySetupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryInDesiredStateException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::SnapshotLimitExceededException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl SnapshotLimitExceededException {
    /// Creates a new builder-style object to manufacture [`SnapshotLimitExceededException`](crate::error::SnapshotLimitExceededException).
    pub fn builder() -> crate::error::snapshot_limit_exceeded_exception::Builder {
        crate::error::snapshot_limit_exceeded_exception::Builder::default()
    }
}
/// See [`SnapshotLimitExceededException`](crate::error::SnapshotLimitExceededException).
pub mod snapshot_limit_exceeded_exception {

    /// A builder for [`SnapshotLimitExceededException`](crate::error::SnapshotLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotLimitExceededException`](crate::error::SnapshotLimitExceededException).
        pub fn build(self) -> crate::error::SnapshotLimitExceededException {
            crate::error::SnapshotLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SnapshotLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotLimitExceededException")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::SnapshotLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> The directory is already updated to desired update type settings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryInDesiredStateException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryInDesiredStateException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryInDesiredStateException {
    /// Creates a new builder-style object to manufacture [`DirectoryInDesiredStateException`](crate::error::DirectoryInDesiredStateException).
    pub fn builder() -> crate::error::directory_in_desired_state_exception::Builder {
        crate::error::directory_in_desired_state_exception::Builder::default()
    }
}
/// See [`DirectoryInDesiredStateException`](crate::error::DirectoryInDesiredStateException).
pub mod directory_in_desired_state_exception {

    /// A builder for [`DirectoryInDesiredStateException`](crate::error::DirectoryInDesiredStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryInDesiredStateException`](crate::error::DirectoryInDesiredStateException).
        pub fn build(self) -> crate::error::DirectoryInDesiredStateException {
            crate::error::DirectoryInDesiredStateException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryInDesiredStateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryInDesiredStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryInDesiredStateException")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryInDesiredStateException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryInDesiredStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryInDesiredStateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Client authentication is not available in this region at this time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessDeniedException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {

    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
impl aws_http::request_id::RequestId for crate::error::AccessDeniedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessDeniedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateConditionalForwarderErrorKind = UpdateConditionalForwarderError;
/// Error type for the `UpdateConditionalForwarderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConditionalForwarderError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateConditionalForwarderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateConditionalForwarderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateConditionalForwarderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateConditionalForwarderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConditionalForwarderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConditionalForwarderError {
    /// Creates the `UpdateConditionalForwarderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateConditionalForwarderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `UpdateConditionalForwarderError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for UpdateConditionalForwarderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UnshareDirectoryErrorKind = UnshareDirectoryError;
/// Error type for the `UnshareDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnshareDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory has not been shared with this Amazon Web Services account.</p>
    DirectoryNotSharedException(crate::error::DirectoryNotSharedException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The specified shared target is not valid.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UnshareDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UnshareDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryNotSharedException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidTargetException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnshareDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryNotSharedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UnshareDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UnshareDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UnshareDirectoryError {
    /// Creates the `UnshareDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UnshareDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryNotSharedException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidTargetException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UnshareDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `UnshareDirectoryError::DirectoryNotSharedException`.
    pub fn is_directory_not_shared_exception(&self) -> bool {
        matches!(self, Self::DirectoryNotSharedException(_))
    }
    /// Returns `true` if the error kind is `UnshareDirectoryError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UnshareDirectoryError::InvalidTargetException`.
    pub fn is_invalid_target_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetException(_))
    }
    /// Returns `true` if the error kind is `UnshareDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for UnshareDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryNotSharedException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidTargetException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified shared target is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidTargetException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetException`](crate::error::InvalidTargetException).
    pub fn builder() -> crate::error::invalid_target_exception::Builder {
        crate::error::invalid_target_exception::Builder::default()
    }
}
/// See [`InvalidTargetException`](crate::error::InvalidTargetException).
pub mod invalid_target_exception {

    /// A builder for [`InvalidTargetException`](crate::error::InvalidTargetException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetException`](crate::error::InvalidTargetException).
        pub fn build(self) -> crate::error::InvalidTargetException {
            crate::error::InvalidTargetException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTargetException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetException")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified directory has not been shared with this Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryNotSharedException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryNotSharedException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryNotSharedException {
    /// Creates a new builder-style object to manufacture [`DirectoryNotSharedException`](crate::error::DirectoryNotSharedException).
    pub fn builder() -> crate::error::directory_not_shared_exception::Builder {
        crate::error::directory_not_shared_exception::Builder::default()
    }
}
/// See [`DirectoryNotSharedException`](crate::error::DirectoryNotSharedException).
pub mod directory_not_shared_exception {

    /// A builder for [`DirectoryNotSharedException`](crate::error::DirectoryNotSharedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryNotSharedException`](crate::error::DirectoryNotSharedException).
        pub fn build(self) -> crate::error::DirectoryNotSharedException {
            crate::error::DirectoryNotSharedException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryNotSharedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryNotSharedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryNotSharedException")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryNotSharedException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryNotSharedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryNotSharedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type StartSchemaExtensionErrorKind = StartSchemaExtensionError;
/// Error type for the `StartSchemaExtensionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSchemaExtensionError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
    SnapshotLimitExceededException(crate::error::SnapshotLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StartSchemaExtensionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for StartSchemaExtensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::SnapshotLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StartSchemaExtensionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StartSchemaExtensionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartSchemaExtensionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSchemaExtensionError {
    /// Creates the `StartSchemaExtensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `StartSchemaExtensionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::SnapshotLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `StartSchemaExtensionError::SnapshotLimitExceededException`.
    pub fn is_snapshot_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::SnapshotLimitExceededException(_))
    }
}
impl std::error::Error for StartSchemaExtensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::SnapshotLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ShareDirectoryErrorKind = ShareDirectoryError;
/// Error type for the `ShareDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ShareDirectoryError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
    DirectoryAlreadySharedException(crate::error::DirectoryAlreadySharedException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The specified shared target is not valid.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>Exception encountered while trying to access your Amazon Web Services organization.</p>
    OrganizationsException(crate::error::OrganizationsException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum number of Amazon Web Services accounts that you can share with this directory has been reached.</p>
    ShareLimitExceededException(crate::error::ShareLimitExceededException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ShareDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ShareDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryAlreadySharedException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::InvalidTargetException(_inner) => _inner.fmt(f),
            Self::OrganizationsException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::ShareLimitExceededException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ShareDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryAlreadySharedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OrganizationsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ShareLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ShareDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ShareDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ShareDirectoryError {
    /// Creates the `ShareDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ShareDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryAlreadySharedException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::InvalidTargetException(e) => e.meta(),
            Self::OrganizationsException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::ShareLimitExceededException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::DirectoryAlreadySharedException`.
    pub fn is_directory_already_shared_exception(&self) -> bool {
        matches!(self, Self::DirectoryAlreadySharedException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::InvalidTargetException`.
    pub fn is_invalid_target_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::OrganizationsException`.
    pub fn is_organizations_exception(&self) -> bool {
        matches!(self, Self::OrganizationsException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::ShareLimitExceededException`.
    pub fn is_share_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::ShareLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `ShareDirectoryError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for ShareDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryAlreadySharedException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::InvalidTargetException(_inner) => Some(_inner),
            Self::OrganizationsException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::ShareLimitExceededException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of Amazon Web Services accounts that you can share with this directory has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShareLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ShareLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl ShareLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ShareLimitExceededException`](crate::error::ShareLimitExceededException).
    pub fn builder() -> crate::error::share_limit_exceeded_exception::Builder {
        crate::error::share_limit_exceeded_exception::Builder::default()
    }
}
/// See [`ShareLimitExceededException`](crate::error::ShareLimitExceededException).
pub mod share_limit_exceeded_exception {

    /// A builder for [`ShareLimitExceededException`](crate::error::ShareLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ShareLimitExceededException`](crate::error::ShareLimitExceededException).
        pub fn build(self) -> crate::error::ShareLimitExceededException {
            crate::error::ShareLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ShareLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ShareLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ShareLimitExceededException")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ShareLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::ShareLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ShareLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Exception encountered while trying to access your Amazon Web Services organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OrganizationsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl OrganizationsException {
    /// Creates a new builder-style object to manufacture [`OrganizationsException`](crate::error::OrganizationsException).
    pub fn builder() -> crate::error::organizations_exception::Builder {
        crate::error::organizations_exception::Builder::default()
    }
}
/// See [`OrganizationsException`](crate::error::OrganizationsException).
pub mod organizations_exception {

    /// A builder for [`OrganizationsException`](crate::error::OrganizationsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationsException`](crate::error::OrganizationsException).
        pub fn build(self) -> crate::error::OrganizationsException {
            crate::error::OrganizationsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OrganizationsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OrganizationsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OrganizationsException")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OrganizationsException {}
impl aws_http::request_id::RequestId for crate::error::OrganizationsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OrganizationsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryAlreadySharedException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryAlreadySharedException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryAlreadySharedException {
    /// Creates a new builder-style object to manufacture [`DirectoryAlreadySharedException`](crate::error::DirectoryAlreadySharedException).
    pub fn builder() -> crate::error::directory_already_shared_exception::Builder {
        crate::error::directory_already_shared_exception::Builder::default()
    }
}
/// See [`DirectoryAlreadySharedException`](crate::error::DirectoryAlreadySharedException).
pub mod directory_already_shared_exception {

    /// A builder for [`DirectoryAlreadySharedException`](crate::error::DirectoryAlreadySharedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryAlreadySharedException`](crate::error::DirectoryAlreadySharedException).
        pub fn build(self) -> crate::error::DirectoryAlreadySharedException {
            crate::error::DirectoryAlreadySharedException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryAlreadySharedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryAlreadySharedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryAlreadySharedException")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryAlreadySharedException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryAlreadySharedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryAlreadySharedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreFromSnapshotErrorKind = RestoreFromSnapshotError;
/// Error type for the `RestoreFromSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreFromSnapshotError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreFromSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreFromSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreFromSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreFromSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreFromSnapshotError {
    /// Creates the `RestoreFromSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreFromSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreFromSnapshotError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RestoreFromSnapshotError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RestoreFromSnapshotError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RestoreFromSnapshotError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for RestoreFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResetUserPasswordErrorKind = ResetUserPasswordError;
/// Error type for the `ResetUserPasswordError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetUserPasswordError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The new password provided by the user does not meet the password complexity requirements defined in your directory.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// <p>The user provided a username that does not exist in your directory.</p>
    UserDoesNotExistException(crate::error::UserDoesNotExistException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResetUserPasswordError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResetUserPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidPasswordException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::UserDoesNotExistException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResetUserPasswordError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPasswordException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UserDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResetUserPasswordError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResetUserPasswordError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetUserPasswordError {
    /// Creates the `ResetUserPasswordError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResetUserPasswordError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidPasswordException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::UserDoesNotExistException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::InvalidPasswordException`.
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(self, Self::InvalidPasswordException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
    /// Returns `true` if the error kind is `ResetUserPasswordError::UserDoesNotExistException`.
    pub fn is_user_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::UserDoesNotExistException(_))
    }
}
impl std::error::Error for ResetUserPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidPasswordException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::UserDoesNotExistException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The user provided a username that does not exist in your directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDoesNotExistException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UserDoesNotExistException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl UserDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`UserDoesNotExistException`](crate::error::UserDoesNotExistException).
    pub fn builder() -> crate::error::user_does_not_exist_exception::Builder {
        crate::error::user_does_not_exist_exception::Builder::default()
    }
}
/// See [`UserDoesNotExistException`](crate::error::UserDoesNotExistException).
pub mod user_does_not_exist_exception {

    /// A builder for [`UserDoesNotExistException`](crate::error::UserDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UserDoesNotExistException`](crate::error::UserDoesNotExistException).
        pub fn build(self) -> crate::error::UserDoesNotExistException {
            crate::error::UserDoesNotExistException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl UserDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserDoesNotExistException")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UserDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::UserDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UserDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The new password provided by the user does not meet the password complexity requirements defined in your directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPasswordException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPasswordException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidPasswordException {
    /// Creates a new builder-style object to manufacture [`InvalidPasswordException`](crate::error::InvalidPasswordException).
    pub fn builder() -> crate::error::invalid_password_exception::Builder {
        crate::error::invalid_password_exception::Builder::default()
    }
}
/// See [`InvalidPasswordException`](crate::error::InvalidPasswordException).
pub mod invalid_password_exception {

    /// A builder for [`InvalidPasswordException`](crate::error::InvalidPasswordException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPasswordException`](crate::error::InvalidPasswordException).
        pub fn build(self) -> crate::error::InvalidPasswordException {
            crate::error::InvalidPasswordException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPasswordException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPasswordException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPasswordException")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPasswordException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPasswordException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPasswordException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveTagsFromResourceErrorKind = RemoveTagsFromResourceError;
/// Error type for the `RemoveTagsFromResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveTagsFromResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveTagsFromResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveTagsFromResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    /// Creates the `RemoveTagsFromResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveTagsFromResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveRegionErrorKind = RemoveRegionError;
/// Error type for the `RemoveRegionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRegionError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveRegionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveRegionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveRegionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveRegionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRegionError {
    /// Creates the `RemoveRegionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveRegionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveRegionError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `RemoveRegionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RemoveRegionError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RemoveRegionError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RemoveRegionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `RemoveRegionError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for RemoveRegionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveIpRoutesErrorKind = RemoveIpRoutesError;
/// Error type for the `RemoveIpRoutesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveIpRoutesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveIpRoutesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveIpRoutesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveIpRoutesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveIpRoutesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveIpRoutesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveIpRoutesError {
    /// Creates the `RemoveIpRoutesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveIpRoutesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveIpRoutesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RemoveIpRoutesError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RemoveIpRoutesError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RemoveIpRoutesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RemoveIpRoutesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for RemoveIpRoutesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RejectSharedDirectoryErrorKind = RejectSharedDirectoryError;
/// Error type for the `RejectSharedDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectSharedDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
    DirectoryAlreadySharedException(crate::error::DirectoryAlreadySharedException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RejectSharedDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RejectSharedDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryAlreadySharedException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RejectSharedDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryAlreadySharedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RejectSharedDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RejectSharedDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectSharedDirectoryError {
    /// Creates the `RejectSharedDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RejectSharedDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryAlreadySharedException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RejectSharedDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RejectSharedDirectoryError::DirectoryAlreadySharedException`.
    pub fn is_directory_already_shared_exception(&self) -> bool {
        matches!(self, Self::DirectoryAlreadySharedException(_))
    }
    /// Returns `true` if the error kind is `RejectSharedDirectoryError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RejectSharedDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RejectSharedDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for RejectSharedDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryAlreadySharedException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RegisterEventTopicErrorKind = RegisterEventTopicError;
/// Error type for the `RegisterEventTopicError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterEventTopicError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterEventTopicError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RegisterEventTopicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterEventTopicError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterEventTopicError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterEventTopicError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterEventTopicError {
    /// Creates the `RegisterEventTopicError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RegisterEventTopicError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterEventTopicError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RegisterEventTopicError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RegisterEventTopicError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RegisterEventTopicError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for RegisterEventTopicError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RegisterCertificateErrorKind = RegisterCertificateError;
/// Error type for the `RegisterCertificateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterCertificateError {
    /// <p>The certificate has already been registered into the system.</p>
    CertificateAlreadyExistsException(crate::error::CertificateAlreadyExistsException),
    /// <p>The certificate could not be added because the certificate limit has been reached.</p>
    CertificateLimitExceededException(crate::error::CertificateLimitExceededException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The certificate PEM that was provided has incorrect encoding.</p>
    InvalidCertificateException(crate::error::InvalidCertificateException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterCertificateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RegisterCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CertificateAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::CertificateLimitExceededException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCertificateException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterCertificateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CertificateAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CertificateLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCertificateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterCertificateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterCertificateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterCertificateError {
    /// Creates the `RegisterCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RegisterCertificateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CertificateAlreadyExistsException(e) => e.meta(),
            Self::CertificateLimitExceededException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::InvalidCertificateException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::CertificateAlreadyExistsException`.
    pub fn is_certificate_already_exists_exception(&self) -> bool {
        matches!(self, Self::CertificateAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::CertificateLimitExceededException`.
    pub fn is_certificate_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CertificateLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::InvalidCertificateException`.
    pub fn is_invalid_certificate_exception(&self) -> bool {
        matches!(self, Self::InvalidCertificateException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `RegisterCertificateError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for RegisterCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CertificateAlreadyExistsException(_inner) => Some(_inner),
            Self::CertificateLimitExceededException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::InvalidCertificateException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The certificate PEM that was provided has incorrect encoding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCertificateException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCertificateException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidCertificateException {
    /// Creates a new builder-style object to manufacture [`InvalidCertificateException`](crate::error::InvalidCertificateException).
    pub fn builder() -> crate::error::invalid_certificate_exception::Builder {
        crate::error::invalid_certificate_exception::Builder::default()
    }
}
/// See [`InvalidCertificateException`](crate::error::InvalidCertificateException).
pub mod invalid_certificate_exception {

    /// A builder for [`InvalidCertificateException`](crate::error::InvalidCertificateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCertificateException`](crate::error::InvalidCertificateException).
        pub fn build(self) -> crate::error::InvalidCertificateException {
            crate::error::InvalidCertificateException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidCertificateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCertificateException")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCertificateException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCertificateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCertificateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The certificate could not be added because the certificate limit has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CertificateLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl CertificateLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CertificateLimitExceededException`](crate::error::CertificateLimitExceededException).
    pub fn builder() -> crate::error::certificate_limit_exceeded_exception::Builder {
        crate::error::certificate_limit_exceeded_exception::Builder::default()
    }
}
/// See [`CertificateLimitExceededException`](crate::error::CertificateLimitExceededException).
pub mod certificate_limit_exceeded_exception {

    /// A builder for [`CertificateLimitExceededException`](crate::error::CertificateLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CertificateLimitExceededException`](crate::error::CertificateLimitExceededException).
        pub fn build(self) -> crate::error::CertificateLimitExceededException {
            crate::error::CertificateLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CertificateLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateLimitExceededException")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CertificateLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::CertificateLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CertificateLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The certificate has already been registered into the system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateAlreadyExistsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CertificateAlreadyExistsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl CertificateAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`CertificateAlreadyExistsException`](crate::error::CertificateAlreadyExistsException).
    pub fn builder() -> crate::error::certificate_already_exists_exception::Builder {
        crate::error::certificate_already_exists_exception::Builder::default()
    }
}
/// See [`CertificateAlreadyExistsException`](crate::error::CertificateAlreadyExistsException).
pub mod certificate_already_exists_exception {

    /// A builder for [`CertificateAlreadyExistsException`](crate::error::CertificateAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CertificateAlreadyExistsException`](crate::error::CertificateAlreadyExistsException).
        pub fn build(self) -> crate::error::CertificateAlreadyExistsException {
            crate::error::CertificateAlreadyExistsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CertificateAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateAlreadyExistsException")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CertificateAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::CertificateAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CertificateAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The <code>NextToken</code> value is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNextTokenException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidNextTokenException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
pub mod invalid_next_token_exception {

    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidNextTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidNextTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListSchemaExtensionsErrorKind = ListSchemaExtensionsError;
/// Error type for the `ListSchemaExtensionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSchemaExtensionsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListSchemaExtensionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListSchemaExtensionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListSchemaExtensionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListSchemaExtensionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListSchemaExtensionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSchemaExtensionsError {
    /// Creates the `ListSchemaExtensionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListSchemaExtensionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListSchemaExtensionsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ListSchemaExtensionsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListSchemaExtensionsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListSchemaExtensionsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for ListSchemaExtensionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListLogSubscriptionsErrorKind = ListLogSubscriptionsError;
/// Error type for the `ListLogSubscriptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLogSubscriptionsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListLogSubscriptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListLogSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListLogSubscriptionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListLogSubscriptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListLogSubscriptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLogSubscriptionsError {
    /// Creates the `ListLogSubscriptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListLogSubscriptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListLogSubscriptionsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ListLogSubscriptionsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListLogSubscriptionsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListLogSubscriptionsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for ListLogSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListIpRoutesErrorKind = ListIpRoutesError;
/// Error type for the `ListIpRoutesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIpRoutesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListIpRoutesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListIpRoutesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListIpRoutesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListIpRoutesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListIpRoutesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIpRoutesError {
    /// Creates the `ListIpRoutesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListIpRoutesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListIpRoutesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ListIpRoutesError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListIpRoutesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListIpRoutesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListIpRoutesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for ListIpRoutesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListCertificatesErrorKind = ListCertificatesError;
/// Error type for the `ListCertificatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificatesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListCertificatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListCertificatesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListCertificatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCertificatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificatesError {
    /// Creates the `ListCertificatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListCertificatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListCertificatesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ListCertificatesError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListCertificatesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListCertificatesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ListCertificatesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `ListCertificatesError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for ListCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetSnapshotLimitsErrorKind = GetSnapshotLimitsError;
/// Error type for the `GetSnapshotLimitsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSnapshotLimitsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetSnapshotLimitsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetSnapshotLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetSnapshotLimitsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetSnapshotLimitsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetSnapshotLimitsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSnapshotLimitsError {
    /// Creates the `GetSnapshotLimitsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetSnapshotLimitsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetSnapshotLimitsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `GetSnapshotLimitsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetSnapshotLimitsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for GetSnapshotLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDirectoryLimitsErrorKind = GetDirectoryLimitsError;
/// Error type for the `GetDirectoryLimitsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDirectoryLimitsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDirectoryLimitsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDirectoryLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDirectoryLimitsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDirectoryLimitsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDirectoryLimitsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDirectoryLimitsError {
    /// Creates the `GetDirectoryLimitsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDirectoryLimitsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDirectoryLimitsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `GetDirectoryLimitsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDirectoryLimitsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for GetDirectoryLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableSsoErrorKind = EnableSsoError;
/// Error type for the `EnableSsoError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableSsoError {
    /// <p>An authentication error occurred.</p>
    AuthenticationFailedException(crate::error::AuthenticationFailedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The account does not have sufficient permission to perform the operation.</p>
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableSsoError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableSsoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationFailedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableSsoError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientPermissionsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableSsoError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableSsoError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableSsoError {
    /// Creates the `EnableSsoError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableSsoError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationFailedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InsufficientPermissionsException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableSsoError::AuthenticationFailedException`.
    pub fn is_authentication_failed_exception(&self) -> bool {
        matches!(self, Self::AuthenticationFailedException(_))
    }
    /// Returns `true` if the error kind is `EnableSsoError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `EnableSsoError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `EnableSsoError::InsufficientPermissionsException`.
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(self, Self::InsufficientPermissionsException(_))
    }
    /// Returns `true` if the error kind is `EnableSsoError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for EnableSsoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationFailedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InsufficientPermissionsException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The account does not have sufficient permission to perform the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientPermissionsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientPermissionsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InsufficientPermissionsException {
    /// Creates a new builder-style object to manufacture [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException).
    pub fn builder() -> crate::error::insufficient_permissions_exception::Builder {
        crate::error::insufficient_permissions_exception::Builder::default()
    }
}
/// See [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException).
pub mod insufficient_permissions_exception {

    /// A builder for [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientPermissionsException`](crate::error::InsufficientPermissionsException).
        pub fn build(self) -> crate::error::InsufficientPermissionsException {
            crate::error::InsufficientPermissionsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InsufficientPermissionsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientPermissionsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientPermissionsException")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientPermissionsException {}
impl aws_http::request_id::RequestId for crate::error::InsufficientPermissionsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InsufficientPermissionsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An authentication error occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationFailedException {
    /// <p>The textual message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The identifier of the request that caused the exception.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthenticationFailedException {
    /// <p>The identifier of the request that caused the exception.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl AuthenticationFailedException {
    /// Creates a new builder-style object to manufacture [`AuthenticationFailedException`](crate::error::AuthenticationFailedException).
    pub fn builder() -> crate::error::authentication_failed_exception::Builder {
        crate::error::authentication_failed_exception::Builder::default()
    }
}
/// See [`AuthenticationFailedException`](crate::error::AuthenticationFailedException).
pub mod authentication_failed_exception {

    /// A builder for [`AuthenticationFailedException`](crate::error::AuthenticationFailedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The textual message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The textual message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The identifier of the request that caused the exception.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The identifier of the request that caused the exception.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationFailedException`](crate::error::AuthenticationFailedException).
        pub fn build(self) -> crate::error::AuthenticationFailedException {
            crate::error::AuthenticationFailedException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl AuthenticationFailedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthenticationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthenticationFailedException")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthenticationFailedException {}
impl aws_http::request_id::RequestId for crate::error::AuthenticationFailedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthenticationFailedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableRadiusErrorKind = EnableRadiusError;
/// Error type for the `EnableRadiusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableRadiusError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableRadiusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableRadiusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableRadiusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableRadiusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableRadiusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableRadiusError {
    /// Creates the `EnableRadiusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableRadiusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableRadiusError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `EnableRadiusError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `EnableRadiusError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `EnableRadiusError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `EnableRadiusError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for EnableRadiusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified entity already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityAlreadyExistsException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EntityAlreadyExistsException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl EntityAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
    pub fn builder() -> crate::error::entity_already_exists_exception::Builder {
        crate::error::entity_already_exists_exception::Builder::default()
    }
}
/// See [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
pub mod entity_already_exists_exception {

    /// A builder for [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EntityAlreadyExistsException`](crate::error::EntityAlreadyExistsException).
        pub fn build(self) -> crate::error::EntityAlreadyExistsException {
            crate::error::EntityAlreadyExistsException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EntityAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntityAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntityAlreadyExistsException")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EntityAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::EntityAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EntityAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableLDAPSErrorKind = EnableLDAPSError;
/// Error type for the `EnableLDAPSError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableLDAPSError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The LDAP activities could not be performed because they are limited by the LDAPS status.</p>
    InvalidLdapsStatusException(crate::error::InvalidLdapsStatusException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>Client authentication setup could not be completed because at least one valid certificate must be registered in the system.</p>
    NoAvailableCertificateException(crate::error::NoAvailableCertificateException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableLDAPSError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableLDAPSError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidLdapsStatusException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::NoAvailableCertificateException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableLDAPSError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLdapsStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoAvailableCertificateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableLDAPSError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableLDAPSError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableLDAPSError {
    /// Creates the `EnableLDAPSError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableLDAPSError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::InvalidLdapsStatusException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::NoAvailableCertificateException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::InvalidLdapsStatusException`.
    pub fn is_invalid_ldaps_status_exception(&self) -> bool {
        matches!(self, Self::InvalidLdapsStatusException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::NoAvailableCertificateException`.
    pub fn is_no_available_certificate_exception(&self) -> bool {
        matches!(self, Self::NoAvailableCertificateException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `EnableLDAPSError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for EnableLDAPSError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::InvalidLdapsStatusException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::NoAvailableCertificateException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Client authentication setup could not be completed because at least one valid certificate must be registered in the system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoAvailableCertificateException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoAvailableCertificateException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl NoAvailableCertificateException {
    /// Creates a new builder-style object to manufacture [`NoAvailableCertificateException`](crate::error::NoAvailableCertificateException).
    pub fn builder() -> crate::error::no_available_certificate_exception::Builder {
        crate::error::no_available_certificate_exception::Builder::default()
    }
}
/// See [`NoAvailableCertificateException`](crate::error::NoAvailableCertificateException).
pub mod no_available_certificate_exception {

    /// A builder for [`NoAvailableCertificateException`](crate::error::NoAvailableCertificateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoAvailableCertificateException`](crate::error::NoAvailableCertificateException).
        pub fn build(self) -> crate::error::NoAvailableCertificateException {
            crate::error::NoAvailableCertificateException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoAvailableCertificateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoAvailableCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoAvailableCertificateException")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoAvailableCertificateException {}
impl aws_http::request_id::RequestId for crate::error::NoAvailableCertificateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoAvailableCertificateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The LDAP activities could not be performed because they are limited by the LDAPS status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLdapsStatusException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLdapsStatusException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidLdapsStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidLdapsStatusException`](crate::error::InvalidLdapsStatusException).
    pub fn builder() -> crate::error::invalid_ldaps_status_exception::Builder {
        crate::error::invalid_ldaps_status_exception::Builder::default()
    }
}
/// See [`InvalidLdapsStatusException`](crate::error::InvalidLdapsStatusException).
pub mod invalid_ldaps_status_exception {

    /// A builder for [`InvalidLdapsStatusException`](crate::error::InvalidLdapsStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLdapsStatusException`](crate::error::InvalidLdapsStatusException).
        pub fn build(self) -> crate::error::InvalidLdapsStatusException {
            crate::error::InvalidLdapsStatusException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidLdapsStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLdapsStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidLdapsStatusException [InvalidLDAPSStatusException]"
        )?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLdapsStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidLdapsStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidLdapsStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableClientAuthenticationErrorKind = EnableClientAuthenticationError;
/// Error type for the `EnableClientAuthenticationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableClientAuthenticationError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>Client authentication is already enabled.</p>
    InvalidClientAuthStatusException(crate::error::InvalidClientAuthStatusException),
    /// <p>Client authentication setup could not be completed because at least one valid certificate must be registered in the system.</p>
    NoAvailableCertificateException(crate::error::NoAvailableCertificateException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableClientAuthenticationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableClientAuthenticationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidClientAuthStatusException(_inner) => _inner.fmt(f),
            Self::NoAvailableCertificateException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableClientAuthenticationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientAuthStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoAvailableCertificateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableClientAuthenticationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableClientAuthenticationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableClientAuthenticationError {
    /// Creates the `EnableClientAuthenticationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableClientAuthenticationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidClientAuthStatusException(e) => e.meta(),
            Self::NoAvailableCertificateException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::InvalidClientAuthStatusException`.
    pub fn is_invalid_client_auth_status_exception(&self) -> bool {
        matches!(self, Self::InvalidClientAuthStatusException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::NoAvailableCertificateException`.
    pub fn is_no_available_certificate_exception(&self) -> bool {
        matches!(self, Self::NoAvailableCertificateException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `EnableClientAuthenticationError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for EnableClientAuthenticationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidClientAuthStatusException(_inner) => Some(_inner),
            Self::NoAvailableCertificateException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Client authentication is already enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClientAuthStatusException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClientAuthStatusException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl InvalidClientAuthStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidClientAuthStatusException`](crate::error::InvalidClientAuthStatusException).
    pub fn builder() -> crate::error::invalid_client_auth_status_exception::Builder {
        crate::error::invalid_client_auth_status_exception::Builder::default()
    }
}
/// See [`InvalidClientAuthStatusException`](crate::error::InvalidClientAuthStatusException).
pub mod invalid_client_auth_status_exception {

    /// A builder for [`InvalidClientAuthStatusException`](crate::error::InvalidClientAuthStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClientAuthStatusException`](crate::error::InvalidClientAuthStatusException).
        pub fn build(self) -> crate::error::InvalidClientAuthStatusException {
            crate::error::InvalidClientAuthStatusException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidClientAuthStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClientAuthStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClientAuthStatusException")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClientAuthStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidClientAuthStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClientAuthStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableSsoErrorKind = DisableSsoError;
/// Error type for the `DisableSsoError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableSsoError {
    /// <p>An authentication error occurred.</p>
    AuthenticationFailedException(crate::error::AuthenticationFailedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The account does not have sufficient permission to perform the operation.</p>
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableSsoError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableSsoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationFailedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableSsoError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientPermissionsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableSsoError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableSsoError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableSsoError {
    /// Creates the `DisableSsoError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableSsoError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationFailedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InsufficientPermissionsException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableSsoError::AuthenticationFailedException`.
    pub fn is_authentication_failed_exception(&self) -> bool {
        matches!(self, Self::AuthenticationFailedException(_))
    }
    /// Returns `true` if the error kind is `DisableSsoError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DisableSsoError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisableSsoError::InsufficientPermissionsException`.
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(self, Self::InsufficientPermissionsException(_))
    }
    /// Returns `true` if the error kind is `DisableSsoError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DisableSsoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationFailedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InsufficientPermissionsException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableRadiusErrorKind = DisableRadiusError;
/// Error type for the `DisableRadiusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableRadiusError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableRadiusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableRadiusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableRadiusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableRadiusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableRadiusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableRadiusError {
    /// Creates the `DisableRadiusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableRadiusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableRadiusError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DisableRadiusError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisableRadiusError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DisableRadiusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableLDAPSErrorKind = DisableLDAPSError;
/// Error type for the `DisableLDAPSError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableLDAPSError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The LDAP activities could not be performed because they are limited by the LDAPS status.</p>
    InvalidLdapsStatusException(crate::error::InvalidLdapsStatusException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableLDAPSError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableLDAPSError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidLdapsStatusException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableLDAPSError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLdapsStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableLDAPSError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableLDAPSError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableLDAPSError {
    /// Creates the `DisableLDAPSError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableLDAPSError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::InvalidLdapsStatusException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::InvalidLdapsStatusException`.
    pub fn is_invalid_ldaps_status_exception(&self) -> bool {
        matches!(self, Self::InvalidLdapsStatusException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DisableLDAPSError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DisableLDAPSError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::InvalidLdapsStatusException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableClientAuthenticationErrorKind = DisableClientAuthenticationError;
/// Error type for the `DisableClientAuthenticationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableClientAuthenticationError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>Client authentication is already enabled.</p>
    InvalidClientAuthStatusException(crate::error::InvalidClientAuthStatusException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableClientAuthenticationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableClientAuthenticationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidClientAuthStatusException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableClientAuthenticationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientAuthStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableClientAuthenticationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableClientAuthenticationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableClientAuthenticationError {
    /// Creates the `DisableClientAuthenticationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableClientAuthenticationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidClientAuthStatusException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::InvalidClientAuthStatusException`.
    pub fn is_invalid_client_auth_status_exception(&self) -> bool {
        matches!(self, Self::InvalidClientAuthStatusException(_))
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DisableClientAuthenticationError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DisableClientAuthenticationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidClientAuthStatusException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeUpdateDirectoryErrorKind = DescribeUpdateDirectoryError;
/// Error type for the `DescribeUpdateDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUpdateDirectoryError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeUpdateDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeUpdateDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeUpdateDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeUpdateDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeUpdateDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUpdateDirectoryError {
    /// Creates the `DescribeUpdateDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeUpdateDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeUpdateDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DescribeUpdateDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeTrustsErrorKind = DescribeTrustsError;
/// Error type for the `DescribeTrustsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTrustsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeTrustsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeTrustsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeTrustsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeTrustsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeTrustsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTrustsError {
    /// Creates the `DescribeTrustsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeTrustsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeTrustsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeTrustsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSnapshotsErrorKind = DescribeSnapshotsError;
/// Error type for the `DescribeSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotsError {
    /// Creates the `DescribeSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DescribeSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSharedDirectoriesErrorKind = DescribeSharedDirectoriesError;
/// Error type for the `DescribeSharedDirectoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSharedDirectoriesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSharedDirectoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSharedDirectoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSharedDirectoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSharedDirectoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSharedDirectoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSharedDirectoriesError {
    /// Creates the `DescribeSharedDirectoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSharedDirectoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeSharedDirectoriesError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeSharedDirectoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSettingsErrorKind = DescribeSettingsError;
/// Error type for the `DescribeSettingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSettingsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSettingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSettingsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSettingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSettingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSettingsError {
    /// Creates the `DescribeSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSettingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeSettingsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeRegionsErrorKind = DescribeRegionsError;
/// Error type for the `DescribeRegionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRegionsError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeRegionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeRegionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeRegionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeRegionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRegionsError {
    /// Creates the `DescribeRegionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeRegionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeRegionsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeLDAPSSettingsErrorKind = DescribeLDAPSSettingsError;
/// Error type for the `DescribeLDAPSSettingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLDAPSSettingsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeLDAPSSettingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeLDAPSSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeLDAPSSettingsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeLDAPSSettingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeLDAPSSettingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLDAPSSettingsError {
    /// Creates the `DescribeLDAPSSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeLDAPSSettingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeLDAPSSettingsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeLDAPSSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventTopicsErrorKind = DescribeEventTopicsError;
/// Error type for the `DescribeEventTopicsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventTopicsError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventTopicsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventTopicsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventTopicsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventTopicsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventTopicsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventTopicsError {
    /// Creates the `DescribeEventTopicsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventTopicsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEventTopicsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeEventTopicsError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeEventTopicsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeEventTopicsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DescribeEventTopicsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDomainControllersErrorKind = DescribeDomainControllersError;
/// Error type for the `DescribeDomainControllersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainControllersError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDomainControllersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDomainControllersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDomainControllersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDomainControllersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDomainControllersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainControllersError {
    /// Creates the `DescribeDomainControllersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDomainControllersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainControllersError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeDomainControllersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDirectoriesErrorKind = DescribeDirectoriesError;
/// Error type for the `DescribeDirectoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDirectoriesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDirectoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDirectoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDirectoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDirectoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDirectoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDirectoriesError {
    /// Creates the `DescribeDirectoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDirectoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDirectoriesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeDirectoriesError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeDirectoriesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeDirectoriesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeDirectoriesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DescribeDirectoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeConditionalForwardersErrorKind = DescribeConditionalForwardersError;
/// Error type for the `DescribeConditionalForwardersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConditionalForwardersError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeConditionalForwardersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeConditionalForwardersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeConditionalForwardersError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeConditionalForwardersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeConditionalForwardersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConditionalForwardersError {
    /// Creates the `DescribeConditionalForwardersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeConditionalForwardersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeConditionalForwardersError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeConditionalForwardersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClientAuthenticationSettingsErrorKind = DescribeClientAuthenticationSettingsError;
/// Error type for the `DescribeClientAuthenticationSettingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClientAuthenticationSettingsError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClientAuthenticationSettingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClientAuthenticationSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeClientAuthenticationSettingsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClientAuthenticationSettingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClientAuthenticationSettingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClientAuthenticationSettingsError {
    /// Creates the `DescribeClientAuthenticationSettingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClientAuthenticationSettingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeClientAuthenticationSettingsError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeClientAuthenticationSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeCertificateErrorKind = DescribeCertificateError;
/// Error type for the `DescribeCertificateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificateError {
    /// <p>The certificate is not present in the system for describe or deregister activities.</p>
    CertificateDoesNotExistException(crate::error::CertificateDoesNotExistException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeCertificateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CertificateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeCertificateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CertificateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeCertificateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCertificateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificateError {
    /// Creates the `DescribeCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeCertificateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CertificateDoesNotExistException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::CertificateDoesNotExistException`.
    pub fn is_certificate_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CertificateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DescribeCertificateError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DescribeCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CertificateDoesNotExistException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The certificate is not present in the system for describe or deregister activities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateDoesNotExistException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CertificateDoesNotExistException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl CertificateDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CertificateDoesNotExistException`](crate::error::CertificateDoesNotExistException).
    pub fn builder() -> crate::error::certificate_does_not_exist_exception::Builder {
        crate::error::certificate_does_not_exist_exception::Builder::default()
    }
}
/// See [`CertificateDoesNotExistException`](crate::error::CertificateDoesNotExistException).
pub mod certificate_does_not_exist_exception {

    /// A builder for [`CertificateDoesNotExistException`](crate::error::CertificateDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CertificateDoesNotExistException`](crate::error::CertificateDoesNotExistException).
        pub fn build(self) -> crate::error::CertificateDoesNotExistException {
            crate::error::CertificateDoesNotExistException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CertificateDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateDoesNotExistException")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CertificateDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::CertificateDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CertificateDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeregisterEventTopicErrorKind = DeregisterEventTopicError;
/// Error type for the `DeregisterEventTopicError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterEventTopicError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeregisterEventTopicError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeregisterEventTopicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeregisterEventTopicError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeregisterEventTopicError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeregisterEventTopicError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterEventTopicError {
    /// Creates the `DeregisterEventTopicError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeregisterEventTopicError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeregisterEventTopicError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeregisterEventTopicError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeregisterEventTopicError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DeregisterEventTopicError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DeregisterEventTopicError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeregisterCertificateErrorKind = DeregisterCertificateError;
/// Error type for the `DeregisterCertificateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterCertificateError {
    /// <p>The certificate is not present in the system for describe or deregister activities.</p>
    CertificateDoesNotExistException(crate::error::CertificateDoesNotExistException),
    /// <p>The certificate is being used for the LDAP security connection and cannot be removed without disabling LDAP security.</p>
    CertificateInUseException(crate::error::CertificateInUseException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeregisterCertificateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeregisterCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CertificateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CertificateInUseException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeregisterCertificateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CertificateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CertificateInUseException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeregisterCertificateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeregisterCertificateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterCertificateError {
    /// Creates the `DeregisterCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeregisterCertificateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CertificateDoesNotExistException(e) => e.meta(),
            Self::CertificateInUseException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::CertificateDoesNotExistException`.
    pub fn is_certificate_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CertificateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::CertificateInUseException`.
    pub fn is_certificate_in_use_exception(&self) -> bool {
        matches!(self, Self::CertificateInUseException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DeregisterCertificateError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DeregisterCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CertificateDoesNotExistException(_inner) => Some(_inner),
            Self::CertificateInUseException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The certificate is being used for the LDAP security connection and cannot be removed without disabling LDAP security.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateInUseException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CertificateInUseException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl CertificateInUseException {
    /// Creates a new builder-style object to manufacture [`CertificateInUseException`](crate::error::CertificateInUseException).
    pub fn builder() -> crate::error::certificate_in_use_exception::Builder {
        crate::error::certificate_in_use_exception::Builder::default()
    }
}
/// See [`CertificateInUseException`](crate::error::CertificateInUseException).
pub mod certificate_in_use_exception {

    /// A builder for [`CertificateInUseException`](crate::error::CertificateInUseException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CertificateInUseException`](crate::error::CertificateInUseException).
        pub fn build(self) -> crate::error::CertificateInUseException {
            crate::error::CertificateInUseException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CertificateInUseException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateInUseException")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CertificateInUseException {}
impl aws_http::request_id::RequestId for crate::error::CertificateInUseException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CertificateInUseException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteTrustErrorKind = DeleteTrustError;
/// Error type for the `DeleteTrustError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTrustError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteTrustError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteTrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteTrustError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteTrustError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTrustError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTrustError {
    /// Creates the `DeleteTrustError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteTrustError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteTrustError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteTrustError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteTrustError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DeleteTrustError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DeleteTrustError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DeleteTrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSnapshotErrorKind = DeleteSnapshotError;
/// Error type for the `DeleteSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotError {
    /// Creates the `DeleteSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DeleteSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteLogSubscriptionErrorKind = DeleteLogSubscriptionError;
/// Error type for the `DeleteLogSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLogSubscriptionError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteLogSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteLogSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteLogSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteLogSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteLogSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLogSubscriptionError {
    /// Creates the `DeleteLogSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteLogSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteLogSubscriptionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteLogSubscriptionError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteLogSubscriptionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DeleteLogSubscriptionError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DeleteLogSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDirectoryErrorKind = DeleteDirectoryError;
/// Error type for the `DeleteDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDirectoryError {
    /// Creates the `DeleteDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteDirectoryError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for DeleteDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteConditionalForwarderErrorKind = DeleteConditionalForwarderError;
/// Error type for the `DeleteConditionalForwarderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConditionalForwarderError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteConditionalForwarderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteConditionalForwarderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteConditionalForwarderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteConditionalForwarderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteConditionalForwarderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConditionalForwarderError {
    /// Creates the `DeleteConditionalForwarderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteConditionalForwarderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `DeleteConditionalForwarderError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for DeleteConditionalForwarderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateTrustErrorKind = CreateTrustError;
/// Error type for the `CreateTrustError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTrustError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateTrustError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateTrustError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateTrustError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateTrustError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTrustError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTrustError {
    /// Creates the `CreateTrustError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateTrustError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateTrustError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateTrustError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateTrustError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateTrustError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateTrustError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateTrustError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for CreateTrustError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSnapshotErrorKind = CreateSnapshotError;
/// Error type for the `CreateSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
    SnapshotLimitExceededException(crate::error::SnapshotLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::SnapshotLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotError {
    /// Creates the `CreateSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::SnapshotLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::SnapshotLimitExceededException`.
    pub fn is_snapshot_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::SnapshotLimitExceededException(_))
    }
}
impl std::error::Error for CreateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::SnapshotLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateMicrosoftADErrorKind = CreateMicrosoftADError;
/// Error type for the `CreateMicrosoftADError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMicrosoftADError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
    DirectoryLimitExceededException(crate::error::DirectoryLimitExceededException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateMicrosoftADError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateMicrosoftADError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateMicrosoftADError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateMicrosoftADError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMicrosoftADError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMicrosoftADError {
    /// Creates the `CreateMicrosoftADError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateMicrosoftADError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryLimitExceededException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateMicrosoftADError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateMicrosoftADError::DirectoryLimitExceededException`.
    pub fn is_directory_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DirectoryLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateMicrosoftADError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateMicrosoftADError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateMicrosoftADError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for CreateMicrosoftADError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryLimitExceededException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryLimitExceededException {
    /// Creates a new builder-style object to manufacture [`DirectoryLimitExceededException`](crate::error::DirectoryLimitExceededException).
    pub fn builder() -> crate::error::directory_limit_exceeded_exception::Builder {
        crate::error::directory_limit_exceeded_exception::Builder::default()
    }
}
/// See [`DirectoryLimitExceededException`](crate::error::DirectoryLimitExceededException).
pub mod directory_limit_exceeded_exception {

    /// A builder for [`DirectoryLimitExceededException`](crate::error::DirectoryLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryLimitExceededException`](crate::error::DirectoryLimitExceededException).
        pub fn build(self) -> crate::error::DirectoryLimitExceededException {
            crate::error::DirectoryLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryLimitExceededException")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateLogSubscriptionErrorKind = CreateLogSubscriptionError;
/// Error type for the `CreateLogSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLogSubscriptionError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The account does not have sufficient permission to perform the operation.</p>
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateLogSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateLogSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InsufficientPermissionsException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateLogSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientPermissionsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateLogSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateLogSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLogSubscriptionError {
    /// Creates the `CreateLogSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateLogSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InsufficientPermissionsException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::InsufficientPermissionsException`.
    pub fn is_insufficient_permissions_exception(&self) -> bool {
        matches!(self, Self::InsufficientPermissionsException(_))
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateLogSubscriptionError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for CreateLogSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InsufficientPermissionsException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDirectoryErrorKind = CreateDirectoryError;
/// Error type for the `CreateDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
    DirectoryLimitExceededException(crate::error::DirectoryLimitExceededException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDirectoryError {
    /// Creates the `CreateDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryLimitExceededException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateDirectoryError::DirectoryLimitExceededException`.
    pub fn is_directory_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DirectoryLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for CreateDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryLimitExceededException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateConditionalForwarderErrorKind = CreateConditionalForwarderError;
/// Error type for the `CreateConditionalForwarderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConditionalForwarderError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateConditionalForwarderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateConditionalForwarderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateConditionalForwarderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateConditionalForwarderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateConditionalForwarderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConditionalForwarderError {
    /// Creates the `CreateConditionalForwarderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateConditionalForwarderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateConditionalForwarderError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for CreateConditionalForwarderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateComputerErrorKind = CreateComputerError;
/// Error type for the `CreateComputerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateComputerError {
    /// <p>An authentication error occurred.</p>
    AuthenticationFailedException(crate::error::AuthenticationFailedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateComputerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateComputerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationFailedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateComputerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateComputerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateComputerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateComputerError {
    /// Creates the `CreateComputerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateComputerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationFailedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateComputerError::AuthenticationFailedException`.
    pub fn is_authentication_failed_exception(&self) -> bool {
        matches!(self, Self::AuthenticationFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateComputerError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for CreateComputerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationFailedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateAliasErrorKind = CreateAliasError;
/// Error type for the `CreateAliasError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAliasError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateAliasError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateAliasError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateAliasError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAliasError {
    /// Creates the `CreateAliasError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateAliasError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateAliasError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CreateAliasError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateAliasError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateAliasError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateAliasError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ConnectDirectoryErrorKind = ConnectDirectoryError;
/// Error type for the `ConnectDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConnectDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
    DirectoryLimitExceededException(crate::error::DirectoryLimitExceededException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ConnectDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ConnectDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ConnectDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ConnectDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ConnectDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConnectDirectoryError {
    /// Creates the `ConnectDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ConnectDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryLimitExceededException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ConnectDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `ConnectDirectoryError::DirectoryLimitExceededException`.
    pub fn is_directory_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DirectoryLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `ConnectDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `ConnectDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for ConnectDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryLimitExceededException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CancelSchemaExtensionErrorKind = CancelSchemaExtensionError;
/// Error type for the `CancelSchemaExtensionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelSchemaExtensionError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CancelSchemaExtensionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CancelSchemaExtensionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CancelSchemaExtensionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CancelSchemaExtensionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelSchemaExtensionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelSchemaExtensionError {
    /// Creates the `CancelSchemaExtensionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CancelSchemaExtensionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CancelSchemaExtensionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `CancelSchemaExtensionError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CancelSchemaExtensionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for CancelSchemaExtensionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddTagsToResourceErrorKind = AddTagsToResourceError;
/// Error type for the `AddTagsToResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddTagsToResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::TagLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddTagsToResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddTagsToResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    /// Creates the `AddTagsToResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddTagsToResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TagLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::TagLimitExceededException`.
    pub fn is_tag_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagLimitExceededException(_))
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::TagLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum allowed number of tags was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl TagLimitExceededException {
    /// Creates a new builder-style object to manufacture [`TagLimitExceededException`](crate::error::TagLimitExceededException).
    pub fn builder() -> crate::error::tag_limit_exceeded_exception::Builder {
        crate::error::tag_limit_exceeded_exception::Builder::default()
    }
}
/// See [`TagLimitExceededException`](crate::error::TagLimitExceededException).
pub mod tag_limit_exceeded_exception {

    /// A builder for [`TagLimitExceededException`](crate::error::TagLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagLimitExceededException`](crate::error::TagLimitExceededException).
        pub fn build(self) -> crate::error::TagLimitExceededException {
            crate::error::TagLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TagLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagLimitExceededException")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::TagLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddRegionErrorKind = AddRegionError;
/// Error type for the `AddRegionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRegionError {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The Region you specified is the same Region where the Managed Microsoft AD directory was created. Specify a different Region and try again.</p>
    DirectoryAlreadyInRegionException(crate::error::DirectoryAlreadyInRegionException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>You have reached the limit for maximum number of simultaneous Region replications per directory.</p>
    RegionLimitExceededException(crate::error::RegionLimitExceededException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddRegionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) => _inner.fmt(f),
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryAlreadyInRegionException(_inner) => _inner.fmt(f),
            Self::DirectoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::RegionLimitExceededException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddRegionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryAlreadyInRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RegionLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddRegionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddRegionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRegionError {
    /// Creates the `AddRegionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddRegionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::ClientException(e) => e.meta(),
            Self::DirectoryAlreadyInRegionException(e) => e.meta(),
            Self::DirectoryDoesNotExistException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::RegionLimitExceededException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::UnsupportedOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddRegionError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::DirectoryAlreadyInRegionException`.
    pub fn is_directory_already_in_region_exception(&self) -> bool {
        matches!(self, Self::DirectoryAlreadyInRegionException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::DirectoryDoesNotExistException`.
    pub fn is_directory_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DirectoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::RegionLimitExceededException`.
    pub fn is_region_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::RegionLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `AddRegionError::UnsupportedOperationException`.
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(self, Self::UnsupportedOperationException(_))
    }
}
impl std::error::Error for AddRegionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) => Some(_inner),
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryAlreadyInRegionException(_inner) => Some(_inner),
            Self::DirectoryDoesNotExistException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::RegionLimitExceededException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::UnsupportedOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have reached the limit for maximum number of simultaneous Region replications per directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegionLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RegionLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl RegionLimitExceededException {
    /// Creates a new builder-style object to manufacture [`RegionLimitExceededException`](crate::error::RegionLimitExceededException).
    pub fn builder() -> crate::error::region_limit_exceeded_exception::Builder {
        crate::error::region_limit_exceeded_exception::Builder::default()
    }
}
/// See [`RegionLimitExceededException`](crate::error::RegionLimitExceededException).
pub mod region_limit_exceeded_exception {

    /// A builder for [`RegionLimitExceededException`](crate::error::RegionLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RegionLimitExceededException`](crate::error::RegionLimitExceededException).
        pub fn build(self) -> crate::error::RegionLimitExceededException {
            crate::error::RegionLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RegionLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RegionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RegionLimitExceededException")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RegionLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::RegionLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegionLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The Region you specified is the same Region where the Managed Microsoft AD directory was created. Specify a different Region and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryAlreadyInRegionException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryAlreadyInRegionException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl DirectoryAlreadyInRegionException {
    /// Creates a new builder-style object to manufacture [`DirectoryAlreadyInRegionException`](crate::error::DirectoryAlreadyInRegionException).
    pub fn builder() -> crate::error::directory_already_in_region_exception::Builder {
        crate::error::directory_already_in_region_exception::Builder::default()
    }
}
/// See [`DirectoryAlreadyInRegionException`](crate::error::DirectoryAlreadyInRegionException).
pub mod directory_already_in_region_exception {

    /// A builder for [`DirectoryAlreadyInRegionException`](crate::error::DirectoryAlreadyInRegionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryAlreadyInRegionException`](crate::error::DirectoryAlreadyInRegionException).
        pub fn build(self) -> crate::error::DirectoryAlreadyInRegionException {
            crate::error::DirectoryAlreadyInRegionException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryAlreadyInRegionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryAlreadyInRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryAlreadyInRegionException")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryAlreadyInRegionException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryAlreadyInRegionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DirectoryAlreadyInRegionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddIpRoutesErrorKind = AddIpRoutesError;
/// Error type for the `AddIpRoutesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddIpRoutesError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.</p>
    IpRouteLimitExceededException(crate::error::IpRouteLimitExceededException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddIpRoutesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddIpRoutesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryUnavailableException(_inner) => _inner.fmt(f),
            Self::EntityAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::IpRouteLimitExceededException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddIpRoutesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IpRouteLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddIpRoutesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddIpRoutesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddIpRoutesError {
    /// Creates the `AddIpRoutesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddIpRoutesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryUnavailableException(e) => e.meta(),
            Self::EntityAlreadyExistsException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::IpRouteLimitExceededException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::DirectoryUnavailableException`.
    pub fn is_directory_unavailable_exception(&self) -> bool {
        matches!(self, Self::DirectoryUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::EntityAlreadyExistsException`.
    pub fn is_entity_already_exists_exception(&self) -> bool {
        matches!(self, Self::EntityAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::IpRouteLimitExceededException`.
    pub fn is_ip_route_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::IpRouteLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AddIpRoutesError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for AddIpRoutesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryUnavailableException(_inner) => Some(_inner),
            Self::EntityAlreadyExistsException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::IpRouteLimitExceededException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IpRouteLimitExceededException {
    /// <p>The descriptive message for the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services request identifier.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IpRouteLimitExceededException {
    /// <p>The Amazon Web Services request identifier.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
}
impl IpRouteLimitExceededException {
    /// Creates a new builder-style object to manufacture [`IpRouteLimitExceededException`](crate::error::IpRouteLimitExceededException).
    pub fn builder() -> crate::error::ip_route_limit_exceeded_exception::Builder {
        crate::error::ip_route_limit_exceeded_exception::Builder::default()
    }
}
/// See [`IpRouteLimitExceededException`](crate::error::IpRouteLimitExceededException).
pub mod ip_route_limit_exceeded_exception {

    /// A builder for [`IpRouteLimitExceededException`](crate::error::IpRouteLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The descriptive message for the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The descriptive message for the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services request identifier.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IpRouteLimitExceededException`](crate::error::IpRouteLimitExceededException).
        pub fn build(self) -> crate::error::IpRouteLimitExceededException {
            crate::error::IpRouteLimitExceededException {
                message: self.message,
                request_id: self.request_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IpRouteLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IpRouteLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IpRouteLimitExceededException")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IpRouteLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::IpRouteLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IpRouteLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AcceptSharedDirectoryErrorKind = AcceptSharedDirectoryError;
/// Error type for the `AcceptSharedDirectoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptSharedDirectoryError {
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
    DirectoryAlreadySharedException(crate::error::DirectoryAlreadySharedException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AcceptSharedDirectoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AcceptSharedDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientException(_inner) => _inner.fmt(f),
            Self::DirectoryAlreadySharedException(_inner) => _inner.fmt(f),
            Self::EntityDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidParameterException(_inner) => _inner.fmt(f),
            Self::ServiceException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AcceptSharedDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryAlreadySharedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EntityDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AcceptSharedDirectoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AcceptSharedDirectoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptSharedDirectoryError {
    /// Creates the `AcceptSharedDirectoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AcceptSharedDirectoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientException(e) => e.meta(),
            Self::DirectoryAlreadySharedException(e) => e.meta(),
            Self::EntityDoesNotExistException(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AcceptSharedDirectoryError::ClientException`.
    pub fn is_client_exception(&self) -> bool {
        matches!(self, Self::ClientException(_))
    }
    /// Returns `true` if the error kind is `AcceptSharedDirectoryError::DirectoryAlreadySharedException`.
    pub fn is_directory_already_shared_exception(&self) -> bool {
        matches!(self, Self::DirectoryAlreadySharedException(_))
    }
    /// Returns `true` if the error kind is `AcceptSharedDirectoryError::EntityDoesNotExistException`.
    pub fn is_entity_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::EntityDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AcceptSharedDirectoryError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `AcceptSharedDirectoryError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
}
impl std::error::Error for AcceptSharedDirectoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientException(_inner) => Some(_inner),
            Self::DirectoryAlreadySharedException(_inner) => Some(_inner),
            Self::EntityDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidParameterException(_inner) => Some(_inner),
            Self::ServiceException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
