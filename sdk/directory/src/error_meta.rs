// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An authentication error occurred.</p>
    AuthenticationFailedException(crate::error::AuthenticationFailedException),
    /// <p>The certificate has already been registered into the system.</p>
    CertificateAlreadyExistsException(crate::error::CertificateAlreadyExistsException),
    /// <p>The certificate is not present in the system for describe or deregister activities.</p>
    CertificateDoesNotExistException(crate::error::CertificateDoesNotExistException),
    /// <p>The certificate is being used for the LDAP security connection and cannot be removed without disabling LDAP security.</p>
    CertificateInUseException(crate::error::CertificateInUseException),
    /// <p>The certificate could not be added because the certificate limit has been reached.</p>
    CertificateLimitExceededException(crate::error::CertificateLimitExceededException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::error::ClientException),
    /// <p>The Region you specified is the same Region where the Managed Microsoft AD directory was created. Specify a different Region and try again.</p>
    DirectoryAlreadyInRegionException(crate::error::DirectoryAlreadyInRegionException),
    /// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
    DirectoryAlreadySharedException(crate::error::DirectoryAlreadySharedException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::error::DirectoryDoesNotExistException),
    /// <p> The directory is already updated to desired update type settings. </p>
    DirectoryInDesiredStateException(crate::error::DirectoryInDesiredStateException),
    /// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
    DirectoryLimitExceededException(crate::error::DirectoryLimitExceededException),
    /// <p>The specified directory has not been shared with this Amazon Web Services account.</p>
    DirectoryNotSharedException(crate::error::DirectoryNotSharedException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::error::DirectoryUnavailableException),
    /// <p>The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.</p>
    DomainControllerLimitExceededException(crate::error::DomainControllerLimitExceededException),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::error::EntityDoesNotExistException),
    /// <p>The specified directory setting is not compatible with other settings.</p>
    IncompatibleSettingsException(crate::error::IncompatibleSettingsException),
    /// <p>The account does not have sufficient permission to perform the operation.</p>
    InsufficientPermissionsException(crate::error::InsufficientPermissionsException),
    /// <p>The certificate PEM that was provided has incorrect encoding.</p>
    InvalidCertificateException(crate::error::InvalidCertificateException),
    /// <p>Client authentication is already enabled.</p>
    InvalidClientAuthStatusException(crate::error::InvalidClientAuthStatusException),
    /// <p>The LDAP activities could not be performed because they are limited by the LDAPS status.</p>
    InvalidLdapsStatusException(crate::error::InvalidLdapsStatusException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::error::InvalidParameterException),
    /// <p>The new password provided by the user does not meet the password complexity requirements defined in your directory.</p>
    InvalidPasswordException(crate::error::InvalidPasswordException),
    /// <p>The specified shared target is not valid.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.</p>
    IpRouteLimitExceededException(crate::error::IpRouteLimitExceededException),
    /// <p>Client authentication setup could not be completed because at least one valid certificate must be registered in the system.</p>
    NoAvailableCertificateException(crate::error::NoAvailableCertificateException),
    /// <p>Exception encountered while trying to access your Amazon Web Services organization.</p>
    OrganizationsException(crate::error::OrganizationsException),
    /// <p>You have reached the limit for maximum number of simultaneous Region replications per directory.</p>
    RegionLimitExceededException(crate::error::RegionLimitExceededException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::error::ServiceException),
    /// <p>The maximum number of Amazon Web Services accounts that you can share with this directory has been reached.</p>
    ShareLimitExceededException(crate::error::ShareLimitExceededException),
    /// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
    SnapshotLimitExceededException(crate::error::SnapshotLimitExceededException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// <p>The specified directory setting is not supported.</p>
    UnsupportedSettingsException(crate::error::UnsupportedSettingsException),
    /// <p>The user provided a username that does not exist in your directory.</p>
    UserDoesNotExistException(crate::error::UserDoesNotExistException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::AuthenticationFailedException(inner) => inner.fmt(f),
            Error::CertificateAlreadyExistsException(inner) => inner.fmt(f),
            Error::CertificateDoesNotExistException(inner) => inner.fmt(f),
            Error::CertificateInUseException(inner) => inner.fmt(f),
            Error::CertificateLimitExceededException(inner) => inner.fmt(f),
            Error::ClientException(inner) => inner.fmt(f),
            Error::DirectoryAlreadyInRegionException(inner) => inner.fmt(f),
            Error::DirectoryAlreadySharedException(inner) => inner.fmt(f),
            Error::DirectoryDoesNotExistException(inner) => inner.fmt(f),
            Error::DirectoryInDesiredStateException(inner) => inner.fmt(f),
            Error::DirectoryLimitExceededException(inner) => inner.fmt(f),
            Error::DirectoryNotSharedException(inner) => inner.fmt(f),
            Error::DirectoryUnavailableException(inner) => inner.fmt(f),
            Error::DomainControllerLimitExceededException(inner) => inner.fmt(f),
            Error::EntityAlreadyExistsException(inner) => inner.fmt(f),
            Error::EntityDoesNotExistException(inner) => inner.fmt(f),
            Error::IncompatibleSettingsException(inner) => inner.fmt(f),
            Error::InsufficientPermissionsException(inner) => inner.fmt(f),
            Error::InvalidCertificateException(inner) => inner.fmt(f),
            Error::InvalidClientAuthStatusException(inner) => inner.fmt(f),
            Error::InvalidLdapsStatusException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::InvalidParameterException(inner) => inner.fmt(f),
            Error::InvalidPasswordException(inner) => inner.fmt(f),
            Error::InvalidTargetException(inner) => inner.fmt(f),
            Error::IpRouteLimitExceededException(inner) => inner.fmt(f),
            Error::NoAvailableCertificateException(inner) => inner.fmt(f),
            Error::OrganizationsException(inner) => inner.fmt(f),
            Error::RegionLimitExceededException(inner) => inner.fmt(f),
            Error::ServiceException(inner) => inner.fmt(f),
            Error::ShareLimitExceededException(inner) => inner.fmt(f),
            Error::SnapshotLimitExceededException(inner) => inner.fmt(f),
            Error::TagLimitExceededException(inner) => inner.fmt(f),
            Error::UnsupportedOperationException(inner) => inner.fmt(f),
            Error::UnsupportedSettingsException(inner) => inner.fmt(f),
            Error::UserDoesNotExistException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AcceptSharedDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AcceptSharedDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::AcceptSharedDirectoryError> for Error {
    fn from(err: crate::error::AcceptSharedDirectoryError) -> Self {
        match err {
            crate::error::AcceptSharedDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::AcceptSharedDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::error::AcceptSharedDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::AcceptSharedDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::AcceptSharedDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::AcceptSharedDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddIpRoutesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AddIpRoutesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::AddIpRoutesError> for Error {
    fn from(err: crate::error::AddIpRoutesError) -> Self {
        match err {
            crate::error::AddIpRoutesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::AddIpRoutesError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::AddIpRoutesError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::AddIpRoutesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::AddIpRoutesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::AddIpRoutesError::IpRouteLimitExceededException(inner) => Error::IpRouteLimitExceededException(inner),
            crate::error::AddIpRoutesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::AddIpRoutesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddRegionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AddRegionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::AddRegionError> for Error {
    fn from(err: crate::error::AddRegionError) -> Self {
        match err {
            crate::error::AddRegionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::AddRegionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::AddRegionError::DirectoryAlreadyInRegionException(inner) => Error::DirectoryAlreadyInRegionException(inner),
            crate::error::AddRegionError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::AddRegionError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::AddRegionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::AddRegionError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::AddRegionError::RegionLimitExceededException(inner) => Error::RegionLimitExceededException(inner),
            crate::error::AddRegionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::AddRegionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::AddRegionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddTagsToResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AddTagsToResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::AddTagsToResourceError> for Error {
    fn from(err: crate::error::AddTagsToResourceError) -> Self {
        match err {
            crate::error::AddTagsToResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::error::AddTagsToResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::AddTagsToResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::AddTagsToResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::AddTagsToResourceError::TagLimitExceededException(inner) => Error::TagLimitExceededException(inner),
            crate::error::AddTagsToResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CancelSchemaExtensionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CancelSchemaExtensionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CancelSchemaExtensionError> for Error {
    fn from(err: crate::error::CancelSchemaExtensionError) -> Self {
        match err {
            crate::error::CancelSchemaExtensionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CancelSchemaExtensionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CancelSchemaExtensionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CancelSchemaExtensionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ConnectDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ConnectDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ConnectDirectoryError> for Error {
    fn from(err: crate::error::ConnectDirectoryError) -> Self {
        match err {
            crate::error::ConnectDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ConnectDirectoryError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::error::ConnectDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::ConnectDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ConnectDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAliasError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateAliasError> for Error {
    fn from(err: crate::error::CreateAliasError) -> Self {
        match err {
            crate::error::CreateAliasError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateAliasError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::CreateAliasError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateAliasError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateAliasError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateComputerError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateComputerError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateComputerError> for Error {
    fn from(err: crate::error::CreateComputerError) -> Self {
        match err {
            crate::error::CreateComputerError::AuthenticationFailedException(inner) => Error::AuthenticationFailedException(inner),
            crate::error::CreateComputerError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateComputerError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::CreateComputerError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::CreateComputerError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateComputerError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateComputerError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateComputerError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::CreateComputerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateConditionalForwarderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateConditionalForwarderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateConditionalForwarderError> for Error {
    fn from(err: crate::error::CreateConditionalForwarderError) -> Self {
        match err {
            crate::error::CreateConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::CreateConditionalForwarderError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::CreateConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::CreateConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateDirectoryError> for Error {
    fn from(err: crate::error::CreateDirectoryError) -> Self {
        match err {
            crate::error::CreateDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateDirectoryError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::error::CreateDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateLogSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateLogSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateLogSubscriptionError> for Error {
    fn from(err: crate::error::CreateLogSubscriptionError) -> Self {
        match err {
            crate::error::CreateLogSubscriptionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateLogSubscriptionError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::CreateLogSubscriptionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateLogSubscriptionError::InsufficientPermissionsException(inner) => Error::InsufficientPermissionsException(inner),
            crate::error::CreateLogSubscriptionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateLogSubscriptionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::CreateLogSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateMicrosoftADError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateMicrosoftADError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateMicrosoftADError> for Error {
    fn from(err: crate::error::CreateMicrosoftADError) -> Self {
        match err {
            crate::error::CreateMicrosoftADError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateMicrosoftADError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::error::CreateMicrosoftADError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateMicrosoftADError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateMicrosoftADError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::CreateMicrosoftADError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateSnapshotError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateSnapshotError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateSnapshotError> for Error {
    fn from(err: crate::error::CreateSnapshotError) -> Self {
        match err {
            crate::error::CreateSnapshotError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateSnapshotError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateSnapshotError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateSnapshotError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateSnapshotError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::error::CreateSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTrustError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateTrustError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateTrustError> for Error {
    fn from(err: crate::error::CreateTrustError) -> Self {
        match err {
            crate::error::CreateTrustError::ClientException(inner) => Error::ClientException(inner),
            crate::error::CreateTrustError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::CreateTrustError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::CreateTrustError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::CreateTrustError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::CreateTrustError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::CreateTrustError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteConditionalForwarderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteConditionalForwarderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteConditionalForwarderError> for Error {
    fn from(err: crate::error::DeleteConditionalForwarderError) -> Self {
        match err {
            crate::error::DeleteConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeleteConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::DeleteConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeleteConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DeleteConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeleteConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DeleteConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteDirectoryError> for Error {
    fn from(err: crate::error::DeleteDirectoryError) -> Self {
        match err {
            crate::error::DeleteDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeleteDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeleteDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeleteDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteLogSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteLogSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteLogSubscriptionError> for Error {
    fn from(err: crate::error::DeleteLogSubscriptionError) -> Self {
        match err {
            crate::error::DeleteLogSubscriptionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeleteLogSubscriptionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeleteLogSubscriptionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeleteLogSubscriptionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DeleteLogSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteSnapshotError> for Error {
    fn from(err: crate::error::DeleteSnapshotError) -> Self {
        match err {
            crate::error::DeleteSnapshotError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeleteSnapshotError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeleteSnapshotError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DeleteSnapshotError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeleteSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTrustError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteTrustError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteTrustError> for Error {
    fn from(err: crate::error::DeleteTrustError) -> Self {
        match err {
            crate::error::DeleteTrustError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeleteTrustError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeleteTrustError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DeleteTrustError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeleteTrustError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DeleteTrustError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeregisterCertificateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeregisterCertificateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeregisterCertificateError> for Error {
    fn from(err: crate::error::DeregisterCertificateError) -> Self {
        match err {
            crate::error::DeregisterCertificateError::CertificateDoesNotExistException(inner) => Error::CertificateDoesNotExistException(inner),
            crate::error::DeregisterCertificateError::CertificateInUseException(inner) => Error::CertificateInUseException(inner),
            crate::error::DeregisterCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeregisterCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DeregisterCertificateError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::DeregisterCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DeregisterCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeregisterCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DeregisterCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeregisterEventTopicError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeregisterEventTopicError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeregisterEventTopicError> for Error {
    fn from(err: crate::error::DeregisterEventTopicError) -> Self {
        match err {
            crate::error::DeregisterEventTopicError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DeregisterEventTopicError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DeregisterEventTopicError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DeregisterEventTopicError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DeregisterEventTopicError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeCertificateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeCertificateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeCertificateError> for Error {
    fn from(err: crate::error::DescribeCertificateError) -> Self {
        match err {
            crate::error::DescribeCertificateError::CertificateDoesNotExistException(inner) => Error::CertificateDoesNotExistException(inner),
            crate::error::DescribeCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClientAuthenticationSettingsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeClientAuthenticationSettingsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeClientAuthenticationSettingsError> for Error {
    fn from(err: crate::error::DescribeClientAuthenticationSettingsError) -> Self {
        match err {
            crate::error::DescribeClientAuthenticationSettingsError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeClientAuthenticationSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeConditionalForwardersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeConditionalForwardersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeConditionalForwardersError> for Error {
    fn from(err: crate::error::DescribeConditionalForwardersError) -> Self {
        match err {
            crate::error::DescribeConditionalForwardersError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeConditionalForwardersError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::DescribeConditionalForwardersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeConditionalForwardersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeConditionalForwardersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeConditionalForwardersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeConditionalForwardersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDirectoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeDirectoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeDirectoriesError> for Error {
    fn from(err: crate::error::DescribeDirectoriesError) -> Self {
        match err {
            crate::error::DescribeDirectoriesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeDirectoriesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeDirectoriesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeDirectoriesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeDirectoriesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeDirectoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDomainControllersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeDomainControllersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeDomainControllersError> for Error {
    fn from(err: crate::error::DescribeDomainControllersError) -> Self {
        match err {
            crate::error::DescribeDomainControllersError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeDomainControllersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeDomainControllersError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeDomainControllersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeDomainControllersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeDomainControllersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeDomainControllersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEventTopicsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeEventTopicsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeEventTopicsError> for Error {
    fn from(err: crate::error::DescribeEventTopicsError) -> Self {
        match err {
            crate::error::DescribeEventTopicsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeEventTopicsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeEventTopicsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeEventTopicsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeEventTopicsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeLDAPSSettingsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeLDAPSSettingsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeLDAPSSettingsError> for Error {
    fn from(err: crate::error::DescribeLDAPSSettingsError) -> Self {
        match err {
            crate::error::DescribeLDAPSSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeLDAPSSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeLDAPSSettingsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeLDAPSSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeLDAPSSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeLDAPSSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeLDAPSSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeRegionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeRegionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeRegionsError> for Error {
    fn from(err: crate::error::DescribeRegionsError) -> Self {
        match err {
            crate::error::DescribeRegionsError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeRegionsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeRegionsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeRegionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeRegionsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeRegionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeRegionsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeRegionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSettingsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeSettingsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeSettingsError> for Error {
    fn from(err: crate::error::DescribeSettingsError) -> Self {
        match err {
            crate::error::DescribeSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeSettingsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSharedDirectoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeSharedDirectoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeSharedDirectoriesError> for Error {
    fn from(err: crate::error::DescribeSharedDirectoriesError) -> Self {
        match err {
            crate::error::DescribeSharedDirectoriesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeSharedDirectoriesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeSharedDirectoriesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeSharedDirectoriesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeSharedDirectoriesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeSharedDirectoriesError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeSharedDirectoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeSnapshotsError> for Error {
    fn from(err: crate::error::DescribeSnapshotsError) -> Self {
        match err {
            crate::error::DescribeSnapshotsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeSnapshotsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeSnapshotsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeSnapshotsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeSnapshotsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeSnapshotsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTrustsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeTrustsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeTrustsError> for Error {
    fn from(err: crate::error::DescribeTrustsError) -> Self {
        match err {
            crate::error::DescribeTrustsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeTrustsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DescribeTrustsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeTrustsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeTrustsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeTrustsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DescribeTrustsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeUpdateDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeUpdateDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeUpdateDirectoryError> for Error {
    fn from(err: crate::error::DescribeUpdateDirectoryError) -> Self {
        match err {
            crate::error::DescribeUpdateDirectoryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DescribeUpdateDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DescribeUpdateDirectoryError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DescribeUpdateDirectoryError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::DescribeUpdateDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DescribeUpdateDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DescribeUpdateDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableClientAuthenticationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableClientAuthenticationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DisableClientAuthenticationError> for Error {
    fn from(err: crate::error::DisableClientAuthenticationError) -> Self {
        match err {
            crate::error::DisableClientAuthenticationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::DisableClientAuthenticationError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DisableClientAuthenticationError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DisableClientAuthenticationError::InvalidClientAuthStatusException(inner) => Error::InvalidClientAuthStatusException(inner),
            crate::error::DisableClientAuthenticationError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DisableClientAuthenticationError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DisableClientAuthenticationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableLDAPSError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableLDAPSError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DisableLDAPSError> for Error {
    fn from(err: crate::error::DisableLDAPSError) -> Self {
        match err {
            crate::error::DisableLDAPSError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DisableLDAPSError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::DisableLDAPSError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::DisableLDAPSError::InvalidLdapsStatusException(inner) => Error::InvalidLdapsStatusException(inner),
            crate::error::DisableLDAPSError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::DisableLDAPSError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DisableLDAPSError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::DisableLDAPSError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableRadiusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableRadiusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DisableRadiusError> for Error {
    fn from(err: crate::error::DisableRadiusError) -> Self {
        match err {
            crate::error::DisableRadiusError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DisableRadiusError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DisableRadiusError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DisableRadiusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableSsoError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableSsoError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DisableSsoError> for Error {
    fn from(err: crate::error::DisableSsoError) -> Self {
        match err {
            crate::error::DisableSsoError::AuthenticationFailedException(inner) => Error::AuthenticationFailedException(inner),
            crate::error::DisableSsoError::ClientException(inner) => Error::ClientException(inner),
            crate::error::DisableSsoError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::DisableSsoError::InsufficientPermissionsException(inner) => Error::InsufficientPermissionsException(inner),
            crate::error::DisableSsoError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::DisableSsoError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableClientAuthenticationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableClientAuthenticationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::EnableClientAuthenticationError> for Error {
    fn from(err: crate::error::EnableClientAuthenticationError) -> Self {
        match err {
            crate::error::EnableClientAuthenticationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::EnableClientAuthenticationError::ClientException(inner) => Error::ClientException(inner),
            crate::error::EnableClientAuthenticationError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::EnableClientAuthenticationError::InvalidClientAuthStatusException(inner) => Error::InvalidClientAuthStatusException(inner),
            crate::error::EnableClientAuthenticationError::NoAvailableCertificateException(inner) => Error::NoAvailableCertificateException(inner),
            crate::error::EnableClientAuthenticationError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::EnableClientAuthenticationError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::EnableClientAuthenticationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableLDAPSError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableLDAPSError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::EnableLDAPSError> for Error {
    fn from(err: crate::error::EnableLDAPSError) -> Self {
        match err {
            crate::error::EnableLDAPSError::ClientException(inner) => Error::ClientException(inner),
            crate::error::EnableLDAPSError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::EnableLDAPSError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::EnableLDAPSError::InvalidLdapsStatusException(inner) => Error::InvalidLdapsStatusException(inner),
            crate::error::EnableLDAPSError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::EnableLDAPSError::NoAvailableCertificateException(inner) => Error::NoAvailableCertificateException(inner),
            crate::error::EnableLDAPSError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::EnableLDAPSError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::EnableLDAPSError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableRadiusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableRadiusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::EnableRadiusError> for Error {
    fn from(err: crate::error::EnableRadiusError) -> Self {
        match err {
            crate::error::EnableRadiusError::ClientException(inner) => Error::ClientException(inner),
            crate::error::EnableRadiusError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::error::EnableRadiusError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::EnableRadiusError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::EnableRadiusError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::EnableRadiusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableSsoError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableSsoError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::EnableSsoError> for Error {
    fn from(err: crate::error::EnableSsoError) -> Self {
        match err {
            crate::error::EnableSsoError::AuthenticationFailedException(inner) => Error::AuthenticationFailedException(inner),
            crate::error::EnableSsoError::ClientException(inner) => Error::ClientException(inner),
            crate::error::EnableSsoError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::EnableSsoError::InsufficientPermissionsException(inner) => Error::InsufficientPermissionsException(inner),
            crate::error::EnableSsoError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::EnableSsoError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDirectoryLimitsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDirectoryLimitsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetDirectoryLimitsError> for Error {
    fn from(err: crate::error::GetDirectoryLimitsError) -> Self {
        match err {
            crate::error::GetDirectoryLimitsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::GetDirectoryLimitsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::GetDirectoryLimitsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::GetDirectoryLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSnapshotLimitsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSnapshotLimitsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetSnapshotLimitsError> for Error {
    fn from(err: crate::error::GetSnapshotLimitsError) -> Self {
        match err {
            crate::error::GetSnapshotLimitsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::GetSnapshotLimitsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::GetSnapshotLimitsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::GetSnapshotLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCertificatesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListCertificatesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListCertificatesError> for Error {
    fn from(err: crate::error::ListCertificatesError) -> Self {
        match err {
            crate::error::ListCertificatesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ListCertificatesError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::ListCertificatesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListCertificatesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::ListCertificatesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ListCertificatesError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::ListCertificatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListIpRoutesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListIpRoutesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListIpRoutesError> for Error {
    fn from(err: crate::error::ListIpRoutesError) -> Self {
        match err {
            crate::error::ListIpRoutesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ListIpRoutesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ListIpRoutesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListIpRoutesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::ListIpRoutesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ListIpRoutesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListLogSubscriptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListLogSubscriptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListLogSubscriptionsError> for Error {
    fn from(err: crate::error::ListLogSubscriptionsError) -> Self {
        match err {
            crate::error::ListLogSubscriptionsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ListLogSubscriptionsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ListLogSubscriptionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListLogSubscriptionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ListLogSubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListSchemaExtensionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListSchemaExtensionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListSchemaExtensionsError> for Error {
    fn from(err: crate::error::ListSchemaExtensionsError) -> Self {
        match err {
            crate::error::ListSchemaExtensionsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ListSchemaExtensionsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ListSchemaExtensionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListSchemaExtensionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ListSchemaExtensionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ListTagsForResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ListTagsForResourceError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListTagsForResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::ListTagsForResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterCertificateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RegisterCertificateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RegisterCertificateError> for Error {
    fn from(err: crate::error::RegisterCertificateError) -> Self {
        match err {
            crate::error::RegisterCertificateError::CertificateAlreadyExistsException(inner) => Error::CertificateAlreadyExistsException(inner),
            crate::error::RegisterCertificateError::CertificateLimitExceededException(inner) => Error::CertificateLimitExceededException(inner),
            crate::error::RegisterCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RegisterCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::RegisterCertificateError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::RegisterCertificateError::InvalidCertificateException(inner) => Error::InvalidCertificateException(inner),
            crate::error::RegisterCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RegisterCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RegisterCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::RegisterCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterEventTopicError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RegisterEventTopicError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RegisterEventTopicError> for Error {
    fn from(err: crate::error::RegisterEventTopicError) -> Self {
        match err {
            crate::error::RegisterEventTopicError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RegisterEventTopicError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::RegisterEventTopicError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RegisterEventTopicError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RegisterEventTopicError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RejectSharedDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RejectSharedDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RejectSharedDirectoryError> for Error {
    fn from(err: crate::error::RejectSharedDirectoryError) -> Self {
        match err {
            crate::error::RejectSharedDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RejectSharedDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::error::RejectSharedDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::RejectSharedDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RejectSharedDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RejectSharedDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveIpRoutesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RemoveIpRoutesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RemoveIpRoutesError> for Error {
    fn from(err: crate::error::RemoveIpRoutesError) -> Self {
        match err {
            crate::error::RemoveIpRoutesError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RemoveIpRoutesError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::RemoveIpRoutesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::RemoveIpRoutesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RemoveIpRoutesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RemoveIpRoutesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveRegionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RemoveRegionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RemoveRegionError> for Error {
    fn from(err: crate::error::RemoveRegionError) -> Self {
        match err {
            crate::error::RemoveRegionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::RemoveRegionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RemoveRegionError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::RemoveRegionError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::RemoveRegionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RemoveRegionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::RemoveRegionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RemoveTagsFromResourceError> for Error {
    fn from(err: crate::error::RemoveTagsFromResourceError) -> Self {
        match err {
            crate::error::RemoveTagsFromResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RemoveTagsFromResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::RemoveTagsFromResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RemoveTagsFromResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RemoveTagsFromResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ResetUserPasswordError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ResetUserPasswordError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ResetUserPasswordError> for Error {
    fn from(err: crate::error::ResetUserPasswordError) -> Self {
        match err {
            crate::error::ResetUserPasswordError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ResetUserPasswordError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::ResetUserPasswordError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ResetUserPasswordError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::error::ResetUserPasswordError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ResetUserPasswordError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::ResetUserPasswordError::UserDoesNotExistException(inner) => Error::UserDoesNotExistException(inner),
            crate::error::ResetUserPasswordError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RestoreFromSnapshotError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RestoreFromSnapshotError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::RestoreFromSnapshotError> for Error {
    fn from(err: crate::error::RestoreFromSnapshotError) -> Self {
        match err {
            crate::error::RestoreFromSnapshotError::ClientException(inner) => Error::ClientException(inner),
            crate::error::RestoreFromSnapshotError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::RestoreFromSnapshotError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::RestoreFromSnapshotError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::RestoreFromSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ShareDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ShareDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ShareDirectoryError> for Error {
    fn from(err: crate::error::ShareDirectoryError) -> Self {
        match err {
            crate::error::ShareDirectoryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::ShareDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::ShareDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::error::ShareDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::ShareDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::ShareDirectoryError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::error::ShareDirectoryError::OrganizationsException(inner) => Error::OrganizationsException(inner),
            crate::error::ShareDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::ShareDirectoryError::ShareLimitExceededException(inner) => Error::ShareLimitExceededException(inner),
            crate::error::ShareDirectoryError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::ShareDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartSchemaExtensionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::StartSchemaExtensionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::StartSchemaExtensionError> for Error {
    fn from(err: crate::error::StartSchemaExtensionError) -> Self {
        match err {
            crate::error::StartSchemaExtensionError::ClientException(inner) => Error::ClientException(inner),
            crate::error::StartSchemaExtensionError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::StartSchemaExtensionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::StartSchemaExtensionError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::StartSchemaExtensionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::StartSchemaExtensionError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::error::StartSchemaExtensionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UnshareDirectoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UnshareDirectoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UnshareDirectoryError> for Error {
    fn from(err: crate::error::UnshareDirectoryError) -> Self {
        match err {
            crate::error::UnshareDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UnshareDirectoryError::DirectoryNotSharedException(inner) => Error::DirectoryNotSharedException(inner),
            crate::error::UnshareDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::UnshareDirectoryError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::error::UnshareDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UnshareDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateConditionalForwarderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateConditionalForwarderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateConditionalForwarderError> for Error {
    fn from(err: crate::error::UpdateConditionalForwarderError) -> Self {
        match err {
            crate::error::UpdateConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::UpdateConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::UpdateConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::UpdateConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDirectorySetupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateDirectorySetupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateDirectorySetupError> for Error {
    fn from(err: crate::error::UpdateDirectorySetupError) -> Self {
        match err {
            crate::error::UpdateDirectorySetupError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::error::UpdateDirectorySetupError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateDirectorySetupError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::UpdateDirectorySetupError::DirectoryInDesiredStateException(inner) => Error::DirectoryInDesiredStateException(inner),
            crate::error::UpdateDirectorySetupError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::UpdateDirectorySetupError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateDirectorySetupError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateDirectorySetupError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::error::UpdateDirectorySetupError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::UpdateDirectorySetupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateNumberOfDomainControllersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateNumberOfDomainControllersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateNumberOfDomainControllersError> for Error {
    fn from(err: crate::error::UpdateNumberOfDomainControllersError) -> Self {
        match err {
            crate::error::UpdateNumberOfDomainControllersError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateNumberOfDomainControllersError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::UpdateNumberOfDomainControllersError::DomainControllerLimitExceededException(inner) => Error::DomainControllerLimitExceededException(inner),
            crate::error::UpdateNumberOfDomainControllersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::UpdateNumberOfDomainControllersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateNumberOfDomainControllersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateNumberOfDomainControllersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::UpdateNumberOfDomainControllersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateRadiusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateRadiusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateRadiusError> for Error {
    fn from(err: crate::error::UpdateRadiusError) -> Self {
        match err {
            crate::error::UpdateRadiusError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateRadiusError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::UpdateRadiusError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateRadiusError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateRadiusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateSettingsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateSettingsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateSettingsError> for Error {
    fn from(err: crate::error::UpdateSettingsError) -> Self {
        match err {
            crate::error::UpdateSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::error::UpdateSettingsError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::error::UpdateSettingsError::IncompatibleSettingsException(inner) => Error::IncompatibleSettingsException(inner),
            crate::error::UpdateSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::UpdateSettingsError::UnsupportedSettingsException(inner) => Error::UnsupportedSettingsException(inner),
            crate::error::UpdateSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTrustError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateTrustError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateTrustError> for Error {
    fn from(err: crate::error::UpdateTrustError) -> Self {
        match err {
            crate::error::UpdateTrustError::ClientException(inner) => Error::ClientException(inner),
            crate::error::UpdateTrustError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::UpdateTrustError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::UpdateTrustError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::UpdateTrustError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyTrustError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyTrustError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::VerifyTrustError> for Error {
    fn from(err: crate::error::VerifyTrustError) -> Self {
        match err {
            crate::error::VerifyTrustError::ClientException(inner) => Error::ClientException(inner),
            crate::error::VerifyTrustError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::error::VerifyTrustError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::error::VerifyTrustError::ServiceException(inner) => Error::ServiceException(inner),
            crate::error::VerifyTrustError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::VerifyTrustError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::AuthenticationFailedException(e) => e.request_id(),
            Self::CertificateAlreadyExistsException(e) => e.request_id(),
            Self::CertificateDoesNotExistException(e) => e.request_id(),
            Self::CertificateInUseException(e) => e.request_id(),
            Self::CertificateLimitExceededException(e) => e.request_id(),
            Self::ClientException(e) => e.request_id(),
            Self::DirectoryAlreadyInRegionException(e) => e.request_id(),
            Self::DirectoryAlreadySharedException(e) => e.request_id(),
            Self::DirectoryDoesNotExistException(e) => e.request_id(),
            Self::DirectoryInDesiredStateException(e) => e.request_id(),
            Self::DirectoryLimitExceededException(e) => e.request_id(),
            Self::DirectoryNotSharedException(e) => e.request_id(),
            Self::DirectoryUnavailableException(e) => e.request_id(),
            Self::DomainControllerLimitExceededException(e) => e.request_id(),
            Self::EntityAlreadyExistsException(e) => e.request_id(),
            Self::EntityDoesNotExistException(e) => e.request_id(),
            Self::IncompatibleSettingsException(e) => e.request_id(),
            Self::InsufficientPermissionsException(e) => e.request_id(),
            Self::InvalidCertificateException(e) => e.request_id(),
            Self::InvalidClientAuthStatusException(e) => e.request_id(),
            Self::InvalidLdapsStatusException(e) => e.request_id(),
            Self::InvalidNextTokenException(e) => e.request_id(),
            Self::InvalidParameterException(e) => e.request_id(),
            Self::InvalidPasswordException(e) => e.request_id(),
            Self::InvalidTargetException(e) => e.request_id(),
            Self::IpRouteLimitExceededException(e) => e.request_id(),
            Self::NoAvailableCertificateException(e) => e.request_id(),
            Self::OrganizationsException(e) => e.request_id(),
            Self::RegionLimitExceededException(e) => e.request_id(),
            Self::ServiceException(e) => e.request_id(),
            Self::ShareLimitExceededException(e) => e.request_id(),
            Self::SnapshotLimitExceededException(e) => e.request_id(),
            Self::TagLimitExceededException(e) => e.request_id(),
            Self::UnsupportedOperationException(e) => e.request_id(),
            Self::UnsupportedSettingsException(e) => e.request_id(),
            Self::UserDoesNotExistException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}

