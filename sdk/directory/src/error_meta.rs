// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Client authentication is not available in this region at this time.</p>
    AccessDeniedException(crate::types::error::AccessDeniedException),
    /// <p>An authentication error occurred.</p>
    AuthenticationFailedException(crate::types::error::AuthenticationFailedException),
    /// <p>The certificate has already been registered into the system.</p>
    CertificateAlreadyExistsException(crate::types::error::CertificateAlreadyExistsException),
    /// <p>The certificate is not present in the system for describe or deregister activities.</p>
    CertificateDoesNotExistException(crate::types::error::CertificateDoesNotExistException),
    /// <p>The certificate is being used for the LDAP security connection and cannot be removed without disabling LDAP security.</p>
    CertificateInUseException(crate::types::error::CertificateInUseException),
    /// <p>The certificate could not be added because the certificate limit has been reached.</p>
    CertificateLimitExceededException(crate::types::error::CertificateLimitExceededException),
    /// <p>A client exception has occurred.</p>
    ClientException(crate::types::error::ClientException),
    /// <p>The Region you specified is the same Region where the Managed Microsoft AD directory was created. Specify a different Region and try again.</p>
    DirectoryAlreadyInRegionException(crate::types::error::DirectoryAlreadyInRegionException),
    /// <p>The specified directory has already been shared with this Amazon Web Services account.</p>
    DirectoryAlreadySharedException(crate::types::error::DirectoryAlreadySharedException),
    /// <p>The specified directory does not exist in the system.</p>
    DirectoryDoesNotExistException(crate::types::error::DirectoryDoesNotExistException),
    /// <p> The directory is already updated to desired update type settings. </p>
    DirectoryInDesiredStateException(crate::types::error::DirectoryInDesiredStateException),
    /// <p>The maximum number of directories in the region has been reached. You can use the <code>GetDirectoryLimits</code> operation to determine your directory limits in the region.</p>
    DirectoryLimitExceededException(crate::types::error::DirectoryLimitExceededException),
    /// <p>The specified directory has not been shared with this Amazon Web Services account.</p>
    DirectoryNotSharedException(crate::types::error::DirectoryNotSharedException),
    /// <p>The specified directory is unavailable or could not be found.</p>
    DirectoryUnavailableException(crate::types::error::DirectoryUnavailableException),
    /// <p>The maximum allowed number of domain controllers per directory was exceeded. The default limit per directory is 20 domain controllers.</p>
    DomainControllerLimitExceededException(
        crate::types::error::DomainControllerLimitExceededException,
    ),
    /// <p>The specified entity already exists.</p>
    EntityAlreadyExistsException(crate::types::error::EntityAlreadyExistsException),
    /// <p>The specified entity could not be found.</p>
    EntityDoesNotExistException(crate::types::error::EntityDoesNotExistException),
    /// <p>The specified directory setting is not compatible with other settings.</p>
    IncompatibleSettingsException(crate::types::error::IncompatibleSettingsException),
    /// <p>The account does not have sufficient permission to perform the operation.</p>
    InsufficientPermissionsException(crate::types::error::InsufficientPermissionsException),
    /// <p>The certificate PEM that was provided has incorrect encoding.</p>
    InvalidCertificateException(crate::types::error::InvalidCertificateException),
    /// <p>Client authentication is already enabled.</p>
    InvalidClientAuthStatusException(crate::types::error::InvalidClientAuthStatusException),
    /// <p>The LDAP activities could not be performed because they are limited by the LDAPS status.</p>
    InvalidLdapsStatusException(crate::types::error::InvalidLdapsStatusException),
    /// <p>The <code>NextToken</code> value is not valid.</p>
    InvalidNextTokenException(crate::types::error::InvalidNextTokenException),
    /// <p>One or more parameters are not valid.</p>
    InvalidParameterException(crate::types::error::InvalidParameterException),
    /// <p>The new password provided by the user does not meet the password complexity requirements defined in your directory.</p>
    InvalidPasswordException(crate::types::error::InvalidPasswordException),
    /// <p>The specified shared target is not valid.</p>
    InvalidTargetException(crate::types::error::InvalidTargetException),
    /// <p>The maximum allowed number of IP addresses was exceeded. The default limit is 100 IP address blocks.</p>
    IpRouteLimitExceededException(crate::types::error::IpRouteLimitExceededException),
    /// <p>Client authentication setup could not be completed because at least one valid certificate must be registered in the system.</p>
    NoAvailableCertificateException(crate::types::error::NoAvailableCertificateException),
    /// <p>Exception encountered while trying to access your Amazon Web Services organization.</p>
    OrganizationsException(crate::types::error::OrganizationsException),
    /// <p>You have reached the limit for maximum number of simultaneous Region replications per directory.</p>
    RegionLimitExceededException(crate::types::error::RegionLimitExceededException),
    /// <p>An exception has occurred in Directory Service.</p>
    ServiceException(crate::types::error::ServiceException),
    /// <p>The maximum number of Amazon Web Services accounts that you can share with this directory has been reached.</p>
    ShareLimitExceededException(crate::types::error::ShareLimitExceededException),
    /// <p>The maximum number of manual snapshots for the directory has been reached. You can use the <code>GetSnapshotLimits</code> operation to determine the snapshot limits for a directory.</p>
    SnapshotLimitExceededException(crate::types::error::SnapshotLimitExceededException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::types::error::TagLimitExceededException),
    /// <p>The operation is not supported.</p>
    UnsupportedOperationException(crate::types::error::UnsupportedOperationException),
    /// <p>The specified directory setting is not supported.</p>
    UnsupportedSettingsException(crate::types::error::UnsupportedSettingsException),
    /// <p>The user provided a username that does not exist in your directory.</p>
    UserDoesNotExistException(crate::types::error::UserDoesNotExistException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::AuthenticationFailedException(inner) => inner.fmt(f),
            Error::CertificateAlreadyExistsException(inner) => inner.fmt(f),
            Error::CertificateDoesNotExistException(inner) => inner.fmt(f),
            Error::CertificateInUseException(inner) => inner.fmt(f),
            Error::CertificateLimitExceededException(inner) => inner.fmt(f),
            Error::ClientException(inner) => inner.fmt(f),
            Error::DirectoryAlreadyInRegionException(inner) => inner.fmt(f),
            Error::DirectoryAlreadySharedException(inner) => inner.fmt(f),
            Error::DirectoryDoesNotExistException(inner) => inner.fmt(f),
            Error::DirectoryInDesiredStateException(inner) => inner.fmt(f),
            Error::DirectoryLimitExceededException(inner) => inner.fmt(f),
            Error::DirectoryNotSharedException(inner) => inner.fmt(f),
            Error::DirectoryUnavailableException(inner) => inner.fmt(f),
            Error::DomainControllerLimitExceededException(inner) => inner.fmt(f),
            Error::EntityAlreadyExistsException(inner) => inner.fmt(f),
            Error::EntityDoesNotExistException(inner) => inner.fmt(f),
            Error::IncompatibleSettingsException(inner) => inner.fmt(f),
            Error::InsufficientPermissionsException(inner) => inner.fmt(f),
            Error::InvalidCertificateException(inner) => inner.fmt(f),
            Error::InvalidClientAuthStatusException(inner) => inner.fmt(f),
            Error::InvalidLdapsStatusException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::InvalidParameterException(inner) => inner.fmt(f),
            Error::InvalidPasswordException(inner) => inner.fmt(f),
            Error::InvalidTargetException(inner) => inner.fmt(f),
            Error::IpRouteLimitExceededException(inner) => inner.fmt(f),
            Error::NoAvailableCertificateException(inner) => inner.fmt(f),
            Error::OrganizationsException(inner) => inner.fmt(f),
            Error::RegionLimitExceededException(inner) => inner.fmt(f),
            Error::ServiceException(inner) => inner.fmt(f),
            Error::ShareLimitExceededException(inner) => inner.fmt(f),
            Error::SnapshotLimitExceededException(inner) => inner.fmt(f),
            Error::TagLimitExceededException(inner) => inner.fmt(f),
            Error::UnsupportedOperationException(inner) => inner.fmt(f),
            Error::UnsupportedSettingsException(inner) => inner.fmt(f),
            Error::UserDoesNotExistException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::accept_shared_directory::AcceptSharedDirectoryError> for Error {
    fn from(err: crate::operation::accept_shared_directory::AcceptSharedDirectoryError) -> Self {
        match err {
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::accept_shared_directory::AcceptSharedDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::add_ip_routes::AddIpRoutesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::add_ip_routes::AddIpRoutesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::add_ip_routes::AddIpRoutesError> for Error {
    fn from(err: crate::operation::add_ip_routes::AddIpRoutesError) -> Self {
        match err {
            crate::operation::add_ip_routes::AddIpRoutesError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::add_ip_routes::AddIpRoutesError::DirectoryUnavailableException(
                inner,
            ) => Error::DirectoryUnavailableException(inner),
            crate::operation::add_ip_routes::AddIpRoutesError::EntityAlreadyExistsException(
                inner,
            ) => Error::EntityAlreadyExistsException(inner),
            crate::operation::add_ip_routes::AddIpRoutesError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::add_ip_routes::AddIpRoutesError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::add_ip_routes::AddIpRoutesError::IpRouteLimitExceededException(
                inner,
            ) => Error::IpRouteLimitExceededException(inner),
            crate::operation::add_ip_routes::AddIpRoutesError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::add_ip_routes::AddIpRoutesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::add_region::AddRegionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::add_region::AddRegionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::add_region::AddRegionError> for Error {
    fn from(err: crate::operation::add_region::AddRegionError) -> Self {
        match err {
            crate::operation::add_region::AddRegionError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::operation::add_region::AddRegionError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::add_region::AddRegionError::DirectoryAlreadyInRegionException(
                inner,
            ) => Error::DirectoryAlreadyInRegionException(inner),
            crate::operation::add_region::AddRegionError::DirectoryDoesNotExistException(inner) => {
                Error::DirectoryDoesNotExistException(inner)
            }
            crate::operation::add_region::AddRegionError::DirectoryUnavailableException(inner) => {
                Error::DirectoryUnavailableException(inner)
            }
            crate::operation::add_region::AddRegionError::EntityDoesNotExistException(inner) => {
                Error::EntityDoesNotExistException(inner)
            }
            crate::operation::add_region::AddRegionError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::add_region::AddRegionError::RegionLimitExceededException(inner) => {
                Error::RegionLimitExceededException(inner)
            }
            crate::operation::add_region::AddRegionError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::add_region::AddRegionError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::operation::add_region::AddRegionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::add_tags_to_resource::AddTagsToResourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::add_tags_to_resource::AddTagsToResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::add_tags_to_resource::AddTagsToResourceError> for Error {
    fn from(err: crate::operation::add_tags_to_resource::AddTagsToResourceError) -> Self {
        match err {
            crate::operation::add_tags_to_resource::AddTagsToResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::add_tags_to_resource::AddTagsToResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::add_tags_to_resource::AddTagsToResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::add_tags_to_resource::AddTagsToResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::add_tags_to_resource::AddTagsToResourceError::TagLimitExceededException(inner) => Error::TagLimitExceededException(inner),
            crate::operation::add_tags_to_resource::AddTagsToResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::cancel_schema_extension::CancelSchemaExtensionError> for Error {
    fn from(err: crate::operation::cancel_schema_extension::CancelSchemaExtensionError) -> Self {
        match err {
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::cancel_schema_extension::CancelSchemaExtensionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::connect_directory::ConnectDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::connect_directory::ConnectDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::connect_directory::ConnectDirectoryError> for Error {
    fn from(err: crate::operation::connect_directory::ConnectDirectoryError) -> Self {
        match err {
            crate::operation::connect_directory::ConnectDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::connect_directory::ConnectDirectoryError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::operation::connect_directory::ConnectDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::connect_directory::ConnectDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::connect_directory::ConnectDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_alias::CreateAliasError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::create_alias::CreateAliasError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_alias::CreateAliasError> for Error {
    fn from(err: crate::operation::create_alias::CreateAliasError) -> Self {
        match err {
            crate::operation::create_alias::CreateAliasError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::create_alias::CreateAliasError::EntityAlreadyExistsException(
                inner,
            ) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_alias::CreateAliasError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_alias::CreateAliasError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::create_alias::CreateAliasError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::create_alias::CreateAliasError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_computer::CreateComputerError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_computer::CreateComputerError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_computer::CreateComputerError> for Error {
    fn from(err: crate::operation::create_computer::CreateComputerError) -> Self {
        match err {
            crate::operation::create_computer::CreateComputerError::AuthenticationFailedException(inner) => Error::AuthenticationFailedException(inner),
            crate::operation::create_computer::CreateComputerError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_computer::CreateComputerError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::create_computer::CreateComputerError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_computer::CreateComputerError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_computer::CreateComputerError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::create_computer::CreateComputerError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_computer::CreateComputerError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::create_computer::CreateComputerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_conditional_forwarder::CreateConditionalForwarderError>
    for Error
{
    fn from(
        err: crate::operation::create_conditional_forwarder::CreateConditionalForwarderError,
    ) -> Self {
        match err {
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::create_conditional_forwarder::CreateConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_directory::CreateDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_directory::CreateDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_directory::CreateDirectoryError> for Error {
    fn from(err: crate::operation::create_directory::CreateDirectoryError) -> Self {
        match err {
            crate::operation::create_directory::CreateDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_directory::CreateDirectoryError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::operation::create_directory::CreateDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::create_directory::CreateDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_directory::CreateDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_log_subscription::CreateLogSubscriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_log_subscription::CreateLogSubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_log_subscription::CreateLogSubscriptionError> for Error {
    fn from(err: crate::operation::create_log_subscription::CreateLogSubscriptionError) -> Self {
        match err {
            crate::operation::create_log_subscription::CreateLogSubscriptionError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::EntityAlreadyExistsException(inner) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::InsufficientPermissionsException(inner) => Error::InsufficientPermissionsException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::create_log_subscription::CreateLogSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_microsoft_ad::CreateMicrosoftADError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_microsoft_ad::CreateMicrosoftADError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_microsoft_ad::CreateMicrosoftADError> for Error {
    fn from(err: crate::operation::create_microsoft_ad::CreateMicrosoftADError) -> Self {
        match err {
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::DirectoryLimitExceededException(inner) => Error::DirectoryLimitExceededException(inner),
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::create_microsoft_ad::CreateMicrosoftADError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_snapshot::CreateSnapshotError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_snapshot::CreateSnapshotError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_snapshot::CreateSnapshotError> for Error {
    fn from(err: crate::operation::create_snapshot::CreateSnapshotError) -> Self {
        match err {
            crate::operation::create_snapshot::CreateSnapshotError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::create_snapshot::CreateSnapshotError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_snapshot::CreateSnapshotError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::create_snapshot::CreateSnapshotError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::create_snapshot::CreateSnapshotError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::operation::create_snapshot::CreateSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_trust::CreateTrustError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::create_trust::CreateTrustError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_trust::CreateTrustError> for Error {
    fn from(err: crate::operation::create_trust::CreateTrustError) -> Self {
        match err {
            crate::operation::create_trust::CreateTrustError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::create_trust::CreateTrustError::EntityAlreadyExistsException(
                inner,
            ) => Error::EntityAlreadyExistsException(inner),
            crate::operation::create_trust::CreateTrustError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::create_trust::CreateTrustError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::create_trust::CreateTrustError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::create_trust::CreateTrustError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::create_trust::CreateTrustError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError>
    for Error
{
    fn from(
        err: crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError,
    ) -> Self {
        match err {
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::delete_conditional_forwarder::DeleteConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_directory::DeleteDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_directory::DeleteDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_directory::DeleteDirectoryError> for Error {
    fn from(err: crate::operation::delete_directory::DeleteDirectoryError) -> Self {
        match err {
            crate::operation::delete_directory::DeleteDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::delete_directory::DeleteDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::delete_directory::DeleteDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::delete_directory::DeleteDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_log_subscription::DeleteLogSubscriptionError> for Error {
    fn from(err: crate::operation::delete_log_subscription::DeleteLogSubscriptionError) -> Self {
        match err {
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::delete_log_subscription::DeleteLogSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_snapshot::DeleteSnapshotError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_snapshot::DeleteSnapshotError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_snapshot::DeleteSnapshotError> for Error {
    fn from(err: crate::operation::delete_snapshot::DeleteSnapshotError) -> Self {
        match err {
            crate::operation::delete_snapshot::DeleteSnapshotError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::delete_snapshot::DeleteSnapshotError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::delete_snapshot::DeleteSnapshotError::InvalidParameterException(
                inner,
            ) => Error::InvalidParameterException(inner),
            crate::operation::delete_snapshot::DeleteSnapshotError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::delete_snapshot::DeleteSnapshotError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_trust::DeleteTrustError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::delete_trust::DeleteTrustError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_trust::DeleteTrustError> for Error {
    fn from(err: crate::operation::delete_trust::DeleteTrustError) -> Self {
        match err {
            crate::operation::delete_trust::DeleteTrustError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::delete_trust::DeleteTrustError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::delete_trust::DeleteTrustError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::delete_trust::DeleteTrustError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::delete_trust::DeleteTrustError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::delete_trust::DeleteTrustError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::deregister_certificate::DeregisterCertificateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::deregister_certificate::DeregisterCertificateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::deregister_certificate::DeregisterCertificateError> for Error {
    fn from(err: crate::operation::deregister_certificate::DeregisterCertificateError) -> Self {
        match err {
            crate::operation::deregister_certificate::DeregisterCertificateError::CertificateDoesNotExistException(inner) => Error::CertificateDoesNotExistException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::CertificateInUseException(inner) => Error::CertificateInUseException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::deregister_certificate::DeregisterCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::deregister_event_topic::DeregisterEventTopicError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::deregister_event_topic::DeregisterEventTopicError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::deregister_event_topic::DeregisterEventTopicError> for Error {
    fn from(err: crate::operation::deregister_event_topic::DeregisterEventTopicError) -> Self {
        match err {
            crate::operation::deregister_event_topic::DeregisterEventTopicError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::deregister_event_topic::DeregisterEventTopicError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::deregister_event_topic::DeregisterEventTopicError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::deregister_event_topic::DeregisterEventTopicError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::deregister_event_topic::DeregisterEventTopicError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_certificate::DescribeCertificateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_certificate::DescribeCertificateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_certificate::DescribeCertificateError> for Error {
    fn from(err: crate::operation::describe_certificate::DescribeCertificateError) -> Self {
        match err {
            crate::operation::describe_certificate::DescribeCertificateError::CertificateDoesNotExistException(inner) => Error::CertificateDoesNotExistException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_certificate::DescribeCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError> for Error {
    fn from(err: crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError) -> Self {
        match err {
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_client_authentication_settings::DescribeClientAuthenticationSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError>
    for Error
{
    fn from(
        err: crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError,
    ) -> Self {
        match err {
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_conditional_forwarders::DescribeConditionalForwardersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_directories::DescribeDirectoriesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_directories::DescribeDirectoriesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_directories::DescribeDirectoriesError> for Error {
    fn from(err: crate::operation::describe_directories::DescribeDirectoriesError) -> Self {
        match err {
            crate::operation::describe_directories::DescribeDirectoriesError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_directories::DescribeDirectoriesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_directories::DescribeDirectoriesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_directories::DescribeDirectoriesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_directories::DescribeDirectoriesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_directories::DescribeDirectoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_domain_controllers::DescribeDomainControllersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_domain_controllers::DescribeDomainControllersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_domain_controllers::DescribeDomainControllersError> for Error {
    fn from(
        err: crate::operation::describe_domain_controllers::DescribeDomainControllersError,
    ) -> Self {
        match err {
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_domain_controllers::DescribeDomainControllersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_event_topics::DescribeEventTopicsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_event_topics::DescribeEventTopicsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_event_topics::DescribeEventTopicsError> for Error {
    fn from(err: crate::operation::describe_event_topics::DescribeEventTopicsError) -> Self {
        match err {
            crate::operation::describe_event_topics::DescribeEventTopicsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_event_topics::DescribeEventTopicsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_event_topics::DescribeEventTopicsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_event_topics::DescribeEventTopicsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_event_topics::DescribeEventTopicsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError> for Error {
    fn from(err: crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError) -> Self {
        match err {
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_ldaps_settings::DescribeLDAPSSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_regions::DescribeRegionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_regions::DescribeRegionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_regions::DescribeRegionsError> for Error {
    fn from(err: crate::operation::describe_regions::DescribeRegionsError) -> Self {
        match err {
            crate::operation::describe_regions::DescribeRegionsError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::describe_regions::DescribeRegionsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_regions::DescribeRegionsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_regions::DescribeRegionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_regions::DescribeRegionsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_regions::DescribeRegionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_regions::DescribeRegionsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_regions::DescribeRegionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_settings::DescribeSettingsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_settings::DescribeSettingsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_settings::DescribeSettingsError> for Error {
    fn from(err: crate::operation::describe_settings::DescribeSettingsError) -> Self {
        match err {
            crate::operation::describe_settings::DescribeSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_settings::DescribeSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_settings::DescribeSettingsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_settings::DescribeSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_settings::DescribeSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_settings::DescribeSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_settings::DescribeSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_shared_directories::DescribeSharedDirectoriesError> for Error {
    fn from(
        err: crate::operation::describe_shared_directories::DescribeSharedDirectoriesError,
    ) -> Self {
        match err {
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_shared_directories::DescribeSharedDirectoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_snapshots::DescribeSnapshotsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_snapshots::DescribeSnapshotsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_snapshots::DescribeSnapshotsError> for Error {
    fn from(err: crate::operation::describe_snapshots::DescribeSnapshotsError) -> Self {
        match err {
            crate::operation::describe_snapshots::DescribeSnapshotsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_snapshots::DescribeSnapshotsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_snapshots::DescribeSnapshotsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_snapshots::DescribeSnapshotsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_snapshots::DescribeSnapshotsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_snapshots::DescribeSnapshotsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_trusts::DescribeTrustsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_trusts::DescribeTrustsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_trusts::DescribeTrustsError> for Error {
    fn from(err: crate::operation::describe_trusts::DescribeTrustsError) -> Self {
        match err {
            crate::operation::describe_trusts::DescribeTrustsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::describe_trusts::DescribeTrustsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_update_directory::DescribeUpdateDirectoryError> for Error {
    fn from(
        err: crate::operation::describe_update_directory::DescribeUpdateDirectoryError,
    ) -> Self {
        match err {
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::describe_update_directory::DescribeUpdateDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::disable_client_authentication::DisableClientAuthenticationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::disable_client_authentication::DisableClientAuthenticationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::disable_client_authentication::DisableClientAuthenticationError>
    for Error
{
    fn from(
        err: crate::operation::disable_client_authentication::DisableClientAuthenticationError,
    ) -> Self {
        match err {
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::InvalidClientAuthStatusException(inner) => Error::InvalidClientAuthStatusException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::disable_client_authentication::DisableClientAuthenticationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::disable_ldaps::DisableLDAPSError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::disable_ldaps::DisableLDAPSError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::disable_ldaps::DisableLDAPSError> for Error {
    fn from(err: crate::operation::disable_ldaps::DisableLDAPSError) -> Self {
        match err {
            crate::operation::disable_ldaps::DisableLDAPSError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::disable_ldaps::DisableLDAPSError::DirectoryDoesNotExistException(
                inner,
            ) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::disable_ldaps::DisableLDAPSError::DirectoryUnavailableException(
                inner,
            ) => Error::DirectoryUnavailableException(inner),
            crate::operation::disable_ldaps::DisableLDAPSError::InvalidLdapsStatusException(
                inner,
            ) => Error::InvalidLdapsStatusException(inner),
            crate::operation::disable_ldaps::DisableLDAPSError::InvalidParameterException(
                inner,
            ) => Error::InvalidParameterException(inner),
            crate::operation::disable_ldaps::DisableLDAPSError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::disable_ldaps::DisableLDAPSError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::disable_ldaps::DisableLDAPSError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::disable_radius::DisableRadiusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::disable_radius::DisableRadiusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::disable_radius::DisableRadiusError> for Error {
    fn from(err: crate::operation::disable_radius::DisableRadiusError) -> Self {
        match err {
            crate::operation::disable_radius::DisableRadiusError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::disable_radius::DisableRadiusError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::disable_radius::DisableRadiusError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::disable_radius::DisableRadiusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::disable_sso::DisableSsoError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::disable_sso::DisableSsoError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::disable_sso::DisableSsoError> for Error {
    fn from(err: crate::operation::disable_sso::DisableSsoError) -> Self {
        match err {
            crate::operation::disable_sso::DisableSsoError::AuthenticationFailedException(
                inner,
            ) => Error::AuthenticationFailedException(inner),
            crate::operation::disable_sso::DisableSsoError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::disable_sso::DisableSsoError::EntityDoesNotExistException(inner) => {
                Error::EntityDoesNotExistException(inner)
            }
            crate::operation::disable_sso::DisableSsoError::InsufficientPermissionsException(
                inner,
            ) => Error::InsufficientPermissionsException(inner),
            crate::operation::disable_sso::DisableSsoError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::disable_sso::DisableSsoError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::enable_client_authentication::EnableClientAuthenticationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::enable_client_authentication::EnableClientAuthenticationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::enable_client_authentication::EnableClientAuthenticationError>
    for Error
{
    fn from(
        err: crate::operation::enable_client_authentication::EnableClientAuthenticationError,
    ) -> Self {
        match err {
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::InvalidClientAuthStatusException(inner) => Error::InvalidClientAuthStatusException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::NoAvailableCertificateException(inner) => Error::NoAvailableCertificateException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::enable_client_authentication::EnableClientAuthenticationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::enable_ldaps::EnableLDAPSError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::enable_ldaps::EnableLDAPSError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::enable_ldaps::EnableLDAPSError> for Error {
    fn from(err: crate::operation::enable_ldaps::EnableLDAPSError) -> Self {
        match err {
            crate::operation::enable_ldaps::EnableLDAPSError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::enable_ldaps::EnableLDAPSError::DirectoryDoesNotExistException(
                inner,
            ) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::enable_ldaps::EnableLDAPSError::DirectoryUnavailableException(
                inner,
            ) => Error::DirectoryUnavailableException(inner),
            crate::operation::enable_ldaps::EnableLDAPSError::InvalidLdapsStatusException(
                inner,
            ) => Error::InvalidLdapsStatusException(inner),
            crate::operation::enable_ldaps::EnableLDAPSError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::enable_ldaps::EnableLDAPSError::NoAvailableCertificateException(
                inner,
            ) => Error::NoAvailableCertificateException(inner),
            crate::operation::enable_ldaps::EnableLDAPSError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::enable_ldaps::EnableLDAPSError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::enable_ldaps::EnableLDAPSError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::enable_radius::EnableRadiusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::enable_radius::EnableRadiusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::enable_radius::EnableRadiusError> for Error {
    fn from(err: crate::operation::enable_radius::EnableRadiusError) -> Self {
        match err {
            crate::operation::enable_radius::EnableRadiusError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::enable_radius::EnableRadiusError::EntityAlreadyExistsException(
                inner,
            ) => Error::EntityAlreadyExistsException(inner),
            crate::operation::enable_radius::EnableRadiusError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::enable_radius::EnableRadiusError::InvalidParameterException(
                inner,
            ) => Error::InvalidParameterException(inner),
            crate::operation::enable_radius::EnableRadiusError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::enable_radius::EnableRadiusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::enable_sso::EnableSsoError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::enable_sso::EnableSsoError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::enable_sso::EnableSsoError> for Error {
    fn from(err: crate::operation::enable_sso::EnableSsoError) -> Self {
        match err {
            crate::operation::enable_sso::EnableSsoError::AuthenticationFailedException(inner) => {
                Error::AuthenticationFailedException(inner)
            }
            crate::operation::enable_sso::EnableSsoError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::enable_sso::EnableSsoError::EntityDoesNotExistException(inner) => {
                Error::EntityDoesNotExistException(inner)
            }
            crate::operation::enable_sso::EnableSsoError::InsufficientPermissionsException(
                inner,
            ) => Error::InsufficientPermissionsException(inner),
            crate::operation::enable_sso::EnableSsoError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::enable_sso::EnableSsoError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_directory_limits::GetDirectoryLimitsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_directory_limits::GetDirectoryLimitsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_directory_limits::GetDirectoryLimitsError> for Error {
    fn from(err: crate::operation::get_directory_limits::GetDirectoryLimitsError) -> Self {
        match err {
            crate::operation::get_directory_limits::GetDirectoryLimitsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::get_directory_limits::GetDirectoryLimitsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::get_directory_limits::GetDirectoryLimitsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::get_directory_limits::GetDirectoryLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_snapshot_limits::GetSnapshotLimitsError> for Error {
    fn from(err: crate::operation::get_snapshot_limits::GetSnapshotLimitsError) -> Self {
        match err {
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::get_snapshot_limits::GetSnapshotLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_certificates::ListCertificatesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_certificates::ListCertificatesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_certificates::ListCertificatesError> for Error {
    fn from(err: crate::operation::list_certificates::ListCertificatesError) -> Self {
        match err {
            crate::operation::list_certificates::ListCertificatesError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::list_certificates::ListCertificatesError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::list_certificates::ListCertificatesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_certificates::ListCertificatesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::list_certificates::ListCertificatesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::list_certificates::ListCertificatesError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::list_certificates::ListCertificatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::list_ip_routes::ListIpRoutesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_ip_routes::ListIpRoutesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_ip_routes::ListIpRoutesError> for Error {
    fn from(err: crate::operation::list_ip_routes::ListIpRoutesError) -> Self {
        match err {
            crate::operation::list_ip_routes::ListIpRoutesError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::list_ip_routes::ListIpRoutesError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::list_ip_routes::ListIpRoutesError::InvalidNextTokenException(
                inner,
            ) => Error::InvalidNextTokenException(inner),
            crate::operation::list_ip_routes::ListIpRoutesError::InvalidParameterException(
                inner,
            ) => Error::InvalidParameterException(inner),
            crate::operation::list_ip_routes::ListIpRoutesError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::list_ip_routes::ListIpRoutesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_log_subscriptions::ListLogSubscriptionsError> for Error {
    fn from(err: crate::operation::list_log_subscriptions::ListLogSubscriptionsError) -> Self {
        match err {
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::list_log_subscriptions::ListLogSubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_schema_extensions::ListSchemaExtensionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_schema_extensions::ListSchemaExtensionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_schema_extensions::ListSchemaExtensionsError> for Error {
    fn from(err: crate::operation::list_schema_extensions::ListSchemaExtensionsError) -> Self {
        match err {
            crate::operation::list_schema_extensions::ListSchemaExtensionsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::list_schema_extensions::ListSchemaExtensionsError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::list_schema_extensions::ListSchemaExtensionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_schema_extensions::ListSchemaExtensionsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::list_schema_extensions::ListSchemaExtensionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_tags_for_resource::ListTagsForResourceError> for Error {
    fn from(err: crate::operation::list_tags_for_resource::ListTagsForResourceError) -> Self {
        match err {
            crate::operation::list_tags_for_resource::ListTagsForResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::register_certificate::RegisterCertificateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::register_certificate::RegisterCertificateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::register_certificate::RegisterCertificateError> for Error {
    fn from(err: crate::operation::register_certificate::RegisterCertificateError) -> Self {
        match err {
            crate::operation::register_certificate::RegisterCertificateError::CertificateAlreadyExistsException(inner) => Error::CertificateAlreadyExistsException(inner),
            crate::operation::register_certificate::RegisterCertificateError::CertificateLimitExceededException(inner) => Error::CertificateLimitExceededException(inner),
            crate::operation::register_certificate::RegisterCertificateError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::register_certificate::RegisterCertificateError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::register_certificate::RegisterCertificateError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::register_certificate::RegisterCertificateError::InvalidCertificateException(inner) => Error::InvalidCertificateException(inner),
            crate::operation::register_certificate::RegisterCertificateError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::register_certificate::RegisterCertificateError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::register_certificate::RegisterCertificateError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::register_certificate::RegisterCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::register_event_topic::RegisterEventTopicError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::register_event_topic::RegisterEventTopicError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::register_event_topic::RegisterEventTopicError> for Error {
    fn from(err: crate::operation::register_event_topic::RegisterEventTopicError) -> Self {
        match err {
            crate::operation::register_event_topic::RegisterEventTopicError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::register_event_topic::RegisterEventTopicError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::register_event_topic::RegisterEventTopicError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::register_event_topic::RegisterEventTopicError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::register_event_topic::RegisterEventTopicError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::reject_shared_directory::RejectSharedDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::reject_shared_directory::RejectSharedDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::reject_shared_directory::RejectSharedDirectoryError> for Error {
    fn from(err: crate::operation::reject_shared_directory::RejectSharedDirectoryError) -> Self {
        match err {
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::reject_shared_directory::RejectSharedDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::remove_ip_routes::RemoveIpRoutesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::remove_ip_routes::RemoveIpRoutesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::remove_ip_routes::RemoveIpRoutesError> for Error {
    fn from(err: crate::operation::remove_ip_routes::RemoveIpRoutesError) -> Self {
        match err {
            crate::operation::remove_ip_routes::RemoveIpRoutesError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::remove_ip_routes::RemoveIpRoutesError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::remove_ip_routes::RemoveIpRoutesError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::remove_ip_routes::RemoveIpRoutesError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::remove_ip_routes::RemoveIpRoutesError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::remove_ip_routes::RemoveIpRoutesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::remove_region::RemoveRegionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::remove_region::RemoveRegionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::remove_region::RemoveRegionError> for Error {
    fn from(err: crate::operation::remove_region::RemoveRegionError) -> Self {
        match err {
            crate::operation::remove_region::RemoveRegionError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::operation::remove_region::RemoveRegionError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::remove_region::RemoveRegionError::DirectoryDoesNotExistException(
                inner,
            ) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::remove_region::RemoveRegionError::DirectoryUnavailableException(
                inner,
            ) => Error::DirectoryUnavailableException(inner),
            crate::operation::remove_region::RemoveRegionError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::remove_region::RemoveRegionError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::remove_region::RemoveRegionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError> for Error {
    fn from(err: crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError) -> Self {
        match err {
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::remove_tags_from_resource::RemoveTagsFromResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::reset_user_password::ResetUserPasswordError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::reset_user_password::ResetUserPasswordError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::reset_user_password::ResetUserPasswordError> for Error {
    fn from(err: crate::operation::reset_user_password::ResetUserPasswordError) -> Self {
        match err {
            crate::operation::reset_user_password::ResetUserPasswordError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::InvalidPasswordException(inner) => Error::InvalidPasswordException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::UserDoesNotExistException(inner) => Error::UserDoesNotExistException(inner),
            crate::operation::reset_user_password::ResetUserPasswordError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::restore_from_snapshot::RestoreFromSnapshotError> for Error {
    fn from(err: crate::operation::restore_from_snapshot::RestoreFromSnapshotError) -> Self {
        match err {
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::restore_from_snapshot::RestoreFromSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::share_directory::ShareDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::share_directory::ShareDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::share_directory::ShareDirectoryError> for Error {
    fn from(err: crate::operation::share_directory::ShareDirectoryError) -> Self {
        match err {
            crate::operation::share_directory::ShareDirectoryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::share_directory::ShareDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::share_directory::ShareDirectoryError::DirectoryAlreadySharedException(inner) => Error::DirectoryAlreadySharedException(inner),
            crate::operation::share_directory::ShareDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::share_directory::ShareDirectoryError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::share_directory::ShareDirectoryError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::operation::share_directory::ShareDirectoryError::OrganizationsException(inner) => Error::OrganizationsException(inner),
            crate::operation::share_directory::ShareDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::share_directory::ShareDirectoryError::ShareLimitExceededException(inner) => Error::ShareLimitExceededException(inner),
            crate::operation::share_directory::ShareDirectoryError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::share_directory::ShareDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::start_schema_extension::StartSchemaExtensionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::start_schema_extension::StartSchemaExtensionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::start_schema_extension::StartSchemaExtensionError> for Error {
    fn from(err: crate::operation::start_schema_extension::StartSchemaExtensionError) -> Self {
        match err {
            crate::operation::start_schema_extension::StartSchemaExtensionError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::operation::start_schema_extension::StartSchemaExtensionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::unshare_directory::UnshareDirectoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::unshare_directory::UnshareDirectoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::unshare_directory::UnshareDirectoryError> for Error {
    fn from(err: crate::operation::unshare_directory::UnshareDirectoryError) -> Self {
        match err {
            crate::operation::unshare_directory::UnshareDirectoryError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::unshare_directory::UnshareDirectoryError::DirectoryNotSharedException(inner) => Error::DirectoryNotSharedException(inner),
            crate::operation::unshare_directory::UnshareDirectoryError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::unshare_directory::UnshareDirectoryError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::operation::unshare_directory::UnshareDirectoryError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::unshare_directory::UnshareDirectoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError>
    for Error
{
    fn from(
        err: crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError,
    ) -> Self {
        match err {
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::update_conditional_forwarder::UpdateConditionalForwarderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_directory_setup::UpdateDirectorySetupError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_directory_setup::UpdateDirectorySetupError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_directory_setup::UpdateDirectorySetupError> for Error {
    fn from(err: crate::operation::update_directory_setup::UpdateDirectorySetupError) -> Self {
        match err {
            crate::operation::update_directory_setup::UpdateDirectorySetupError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::DirectoryInDesiredStateException(inner) => Error::DirectoryInDesiredStateException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::SnapshotLimitExceededException(inner) => Error::SnapshotLimitExceededException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::update_directory_setup::UpdateDirectorySetupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl
    From<
        crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError,
    > for Error
{
    fn from(
        err: crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError,
    ) -> Self {
        match err {
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::DomainControllerLimitExceededException(inner) => Error::DomainControllerLimitExceededException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::EntityDoesNotExistException(inner) => Error::EntityDoesNotExistException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::update_number_of_domain_controllers::UpdateNumberOfDomainControllersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::update_radius::UpdateRadiusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_radius::UpdateRadiusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_radius::UpdateRadiusError> for Error {
    fn from(err: crate::operation::update_radius::UpdateRadiusError) -> Self {
        match err {
            crate::operation::update_radius::UpdateRadiusError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::update_radius::UpdateRadiusError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::update_radius::UpdateRadiusError::InvalidParameterException(
                inner,
            ) => Error::InvalidParameterException(inner),
            crate::operation::update_radius::UpdateRadiusError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::update_radius::UpdateRadiusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_settings::UpdateSettingsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_settings::UpdateSettingsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_settings::UpdateSettingsError> for Error {
    fn from(err: crate::operation::update_settings::UpdateSettingsError) -> Self {
        match err {
            crate::operation::update_settings::UpdateSettingsError::ClientException(inner) => Error::ClientException(inner),
            crate::operation::update_settings::UpdateSettingsError::DirectoryDoesNotExistException(inner) => Error::DirectoryDoesNotExistException(inner),
            crate::operation::update_settings::UpdateSettingsError::DirectoryUnavailableException(inner) => Error::DirectoryUnavailableException(inner),
            crate::operation::update_settings::UpdateSettingsError::IncompatibleSettingsException(inner) => Error::IncompatibleSettingsException(inner),
            crate::operation::update_settings::UpdateSettingsError::InvalidParameterException(inner) => Error::InvalidParameterException(inner),
            crate::operation::update_settings::UpdateSettingsError::ServiceException(inner) => Error::ServiceException(inner),
            crate::operation::update_settings::UpdateSettingsError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::operation::update_settings::UpdateSettingsError::UnsupportedSettingsException(inner) => Error::UnsupportedSettingsException(inner),
            crate::operation::update_settings::UpdateSettingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_trust::UpdateTrustError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::update_trust::UpdateTrustError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_trust::UpdateTrustError> for Error {
    fn from(err: crate::operation::update_trust::UpdateTrustError) -> Self {
        match err {
            crate::operation::update_trust::UpdateTrustError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::update_trust::UpdateTrustError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::update_trust::UpdateTrustError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::update_trust::UpdateTrustError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::update_trust::UpdateTrustError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::verify_trust::VerifyTrustError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::verify_trust::VerifyTrustError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::verify_trust::VerifyTrustError> for Error {
    fn from(err: crate::operation::verify_trust::VerifyTrustError) -> Self {
        match err {
            crate::operation::verify_trust::VerifyTrustError::ClientException(inner) => {
                Error::ClientException(inner)
            }
            crate::operation::verify_trust::VerifyTrustError::EntityDoesNotExistException(
                inner,
            ) => Error::EntityDoesNotExistException(inner),
            crate::operation::verify_trust::VerifyTrustError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::verify_trust::VerifyTrustError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::verify_trust::VerifyTrustError::UnsupportedOperationException(
                inner,
            ) => Error::UnsupportedOperationException(inner),
            crate::operation::verify_trust::VerifyTrustError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::AuthenticationFailedException(e) => e.request_id(),
            Self::CertificateAlreadyExistsException(e) => e.request_id(),
            Self::CertificateDoesNotExistException(e) => e.request_id(),
            Self::CertificateInUseException(e) => e.request_id(),
            Self::CertificateLimitExceededException(e) => e.request_id(),
            Self::ClientException(e) => e.request_id(),
            Self::DirectoryAlreadyInRegionException(e) => e.request_id(),
            Self::DirectoryAlreadySharedException(e) => e.request_id(),
            Self::DirectoryDoesNotExistException(e) => e.request_id(),
            Self::DirectoryInDesiredStateException(e) => e.request_id(),
            Self::DirectoryLimitExceededException(e) => e.request_id(),
            Self::DirectoryNotSharedException(e) => e.request_id(),
            Self::DirectoryUnavailableException(e) => e.request_id(),
            Self::DomainControllerLimitExceededException(e) => e.request_id(),
            Self::EntityAlreadyExistsException(e) => e.request_id(),
            Self::EntityDoesNotExistException(e) => e.request_id(),
            Self::IncompatibleSettingsException(e) => e.request_id(),
            Self::InsufficientPermissionsException(e) => e.request_id(),
            Self::InvalidCertificateException(e) => e.request_id(),
            Self::InvalidClientAuthStatusException(e) => e.request_id(),
            Self::InvalidLdapsStatusException(e) => e.request_id(),
            Self::InvalidNextTokenException(e) => e.request_id(),
            Self::InvalidParameterException(e) => e.request_id(),
            Self::InvalidPasswordException(e) => e.request_id(),
            Self::InvalidTargetException(e) => e.request_id(),
            Self::IpRouteLimitExceededException(e) => e.request_id(),
            Self::NoAvailableCertificateException(e) => e.request_id(),
            Self::OrganizationsException(e) => e.request_id(),
            Self::RegionLimitExceededException(e) => e.request_id(),
            Self::ServiceException(e) => e.request_id(),
            Self::ShareLimitExceededException(e) => e.request_id(),
            Self::SnapshotLimitExceededException(e) => e.request_id(),
            Self::TagLimitExceededException(e) => e.request_id(),
            Self::UnsupportedOperationException(e) => e.request_id(),
            Self::UnsupportedSettingsException(e) => e.request_id(),
            Self::UserDoesNotExistException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
