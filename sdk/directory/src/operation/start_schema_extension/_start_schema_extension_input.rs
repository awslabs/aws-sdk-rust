// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartSchemaExtensionInput  {
    /// <p>The identifier of the directory for which the schema extension will be applied to.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>If true, creates a snapshot of the directory before applying the schema extension.</p>
    #[doc(hidden)]
    pub create_snapshot_before_schema_extension: bool,
    /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.</p>
    #[doc(hidden)]
    pub ldif_content: std::option::Option<std::string::String>,
    /// <p>A description of the schema extension.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl StartSchemaExtensionInput {
    /// <p>The identifier of the directory for which the schema extension will be applied to.</p>
    pub fn directory_id(&self) -> std::option::Option<& str> {
        self.directory_id.as_deref()
    }
    /// <p>If true, creates a snapshot of the directory before applying the schema extension.</p>
    pub fn create_snapshot_before_schema_extension(&self) -> bool {
        self.create_snapshot_before_schema_extension
    }
    /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.</p>
    pub fn ldif_content(&self) -> std::option::Option<& str> {
        self.ldif_content.as_deref()
    }
    /// <p>A description of the schema extension.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}
impl StartSchemaExtensionInput {
    /// Creates a new builder-style object to manufacture [`StartSchemaExtensionInput`](crate::operation::start_schema_extension::StartSchemaExtensionInput).
    pub fn builder() -> crate::operation::start_schema_extension::builders::StartSchemaExtensionInputBuilder {
        crate::operation::start_schema_extension::builders::StartSchemaExtensionInputBuilder::default()
    }
}

/// A builder for [`StartSchemaExtensionInput`](crate::operation::start_schema_extension::StartSchemaExtensionInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct StartSchemaExtensionInputBuilder {
    pub(crate) directory_id: std::option::Option<std::string::String>,
    pub(crate) create_snapshot_before_schema_extension: std::option::Option<bool>,
    pub(crate) ldif_content: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
}
impl StartSchemaExtensionInputBuilder {
    /// <p>The identifier of the directory for which the schema extension will be applied to.</p>
    pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.directory_id = Some(input.into());
        self
    }
    /// <p>The identifier of the directory for which the schema extension will be applied to.</p>
    pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.directory_id = input; self
    }
    /// <p>If true, creates a snapshot of the directory before applying the schema extension.</p>
    pub fn create_snapshot_before_schema_extension(mut self, input: bool) -> Self {
        self.create_snapshot_before_schema_extension = Some(input);
        self
    }
    /// <p>If true, creates a snapshot of the directory before applying the schema extension.</p>
    pub fn set_create_snapshot_before_schema_extension(mut self, input: std::option::Option<bool>) -> Self {
        self.create_snapshot_before_schema_extension = input; self
    }
    /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.</p>
    pub fn ldif_content(mut self, input: impl Into<std::string::String>) -> Self {
        self.ldif_content = Some(input.into());
        self
    }
    /// <p>The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.</p>
    pub fn set_ldif_content(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ldif_content = input; self
    }
    /// <p>A description of the schema extension.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>A description of the schema extension.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input; self
    }
    /// Consumes the builder and constructs a [`StartSchemaExtensionInput`](crate::operation::start_schema_extension::StartSchemaExtensionInput).
    pub fn build(self) -> Result<crate::operation::start_schema_extension::StartSchemaExtensionInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::start_schema_extension::StartSchemaExtensionInput {
                directory_id: self.directory_id
                ,
                create_snapshot_before_schema_extension: self.create_snapshot_before_schema_extension
                    .unwrap_or_default()
                ,
                ldif_content: self.ldif_content
                ,
                description: self.description
                ,
            }
        )
    }
}

