// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a Remote Authentication Dial In User Service (RADIUS) server.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct RadiusSettings {
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    pub radius_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.</p>
    pub radius_port: ::std::option::Option<i32>,
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    pub radius_timeout: ::std::option::Option<i32>,
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    pub radius_retries: i32,
    /// <p>Required for enabling RADIUS on the directory.</p>
    pub shared_secret: ::std::option::Option<::std::string::String>,
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    pub authentication_protocol: ::std::option::Option<crate::types::RadiusAuthenticationProtocol>,
    /// <p>Not currently used.</p>
    pub display_label: ::std::option::Option<::std::string::String>,
    /// <p>Not currently used.</p>
    pub use_same_username: bool,
}
impl RadiusSettings {
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.radius_servers.is_none()`.
    pub fn radius_servers(&self) -> &[::std::string::String] {
        self.radius_servers.as_deref().unwrap_or_default()
    }
    /// <p>The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.</p>
    pub fn radius_port(&self) -> ::std::option::Option<i32> {
        self.radius_port
    }
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    pub fn radius_timeout(&self) -> ::std::option::Option<i32> {
        self.radius_timeout
    }
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    pub fn radius_retries(&self) -> i32 {
        self.radius_retries
    }
    /// <p>Required for enabling RADIUS on the directory.</p>
    pub fn shared_secret(&self) -> ::std::option::Option<&str> {
        self.shared_secret.as_deref()
    }
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    pub fn authentication_protocol(&self) -> ::std::option::Option<&crate::types::RadiusAuthenticationProtocol> {
        self.authentication_protocol.as_ref()
    }
    /// <p>Not currently used.</p>
    pub fn display_label(&self) -> ::std::option::Option<&str> {
        self.display_label.as_deref()
    }
    /// <p>Not currently used.</p>
    pub fn use_same_username(&self) -> bool {
        self.use_same_username
    }
}
impl ::std::fmt::Debug for RadiusSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RadiusSettings");
        formatter.field("radius_servers", &self.radius_servers);
        formatter.field("radius_port", &self.radius_port);
        formatter.field("radius_timeout", &self.radius_timeout);
        formatter.field("radius_retries", &self.radius_retries);
        formatter.field("shared_secret", &"*** Sensitive Data Redacted ***");
        formatter.field("authentication_protocol", &self.authentication_protocol);
        formatter.field("display_label", &self.display_label);
        formatter.field("use_same_username", &self.use_same_username);
        formatter.finish()
    }
}
impl RadiusSettings {
    /// Creates a new builder-style object to manufacture [`RadiusSettings`](crate::types::RadiusSettings).
    pub fn builder() -> crate::types::builders::RadiusSettingsBuilder {
        crate::types::builders::RadiusSettingsBuilder::default()
    }
}

/// A builder for [`RadiusSettings`](crate::types::RadiusSettings).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct RadiusSettingsBuilder {
    pub(crate) radius_servers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) radius_port: ::std::option::Option<i32>,
    pub(crate) radius_timeout: ::std::option::Option<i32>,
    pub(crate) radius_retries: ::std::option::Option<i32>,
    pub(crate) shared_secret: ::std::option::Option<::std::string::String>,
    pub(crate) authentication_protocol: ::std::option::Option<crate::types::RadiusAuthenticationProtocol>,
    pub(crate) display_label: ::std::option::Option<::std::string::String>,
    pub(crate) use_same_username: ::std::option::Option<bool>,
}
impl RadiusSettingsBuilder {
    /// Appends an item to `radius_servers`.
    ///
    /// To override the contents of this collection use [`set_radius_servers`](Self::set_radius_servers).
    ///
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    pub fn radius_servers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.radius_servers.unwrap_or_default();
        v.push(input.into());
        self.radius_servers = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    pub fn set_radius_servers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.radius_servers = input;
        self
    }
    /// <p>An array of strings that contains the fully qualified domain name (FQDN) or IP addresses of the RADIUS server endpoints, or the FQDN or IP addresses of your RADIUS server load balancer.</p>
    pub fn get_radius_servers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.radius_servers
    }
    /// <p>The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.</p>
    pub fn radius_port(mut self, input: i32) -> Self {
        self.radius_port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.</p>
    pub fn set_radius_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.radius_port = input;
        self
    }
    /// <p>The port that your RADIUS server is using for communications. Your self-managed network must allow inbound traffic over this port from the Directory Service servers.</p>
    pub fn get_radius_port(&self) -> &::std::option::Option<i32> {
        &self.radius_port
    }
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    pub fn radius_timeout(mut self, input: i32) -> Self {
        self.radius_timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    pub fn set_radius_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.radius_timeout = input;
        self
    }
    /// <p>The amount of time, in seconds, to wait for the RADIUS server to respond.</p>
    pub fn get_radius_timeout(&self) -> &::std::option::Option<i32> {
        &self.radius_timeout
    }
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    pub fn radius_retries(mut self, input: i32) -> Self {
        self.radius_retries = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    pub fn set_radius_retries(mut self, input: ::std::option::Option<i32>) -> Self {
        self.radius_retries = input;
        self
    }
    /// <p>The maximum number of times that communication with the RADIUS server is attempted.</p>
    pub fn get_radius_retries(&self) -> &::std::option::Option<i32> {
        &self.radius_retries
    }
    /// <p>Required for enabling RADIUS on the directory.</p>
    pub fn shared_secret(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shared_secret = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Required for enabling RADIUS on the directory.</p>
    pub fn set_shared_secret(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shared_secret = input;
        self
    }
    /// <p>Required for enabling RADIUS on the directory.</p>
    pub fn get_shared_secret(&self) -> &::std::option::Option<::std::string::String> {
        &self.shared_secret
    }
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    pub fn authentication_protocol(mut self, input: crate::types::RadiusAuthenticationProtocol) -> Self {
        self.authentication_protocol = ::std::option::Option::Some(input);
        self
    }
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    pub fn set_authentication_protocol(mut self, input: ::std::option::Option<crate::types::RadiusAuthenticationProtocol>) -> Self {
        self.authentication_protocol = input;
        self
    }
    /// <p>The protocol specified for your RADIUS endpoints.</p>
    pub fn get_authentication_protocol(&self) -> &::std::option::Option<crate::types::RadiusAuthenticationProtocol> {
        &self.authentication_protocol
    }
    /// <p>Not currently used.</p>
    pub fn display_label(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_label = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Not currently used.</p>
    pub fn set_display_label(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_label = input;
        self
    }
    /// <p>Not currently used.</p>
    pub fn get_display_label(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_label
    }
    /// <p>Not currently used.</p>
    pub fn use_same_username(mut self, input: bool) -> Self {
        self.use_same_username = ::std::option::Option::Some(input);
        self
    }
    /// <p>Not currently used.</p>
    pub fn set_use_same_username(mut self, input: ::std::option::Option<bool>) -> Self {
        self.use_same_username = input;
        self
    }
    /// <p>Not currently used.</p>
    pub fn get_use_same_username(&self) -> &::std::option::Option<bool> {
        &self.use_same_username
    }
    /// Consumes the builder and constructs a [`RadiusSettings`](crate::types::RadiusSettings).
    pub fn build(self) -> crate::types::RadiusSettings {
        crate::types::RadiusSettings {
            radius_servers: self.radius_servers,
            radius_port: self.radius_port,
            radius_timeout: self.radius_timeout,
            radius_retries: self.radius_retries.unwrap_or_default(),
            shared_secret: self.shared_secret,
            authentication_protocol: self.authentication_protocol,
            display_label: self.display_label,
            use_same_username: self.use_same_username.unwrap_or_default(),
        }
    }
}
impl ::std::fmt::Debug for RadiusSettingsBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RadiusSettingsBuilder");
        formatter.field("radius_servers", &self.radius_servers);
        formatter.field("radius_port", &self.radius_port);
        formatter.field("radius_timeout", &self.radius_timeout);
        formatter.field("radius_retries", &self.radius_retries);
        formatter.field("shared_secret", &"*** Sensitive Data Redacted ***");
        formatter.field("authentication_protocol", &self.authentication_protocol);
        formatter.field("display_label", &self.display_label);
        formatter.field("use_same_username", &self.use_same_username);
        formatter.finish()
    }
}
