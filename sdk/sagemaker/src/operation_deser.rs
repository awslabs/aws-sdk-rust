// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddAssociationOutput, crate::error::AddAssociationError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AddAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::AddAssociationError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::AddAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::AddAssociationError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::AddAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddAssociationOutput, crate::error::AddAssociationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_add_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AddTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::AddTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_add_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddTagsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTrialComponentOutput,
    crate::error::AssociateTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateTrialComponentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::AssociateTrialComponentError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateTrialComponentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::AssociateTrialComponentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AssociateTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::AssociateTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateTrialComponentOutput,
    crate::error::AssociateTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_model_package_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeModelPackageOutput,
    crate::error::BatchDescribeModelPackageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BatchDescribeModelPackageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::BatchDescribeModelPackageError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_model_package_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeModelPackageOutput,
    crate::error::BatchDescribeModelPackageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_describe_model_package_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_describe_model_package(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchDescribeModelPackageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActionOutput, crate::error::CreateActionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateActionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateActionError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateActionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateActionOutput, crate::error::CreateActionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_action_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateActionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_algorithm_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAlgorithmOutput, crate::error::CreateAlgorithmError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAlgorithmError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateAlgorithmError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_algorithm_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAlgorithmOutput, crate::error::CreateAlgorithmError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_algorithm_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_algorithm(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAlgorithmError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAppOutput, crate::error::CreateAppError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAppError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAppError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateAppError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAppError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateAppError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAppError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateAppError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAppOutput, crate::error::CreateAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_app_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_app(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAppError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_image_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAppImageConfigOutput,
    crate::error::CreateAppImageConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAppImageConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAppImageConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateAppImageConfigError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAppImageConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateAppImageConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_image_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAppImageConfigOutput,
    crate::error::CreateAppImageConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_app_image_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_app_image_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAppImageConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_artifact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateArtifactOutput, crate::error::CreateArtifactError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateArtifactError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateArtifactError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateArtifactError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateArtifactError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateArtifactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_artifact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateArtifactOutput, crate::error::CreateArtifactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_artifact_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_artifact(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateArtifactError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_auto_ml_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAutoMlJobOutput, crate::error::CreateAutoMLJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateAutoMLJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAutoMLJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateAutoMLJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAutoMLJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateAutoMLJobError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAutoMLJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateAutoMLJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_auto_ml_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAutoMlJobOutput, crate::error::CreateAutoMLJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_auto_ml_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_auto_ml_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAutoMLJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_code_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCodeRepositoryOutput,
    crate::error::CreateCodeRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCodeRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateCodeRepositoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_code_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCodeRepositoryOutput,
    crate::error::CreateCodeRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_code_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_code_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCodeRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_compilation_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCompilationJobOutput,
    crate::error::CreateCompilationJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCompilationJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCompilationJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateCompilationJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateCompilationJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateCompilationJobError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCompilationJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateCompilationJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_compilation_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCompilationJobOutput,
    crate::error::CreateCompilationJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_compilation_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_compilation_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCompilationJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_context_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContextOutput, crate::error::CreateContextError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateContextError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateContextError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateContextError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateContextError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateContextError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_context_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContextOutput, crate::error::CreateContextError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_context_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_context(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateContextError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_data_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDataQualityJobDefinitionOutput,
    crate::error::CreateDataQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDataQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDataQualityJobDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateDataQualityJobDefinitionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDataQualityJobDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateDataQualityJobDefinitionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDataQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateDataQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_data_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDataQualityJobDefinitionOutput,
    crate::error::CreateDataQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_data_quality_job_definition_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_data_quality_job_definition(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateDataQualityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeviceFleetOutput, crate::error::CreateDeviceFleetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDeviceFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDeviceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateDeviceFleetError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDeviceFleetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateDeviceFleetError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDeviceFleetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateDeviceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeviceFleetOutput, crate::error::CreateDeviceFleetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_device_fleet_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDomainError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateDomainError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateDomainError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateDomainError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_domain_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_domain(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_deployment_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgeDeploymentPlanOutput,
    crate::error::CreateEdgeDeploymentPlanError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEdgeDeploymentPlanError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEdgeDeploymentPlanError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateEdgeDeploymentPlanError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateEdgeDeploymentPlanError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateEdgeDeploymentPlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_deployment_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgeDeploymentPlanOutput,
    crate::error::CreateEdgeDeploymentPlanError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_edge_deployment_plan_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_edge_deployment_plan(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEdgeDeploymentPlanError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_deployment_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgeDeploymentStageOutput,
    crate::error::CreateEdgeDeploymentStageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEdgeDeploymentStageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEdgeDeploymentStageError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateEdgeDeploymentStageError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateEdgeDeploymentStageError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateEdgeDeploymentStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_deployment_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgeDeploymentStageOutput,
    crate::error::CreateEdgeDeploymentStageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_edge_deployment_stage_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_packaging_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgePackagingJobOutput,
    crate::error::CreateEdgePackagingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEdgePackagingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEdgePackagingJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateEdgePackagingJobError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateEdgePackagingJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateEdgePackagingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_edge_packaging_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEdgePackagingJobOutput,
    crate::error::CreateEdgePackagingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_edge_packaging_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateEndpointOutput, crate::error::CreateEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateEndpointError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateEndpointError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateEndpointOutput, crate::error::CreateEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_endpoint_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEndpointConfigOutput,
    crate::error::CreateEndpointConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateEndpointConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateEndpointConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateEndpointConfigError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateEndpointConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEndpointConfigOutput,
    crate::error::CreateEndpointConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_endpoint_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_endpoint_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEndpointConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateExperimentOutput, crate::error::CreateExperimentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateExperimentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateExperimentError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateExperimentOutput, crate::error::CreateExperimentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_feature_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFeatureGroupOutput,
    crate::error::CreateFeatureGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFeatureGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFeatureGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateFeatureGroupError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFeatureGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateFeatureGroupError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFeatureGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateFeatureGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_feature_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFeatureGroupOutput,
    crate::error::CreateFeatureGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_feature_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_feature_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFeatureGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFlowDefinitionOutput,
    crate::error::CreateFlowDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateFlowDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateFlowDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateFlowDefinitionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateFlowDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateFlowDefinitionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateFlowDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateFlowDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_flow_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateFlowDefinitionOutput,
    crate::error::CreateFlowDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_flow_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_flow_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateFlowDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hub_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHubOutput, crate::error::CreateHubError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateHubError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateHubError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateHubError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateHubError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateHubError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hub_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHubOutput, crate::error::CreateHubError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_hub_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_hub(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHubError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_human_task_ui_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHumanTaskUiOutput, crate::error::CreateHumanTaskUiError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateHumanTaskUiError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateHumanTaskUiError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateHumanTaskUiError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHumanTaskUiError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateHumanTaskUiError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateHumanTaskUiError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateHumanTaskUiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_human_task_ui_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateHumanTaskUiOutput, crate::error::CreateHumanTaskUiError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_human_task_ui_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_human_task_ui(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHumanTaskUiError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hyper_parameter_tuning_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHyperParameterTuningJobOutput,
    crate::error::CreateHyperParameterTuningJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateHyperParameterTuningJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateHyperParameterTuningJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateHyperParameterTuningJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateHyperParameterTuningJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateHyperParameterTuningJobError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateHyperParameterTuningJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateHyperParameterTuningJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hyper_parameter_tuning_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHyperParameterTuningJobOutput,
    crate::error::CreateHyperParameterTuningJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_hyper_parameter_tuning_job_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_hyper_parameter_tuning_job(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateHyperParameterTuningJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateImageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateImageError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateImageError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateImageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_image_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateImageVersionOutput,
    crate::error::CreateImageVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateImageVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateImageVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateImageVersionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateImageVersionError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreateImageVersionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateImageVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_image_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateImageVersionOutput,
    crate::error::CreateImageVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_image_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_image_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateImageVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInferenceExperimentOutput,
    crate::error::CreateInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateInferenceExperimentError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateInferenceExperimentError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInferenceExperimentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInferenceExperimentOutput,
    crate::error::CreateInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_inference_recommendations_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInferenceRecommendationsJobOutput,
    crate::error::CreateInferenceRecommendationsJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInferenceRecommendationsJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateInferenceRecommendationsJobError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateInferenceRecommendationsJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateInferenceRecommendationsJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateInferenceRecommendationsJobError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInferenceRecommendationsJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateInferenceRecommendationsJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_inference_recommendations_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInferenceRecommendationsJobOutput,
    crate::error::CreateInferenceRecommendationsJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_inference_recommendations_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_inference_recommendations_job(response.body().as_ref(), output).map_err(crate::error::CreateInferenceRecommendationsJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_labeling_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLabelingJobOutput, crate::error::CreateLabelingJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLabelingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLabelingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateLabelingJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateLabelingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateLabelingJobError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLabelingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateLabelingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_labeling_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLabelingJobOutput, crate::error::CreateLabelingJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_labeling_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_labeling_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLabelingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateModelError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateModelError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateModelError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateModelError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_bias_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelBiasJobDefinitionOutput,
    crate::error::CreateModelBiasJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelBiasJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateModelBiasJobDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateModelBiasJobDefinitionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateModelBiasJobDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateModelBiasJobDefinitionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelBiasJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateModelBiasJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_bias_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelBiasJobDefinitionOutput,
    crate::error::CreateModelBiasJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_bias_job_definition_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_model_bias_job_definition(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateModelBiasJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_card_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelCardOutput, crate::error::CreateModelCardError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelCardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateModelCardError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateModelCardError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateModelCardError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateModelCardError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_card_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelCardOutput, crate::error::CreateModelCardError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_card_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model_card(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateModelCardError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_card_export_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelCardExportJobOutput,
    crate::error::CreateModelCardExportJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelCardExportJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateModelCardExportJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateModelCardExportJobError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateModelCardExportJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateModelCardExportJobError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelCardExportJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::CreateModelCardExportJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateModelCardExportJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateModelCardExportJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_card_export_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelCardExportJobOutput,
    crate::error::CreateModelCardExportJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_card_export_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model_card_export_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateModelCardExportJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_explainability_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelExplainabilityJobDefinitionOutput,
    crate::error::CreateModelExplainabilityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelExplainabilityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateModelExplainabilityJobDefinitionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => {
            crate::error::CreateModelExplainabilityJobDefinitionError::ResourceInUse({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_in_use::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::CreateModelExplainabilityJobDefinitionError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceLimitExceeded" => {
            crate::error::CreateModelExplainabilityJobDefinitionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelExplainabilityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateModelExplainabilityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_explainability_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelExplainabilityJobDefinitionOutput,
    crate::error::CreateModelExplainabilityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_model_explainability_job_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model_explainability_job_definition(response.body().as_ref(), output).map_err(crate::error::CreateModelExplainabilityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_package_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelPackageOutput,
    crate::error::CreateModelPackageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelPackageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateModelPackageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::CreateModelPackageError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateModelPackageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateModelPackageError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelPackageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateModelPackageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_package_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelPackageOutput,
    crate::error::CreateModelPackageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_package_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model_package(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateModelPackageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_package_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelPackageGroupOutput,
    crate::error::CreateModelPackageGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelPackageGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateModelPackageGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateModelPackageGroupError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelPackageGroupError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateModelPackageGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_package_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelPackageGroupOutput,
    crate::error::CreateModelPackageGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_package_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_model_package_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateModelPackageGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelQualityJobDefinitionOutput,
    crate::error::CreateModelQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateModelQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateModelQualityJobDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateModelQualityJobDefinitionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateModelQualityJobDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateModelQualityJobDefinitionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateModelQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateModelQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateModelQualityJobDefinitionOutput,
    crate::error::CreateModelQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_model_quality_job_definition_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_model_quality_job_definition(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateModelQualityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMonitoringScheduleOutput,
    crate::error::CreateMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateMonitoringScheduleError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::CreateMonitoringScheduleError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateMonitoringScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateMonitoringScheduleOutput,
    crate::error::CreateMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_monitoring_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_monitoring_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateMonitoringScheduleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotebookInstanceOutput,
    crate::error::CreateNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateNotebookInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateNotebookInstanceError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateNotebookInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateNotebookInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotebookInstanceOutput,
    crate::error::CreateNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_notebook_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_notebook_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNotebookInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notebook_instance_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotebookInstanceLifecycleConfigOutput,
    crate::error::CreateNotebookInstanceLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNotebookInstanceLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateNotebookInstanceLifecycleConfigError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateNotebookInstanceLifecycleConfigError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateNotebookInstanceLifecycleConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateNotebookInstanceLifecycleConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_notebook_instance_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNotebookInstanceLifecycleConfigOutput,
    crate::error::CreateNotebookInstanceLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_notebook_instance_lifecycle_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_notebook_instance_lifecycle_config(response.body().as_ref(), output).map_err(crate::error::CreateNotebookInstanceLifecycleConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pipeline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePipelineOutput, crate::error::CreatePipelineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePipelineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePipelineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreatePipelineError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePipelineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreatePipelineError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePipelineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreatePipelineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pipeline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePipelineOutput, crate::error::CreatePipelineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_pipeline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_pipeline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePipelineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_presigned_domain_url_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePresignedDomainUrlOutput,
    crate::error::CreatePresignedDomainUrlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePresignedDomainUrlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePresignedDomainUrlError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::CreatePresignedDomainUrlError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePresignedDomainUrlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreatePresignedDomainUrlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_presigned_domain_url_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePresignedDomainUrlOutput,
    crate::error::CreatePresignedDomainUrlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_presigned_domain_url_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_presigned_domain_url(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePresignedDomainUrlError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_presigned_notebook_instance_url_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePresignedNotebookInstanceUrlOutput,
    crate::error::CreatePresignedNotebookInstanceUrlError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePresignedNotebookInstanceUrlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreatePresignedNotebookInstanceUrlError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_presigned_notebook_instance_url_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePresignedNotebookInstanceUrlOutput,
    crate::error::CreatePresignedNotebookInstanceUrlError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_presigned_notebook_instance_url_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_presigned_notebook_instance_url(response.body().as_ref(), output).map_err(crate::error::CreatePresignedNotebookInstanceUrlError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_processing_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateProcessingJobOutput,
    crate::error::CreateProcessingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateProcessingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateProcessingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateProcessingJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateProcessingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateProcessingJobError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProcessingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreateProcessingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProcessingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateProcessingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_processing_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateProcessingJobOutput,
    crate::error::CreateProcessingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_processing_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_processing_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateProcessingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateProjectError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_space_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSpaceOutput, crate::error::CreateSpaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateSpaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateSpaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateSpaceError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateSpaceError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateSpaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_space_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateSpaceOutput, crate::error::CreateSpaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_space_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_space(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSpaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStudioLifecycleConfigOutput,
    crate::error::CreateStudioLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStudioLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateStudioLifecycleConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateStudioLifecycleConfigError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStudioLifecycleConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateStudioLifecycleConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStudioLifecycleConfigOutput,
    crate::error::CreateStudioLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_studio_lifecycle_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_studio_lifecycle_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateStudioLifecycleConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_training_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTrainingJobOutput, crate::error::CreateTrainingJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrainingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTrainingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateTrainingJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateTrainingJobError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreateTrainingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateTrainingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_training_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTrainingJobOutput, crate::error::CreateTrainingJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_training_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_training_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrainingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transform_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransformJobOutput,
    crate::error::CreateTransformJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransformJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTransformJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateTransformJobError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateTransformJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateTransformJobError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTransformJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreateTransformJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTransformJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateTransformJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transform_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransformJobOutput,
    crate::error::CreateTransformJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transform_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_transform_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTransformJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_trial_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTrialOutput, crate::error::CreateTrialError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrialError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTrialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::CreateTrialError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::CreateTrialError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateTrialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_trial_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTrialOutput, crate::error::CreateTrialError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_trial_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_trial(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrialError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrialComponentOutput,
    crate::error::CreateTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTrialComponentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::CreateTrialComponentError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTrialComponentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTrialComponentOutput,
    crate::error::CreateTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserProfileOutput, crate::error::CreateUserProfileError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateUserProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUserProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateUserProfileError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateUserProfileError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateUserProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUserProfileOutput, crate::error::CreateUserProfileError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_user_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_user_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUserProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_workforce_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWorkforceOutput, crate::error::CreateWorkforceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateWorkforceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::CreateWorkforceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_workforce_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWorkforceOutput, crate::error::CreateWorkforceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_workforce_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_workforce(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateWorkforceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWorkteamOutput, crate::error::CreateWorkteamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateWorkteamError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::CreateWorkteamError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateWorkteamError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::CreateWorkteamError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::CreateWorkteamError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateWorkteamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateWorkteamOutput, crate::error::CreateWorkteamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_workteam_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_workteam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActionOutput, crate::error::DeleteActionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteActionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteActionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteActionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteActionOutput, crate::error::DeleteActionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_action_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteActionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_algorithm_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAlgorithmOutput, crate::error::DeleteAlgorithmError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteAlgorithmError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteAlgorithmError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_algorithm_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAlgorithmOutput, crate::error::DeleteAlgorithmError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_algorithm_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAppOutput, crate::error::DeleteAppError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteAppError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAppError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteAppError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAppError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteAppError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteAppError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteAppError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAppOutput, crate::error::DeleteAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_app_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_image_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAppImageConfigOutput,
    crate::error::DeleteAppImageConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteAppImageConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAppImageConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteAppImageConfigError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteAppImageConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteAppImageConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_image_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAppImageConfigOutput,
    crate::error::DeleteAppImageConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_app_image_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_artifact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteArtifactOutput, crate::error::DeleteArtifactError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteArtifactError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteArtifactError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteArtifactError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteArtifactError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteArtifactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_artifact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteArtifactOutput, crate::error::DeleteArtifactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_artifact_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_artifact(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteArtifactError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAssociationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteAssociationError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteAssociationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAssociationOutput, crate::error::DeleteAssociationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_code_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCodeRepositoryOutput,
    crate::error::DeleteCodeRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCodeRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteCodeRepositoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_code_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCodeRepositoryOutput,
    crate::error::DeleteCodeRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_code_repository_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_context_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContextOutput, crate::error::DeleteContextError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteContextError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteContextError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteContextError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteContextError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteContextError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_context_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContextOutput, crate::error::DeleteContextError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_context_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_context(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteContextError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_data_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDataQualityJobDefinitionOutput,
    crate::error::DeleteDataQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDataQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDataQualityJobDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DeleteDataQualityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteDataQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteDataQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_data_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDataQualityJobDefinitionOutput,
    crate::error::DeleteDataQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_data_quality_job_definition_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDeviceFleetOutput, crate::error::DeleteDeviceFleetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDeviceFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDeviceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteDeviceFleetError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDeviceFleetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteDeviceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDeviceFleetOutput, crate::error::DeleteDeviceFleetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_device_fleet_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDomainError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteDomainError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteDomainError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteDomainError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_domain_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_edge_deployment_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEdgeDeploymentPlanOutput,
    crate::error::DeleteEdgeDeploymentPlanError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteEdgeDeploymentPlanError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEdgeDeploymentPlanError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteEdgeDeploymentPlanError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEdgeDeploymentPlanError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteEdgeDeploymentPlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_edge_deployment_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEdgeDeploymentPlanOutput,
    crate::error::DeleteEdgeDeploymentPlanError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_edge_deployment_plan_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_edge_deployment_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEdgeDeploymentStageOutput,
    crate::error::DeleteEdgeDeploymentStageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteEdgeDeploymentStageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEdgeDeploymentStageError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteEdgeDeploymentStageError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEdgeDeploymentStageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteEdgeDeploymentStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_edge_deployment_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEdgeDeploymentStageOutput,
    crate::error::DeleteEdgeDeploymentStageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_edge_deployment_stage_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteEndpointOutput, crate::error::DeleteEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteEndpointOutput, crate::error::DeleteEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_endpoint_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEndpointConfigOutput,
    crate::error::DeleteEndpointConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteEndpointConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteEndpointConfigError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEndpointConfigOutput,
    crate::error::DeleteEndpointConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_endpoint_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteExperimentOutput, crate::error::DeleteExperimentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteExperimentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteExperimentOutput, crate::error::DeleteExperimentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_feature_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFeatureGroupOutput,
    crate::error::DeleteFeatureGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFeatureGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFeatureGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteFeatureGroupError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFeatureGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteFeatureGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_feature_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFeatureGroupOutput,
    crate::error::DeleteFeatureGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_feature_group_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFlowDefinitionOutput,
    crate::error::DeleteFlowDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFlowDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFlowDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteFlowDefinitionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteFlowDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteFlowDefinitionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFlowDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteFlowDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_flow_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteFlowDefinitionOutput,
    crate::error::DeleteFlowDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_flow_definition_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hub_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHubOutput, crate::error::DeleteHubError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteHubError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteHubError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteHubError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteHubError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteHubError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hub_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHubOutput, crate::error::DeleteHubError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_hub_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hub_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHubContentOutput, crate::error::DeleteHubContentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteHubContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteHubContentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteHubContentError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteHubContentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteHubContentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hub_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHubContentOutput, crate::error::DeleteHubContentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_hub_content_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_human_task_ui_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHumanTaskUiOutput, crate::error::DeleteHumanTaskUiError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteHumanTaskUiError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteHumanTaskUiError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteHumanTaskUiError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteHumanTaskUiError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteHumanTaskUiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_human_task_ui_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteHumanTaskUiOutput, crate::error::DeleteHumanTaskUiError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_human_task_ui_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteImageOutput, crate::error::DeleteImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteImageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteImageError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteImageError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteImageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteImageOutput, crate::error::DeleteImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_image_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_image_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteImageVersionOutput,
    crate::error::DeleteImageVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteImageVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteImageVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteImageVersionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteImageVersionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteImageVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_image_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteImageVersionOutput,
    crate::error::DeleteImageVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_image_version_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInferenceExperimentOutput,
    crate::error::DeleteInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::DeleteInferenceExperimentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteInferenceExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInferenceExperimentOutput,
    crate::error::DeleteInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteModelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_bias_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelBiasJobDefinitionOutput,
    crate::error::DeleteModelBiasJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelBiasJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteModelBiasJobDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteModelBiasJobDefinitionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteModelBiasJobDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteModelBiasJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_bias_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelBiasJobDefinitionOutput,
    crate::error::DeleteModelBiasJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_bias_job_definition_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_card_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelCardOutput, crate::error::DeleteModelCardError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelCardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteModelCardError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::DeleteModelCardError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteModelCardError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteModelCardError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_card_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelCardOutput, crate::error::DeleteModelCardError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_card_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_explainability_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelExplainabilityJobDefinitionOutput,
    crate::error::DeleteModelExplainabilityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelExplainabilityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteModelExplainabilityJobDefinitionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DeleteModelExplainabilityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DeleteModelExplainabilityJobDefinitionError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteModelExplainabilityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_explainability_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelExplainabilityJobDefinitionOutput,
    crate::error::DeleteModelExplainabilityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_model_explainability_job_definition_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageOutput,
    crate::error::DeleteModelPackageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelPackageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteModelPackageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::DeleteModelPackageError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteModelPackageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteModelPackageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageOutput,
    crate::error::DeleteModelPackageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_package_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageGroupOutput,
    crate::error::DeleteModelPackageGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelPackageGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteModelPackageGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::DeleteModelPackageGroupError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteModelPackageGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteModelPackageGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageGroupOutput,
    crate::error::DeleteModelPackageGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_package_group_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageGroupPolicyOutput,
    crate::error::DeleteModelPackageGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelPackageGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteModelPackageGroupPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_package_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelPackageGroupPolicyOutput,
    crate::error::DeleteModelPackageGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_model_package_group_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelQualityJobDefinitionOutput,
    crate::error::DeleteModelQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteModelQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteModelQualityJobDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DeleteModelQualityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteModelQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteModelQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteModelQualityJobDefinitionOutput,
    crate::error::DeleteModelQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_model_quality_job_definition_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMonitoringScheduleOutput,
    crate::error::DeleteMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteMonitoringScheduleError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMonitoringScheduleOutput,
    crate::error::DeleteMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_monitoring_schedule_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotebookInstanceOutput,
    crate::error::DeleteNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNotebookInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotebookInstanceOutput,
    crate::error::DeleteNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_notebook_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notebook_instance_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotebookInstanceLifecycleConfigOutput,
    crate::error::DeleteNotebookInstanceLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNotebookInstanceLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteNotebookInstanceLifecycleConfigError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_notebook_instance_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNotebookInstanceLifecycleConfigOutput,
    crate::error::DeleteNotebookInstanceLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_notebook_instance_lifecycle_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pipeline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePipelineOutput, crate::error::DeletePipelineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePipelineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePipelineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeletePipelineError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeletePipelineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeletePipelineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pipeline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePipelineOutput, crate::error::DeletePipelineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_pipeline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_pipeline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePipelineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::DeleteProjectError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_project_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_space_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSpaceOutput, crate::error::DeleteSpaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteSpaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteSpaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteSpaceError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteSpaceError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteSpaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_space_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteSpaceOutput, crate::error::DeleteSpaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_space_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStudioLifecycleConfigOutput,
    crate::error::DeleteStudioLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteStudioLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteStudioLifecycleConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteStudioLifecycleConfigError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteStudioLifecycleConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteStudioLifecycleConfigError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteStudioLifecycleConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteStudioLifecycleConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStudioLifecycleConfigOutput,
    crate::error::DeleteStudioLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_studio_lifecycle_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_tags_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_trial_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTrialOutput, crate::error::DeleteTrialError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrialError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTrialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteTrialError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteTrialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_trial_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTrialOutput, crate::error::DeleteTrialError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_trial_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_trial(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTrialError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrialComponentOutput,
    crate::error::DeleteTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTrialComponentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DeleteTrialComponentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTrialComponentOutput,
    crate::error::DeleteTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserProfileOutput, crate::error::DeleteUserProfileError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteUserProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUserProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::DeleteUserProfileError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::DeleteUserProfileError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteUserProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUserProfileOutput, crate::error::DeleteUserProfileError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_profile_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_workforce_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWorkforceOutput, crate::error::DeleteWorkforceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteWorkforceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeleteWorkforceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_workforce_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWorkforceOutput, crate::error::DeleteWorkforceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_workforce_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWorkteamOutput, crate::error::DeleteWorkteamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteWorkteamError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::DeleteWorkteamError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteWorkteamError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteWorkteamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteWorkteamOutput, crate::error::DeleteWorkteamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_workteam_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_workteam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterDevicesOutput, crate::error::DeregisterDevicesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DeregisterDevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterDevicesOutput, crate::error::DeregisterDevicesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_devices_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeActionOutput, crate::error::DescribeActionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeActionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeActionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeActionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeActionOutput, crate::error::DescribeActionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_action_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeActionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_algorithm_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAlgorithmOutput, crate::error::DescribeAlgorithmError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAlgorithmError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAlgorithmError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_algorithm_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAlgorithmOutput, crate::error::DescribeAlgorithmError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_algorithm_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_algorithm(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAlgorithmError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_app_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAppOutput, crate::error::DescribeAppError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAppError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeAppError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeAppError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAppError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeAppError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_app_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAppOutput, crate::error::DescribeAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_app_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_app(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAppError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_app_image_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAppImageConfigOutput,
    crate::error::DescribeAppImageConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAppImageConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeAppImageConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeAppImageConfigError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAppImageConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeAppImageConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_app_image_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAppImageConfigOutput,
    crate::error::DescribeAppImageConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_app_image_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_app_image_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAppImageConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_artifact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeArtifactOutput, crate::error::DescribeArtifactError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeArtifactError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeArtifactError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeArtifactError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeArtifactError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeArtifactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_artifact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeArtifactOutput, crate::error::DescribeArtifactError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_artifact_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_artifact(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeArtifactError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_auto_ml_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAutoMlJobOutput, crate::error::DescribeAutoMLJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAutoMLJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeAutoMLJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeAutoMLJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeAutoMLJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeAutoMLJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_auto_ml_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeAutoMlJobOutput, crate::error::DescribeAutoMLJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_auto_ml_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_auto_ml_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAutoMLJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCodeRepositoryOutput,
    crate::error::DescribeCodeRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCodeRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeCodeRepositoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_code_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCodeRepositoryOutput,
    crate::error::DescribeCodeRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_code_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_code_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCodeRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compilation_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCompilationJobOutput,
    crate::error::DescribeCompilationJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCompilationJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeCompilationJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeCompilationJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeCompilationJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeCompilationJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_compilation_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCompilationJobOutput,
    crate::error::DescribeCompilationJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_compilation_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_compilation_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCompilationJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_context_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeContextOutput, crate::error::DescribeContextError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeContextError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeContextError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeContextError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeContextError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeContextError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_context_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeContextOutput, crate::error::DescribeContextError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_context_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_context(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeContextError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataQualityJobDefinitionOutput,
    crate::error::DescribeDataQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDataQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDataQualityJobDefinitionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeDataQualityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeDataQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeDataQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataQualityJobDefinitionOutput,
    crate::error::DescribeDataQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_data_quality_job_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_data_quality_job_definition(response.body().as_ref(), output).map_err(crate::error::DescribeDataQualityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDeviceOutput, crate::error::DescribeDeviceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDeviceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeDeviceError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDeviceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeDeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDeviceOutput, crate::error::DescribeDeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_device_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_device(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDeviceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_device_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeviceFleetOutput,
    crate::error::DescribeDeviceFleetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDeviceFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDeviceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeDeviceFleetError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDeviceFleetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeDeviceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_device_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDeviceFleetOutput,
    crate::error::DescribeDeviceFleetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_device_fleet_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_device_fleet(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDeviceFleetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDomainOutput, crate::error::DescribeDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDomainError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeDomainError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeDomainError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeDomainOutput, crate::error::DescribeDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_domain_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_domain(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_edge_deployment_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEdgeDeploymentPlanOutput,
    crate::error::DescribeEdgeDeploymentPlanError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEdgeDeploymentPlanError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEdgeDeploymentPlanError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeEdgeDeploymentPlanError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeEdgeDeploymentPlanError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeEdgeDeploymentPlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_edge_deployment_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEdgeDeploymentPlanOutput,
    crate::error::DescribeEdgeDeploymentPlanError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_edge_deployment_plan_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_edge_deployment_plan(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEdgeDeploymentPlanError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_edge_packaging_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEdgePackagingJobOutput,
    crate::error::DescribeEdgePackagingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEdgePackagingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEdgePackagingJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeEdgePackagingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeEdgePackagingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeEdgePackagingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_edge_packaging_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEdgePackagingJobOutput,
    crate::error::DescribeEdgePackagingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_edge_packaging_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_edge_packaging_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEdgePackagingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEndpointOutput, crate::error::DescribeEndpointError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeEndpointError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEndpointOutput, crate::error::DescribeEndpointError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_endpoint_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointConfigOutput,
    crate::error::DescribeEndpointConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeEndpointConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeEndpointConfigError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointConfigOutput,
    crate::error::DescribeEndpointConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_endpoint_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_endpoint_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEndpointConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExperimentOutput,
    crate::error::DescribeExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeExperimentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeExperimentOutput,
    crate::error::DescribeExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_feature_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFeatureGroupOutput,
    crate::error::DescribeFeatureGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFeatureGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeFeatureGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeFeatureGroupError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeFeatureGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeFeatureGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_feature_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFeatureGroupOutput,
    crate::error::DescribeFeatureGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_feature_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_feature_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFeatureGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_feature_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFeatureMetadataOutput,
    crate::error::DescribeFeatureMetadataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFeatureMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeFeatureMetadataError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeFeatureMetadataError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeFeatureMetadataError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeFeatureMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_feature_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFeatureMetadataOutput,
    crate::error::DescribeFeatureMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_feature_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_feature_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFeatureMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFlowDefinitionOutput,
    crate::error::DescribeFlowDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeFlowDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeFlowDefinitionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeFlowDefinitionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeFlowDefinitionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeFlowDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_flow_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeFlowDefinitionOutput,
    crate::error::DescribeFlowDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_flow_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_flow_definition(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeFlowDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hub_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeHubOutput, crate::error::DescribeHubError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHubError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeHubError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeHubError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeHubError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hub_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeHubOutput, crate::error::DescribeHubError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hub_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_hub(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHubError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hub_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHubContentOutput,
    crate::error::DescribeHubContentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHubContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeHubContentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeHubContentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeHubContentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hub_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHubContentOutput,
    crate::error::DescribeHubContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hub_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_hub_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHubContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_human_task_ui_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHumanTaskUiOutput,
    crate::error::DescribeHumanTaskUiError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHumanTaskUiError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeHumanTaskUiError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeHumanTaskUiError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeHumanTaskUiError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeHumanTaskUiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_human_task_ui_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHumanTaskUiOutput,
    crate::error::DescribeHumanTaskUiError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_human_task_ui_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_human_task_ui(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHumanTaskUiError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hyper_parameter_tuning_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHyperParameterTuningJobOutput,
    crate::error::DescribeHyperParameterTuningJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHyperParameterTuningJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeHyperParameterTuningJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeHyperParameterTuningJobError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeHyperParameterTuningJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeHyperParameterTuningJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hyper_parameter_tuning_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHyperParameterTuningJobOutput,
    crate::error::DescribeHyperParameterTuningJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_hyper_parameter_tuning_job_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_hyper_parameter_tuning_job(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeHyperParameterTuningJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeImageOutput, crate::error::DescribeImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeImageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeImageError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeImageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeImageOutput, crate::error::DescribeImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_image_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImageVersionOutput,
    crate::error::DescribeImageVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeImageVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeImageVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeImageVersionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeImageVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_image_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeImageVersionOutput,
    crate::error::DescribeImageVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_image_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_image_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeImageVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInferenceExperimentOutput,
    crate::error::DescribeInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeInferenceExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInferenceExperimentOutput,
    crate::error::DescribeInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inference_recommendations_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInferenceRecommendationsJobOutput,
    crate::error::DescribeInferenceRecommendationsJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInferenceRecommendationsJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInferenceRecommendationsJobError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeInferenceRecommendationsJobError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeInferenceRecommendationsJobError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeInferenceRecommendationsJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_inference_recommendations_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInferenceRecommendationsJobOutput,
    crate::error::DescribeInferenceRecommendationsJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_inference_recommendations_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_inference_recommendations_job(response.body().as_ref(), output).map_err(crate::error::DescribeInferenceRecommendationsJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_labeling_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLabelingJobOutput,
    crate::error::DescribeLabelingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLabelingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLabelingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeLabelingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeLabelingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeLabelingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_labeling_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLabelingJobOutput,
    crate::error::DescribeLabelingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_labeling_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_labeling_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLabelingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lineage_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLineageGroupOutput,
    crate::error::DescribeLineageGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLineageGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLineageGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeLineageGroupError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeLineageGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeLineageGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lineage_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLineageGroupOutput,
    crate::error::DescribeLineageGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_lineage_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_lineage_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLineageGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeModelOutput, crate::error::DescribeModelError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeModelError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeModelOutput, crate::error::DescribeModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_model_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeModelError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_bias_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelBiasJobDefinitionOutput,
    crate::error::DescribeModelBiasJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelBiasJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeModelBiasJobDefinitionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeModelBiasJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeModelBiasJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeModelBiasJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_bias_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelBiasJobDefinitionOutput,
    crate::error::DescribeModelBiasJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_model_bias_job_definition_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_model_bias_job_definition(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeModelBiasJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_card_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeModelCardOutput, crate::error::DescribeModelCardError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelCardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeModelCardError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeModelCardError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeModelCardError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_card_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeModelCardOutput, crate::error::DescribeModelCardError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_model_card_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_card(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeModelCardError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_card_export_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelCardExportJobOutput,
    crate::error::DescribeModelCardExportJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelCardExportJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeModelCardExportJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeModelCardExportJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeModelCardExportJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeModelCardExportJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_card_export_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelCardExportJobOutput,
    crate::error::DescribeModelCardExportJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_model_card_export_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_card_export_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeModelCardExportJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_explainability_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelExplainabilityJobDefinitionOutput,
    crate::error::DescribeModelExplainabilityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelExplainabilityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeModelExplainabilityJobDefinitionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeModelExplainabilityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribeModelExplainabilityJobDefinitionError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeModelExplainabilityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_explainability_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelExplainabilityJobDefinitionOutput,
    crate::error::DescribeModelExplainabilityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_model_explainability_job_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_explainability_job_definition(response.body().as_ref(), output).map_err(crate::error::DescribeModelExplainabilityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_package_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelPackageOutput,
    crate::error::DescribeModelPackageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelPackageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeModelPackageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_package_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelPackageOutput,
    crate::error::DescribeModelPackageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_model_package_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_package(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeModelPackageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_package_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelPackageGroupOutput,
    crate::error::DescribeModelPackageGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelPackageGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeModelPackageGroupError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_package_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelPackageGroupOutput,
    crate::error::DescribeModelPackageGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_model_package_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_package_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeModelPackageGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_quality_job_definition_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelQualityJobDefinitionOutput,
    crate::error::DescribeModelQualityJobDefinitionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeModelQualityJobDefinitionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeModelQualityJobDefinitionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribeModelQualityJobDefinitionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeModelQualityJobDefinitionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeModelQualityJobDefinitionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_model_quality_job_definition_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeModelQualityJobDefinitionOutput,
    crate::error::DescribeModelQualityJobDefinitionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_model_quality_job_definition_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_model_quality_job_definition(response.body().as_ref(), output).map_err(crate::error::DescribeModelQualityJobDefinitionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMonitoringScheduleOutput,
    crate::error::DescribeMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeMonitoringScheduleError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMonitoringScheduleOutput,
    crate::error::DescribeMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_monitoring_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_monitoring_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMonitoringScheduleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookInstanceOutput,
    crate::error::DescribeNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNotebookInstanceError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookInstanceOutput,
    crate::error::DescribeNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_notebook_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_notebook_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNotebookInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_instance_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookInstanceLifecycleConfigOutput,
    crate::error::DescribeNotebookInstanceLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeNotebookInstanceLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeNotebookInstanceLifecycleConfigError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_instance_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookInstanceLifecycleConfigOutput,
    crate::error::DescribeNotebookInstanceLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_notebook_instance_lifecycle_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_notebook_instance_lifecycle_config(response.body().as_ref(), output).map_err(crate::error::DescribeNotebookInstanceLifecycleConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePipelineOutput, crate::error::DescribePipelineError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePipelineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribePipelineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribePipelineError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribePipelineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribePipelineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePipelineOutput, crate::error::DescribePipelineError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_pipeline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pipeline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePipelineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_definition_for_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePipelineDefinitionForExecutionOutput,
    crate::error::DescribePipelineDefinitionForExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePipelineDefinitionForExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribePipelineDefinitionForExecutionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::DescribePipelineDefinitionForExecutionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DescribePipelineDefinitionForExecutionError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePipelineDefinitionForExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_definition_for_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePipelineDefinitionForExecutionOutput,
    crate::error::DescribePipelineDefinitionForExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_pipeline_definition_for_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pipeline_definition_for_execution(response.body().as_ref(), output).map_err(crate::error::DescribePipelineDefinitionForExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePipelineExecutionOutput,
    crate::error::DescribePipelineExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePipelineExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePipelineExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribePipelineExecutionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribePipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribePipelineExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pipeline_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePipelineExecutionOutput,
    crate::error::DescribePipelineExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_pipeline_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pipeline_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePipelineExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_processing_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeProcessingJobOutput,
    crate::error::DescribeProcessingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeProcessingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeProcessingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeProcessingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeProcessingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeProcessingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_processing_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeProcessingJobOutput,
    crate::error::DescribeProcessingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_processing_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_processing_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeProcessingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeProjectOutput, crate::error::DescribeProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeProjectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeProjectOutput, crate::error::DescribeProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_space_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSpaceOutput, crate::error::DescribeSpaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSpaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeSpaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeSpaceError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeSpaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_space_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeSpaceOutput, crate::error::DescribeSpaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_space_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_space(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSpaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStudioLifecycleConfigOutput,
    crate::error::DescribeStudioLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStudioLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeStudioLifecycleConfigError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeStudioLifecycleConfigError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeStudioLifecycleConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeStudioLifecycleConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStudioLifecycleConfigOutput,
    crate::error::DescribeStudioLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_studio_lifecycle_config_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_studio_lifecycle_config(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeStudioLifecycleConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subscribed_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSubscribedWorkteamOutput,
    crate::error::DescribeSubscribedWorkteamError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeSubscribedWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeSubscribedWorkteamError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_subscribed_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSubscribedWorkteamOutput,
    crate::error::DescribeSubscribedWorkteamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_subscribed_workteam_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_subscribed_workteam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSubscribedWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_training_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrainingJobOutput,
    crate::error::DescribeTrainingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrainingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTrainingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeTrainingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeTrainingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_training_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrainingJobOutput,
    crate::error::DescribeTrainingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_training_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_training_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTrainingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transform_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransformJobOutput,
    crate::error::DescribeTransformJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTransformJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTransformJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeTransformJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeTransformJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeTransformJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_transform_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTransformJobOutput,
    crate::error::DescribeTransformJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_transform_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_transform_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTransformJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trial_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTrialOutput, crate::error::DescribeTrialError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrialError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTrialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeTrialError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeTrialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trial_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTrialOutput, crate::error::DescribeTrialError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_trial_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_trial(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTrialError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrialComponentOutput,
    crate::error::DescribeTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeTrialComponentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeTrialComponentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTrialComponentOutput,
    crate::error::DescribeTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_user_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeUserProfileOutput,
    crate::error::DescribeUserProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeUserProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeUserProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DescribeUserProfileError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeUserProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_user_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeUserProfileOutput,
    crate::error::DescribeUserProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_user_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_user_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeUserProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_workforce_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeWorkforceOutput, crate::error::DescribeWorkforceError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeWorkforceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeWorkforceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_workforce_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeWorkforceOutput, crate::error::DescribeWorkforceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_workforce_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_workforce(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeWorkforceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeWorkteamOutput, crate::error::DescribeWorkteamError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeWorkteamError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeWorkteamOutput, crate::error::DescribeWorkteamError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_workteam_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_workteam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_sagemaker_servicecatalog_portfolio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSagemakerServicecatalogPortfolioOutput,
    crate::error::DisableSagemakerServicecatalogPortfolioError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisableSagemakerServicecatalogPortfolioError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DisableSagemakerServicecatalogPortfolioError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_sagemaker_servicecatalog_portfolio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSagemakerServicecatalogPortfolioOutput,
    crate::error::DisableSagemakerServicecatalogPortfolioError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::disable_sagemaker_servicecatalog_portfolio_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTrialComponentOutput,
    crate::error::DisassociateTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateTrialComponentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::DisassociateTrialComponentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DisassociateTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DisassociateTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateTrialComponentOutput,
    crate::error::DisassociateTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_disassociate_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_sagemaker_servicecatalog_portfolio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSagemakerServicecatalogPortfolioOutput,
    crate::error::EnableSagemakerServicecatalogPortfolioError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EnableSagemakerServicecatalogPortfolioError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EnableSagemakerServicecatalogPortfolioError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_sagemaker_servicecatalog_portfolio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSagemakerServicecatalogPortfolioOutput,
    crate::error::EnableSagemakerServicecatalogPortfolioError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::enable_sagemaker_servicecatalog_portfolio_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_fleet_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceFleetReportOutput,
    crate::error::GetDeviceFleetReportError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDeviceFleetReportError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetDeviceFleetReportError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_fleet_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeviceFleetReportOutput,
    crate::error::GetDeviceFleetReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_fleet_report_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_device_fleet_report(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceFleetReportError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_lineage_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLineageGroupPolicyOutput,
    crate::error::GetLineageGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetLineageGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetLineageGroupPolicyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::GetLineageGroupPolicyError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetLineageGroupPolicyError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetLineageGroupPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_lineage_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetLineageGroupPolicyOutput,
    crate::error::GetLineageGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_lineage_group_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_lineage_group_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetLineageGroupPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_package_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetModelPackageGroupPolicyOutput,
    crate::error::GetModelPackageGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetModelPackageGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetModelPackageGroupPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_package_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetModelPackageGroupPolicyOutput,
    crate::error::GetModelPackageGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_model_package_group_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_model_package_group_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetModelPackageGroupPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sagemaker_servicecatalog_portfolio_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSagemakerServicecatalogPortfolioStatusOutput,
    crate::error::GetSagemakerServicecatalogPortfolioStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSagemakerServicecatalogPortfolioStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSagemakerServicecatalogPortfolioStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sagemaker_servicecatalog_portfolio_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSagemakerServicecatalogPortfolioStatusOutput,
    crate::error::GetSagemakerServicecatalogPortfolioStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_sagemaker_servicecatalog_portfolio_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_sagemaker_servicecatalog_portfolio_status(response.body().as_ref(), output).map_err(crate::error::GetSagemakerServicecatalogPortfolioStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_search_suggestions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSearchSuggestionsOutput,
    crate::error::GetSearchSuggestionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSearchSuggestionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetSearchSuggestionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_search_suggestions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSearchSuggestionsOutput,
    crate::error::GetSearchSuggestionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_search_suggestions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_search_suggestions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSearchSuggestionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_hub_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportHubContentOutput, crate::error::ImportHubContentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportHubContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ImportHubContentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::ImportHubContentError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ImportHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::ImportHubContentError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::ImportHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::ImportHubContentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ImportHubContentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ImportHubContentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_hub_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportHubContentOutput, crate::error::ImportHubContentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_hub_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_import_hub_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportHubContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListActionsOutput, crate::error::ListActionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListActionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListActionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListActionsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListActionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListActionsOutput, crate::error::ListActionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListActionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_algorithms_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAlgorithmsOutput, crate::error::ListAlgorithmsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAlgorithmsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListAlgorithmsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_algorithms_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAlgorithmsOutput, crate::error::ListAlgorithmsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_algorithms_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_algorithms(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAlgorithmsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAliasesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAliasesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListAliasesError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListAliasesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListAliasesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_aliases_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAliasesOutput, crate::error::ListAliasesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_aliases_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_aliases(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAliasesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_app_image_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAppImageConfigsOutput,
    crate::error::ListAppImageConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAppImageConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListAppImageConfigsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_app_image_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAppImageConfigsOutput,
    crate::error::ListAppImageConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_app_image_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_app_image_configs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAppImageConfigsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_apps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAppsOutput, crate::error::ListAppsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAppsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListAppsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_apps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAppsOutput, crate::error::ListAppsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_apps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_apps(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAppsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListArtifactsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListArtifactsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListArtifactsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListArtifactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_artifacts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_artifacts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListArtifactsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListAssociationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListAssociationsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListAssociationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListAssociationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAssociationsOutput, crate::error::ListAssociationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_auto_ml_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAutoMlJobsOutput, crate::error::ListAutoMLJobsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAutoMLJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListAutoMLJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_auto_ml_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListAutoMlJobsOutput, crate::error::ListAutoMLJobsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_auto_ml_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_auto_ml_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListAutoMLJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_candidates_for_auto_ml_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCandidatesForAutoMlJobOutput,
    crate::error::ListCandidatesForAutoMLJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCandidatesForAutoMLJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCandidatesForAutoMLJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListCandidatesForAutoMLJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCandidatesForAutoMLJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListCandidatesForAutoMLJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_candidates_for_auto_ml_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCandidatesForAutoMlJobOutput,
    crate::error::ListCandidatesForAutoMLJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_candidates_for_auto_ml_job_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_candidates_for_auto_ml_job(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListCandidatesForAutoMLJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_code_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCodeRepositoriesOutput,
    crate::error::ListCodeRepositoriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCodeRepositoriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListCodeRepositoriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_code_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCodeRepositoriesOutput,
    crate::error::ListCodeRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_code_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_code_repositories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCodeRepositoriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compilation_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCompilationJobsOutput,
    crate::error::ListCompilationJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListCompilationJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListCompilationJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_compilation_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCompilationJobsOutput,
    crate::error::ListCompilationJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_compilation_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_compilation_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCompilationJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contexts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContextsOutput, crate::error::ListContextsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListContextsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListContextsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListContextsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListContextsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListContextsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contexts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContextsOutput, crate::error::ListContextsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_contexts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_contexts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListContextsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_data_quality_job_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDataQualityJobDefinitionsOutput,
    crate::error::ListDataQualityJobDefinitionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDataQualityJobDefinitionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListDataQualityJobDefinitionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_data_quality_job_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDataQualityJobDefinitionsOutput,
    crate::error::ListDataQualityJobDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_data_quality_job_definitions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_data_quality_job_definitions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListDataQualityJobDefinitionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDeviceFleetsOutput, crate::error::ListDeviceFleetsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDeviceFleetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListDeviceFleetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDeviceFleetsOutput, crate::error::ListDeviceFleetsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_fleets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_device_fleets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeviceFleetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListDevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_devices_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDevicesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_domains_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDomainsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListDomainsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_domains_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_domains_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_domains(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDomainsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_edge_deployment_plans_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEdgeDeploymentPlansOutput,
    crate::error::ListEdgeDeploymentPlansError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListEdgeDeploymentPlansError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListEdgeDeploymentPlansError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_edge_deployment_plans_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEdgeDeploymentPlansOutput,
    crate::error::ListEdgeDeploymentPlansError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_edge_deployment_plans_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_edge_deployment_plans(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEdgeDeploymentPlansError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_edge_packaging_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEdgePackagingJobsOutput,
    crate::error::ListEdgePackagingJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListEdgePackagingJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListEdgePackagingJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_edge_packaging_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEdgePackagingJobsOutput,
    crate::error::ListEdgePackagingJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_edge_packaging_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_edge_packaging_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEdgePackagingJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_endpoint_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEndpointConfigsOutput,
    crate::error::ListEndpointConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListEndpointConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListEndpointConfigsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_endpoint_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEndpointConfigsOutput,
    crate::error::ListEndpointConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_endpoint_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_endpoint_configs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEndpointConfigsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_endpoints_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListEndpointsOutput, crate::error::ListEndpointsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListEndpointsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListEndpointsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_endpoints_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListEndpointsOutput, crate::error::ListEndpointsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_endpoints_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_endpoints(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEndpointsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_experiments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListExperimentsOutput, crate::error::ListExperimentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListExperimentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListExperimentsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_experiments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListExperimentsOutput, crate::error::ListExperimentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_experiments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_experiments(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListExperimentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_feature_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFeatureGroupsOutput, crate::error::ListFeatureGroupsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListFeatureGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListFeatureGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_feature_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFeatureGroupsOutput, crate::error::ListFeatureGroupsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_feature_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_feature_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFeatureGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_flow_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFlowDefinitionsOutput,
    crate::error::ListFlowDefinitionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListFlowDefinitionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListFlowDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_flow_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListFlowDefinitionsOutput,
    crate::error::ListFlowDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_flow_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_flow_definitions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListFlowDefinitionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hub_contents_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHubContentsOutput, crate::error::ListHubContentsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHubContentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListHubContentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListHubContentsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListHubContentsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListHubContentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hub_contents_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHubContentsOutput, crate::error::ListHubContentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hub_contents_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_hub_contents(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHubContentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hub_content_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHubContentVersionsOutput,
    crate::error::ListHubContentVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHubContentVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListHubContentVersionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListHubContentVersionsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListHubContentVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListHubContentVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hub_content_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHubContentVersionsOutput,
    crate::error::ListHubContentVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hub_content_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_hub_content_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHubContentVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hubs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHubsOutput, crate::error::ListHubsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHubsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListHubsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hubs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHubsOutput, crate::error::ListHubsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hubs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_hubs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHubsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_human_task_uis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHumanTaskUisOutput, crate::error::ListHumanTaskUisError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHumanTaskUisError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListHumanTaskUisError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_human_task_uis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListHumanTaskUisOutput, crate::error::ListHumanTaskUisError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_human_task_uis_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_human_task_uis(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListHumanTaskUisError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hyper_parameter_tuning_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHyperParameterTuningJobsOutput,
    crate::error::ListHyperParameterTuningJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListHyperParameterTuningJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListHyperParameterTuningJobsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_hyper_parameter_tuning_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListHyperParameterTuningJobsOutput,
    crate::error::ListHyperParameterTuningJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_hyper_parameter_tuning_jobs_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_hyper_parameter_tuning_jobs(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListHyperParameterTuningJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImagesOutput, crate::error::ListImagesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListImagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListImagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_images_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImagesOutput, crate::error::ListImagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_images_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_images(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListImagesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_image_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImageVersionsOutput, crate::error::ListImageVersionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListImageVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListImageVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListImageVersionsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListImageVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListImageVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_image_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImageVersionsOutput, crate::error::ListImageVersionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_image_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_image_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListImageVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_experiments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceExperimentsOutput,
    crate::error::ListInferenceExperimentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInferenceExperimentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListInferenceExperimentsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_experiments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceExperimentsOutput,
    crate::error::ListInferenceExperimentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_inference_experiments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_inference_experiments(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInferenceExperimentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_recommendations_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceRecommendationsJobsOutput,
    crate::error::ListInferenceRecommendationsJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInferenceRecommendationsJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListInferenceRecommendationsJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_recommendations_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceRecommendationsJobsOutput,
    crate::error::ListInferenceRecommendationsJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_inference_recommendations_jobs_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_inference_recommendations_jobs(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListInferenceRecommendationsJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_recommendations_job_steps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceRecommendationsJobStepsOutput,
    crate::error::ListInferenceRecommendationsJobStepsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInferenceRecommendationsJobStepsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListInferenceRecommendationsJobStepsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_inference_recommendations_job_steps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInferenceRecommendationsJobStepsOutput,
    crate::error::ListInferenceRecommendationsJobStepsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_inference_recommendations_job_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_inference_recommendations_job_steps(response.body().as_ref(), output).map_err(crate::error::ListInferenceRecommendationsJobStepsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_labeling_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListLabelingJobsOutput, crate::error::ListLabelingJobsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListLabelingJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListLabelingJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_labeling_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListLabelingJobsOutput, crate::error::ListLabelingJobsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_labeling_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_labeling_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListLabelingJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_labeling_jobs_for_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLabelingJobsForWorkteamOutput,
    crate::error::ListLabelingJobsForWorkteamError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListLabelingJobsForWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListLabelingJobsForWorkteamError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListLabelingJobsForWorkteamError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListLabelingJobsForWorkteamError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListLabelingJobsForWorkteamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_labeling_jobs_for_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListLabelingJobsForWorkteamOutput,
    crate::error::ListLabelingJobsForWorkteamError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_labeling_jobs_for_workteam_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_labeling_jobs_for_workteam(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListLabelingJobsForWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_lineage_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListLineageGroupsOutput, crate::error::ListLineageGroupsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListLineageGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListLineageGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_lineage_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListLineageGroupsOutput, crate::error::ListLineageGroupsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_lineage_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_lineage_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListLineageGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_bias_job_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelBiasJobDefinitionsOutput,
    crate::error::ListModelBiasJobDefinitionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelBiasJobDefinitionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelBiasJobDefinitionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_bias_job_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelBiasJobDefinitionsOutput,
    crate::error::ListModelBiasJobDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_bias_job_definitions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_model_bias_job_definitions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListModelBiasJobDefinitionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_card_export_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelCardExportJobsOutput,
    crate::error::ListModelCardExportJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelCardExportJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelCardExportJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_card_export_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelCardExportJobsOutput,
    crate::error::ListModelCardExportJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_card_export_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_card_export_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelCardExportJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_cards_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelCardsOutput, crate::error::ListModelCardsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelCardsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelCardsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_cards_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelCardsOutput, crate::error::ListModelCardsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_cards_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_cards(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelCardsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_card_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelCardVersionsOutput,
    crate::error::ListModelCardVersionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelCardVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListModelCardVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListModelCardVersionsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListModelCardVersionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListModelCardVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_card_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelCardVersionsOutput,
    crate::error::ListModelCardVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_card_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_card_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelCardVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_explainability_job_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelExplainabilityJobDefinitionsOutput,
    crate::error::ListModelExplainabilityJobDefinitionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelExplainabilityJobDefinitionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelExplainabilityJobDefinitionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_explainability_job_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelExplainabilityJobDefinitionsOutput,
    crate::error::ListModelExplainabilityJobDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_model_explainability_job_definitions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_explainability_job_definitions(response.body().as_ref(), output).map_err(crate::error::ListModelExplainabilityJobDefinitionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelMetadataOutput, crate::error::ListModelMetadataError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelMetadataError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelMetadataOutput, crate::error::ListModelMetadataError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_package_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelPackageGroupsOutput,
    crate::error::ListModelPackageGroupsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelPackageGroupsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelPackageGroupsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_package_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelPackageGroupsOutput,
    crate::error::ListModelPackageGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_package_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_package_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelPackageGroupsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_packages_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelPackagesOutput, crate::error::ListModelPackagesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelPackagesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelPackagesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_packages_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelPackagesOutput, crate::error::ListModelPackagesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_model_packages_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_model_packages(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelPackagesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_quality_job_definitions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelQualityJobDefinitionsOutput,
    crate::error::ListModelQualityJobDefinitionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelQualityJobDefinitionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelQualityJobDefinitionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_model_quality_job_definitions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListModelQualityJobDefinitionsOutput,
    crate::error::ListModelQualityJobDefinitionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_model_quality_job_definitions_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_model_quality_job_definitions(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListModelQualityJobDefinitionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_models_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelsOutput, crate::error::ListModelsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListModelsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListModelsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_models_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListModelsOutput, crate::error::ListModelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_models_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_models(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListModelsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_alert_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringAlertHistoryOutput,
    crate::error::ListMonitoringAlertHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListMonitoringAlertHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListMonitoringAlertHistoryError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListMonitoringAlertHistoryError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListMonitoringAlertHistoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListMonitoringAlertHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_alert_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringAlertHistoryOutput,
    crate::error::ListMonitoringAlertHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_monitoring_alert_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_monitoring_alert_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMonitoringAlertHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_alerts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringAlertsOutput,
    crate::error::ListMonitoringAlertsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListMonitoringAlertsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListMonitoringAlertsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListMonitoringAlertsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListMonitoringAlertsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListMonitoringAlertsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_alerts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringAlertsOutput,
    crate::error::ListMonitoringAlertsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_monitoring_alerts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_monitoring_alerts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMonitoringAlertsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringExecutionsOutput,
    crate::error::ListMonitoringExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListMonitoringExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListMonitoringExecutionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringExecutionsOutput,
    crate::error::ListMonitoringExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_monitoring_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_monitoring_executions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMonitoringExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_schedules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringSchedulesOutput,
    crate::error::ListMonitoringSchedulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListMonitoringSchedulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListMonitoringSchedulesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_monitoring_schedules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListMonitoringSchedulesOutput,
    crate::error::ListMonitoringSchedulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_monitoring_schedules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_monitoring_schedules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListMonitoringSchedulesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_instance_lifecycle_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookInstanceLifecycleConfigsOutput,
    crate::error::ListNotebookInstanceLifecycleConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListNotebookInstanceLifecycleConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListNotebookInstanceLifecycleConfigsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_instance_lifecycle_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookInstanceLifecycleConfigsOutput,
    crate::error::ListNotebookInstanceLifecycleConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_notebook_instance_lifecycle_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_notebook_instance_lifecycle_configs(response.body().as_ref(), output).map_err(crate::error::ListNotebookInstanceLifecycleConfigsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookInstancesOutput,
    crate::error::ListNotebookInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListNotebookInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListNotebookInstancesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookInstancesOutput,
    crate::error::ListNotebookInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_notebook_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_notebook_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListNotebookInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineExecutionsOutput,
    crate::error::ListPipelineExecutionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPipelineExecutionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListPipelineExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListPipelineExecutionsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListPipelineExecutionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListPipelineExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineExecutionsOutput,
    crate::error::ListPipelineExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pipeline_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pipeline_executions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPipelineExecutionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_execution_steps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineExecutionStepsOutput,
    crate::error::ListPipelineExecutionStepsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPipelineExecutionStepsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListPipelineExecutionStepsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListPipelineExecutionStepsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListPipelineExecutionStepsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListPipelineExecutionStepsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_execution_steps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineExecutionStepsOutput,
    crate::error::ListPipelineExecutionStepsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pipeline_execution_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pipeline_execution_steps(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPipelineExecutionStepsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_parameters_for_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineParametersForExecutionOutput,
    crate::error::ListPipelineParametersForExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPipelineParametersForExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListPipelineParametersForExecutionError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::ListPipelineParametersForExecutionError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::ListPipelineParametersForExecutionError::unhandled,
                        )?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListPipelineParametersForExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipeline_parameters_for_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListPipelineParametersForExecutionOutput,
    crate::error::ListPipelineParametersForExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_pipeline_parameters_for_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pipeline_parameters_for_execution(response.body().as_ref(), output).map_err(crate::error::ListPipelineParametersForExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipelines_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPipelinesOutput, crate::error::ListPipelinesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPipelinesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListPipelinesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pipelines_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPipelinesOutput, crate::error::ListPipelinesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pipelines_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pipelines(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPipelinesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_processing_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListProcessingJobsOutput,
    crate::error::ListProcessingJobsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListProcessingJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListProcessingJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_processing_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListProcessingJobsOutput,
    crate::error::ListProcessingJobsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_processing_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_processing_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListProcessingJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListProjectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListProjectsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_projects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListProjectsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_spaces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSpacesOutput, crate::error::ListSpacesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListSpacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListSpacesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_spaces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSpacesOutput, crate::error::ListSpacesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_spaces_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_spaces(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSpacesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stage_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStageDevicesOutput, crate::error::ListStageDevicesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStageDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListStageDevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stage_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStageDevicesOutput, crate::error::ListStageDevicesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stage_devices_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_stage_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStageDevicesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_lifecycle_configs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStudioLifecycleConfigsOutput,
    crate::error::ListStudioLifecycleConfigsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStudioLifecycleConfigsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListStudioLifecycleConfigsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::ListStudioLifecycleConfigsError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListStudioLifecycleConfigsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListStudioLifecycleConfigsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_lifecycle_configs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStudioLifecycleConfigsOutput,
    crate::error::ListStudioLifecycleConfigsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_studio_lifecycle_configs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_studio_lifecycle_configs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStudioLifecycleConfigsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscribed_workteams_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscribedWorkteamsOutput,
    crate::error::ListSubscribedWorkteamsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListSubscribedWorkteamsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListSubscribedWorkteamsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_subscribed_workteams_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSubscribedWorkteamsOutput,
    crate::error::ListSubscribedWorkteamsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_subscribed_workteams_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_subscribed_workteams(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSubscribedWorkteamsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_training_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTrainingJobsOutput, crate::error::ListTrainingJobsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrainingJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListTrainingJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_training_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTrainingJobsOutput, crate::error::ListTrainingJobsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_training_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_training_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrainingJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_training_jobs_for_hyper_parameter_tuning_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrainingJobsForHyperParameterTuningJobOutput,
    crate::error::ListTrainingJobsForHyperParameterTuningJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrainingJobsForHyperParameterTuningJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListTrainingJobsForHyperParameterTuningJobError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::ListTrainingJobsForHyperParameterTuningJobError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(response.body().as_ref(), output).map_err(crate::error::ListTrainingJobsForHyperParameterTuningJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTrainingJobsForHyperParameterTuningJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_training_jobs_for_hyper_parameter_tuning_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrainingJobsForHyperParameterTuningJobOutput,
    crate::error::ListTrainingJobsForHyperParameterTuningJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_training_jobs_for_hyper_parameter_tuning_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_training_jobs_for_hyper_parameter_tuning_job(response.body().as_ref(), output).map_err(crate::error::ListTrainingJobsForHyperParameterTuningJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_transform_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTransformJobsOutput, crate::error::ListTransformJobsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTransformJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListTransformJobsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_transform_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTransformJobsOutput, crate::error::ListTransformJobsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_transform_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_transform_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTransformJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_trial_components_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrialComponentsOutput,
    crate::error::ListTrialComponentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrialComponentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTrialComponentsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListTrialComponentsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTrialComponentsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTrialComponentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_trial_components_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTrialComponentsOutput,
    crate::error::ListTrialComponentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_trial_components_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_trial_components(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrialComponentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_trials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTrialsOutput, crate::error::ListTrialsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTrialsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTrialsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::ListTrialsError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTrialsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTrialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_trials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTrialsOutput, crate::error::ListTrialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_trials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_trials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTrialsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserProfilesOutput, crate::error::ListUserProfilesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListUserProfilesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListUserProfilesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_user_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUserProfilesOutput, crate::error::ListUserProfilesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_user_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_user_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUserProfilesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_workforces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListWorkforcesOutput, crate::error::ListWorkforcesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListWorkforcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListWorkforcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_workforces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListWorkforcesOutput, crate::error::ListWorkforcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_workforces_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_workforces(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListWorkforcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_workteams_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListWorkteamsOutput, crate::error::ListWorkteamsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListWorkteamsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListWorkteamsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_workteams_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListWorkteamsOutput, crate::error::ListWorkteamsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_workteams_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_workteams(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListWorkteamsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_model_package_group_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutModelPackageGroupPolicyOutput,
    crate::error::PutModelPackageGroupPolicyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutModelPackageGroupPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::PutModelPackageGroupPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_model_package_group_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutModelPackageGroupPolicyOutput,
    crate::error::PutModelPackageGroupPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_model_package_group_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_model_package_group_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutModelPackageGroupPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_query_lineage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::QueryLineageOutput, crate::error::QueryLineageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::QueryLineageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::QueryLineageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::QueryLineageError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::QueryLineageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::QueryLineageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_query_lineage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::QueryLineageOutput, crate::error::QueryLineageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::query_lineage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_query_lineage(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::QueryLineageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterDevicesOutput, crate::error::RegisterDevicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RegisterDevicesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::RegisterDevicesError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterDevicesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::RegisterDevicesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterDevicesOutput, crate::error::RegisterDevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_devices_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_render_ui_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenderUiTemplateOutput, crate::error::RenderUiTemplateError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RenderUiTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RenderUiTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::RenderUiTemplateError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenderUiTemplateError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::RenderUiTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_render_ui_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenderUiTemplateOutput, crate::error::RenderUiTemplateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::render_ui_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_render_ui_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RenderUiTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_pipeline_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RetryPipelineExecutionOutput,
    crate::error::RetryPipelineExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RetryPipelineExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RetryPipelineExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::RetryPipelineExecutionError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RetryPipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => {
            crate::error::RetryPipelineExecutionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::RetryPipelineExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::RetryPipelineExecutionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RetryPipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::RetryPipelineExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_retry_pipeline_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RetryPipelineExecutionOutput,
    crate::error::RetryPipelineExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::retry_pipeline_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_retry_pipeline_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RetryPipelineExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SearchOutput, crate::error::SearchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SearchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SearchError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SearchOutput, crate::error::SearchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::search_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_search(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SearchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_pipeline_execution_step_failure_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendPipelineExecutionStepFailureOutput,
    crate::error::SendPipelineExecutionStepFailureError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SendPipelineExecutionStepFailureError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SendPipelineExecutionStepFailureError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::SendPipelineExecutionStepFailureError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::SendPipelineExecutionStepFailureError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => {
            crate::error::SendPipelineExecutionStepFailureError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendPipelineExecutionStepFailureError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::SendPipelineExecutionStepFailureError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_pipeline_execution_step_failure_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendPipelineExecutionStepFailureOutput,
    crate::error::SendPipelineExecutionStepFailureError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::send_pipeline_execution_step_failure_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_send_pipeline_execution_step_failure(response.body().as_ref(), output).map_err(crate::error::SendPipelineExecutionStepFailureError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_pipeline_execution_step_success_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendPipelineExecutionStepSuccessOutput,
    crate::error::SendPipelineExecutionStepSuccessError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SendPipelineExecutionStepSuccessError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SendPipelineExecutionStepSuccessError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::SendPipelineExecutionStepSuccessError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::SendPipelineExecutionStepSuccessError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => {
            crate::error::SendPipelineExecutionStepSuccessError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendPipelineExecutionStepSuccessError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::SendPipelineExecutionStepSuccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_pipeline_execution_step_success_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendPipelineExecutionStepSuccessOutput,
    crate::error::SendPipelineExecutionStepSuccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::send_pipeline_execution_step_success_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_send_pipeline_execution_step_success(response.body().as_ref(), output).map_err(crate::error::SendPipelineExecutionStepSuccessError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_edge_deployment_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartEdgeDeploymentStageOutput,
    crate::error::StartEdgeDeploymentStageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartEdgeDeploymentStageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StartEdgeDeploymentStageError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_edge_deployment_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartEdgeDeploymentStageOutput,
    crate::error::StartEdgeDeploymentStageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_edge_deployment_stage_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartInferenceExperimentOutput,
    crate::error::StartInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::StartInferenceExperimentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::StartInferenceExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StartInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartInferenceExperimentOutput,
    crate::error::StartInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartMonitoringScheduleOutput,
    crate::error::StartMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StartMonitoringScheduleError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StartMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartMonitoringScheduleOutput,
    crate::error::StartMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_monitoring_schedule_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNotebookInstanceOutput,
    crate::error::StartNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartNotebookInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::StartNotebookInstanceError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::StartNotebookInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StartNotebookInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNotebookInstanceOutput,
    crate::error::StartNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_notebook_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_pipeline_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartPipelineExecutionOutput,
    crate::error::StartPipelineExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartPipelineExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartPipelineExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::StartPipelineExecutionError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::StartPipelineExecutionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::StartPipelineExecutionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartPipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StartPipelineExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_pipeline_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartPipelineExecutionOutput,
    crate::error::StartPipelineExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_pipeline_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_pipeline_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartPipelineExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_auto_ml_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopAutoMlJobOutput, crate::error::StopAutoMLJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopAutoMLJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopAutoMLJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopAutoMLJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopAutoMLJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopAutoMLJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_auto_ml_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopAutoMlJobOutput, crate::error::StopAutoMLJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_auto_ml_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_compilation_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopCompilationJobOutput,
    crate::error::StopCompilationJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopCompilationJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopCompilationJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopCompilationJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopCompilationJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopCompilationJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_compilation_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopCompilationJobOutput,
    crate::error::StopCompilationJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_compilation_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_edge_deployment_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopEdgeDeploymentStageOutput,
    crate::error::StopEdgeDeploymentStageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopEdgeDeploymentStageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StopEdgeDeploymentStageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_edge_deployment_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopEdgeDeploymentStageOutput,
    crate::error::StopEdgeDeploymentStageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_edge_deployment_stage_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_edge_packaging_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopEdgePackagingJobOutput,
    crate::error::StopEdgePackagingJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopEdgePackagingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StopEdgePackagingJobError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_edge_packaging_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopEdgePackagingJobOutput,
    crate::error::StopEdgePackagingJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_edge_packaging_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_hyper_parameter_tuning_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopHyperParameterTuningJobOutput,
    crate::error::StopHyperParameterTuningJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopHyperParameterTuningJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopHyperParameterTuningJobError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopHyperParameterTuningJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopHyperParameterTuningJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopHyperParameterTuningJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_hyper_parameter_tuning_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopHyperParameterTuningJobOutput,
    crate::error::StopHyperParameterTuningJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_hyper_parameter_tuning_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopInferenceExperimentOutput,
    crate::error::StopInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::StopInferenceExperimentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::StopInferenceExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopInferenceExperimentOutput,
    crate::error::StopInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_inference_recommendations_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopInferenceRecommendationsJobOutput,
    crate::error::StopInferenceRecommendationsJobError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopInferenceRecommendationsJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopInferenceRecommendationsJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => {
            crate::error::StopInferenceRecommendationsJobError::ResourceNotFound({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::StopInferenceRecommendationsJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StopInferenceRecommendationsJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_inference_recommendations_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopInferenceRecommendationsJobOutput,
    crate::error::StopInferenceRecommendationsJobError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::stop_inference_recommendations_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_labeling_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopLabelingJobOutput, crate::error::StopLabelingJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopLabelingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopLabelingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopLabelingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopLabelingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopLabelingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_labeling_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopLabelingJobOutput, crate::error::StopLabelingJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_labeling_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopMonitoringScheduleOutput,
    crate::error::StopMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopMonitoringScheduleError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopMonitoringScheduleOutput,
    crate::error::StopMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_monitoring_schedule_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopNotebookInstanceOutput,
    crate::error::StopNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::StopNotebookInstanceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopNotebookInstanceOutput,
    crate::error::StopNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_notebook_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_pipeline_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopPipelineExecutionOutput,
    crate::error::StopPipelineExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopPipelineExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopPipelineExecutionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopPipelineExecutionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopPipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopPipelineExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_pipeline_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopPipelineExecutionOutput,
    crate::error::StopPipelineExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_pipeline_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_pipeline_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopPipelineExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_processing_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopProcessingJobOutput, crate::error::StopProcessingJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopProcessingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopProcessingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopProcessingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopProcessingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopProcessingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_processing_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopProcessingJobOutput, crate::error::StopProcessingJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_processing_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_training_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopTrainingJobOutput, crate::error::StopTrainingJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopTrainingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopTrainingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopTrainingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopTrainingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_training_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopTrainingJobOutput, crate::error::StopTrainingJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_training_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_transform_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopTransformJobOutput, crate::error::StopTransformJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopTransformJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopTransformJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::StopTransformJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopTransformJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopTransformJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_transform_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopTransformJobOutput, crate::error::StopTransformJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_transform_job_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateActionOutput, crate::error::UpdateActionError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateActionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateActionError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateActionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateActionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateActionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateActionOutput, crate::error::UpdateActionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_action_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateActionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_app_image_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAppImageConfigOutput,
    crate::error::UpdateAppImageConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateAppImageConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAppImageConfigError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdateAppImageConfigError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateAppImageConfigError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateAppImageConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_app_image_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateAppImageConfigOutput,
    crate::error::UpdateAppImageConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_app_image_config_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_app_image_config(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateAppImageConfigError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_artifact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateArtifactOutput, crate::error::UpdateArtifactError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateArtifactError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateArtifactError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateArtifactError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateArtifactError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateArtifactError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateArtifactError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateArtifactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_artifact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateArtifactOutput, crate::error::UpdateArtifactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_artifact_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_artifact(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateArtifactError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_code_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCodeRepositoryOutput,
    crate::error::UpdateCodeRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateCodeRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateCodeRepositoryError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_code_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCodeRepositoryOutput,
    crate::error::UpdateCodeRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_code_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_code_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateCodeRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_context_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContextOutput, crate::error::UpdateContextError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateContextError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateContextError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateContextError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateContextError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateContextError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateContextError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateContextError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_context_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContextOutput, crate::error::UpdateContextError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_context_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_context(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateContextError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDeviceFleetOutput, crate::error::UpdateDeviceFleetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDeviceFleetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDeviceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateDeviceFleetError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDeviceFleetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateDeviceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDeviceFleetOutput, crate::error::UpdateDeviceFleetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_fleet_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicesOutput, crate::error::UpdateDevicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateDevicesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicesOutput, crate::error::UpdateDevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_devices_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_domain_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDomainOutput, crate::error::UpdateDomainError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDomainError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDomainError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateDomainError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::UpdateDomainError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateDomainError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDomainError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateDomainError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_domain_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDomainOutput, crate::error::UpdateDomainError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_domain_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_domain(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDomainError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_endpoint_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateEndpointOutput, crate::error::UpdateEndpointError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateEndpointError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateEndpointError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::UpdateEndpointError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateEndpointError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateEndpointError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_endpoint_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateEndpointOutput, crate::error::UpdateEndpointError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_endpoint_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_endpoint(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateEndpointError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_endpoint_weights_and_capacities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEndpointWeightsAndCapacitiesOutput,
    crate::error::UpdateEndpointWeightsAndCapacitiesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateEndpointWeightsAndCapacitiesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateEndpointWeightsAndCapacitiesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::UpdateEndpointWeightsAndCapacitiesError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateEndpointWeightsAndCapacitiesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateEndpointWeightsAndCapacitiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_endpoint_weights_and_capacities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEndpointWeightsAndCapacitiesOutput,
    crate::error::UpdateEndpointWeightsAndCapacitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_endpoint_weights_and_capacities_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_endpoint_weights_and_capacities(response.body().as_ref(), output).map_err(crate::error::UpdateEndpointWeightsAndCapacitiesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateExperimentOutput, crate::error::UpdateExperimentError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateExperimentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateExperimentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateExperimentOutput, crate::error::UpdateExperimentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_feature_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFeatureGroupOutput,
    crate::error::UpdateFeatureGroupError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateFeatureGroupError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFeatureGroupError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdateFeatureGroupError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFeatureGroupError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateFeatureGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_feature_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFeatureGroupOutput,
    crate::error::UpdateFeatureGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_feature_group_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_feature_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateFeatureGroupError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_feature_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFeatureMetadataOutput,
    crate::error::UpdateFeatureMetadataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateFeatureMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateFeatureMetadataError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdateFeatureMetadataError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateFeatureMetadataError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateFeatureMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_feature_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateFeatureMetadataOutput,
    crate::error::UpdateFeatureMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_feature_metadata_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_hub_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateHubOutput, crate::error::UpdateHubError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateHubError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateHubError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdateHubError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateHubError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateHubError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_hub_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateHubOutput, crate::error::UpdateHubError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_hub_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_hub(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateHubError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_image_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateImageOutput, crate::error::UpdateImageError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateImageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateImageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateImageError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateImageError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateImageError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateImageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_image_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateImageOutput, crate::error::UpdateImageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_image_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_image(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateImageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_image_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateImageVersionOutput,
    crate::error::UpdateImageVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateImageVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateImageVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateImageVersionError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateImageVersionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateImageVersionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateImageVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_image_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateImageVersionOutput,
    crate::error::UpdateImageVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_image_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_image_version(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateImageVersionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_inference_experiment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInferenceExperimentOutput,
    crate::error::UpdateInferenceExperimentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateInferenceExperimentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateInferenceExperimentError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateInferenceExperimentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateInferenceExperimentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInferenceExperimentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateInferenceExperimentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_inference_experiment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInferenceExperimentOutput,
    crate::error::UpdateInferenceExperimentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_inference_experiment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_inference_experiment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateInferenceExperimentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_card_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateModelCardOutput, crate::error::UpdateModelCardError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateModelCardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateModelCardError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateModelCardError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::UpdateModelCardError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateModelCardError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateModelCardError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateModelCardError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_card_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateModelCardOutput, crate::error::UpdateModelCardError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_model_card_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_model_card(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateModelCardError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_package_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateModelPackageOutput,
    crate::error::UpdateModelPackageError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateModelPackageError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateModelPackageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_package_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateModelPackageOutput,
    crate::error::UpdateModelPackageError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_model_package_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_model_package(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateModelPackageError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_monitoring_alert_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMonitoringAlertOutput,
    crate::error::UpdateMonitoringAlertError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateMonitoringAlertError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateMonitoringAlertError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::UpdateMonitoringAlertError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMonitoringAlertError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::UpdateMonitoringAlertError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateMonitoringAlertError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateMonitoringAlertError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_monitoring_alert_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMonitoringAlertOutput,
    crate::error::UpdateMonitoringAlertError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_monitoring_alert_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_monitoring_alert(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMonitoringAlertError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_monitoring_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMonitoringScheduleOutput,
    crate::error::UpdateMonitoringScheduleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateMonitoringScheduleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateMonitoringScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::UpdateMonitoringScheduleError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMonitoringScheduleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceNotFound" => crate::error::UpdateMonitoringScheduleError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateMonitoringScheduleError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateMonitoringScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_monitoring_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMonitoringScheduleOutput,
    crate::error::UpdateMonitoringScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_monitoring_schedule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_monitoring_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMonitoringScheduleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_notebook_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNotebookInstanceOutput,
    crate::error::UpdateNotebookInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateNotebookInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateNotebookInstanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::UpdateNotebookInstanceError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNotebookInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateNotebookInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_notebook_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNotebookInstanceOutput,
    crate::error::UpdateNotebookInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_notebook_instance_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_notebook_instance_lifecycle_config_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNotebookInstanceLifecycleConfigOutput,
    crate::error::UpdateNotebookInstanceLifecycleConfigError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateNotebookInstanceLifecycleConfigError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateNotebookInstanceLifecycleConfigError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => {
            crate::error::UpdateNotebookInstanceLifecycleConfigError::ResourceLimitExceeded({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_limit_exceeded::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNotebookInstanceLifecycleConfigError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateNotebookInstanceLifecycleConfigError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_notebook_instance_lifecycle_config_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNotebookInstanceLifecycleConfigOutput,
    crate::error::UpdateNotebookInstanceLifecycleConfigError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_notebook_instance_lifecycle_config_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pipeline_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdatePipelineOutput, crate::error::UpdatePipelineError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePipelineError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePipelineError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdatePipelineError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdatePipelineError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdatePipelineError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pipeline_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdatePipelineOutput, crate::error::UpdatePipelineError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pipeline_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pipeline(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePipelineError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pipeline_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePipelineExecutionOutput,
    crate::error::UpdatePipelineExecutionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePipelineExecutionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePipelineExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdatePipelineExecutionError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdatePipelineExecutionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdatePipelineExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pipeline_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePipelineExecutionOutput,
    crate::error::UpdatePipelineExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pipeline_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pipeline_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePipelineExecutionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateProjectError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_space_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateSpaceOutput, crate::error::UpdateSpaceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateSpaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateSpaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateSpaceError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::UpdateSpaceError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateSpaceError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateSpaceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateSpaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_space_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateSpaceOutput, crate::error::UpdateSpaceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_space_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_space(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateSpaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_training_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTrainingJobOutput, crate::error::UpdateTrainingJobError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTrainingJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTrainingJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceNotFound" => crate::error::UpdateTrainingJobError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTrainingJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateTrainingJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_training_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTrainingJobOutput, crate::error::UpdateTrainingJobError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_training_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_training_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTrainingJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_trial_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTrialOutput, crate::error::UpdateTrialError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTrialError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTrialError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateTrialError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateTrialError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTrialError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateTrialError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_trial_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateTrialOutput, crate::error::UpdateTrialError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_trial_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_trial(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTrialError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_trial_component_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrialComponentOutput,
    crate::error::UpdateTrialComponentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTrialComponentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTrialComponentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateTrialComponentError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateTrialComponentError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTrialComponentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateTrialComponentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_trial_component_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTrialComponentOutput,
    crate::error::UpdateTrialComponentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_trial_component_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_trial_component(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTrialComponentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserProfileOutput, crate::error::UpdateUserProfileError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateUserProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUserProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceInUse" => crate::error::UpdateUserProfileError::ResourceInUse({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_in_use::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_in_use_json_err(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceLimitExceeded" => crate::error::UpdateUserProfileError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ResourceNotFound" => crate::error::UpdateUserProfileError::ResourceNotFound({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_not_found::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_resource_not_found_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUserProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateUserProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUserProfileOutput, crate::error::UpdateUserProfileError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_user_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_user_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateUserProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_workforce_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWorkforceOutput, crate::error::UpdateWorkforceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateWorkforceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateWorkforceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConflictException" => crate::error::UpdateWorkforceError::ConflictException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_conflict_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateWorkforceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateWorkforceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_workforce_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWorkforceOutput, crate::error::UpdateWorkforceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_workforce_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_workforce(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateWorkforceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_workteam_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWorkteamOutput, crate::error::UpdateWorkteamError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateWorkteamError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateWorkteamError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ResourceLimitExceeded" => crate::error::UpdateWorkteamError::ResourceLimitExceeded({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::resource_limit_exceeded::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_resource_limit_exceeded_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateWorkteamError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateWorkteamError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_workteam_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateWorkteamOutput, crate::error::UpdateWorkteamError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_workteam_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_workteam(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateWorkteamError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
