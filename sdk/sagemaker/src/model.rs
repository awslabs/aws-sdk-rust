// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Provides details about a labeling work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workteam {
    /// <p>The name of the work team.</p>
    pub workteam_name: std::option::Option<std::string::String>,
    /// <p>A list of <code>MemberDefinition</code> objects that contains objects that identify
    /// the workers that make up the work team. </p>
    /// <p>Workforces can be created using Amazon Cognito or your own OIDC Identity Provider (IdP).
    /// For private workforces created using Amazon Cognito use
    /// <code>CognitoMemberDefinition</code>. For workforces created using your own OIDC identity
    /// provider (IdP) use <code>OidcMemberDefinition</code>.</p>
    pub member_definitions: std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
    /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
    pub workforce_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Marketplace identifier for a vendor's work team.</p>
    pub product_listing_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A description of the work team.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling
    /// your data objects.</p>
    pub sub_domain: std::option::Option<std::string::String>,
    /// <p>The date and time that the work team was created (timestamp).</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the work team was last updated (timestamp).</p>
    pub last_updated_date: std::option::Option<smithy_types::Instant>,
    /// <p>Configures SNS notifications of available or expiring work items for work
    /// teams.</p>
    pub notification_configuration: std::option::Option<crate::model::NotificationConfiguration>,
}
impl std::fmt::Debug for Workteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workteam");
        formatter.field("workteam_name", &self.workteam_name);
        formatter.field("member_definitions", &self.member_definitions);
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("workforce_arn", &self.workforce_arn);
        formatter.field("product_listing_ids", &self.product_listing_ids);
        formatter.field("description", &self.description);
        formatter.field("sub_domain", &self.sub_domain);
        formatter.field("create_date", &self.create_date);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field(
            "notification_configuration",
            &self.notification_configuration,
        );
        formatter.finish()
    }
}
/// See [`Workteam`](crate::model::Workteam)
pub mod workteam {
    /// A builder for [`Workteam`](crate::model::Workteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_name: std::option::Option<std::string::String>,
        pub(crate) member_definitions:
            std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) workforce_arn: std::option::Option<std::string::String>,
        pub(crate) product_listing_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) sub_domain: std::option::Option<std::string::String>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
        pub(crate) last_updated_date: std::option::Option<smithy_types::Instant>,
        pub(crate) notification_configuration:
            std::option::Option<crate::model::NotificationConfiguration>,
    }
    impl Builder {
        /// <p>The name of the work team.</p>
        pub fn workteam_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_name = Some(input.into());
            self
        }
        pub fn set_workteam_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workteam_name = input;
            self
        }
        pub fn member_definitions(
            mut self,
            input: impl Into<crate::model::MemberDefinition>,
        ) -> Self {
            let mut v = self.member_definitions.unwrap_or_default();
            v.push(input.into());
            self.member_definitions = Some(v);
            self
        }
        pub fn set_member_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MemberDefinition>>,
        ) -> Self {
            self.member_definitions = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the work team.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the workforce.</p>
        pub fn workforce_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_arn = Some(input.into());
            self
        }
        pub fn set_workforce_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_arn = input;
            self
        }
        pub fn product_listing_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.product_listing_ids.unwrap_or_default();
            v.push(input.into());
            self.product_listing_ids = Some(v);
            self
        }
        pub fn set_product_listing_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.product_listing_ids = input;
            self
        }
        /// <p>A description of the work team.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The URI of the labeling job's user interface. Workers open this URI to start labeling
        /// your data objects.</p>
        pub fn sub_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.sub_domain = Some(input.into());
            self
        }
        pub fn set_sub_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sub_domain = input;
            self
        }
        /// <p>The date and time that the work team was created (timestamp).</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// <p>The date and time that the work team was last updated (timestamp).</p>
        pub fn last_updated_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_updated_date = Some(input);
            self
        }
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>Configures SNS notifications of available or expiring work items for work
        /// teams.</p>
        pub fn notification_configuration(
            mut self,
            input: crate::model::NotificationConfiguration,
        ) -> Self {
            self.notification_configuration = Some(input);
            self
        }
        pub fn set_notification_configuration(
            mut self,
            input: std::option::Option<crate::model::NotificationConfiguration>,
        ) -> Self {
            self.notification_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Workteam`](crate::model::Workteam)
        pub fn build(self) -> crate::model::Workteam {
            crate::model::Workteam {
                workteam_name: self.workteam_name,
                member_definitions: self.member_definitions,
                workteam_arn: self.workteam_arn,
                workforce_arn: self.workforce_arn,
                product_listing_ids: self.product_listing_ids,
                description: self.description,
                sub_domain: self.sub_domain,
                create_date: self.create_date,
                last_updated_date: self.last_updated_date,
                notification_configuration: self.notification_configuration,
            }
        }
    }
}
impl Workteam {
    /// Creates a new builder-style object to manufacture [`Workteam`](crate::model::Workteam)
    pub fn builder() -> crate::model::workteam::Builder {
        crate::model::workteam::Builder::default()
    }
}

/// <p>Configures SNS notifications of available or expiring work items for work
/// teams.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotificationConfiguration {
    /// <p>The ARN for the SNS topic to which notifications should be published.</p>
    pub notification_topic_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotificationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotificationConfiguration");
        formatter.field("notification_topic_arn", &self.notification_topic_arn);
        formatter.finish()
    }
}
/// See [`NotificationConfiguration`](crate::model::NotificationConfiguration)
pub mod notification_configuration {
    /// A builder for [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notification_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for the SNS topic to which notifications should be published.</p>
        pub fn notification_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_topic_arn = Some(input.into());
            self
        }
        pub fn set_notification_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationConfiguration`](crate::model::NotificationConfiguration)
        pub fn build(self) -> crate::model::NotificationConfiguration {
            crate::model::NotificationConfiguration {
                notification_topic_arn: self.notification_topic_arn,
            }
        }
    }
}
impl NotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    pub fn builder() -> crate::model::notification_configuration::Builder {
        crate::model::notification_configuration::Builder::default()
    }
}

/// <p>Defines an Amazon Cognito or your own OIDC IdP user group that is part of a work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MemberDefinition {
    /// <p>The Amazon Cognito user group that is part of the work team.</p>
    pub cognito_member_definition: std::option::Option<crate::model::CognitoMemberDefinition>,
    /// <p>A list user groups that exist in your OIDC Identity Provider (IdP).
    /// One to ten groups can be used to create a single private work team.
    /// When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more
    /// private work teams. If you add a user group to a private work team, all workers in that user group
    /// are added to the work team.</p>
    pub oidc_member_definition: std::option::Option<crate::model::OidcMemberDefinition>,
}
impl std::fmt::Debug for MemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MemberDefinition");
        formatter.field("cognito_member_definition", &self.cognito_member_definition);
        formatter.field("oidc_member_definition", &self.oidc_member_definition);
        formatter.finish()
    }
}
/// See [`MemberDefinition`](crate::model::MemberDefinition)
pub mod member_definition {
    /// A builder for [`MemberDefinition`](crate::model::MemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cognito_member_definition:
            std::option::Option<crate::model::CognitoMemberDefinition>,
        pub(crate) oidc_member_definition: std::option::Option<crate::model::OidcMemberDefinition>,
    }
    impl Builder {
        /// <p>The Amazon Cognito user group that is part of the work team.</p>
        pub fn cognito_member_definition(
            mut self,
            input: crate::model::CognitoMemberDefinition,
        ) -> Self {
            self.cognito_member_definition = Some(input);
            self
        }
        pub fn set_cognito_member_definition(
            mut self,
            input: std::option::Option<crate::model::CognitoMemberDefinition>,
        ) -> Self {
            self.cognito_member_definition = input;
            self
        }
        /// <p>A list user groups that exist in your OIDC Identity Provider (IdP).
        /// One to ten groups can be used to create a single private work team.
        /// When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more
        /// private work teams. If you add a user group to a private work team, all workers in that user group
        /// are added to the work team.</p>
        pub fn oidc_member_definition(mut self, input: crate::model::OidcMemberDefinition) -> Self {
            self.oidc_member_definition = Some(input);
            self
        }
        pub fn set_oidc_member_definition(
            mut self,
            input: std::option::Option<crate::model::OidcMemberDefinition>,
        ) -> Self {
            self.oidc_member_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`MemberDefinition`](crate::model::MemberDefinition)
        pub fn build(self) -> crate::model::MemberDefinition {
            crate::model::MemberDefinition {
                cognito_member_definition: self.cognito_member_definition,
                oidc_member_definition: self.oidc_member_definition,
            }
        }
    }
}
impl MemberDefinition {
    /// Creates a new builder-style object to manufacture [`MemberDefinition`](crate::model::MemberDefinition)
    pub fn builder() -> crate::model::member_definition::Builder {
        crate::model::member_definition::Builder::default()
    }
}

/// <p>A list of user groups that exist in your OIDC Identity Provider (IdP).
/// One to ten groups can be used to create a single private work team.
/// When you add a user group to the list of <code>Groups</code>, you can add that user group to one or more
/// private work teams. If you add a user group to a private work team, all workers in that user group
/// are added to the work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcMemberDefinition {
    /// <p>A list of comma seperated strings that identifies
    /// user groups in your OIDC IdP. Each user group is
    /// made up of a group of private workers.</p>
    pub groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for OidcMemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcMemberDefinition");
        formatter.field("groups", &self.groups);
        formatter.finish()
    }
}
/// See [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
pub mod oidc_member_definition {
    /// A builder for [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
        pub fn build(self) -> crate::model::OidcMemberDefinition {
            crate::model::OidcMemberDefinition {
                groups: self.groups,
            }
        }
    }
}
impl OidcMemberDefinition {
    /// Creates a new builder-style object to manufacture [`OidcMemberDefinition`](crate::model::OidcMemberDefinition)
    pub fn builder() -> crate::model::oidc_member_definition::Builder {
        crate::model::oidc_member_definition::Builder::default()
    }
}

/// <p>Identifies a Amazon Cognito user group. A user group can be used in on or more work
/// teams.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoMemberDefinition {
    /// <p>An identifier for a user pool. The user pool must be in the same region as the service
    /// that you are calling.</p>
    pub user_pool: std::option::Option<std::string::String>,
    /// <p>An identifier for a user group.</p>
    pub user_group: std::option::Option<std::string::String>,
    /// <p>An identifier for an application client. You must create the app client ID using
    /// Amazon Cognito.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CognitoMemberDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoMemberDefinition");
        formatter.field("user_pool", &self.user_pool);
        formatter.field("user_group", &self.user_group);
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}
/// See [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
pub mod cognito_member_definition {
    /// A builder for [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_pool: std::option::Option<std::string::String>,
        pub(crate) user_group: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for a user pool. The user pool must be in the same region as the service
        /// that you are calling.</p>
        pub fn user_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool = Some(input.into());
            self
        }
        pub fn set_user_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool = input;
            self
        }
        /// <p>An identifier for a user group.</p>
        pub fn user_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_group = Some(input.into());
            self
        }
        pub fn set_user_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_group = input;
            self
        }
        /// <p>An identifier for an application client. You must create the app client ID using
        /// Amazon Cognito.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
        pub fn build(self) -> crate::model::CognitoMemberDefinition {
            crate::model::CognitoMemberDefinition {
                user_pool: self.user_pool,
                user_group: self.user_group,
                client_id: self.client_id,
            }
        }
    }
}
impl CognitoMemberDefinition {
    /// Creates a new builder-style object to manufacture [`CognitoMemberDefinition`](crate::model::CognitoMemberDefinition)
    pub fn builder() -> crate::model::cognito_member_definition::Builder {
        crate::model::cognito_member_definition::Builder::default()
    }
}

/// <p>A single private workforce, which is automatically created when you create your first
/// private work team. You can create one private work force in each Amazon Web Services Region. By default,
/// any workforce-related API operation used in a specific region will apply to the
/// workforce created in that region. To learn how to create a private workforce, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-create-private.html">Create a Private Workforce</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Workforce {
    /// <p>The name of the private workforce.</p>
    pub workforce_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
    pub workforce_arn: std::option::Option<std::string::String>,
    /// <p>The most recent date that  was used to
    /// successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's
    /// allow list.</p>
    pub last_updated_date: std::option::Option<smithy_types::Instant>,
    /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the
    /// workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
    pub source_ip_config: std::option::Option<crate::model::SourceIpConfig>,
    /// <p>The subdomain for your OIDC Identity Provider.</p>
    pub sub_domain: std::option::Option<std::string::String>,
    /// <p>The configuration of an Amazon Cognito workforce.
    /// A single Cognito workforce is created using and corresponds to a single
    /// <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
    /// Amazon Cognito user pool</a>.</p>
    pub cognito_config: std::option::Option<crate::model::CognitoConfig>,
    /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
    pub oidc_config: std::option::Option<crate::model::OidcConfigForResponse>,
    /// <p>The date that the workforce is created.</p>
    pub create_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for Workforce {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Workforce");
        formatter.field("workforce_name", &self.workforce_name);
        formatter.field("workforce_arn", &self.workforce_arn);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field("source_ip_config", &self.source_ip_config);
        formatter.field("sub_domain", &self.sub_domain);
        formatter.field("cognito_config", &self.cognito_config);
        formatter.field("oidc_config", &self.oidc_config);
        formatter.field("create_date", &self.create_date);
        formatter.finish()
    }
}
/// See [`Workforce`](crate::model::Workforce)
pub mod workforce {
    /// A builder for [`Workforce`](crate::model::Workforce)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workforce_name: std::option::Option<std::string::String>,
        pub(crate) workforce_arn: std::option::Option<std::string::String>,
        pub(crate) last_updated_date: std::option::Option<smithy_types::Instant>,
        pub(crate) source_ip_config: std::option::Option<crate::model::SourceIpConfig>,
        pub(crate) sub_domain: std::option::Option<std::string::String>,
        pub(crate) cognito_config: std::option::Option<crate::model::CognitoConfig>,
        pub(crate) oidc_config: std::option::Option<crate::model::OidcConfigForResponse>,
        pub(crate) create_date: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the private workforce.</p>
        pub fn workforce_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_name = Some(input.into());
            self
        }
        pub fn set_workforce_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the private workforce.</p>
        pub fn workforce_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workforce_arn = Some(input.into());
            self
        }
        pub fn set_workforce_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workforce_arn = input;
            self
        }
        /// <p>The most recent date that  was used to
        /// successfully add one or more IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to a private workforce's
        /// allow list.</p>
        pub fn last_updated_date(mut self, input: smithy_types::Instant) -> Self {
            self.last_updated_date = Some(input);
            self
        }
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>A list of one to ten IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>) to be added to the
        /// workforce allow list. By default, a workforce isn't restricted to specific IP addresses.</p>
        pub fn source_ip_config(mut self, input: crate::model::SourceIpConfig) -> Self {
            self.source_ip_config = Some(input);
            self
        }
        pub fn set_source_ip_config(
            mut self,
            input: std::option::Option<crate::model::SourceIpConfig>,
        ) -> Self {
            self.source_ip_config = input;
            self
        }
        /// <p>The subdomain for your OIDC Identity Provider.</p>
        pub fn sub_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.sub_domain = Some(input.into());
            self
        }
        pub fn set_sub_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sub_domain = input;
            self
        }
        /// <p>The configuration of an Amazon Cognito workforce.
        /// A single Cognito workforce is created using and corresponds to a single
        /// <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
        /// Amazon Cognito user pool</a>.</p>
        pub fn cognito_config(mut self, input: crate::model::CognitoConfig) -> Self {
            self.cognito_config = Some(input);
            self
        }
        pub fn set_cognito_config(
            mut self,
            input: std::option::Option<crate::model::CognitoConfig>,
        ) -> Self {
            self.cognito_config = input;
            self
        }
        /// <p>The configuration of an OIDC Identity Provider (IdP) private workforce.</p>
        pub fn oidc_config(mut self, input: crate::model::OidcConfigForResponse) -> Self {
            self.oidc_config = Some(input);
            self
        }
        pub fn set_oidc_config(
            mut self,
            input: std::option::Option<crate::model::OidcConfigForResponse>,
        ) -> Self {
            self.oidc_config = input;
            self
        }
        /// <p>The date that the workforce is created.</p>
        pub fn create_date(mut self, input: smithy_types::Instant) -> Self {
            self.create_date = Some(input);
            self
        }
        pub fn set_create_date(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.create_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Workforce`](crate::model::Workforce)
        pub fn build(self) -> crate::model::Workforce {
            crate::model::Workforce {
                workforce_name: self.workforce_name,
                workforce_arn: self.workforce_arn,
                last_updated_date: self.last_updated_date,
                source_ip_config: self.source_ip_config,
                sub_domain: self.sub_domain,
                cognito_config: self.cognito_config,
                oidc_config: self.oidc_config,
                create_date: self.create_date,
            }
        }
    }
}
impl Workforce {
    /// Creates a new builder-style object to manufacture [`Workforce`](crate::model::Workforce)
    pub fn builder() -> crate::model::workforce::Builder {
        crate::model::workforce::Builder::default()
    }
}

/// <p>Your OIDC IdP workforce configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcConfigForResponse {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub authorization_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub token_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub user_info_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub logout_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub jwks_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OidcConfigForResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcConfigForResponse");
        formatter.field("client_id", &self.client_id);
        formatter.field("issuer", &self.issuer);
        formatter.field("authorization_endpoint", &self.authorization_endpoint);
        formatter.field("token_endpoint", &self.token_endpoint);
        formatter.field("user_info_endpoint", &self.user_info_endpoint);
        formatter.field("logout_endpoint", &self.logout_endpoint);
        formatter.field("jwks_uri", &self.jwks_uri);
        formatter.finish()
    }
}
/// See [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
pub mod oidc_config_for_response {
    /// A builder for [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) authorization_endpoint: std::option::Option<std::string::String>,
        pub(crate) token_endpoint: std::option::Option<std::string::String>,
        pub(crate) user_info_endpoint: std::option::Option<std::string::String>,
        pub(crate) logout_endpoint: std::option::Option<std::string::String>,
        pub(crate) jwks_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn authorization_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_endpoint = Some(input.into());
            self
        }
        pub fn set_authorization_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_endpoint = input;
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn token_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_endpoint = Some(input.into());
            self
        }
        pub fn set_token_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_endpoint = input;
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn user_info_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_info_endpoint = Some(input.into());
            self
        }
        pub fn set_user_info_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_info_endpoint = input;
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn logout_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.logout_endpoint = Some(input.into());
            self
        }
        pub fn set_logout_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logout_endpoint = input;
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn jwks_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.jwks_uri = Some(input.into());
            self
        }
        pub fn set_jwks_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.jwks_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
        pub fn build(self) -> crate::model::OidcConfigForResponse {
            crate::model::OidcConfigForResponse {
                client_id: self.client_id,
                issuer: self.issuer,
                authorization_endpoint: self.authorization_endpoint,
                token_endpoint: self.token_endpoint,
                user_info_endpoint: self.user_info_endpoint,
                logout_endpoint: self.logout_endpoint,
                jwks_uri: self.jwks_uri,
            }
        }
    }
}
impl OidcConfigForResponse {
    /// Creates a new builder-style object to manufacture [`OidcConfigForResponse`](crate::model::OidcConfigForResponse)
    pub fn builder() -> crate::model::oidc_config_for_response::Builder {
        crate::model::oidc_config_for_response::Builder::default()
    }
}

/// <p>Use this parameter to configure your Amazon Cognito workforce.
/// A single Cognito workforce is created using and corresponds to a single
/// <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
/// Amazon Cognito user pool</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CognitoConfig {
    /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
    /// user pool</a> is a user directory in Amazon Cognito.
    /// With a user pool, your users can sign in to your web or mobile app through Amazon Cognito.
    /// Your users can also sign in through social identity providers like
    /// Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
    pub user_pool: std::option::Option<std::string::String>,
    /// <p>The client ID for your Amazon Cognito user pool.</p>
    pub client_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CognitoConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CognitoConfig");
        formatter.field("user_pool", &self.user_pool);
        formatter.field("client_id", &self.client_id);
        formatter.finish()
    }
}
/// See [`CognitoConfig`](crate::model::CognitoConfig)
pub mod cognito_config {
    /// A builder for [`CognitoConfig`](crate::model::CognitoConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_pool: std::option::Option<std::string::String>,
        pub(crate) client_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html">
        /// user pool</a> is a user directory in Amazon Cognito.
        /// With a user pool, your users can sign in to your web or mobile app through Amazon Cognito.
        /// Your users can also sign in through social identity providers like
        /// Google, Facebook, Amazon, or Apple, and through SAML identity providers.</p>
        pub fn user_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_pool = Some(input.into());
            self
        }
        pub fn set_user_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_pool = input;
            self
        }
        /// <p>The client ID for your Amazon Cognito user pool.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CognitoConfig`](crate::model::CognitoConfig)
        pub fn build(self) -> crate::model::CognitoConfig {
            crate::model::CognitoConfig {
                user_pool: self.user_pool,
                client_id: self.client_id,
            }
        }
    }
}
impl CognitoConfig {
    /// Creates a new builder-style object to manufacture [`CognitoConfig`](crate::model::CognitoConfig)
    pub fn builder() -> crate::model::cognito_config::Builder {
        crate::model::cognito_config::Builder::default()
    }
}

/// <p>A list of IP address ranges (<a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">CIDRs</a>). Used to create an allow
/// list of IP addresses for a private workforce. Workers will only be able to login to their worker portal from an
/// IP address within this range. By default, a workforce isn't restricted to specific IP addresses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceIpConfig {
    /// <p>A list of one to ten <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">Classless Inter-Domain Routing</a> (CIDR) values.</p>
    /// <p>Maximum: Ten CIDR values</p>
    /// <note>
    /// <p>The following Length Constraints apply to individual CIDR values in
    /// the CIDR value list.</p>
    /// </note>
    pub cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SourceIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceIpConfig");
        formatter.field("cidrs", &self.cidrs);
        formatter.finish()
    }
}
/// See [`SourceIpConfig`](crate::model::SourceIpConfig)
pub mod source_ip_config {
    /// A builder for [`SourceIpConfig`](crate::model::SourceIpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cidrs: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn cidrs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.cidrs.unwrap_or_default();
            v.push(input.into());
            self.cidrs = Some(v);
            self
        }
        pub fn set_cidrs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.cidrs = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceIpConfig`](crate::model::SourceIpConfig)
        pub fn build(self) -> crate::model::SourceIpConfig {
            crate::model::SourceIpConfig { cidrs: self.cidrs }
        }
    }
}
impl SourceIpConfig {
    /// Creates a new builder-style object to manufacture [`SourceIpConfig`](crate::model::SourceIpConfig)
    pub fn builder() -> crate::model::source_ip_config::Builder {
        crate::model::source_ip_config::Builder::default()
    }
}

/// <p>Use this parameter to configure your OIDC Identity Provider (IdP).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OidcConfig {
    /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
    pub client_secret: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
    pub issuer: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
    pub authorization_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
    pub token_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
    pub user_info_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
    pub logout_endpoint: std::option::Option<std::string::String>,
    /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
    pub jwks_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OidcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OidcConfig");
        formatter.field("client_id", &self.client_id);
        formatter.field("client_secret", &"*** Sensitive Data Redacted ***");
        formatter.field("issuer", &self.issuer);
        formatter.field("authorization_endpoint", &self.authorization_endpoint);
        formatter.field("token_endpoint", &self.token_endpoint);
        formatter.field("user_info_endpoint", &self.user_info_endpoint);
        formatter.field("logout_endpoint", &self.logout_endpoint);
        formatter.field("jwks_uri", &self.jwks_uri);
        formatter.finish()
    }
}
/// See [`OidcConfig`](crate::model::OidcConfig)
pub mod oidc_config {
    /// A builder for [`OidcConfig`](crate::model::OidcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) client_secret: std::option::Option<std::string::String>,
        pub(crate) issuer: std::option::Option<std::string::String>,
        pub(crate) authorization_endpoint: std::option::Option<std::string::String>,
        pub(crate) token_endpoint: std::option::Option<std::string::String>,
        pub(crate) user_info_endpoint: std::option::Option<std::string::String>,
        pub(crate) logout_endpoint: std::option::Option<std::string::String>,
        pub(crate) jwks_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The OIDC IdP client ID used to configure your private workforce.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// <p>The OIDC IdP client secret used to configure your private workforce.</p>
        pub fn client_secret(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_secret = Some(input.into());
            self
        }
        pub fn set_client_secret(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_secret = input;
            self
        }
        /// <p>The OIDC IdP issuer used to configure your private workforce.</p>
        pub fn issuer(mut self, input: impl Into<std::string::String>) -> Self {
            self.issuer = Some(input.into());
            self
        }
        pub fn set_issuer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.issuer = input;
            self
        }
        /// <p>The OIDC IdP authorization endpoint used to configure your private workforce.</p>
        pub fn authorization_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_endpoint = Some(input.into());
            self
        }
        pub fn set_authorization_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_endpoint = input;
            self
        }
        /// <p>The OIDC IdP token endpoint used to configure your private workforce.</p>
        pub fn token_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_endpoint = Some(input.into());
            self
        }
        pub fn set_token_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.token_endpoint = input;
            self
        }
        /// <p>The OIDC IdP user information endpoint used to configure your private workforce.</p>
        pub fn user_info_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_info_endpoint = Some(input.into());
            self
        }
        pub fn set_user_info_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_info_endpoint = input;
            self
        }
        /// <p>The OIDC IdP logout endpoint used to configure your private workforce.</p>
        pub fn logout_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.logout_endpoint = Some(input.into());
            self
        }
        pub fn set_logout_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logout_endpoint = input;
            self
        }
        /// <p>The OIDC IdP JSON Web Key Set (Jwks) URI used to configure your private workforce.</p>
        pub fn jwks_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.jwks_uri = Some(input.into());
            self
        }
        pub fn set_jwks_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.jwks_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`OidcConfig`](crate::model::OidcConfig)
        pub fn build(self) -> crate::model::OidcConfig {
            crate::model::OidcConfig {
                client_id: self.client_id,
                client_secret: self.client_secret,
                issuer: self.issuer,
                authorization_endpoint: self.authorization_endpoint,
                token_endpoint: self.token_endpoint,
                user_info_endpoint: self.user_info_endpoint,
                logout_endpoint: self.logout_endpoint,
                jwks_uri: self.jwks_uri,
            }
        }
    }
}
impl OidcConfig {
    /// Creates a new builder-style object to manufacture [`OidcConfig`](crate::model::OidcConfig)
    pub fn builder() -> crate::model::oidc_config::Builder {
        crate::model::oidc_config::Builder::default()
    }
}

/// <p>A collection of settings that apply to users of Amazon SageMaker Studio. These settings are
/// specified when the <code>CreateUserProfile</code> API is called, and as <code>DefaultUserSettings</code>
/// when the <code>CreateDomain</code> API is called.</p>
/// <p>
/// <code>SecurityGroups</code> is aggregated when specified in both calls. For all other
/// settings in <code>UserSettings</code>, the values specified in <code>CreateUserProfile</code>
/// take precedence over those specified in <code>CreateDomain</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserSettings {
    /// <p>The execution role for the user.</p>
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.</p>
    /// <p>Optional when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to
    /// <code>PublicInternetOnly</code>.</p>
    /// <p>Required when the <code>CreateDomain.AppNetworkAccessType</code> parameter is set to
    /// <code>VpcOnly</code>.</p>
    /// <p>Amazon SageMaker adds a security group to allow NFS traffic from SageMaker Studio. Therefore, the
    /// number of security groups that you can specify is one less than the maximum number shown.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
    pub sharing_settings: std::option::Option<crate::model::SharingSettings>,
    /// <p>The Jupyter server's app settings.</p>
    pub jupyter_server_app_settings: std::option::Option<crate::model::JupyterServerAppSettings>,
    /// <p>The kernel gateway app settings.</p>
    pub kernel_gateway_app_settings: std::option::Option<crate::model::KernelGatewayAppSettings>,
    /// <p>The TensorBoard app settings.</p>
    pub tensor_board_app_settings: std::option::Option<crate::model::TensorBoardAppSettings>,
}
impl std::fmt::Debug for UserSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserSettings");
        formatter.field("execution_role", &self.execution_role);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("sharing_settings", &self.sharing_settings);
        formatter.field(
            "jupyter_server_app_settings",
            &self.jupyter_server_app_settings,
        );
        formatter.field(
            "kernel_gateway_app_settings",
            &self.kernel_gateway_app_settings,
        );
        formatter.field("tensor_board_app_settings", &self.tensor_board_app_settings);
        formatter.finish()
    }
}
/// See [`UserSettings`](crate::model::UserSettings)
pub mod user_settings {
    /// A builder for [`UserSettings`](crate::model::UserSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sharing_settings: std::option::Option<crate::model::SharingSettings>,
        pub(crate) jupyter_server_app_settings:
            std::option::Option<crate::model::JupyterServerAppSettings>,
        pub(crate) kernel_gateway_app_settings:
            std::option::Option<crate::model::KernelGatewayAppSettings>,
        pub(crate) tensor_board_app_settings:
            std::option::Option<crate::model::TensorBoardAppSettings>,
    }
    impl Builder {
        /// <p>The execution role for the user.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Specifies options for sharing SageMaker Studio notebooks.</p>
        pub fn sharing_settings(mut self, input: crate::model::SharingSettings) -> Self {
            self.sharing_settings = Some(input);
            self
        }
        pub fn set_sharing_settings(
            mut self,
            input: std::option::Option<crate::model::SharingSettings>,
        ) -> Self {
            self.sharing_settings = input;
            self
        }
        /// <p>The Jupyter server's app settings.</p>
        pub fn jupyter_server_app_settings(
            mut self,
            input: crate::model::JupyterServerAppSettings,
        ) -> Self {
            self.jupyter_server_app_settings = Some(input);
            self
        }
        pub fn set_jupyter_server_app_settings(
            mut self,
            input: std::option::Option<crate::model::JupyterServerAppSettings>,
        ) -> Self {
            self.jupyter_server_app_settings = input;
            self
        }
        /// <p>The kernel gateway app settings.</p>
        pub fn kernel_gateway_app_settings(
            mut self,
            input: crate::model::KernelGatewayAppSettings,
        ) -> Self {
            self.kernel_gateway_app_settings = Some(input);
            self
        }
        pub fn set_kernel_gateway_app_settings(
            mut self,
            input: std::option::Option<crate::model::KernelGatewayAppSettings>,
        ) -> Self {
            self.kernel_gateway_app_settings = input;
            self
        }
        /// <p>The TensorBoard app settings.</p>
        pub fn tensor_board_app_settings(
            mut self,
            input: crate::model::TensorBoardAppSettings,
        ) -> Self {
            self.tensor_board_app_settings = Some(input);
            self
        }
        pub fn set_tensor_board_app_settings(
            mut self,
            input: std::option::Option<crate::model::TensorBoardAppSettings>,
        ) -> Self {
            self.tensor_board_app_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`UserSettings`](crate::model::UserSettings)
        pub fn build(self) -> crate::model::UserSettings {
            crate::model::UserSettings {
                execution_role: self.execution_role,
                security_groups: self.security_groups,
                sharing_settings: self.sharing_settings,
                jupyter_server_app_settings: self.jupyter_server_app_settings,
                kernel_gateway_app_settings: self.kernel_gateway_app_settings,
                tensor_board_app_settings: self.tensor_board_app_settings,
            }
        }
    }
}
impl UserSettings {
    /// Creates a new builder-style object to manufacture [`UserSettings`](crate::model::UserSettings)
    pub fn builder() -> crate::model::user_settings::Builder {
        crate::model::user_settings::Builder::default()
    }
}

/// <p>The TensorBoard app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TensorBoardAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl std::fmt::Debug for TensorBoardAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TensorBoardAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.finish()
    }
}
/// See [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
pub mod tensor_board_app_settings {
    /// A builder for [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Consumes the builder and constructs a [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
        pub fn build(self) -> crate::model::TensorBoardAppSettings {
            crate::model::TensorBoardAppSettings {
                default_resource_spec: self.default_resource_spec,
            }
        }
    }
}
impl TensorBoardAppSettings {
    /// Creates a new builder-style object to manufacture [`TensorBoardAppSettings`](crate::model::TensorBoardAppSettings)
    pub fn builder() -> crate::model::tensor_board_app_settings::Builder {
        crate::model::tensor_board_app_settings::Builder::default()
    }
}

/// <p>Specifies the ARN's of a SageMaker image and SageMaker image version, and the instance type that
/// the version runs on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceSpec {
    /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
    pub sage_maker_image_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the image version created on the instance.</p>
    pub sage_maker_image_version_arn: std::option::Option<std::string::String>,
    /// <p>The instance type that the image version runs on.</p>
    pub instance_type: std::option::Option<crate::model::AppInstanceType>,
}
impl std::fmt::Debug for ResourceSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceSpec");
        formatter.field("sage_maker_image_arn", &self.sage_maker_image_arn);
        formatter.field(
            "sage_maker_image_version_arn",
            &self.sage_maker_image_version_arn,
        );
        formatter.field("instance_type", &self.instance_type);
        formatter.finish()
    }
}
/// See [`ResourceSpec`](crate::model::ResourceSpec)
pub mod resource_spec {
    /// A builder for [`ResourceSpec`](crate::model::ResourceSpec)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sage_maker_image_arn: std::option::Option<std::string::String>,
        pub(crate) sage_maker_image_version_arn: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::AppInstanceType>,
    }
    impl Builder {
        /// <p>The ARN of the SageMaker image that the image version belongs to.</p>
        pub fn sage_maker_image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sage_maker_image_arn = Some(input.into());
            self
        }
        pub fn set_sage_maker_image_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sage_maker_image_arn = input;
            self
        }
        /// <p>The ARN of the image version created on the instance.</p>
        pub fn sage_maker_image_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.sage_maker_image_version_arn = Some(input.into());
            self
        }
        pub fn set_sage_maker_image_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sage_maker_image_version_arn = input;
            self
        }
        /// <p>The instance type that the image version runs on.</p>
        pub fn instance_type(mut self, input: crate::model::AppInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::AppInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceSpec`](crate::model::ResourceSpec)
        pub fn build(self) -> crate::model::ResourceSpec {
            crate::model::ResourceSpec {
                sage_maker_image_arn: self.sage_maker_image_arn,
                sage_maker_image_version_arn: self.sage_maker_image_version_arn,
                instance_type: self.instance_type,
            }
        }
    }
}
impl ResourceSpec {
    /// Creates a new builder-style object to manufacture [`ResourceSpec`](crate::model::ResourceSpec)
    pub fn builder() -> crate::model::resource_spec::Builder {
        crate::model::resource_spec::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppInstanceType {
    MlC512Xlarge,
    MlC518Xlarge,
    MlC524Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Large,
    MlC5Xlarge,
    MlG4Dn12Xlarge,
    MlG4Dn16Xlarge,
    MlG4Dn2Xlarge,
    MlG4Dn4Xlarge,
    MlG4Dn8Xlarge,
    MlG4DnXlarge,
    MlM512Xlarge,
    MlM516Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM58Xlarge,
    MlM5Large,
    MlM5Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    MlT32Xlarge,
    MlT3Large,
    MlT3Medium,
    MlT3Micro,
    MlT3Small,
    MlT3Xlarge,
    System,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c5.12xlarge" => AppInstanceType::MlC512Xlarge,
            "ml.c5.18xlarge" => AppInstanceType::MlC518Xlarge,
            "ml.c5.24xlarge" => AppInstanceType::MlC524Xlarge,
            "ml.c5.2xlarge" => AppInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => AppInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => AppInstanceType::MlC59Xlarge,
            "ml.c5.large" => AppInstanceType::MlC5Large,
            "ml.c5.xlarge" => AppInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => AppInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => AppInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => AppInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => AppInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => AppInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => AppInstanceType::MlG4DnXlarge,
            "ml.m5.12xlarge" => AppInstanceType::MlM512Xlarge,
            "ml.m5.16xlarge" => AppInstanceType::MlM516Xlarge,
            "ml.m5.24xlarge" => AppInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => AppInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => AppInstanceType::MlM54Xlarge,
            "ml.m5.8xlarge" => AppInstanceType::MlM58Xlarge,
            "ml.m5.large" => AppInstanceType::MlM5Large,
            "ml.m5.xlarge" => AppInstanceType::MlM5Xlarge,
            "ml.p3.16xlarge" => AppInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => AppInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => AppInstanceType::MlP38Xlarge,
            "ml.t3.2xlarge" => AppInstanceType::MlT32Xlarge,
            "ml.t3.large" => AppInstanceType::MlT3Large,
            "ml.t3.medium" => AppInstanceType::MlT3Medium,
            "ml.t3.micro" => AppInstanceType::MlT3Micro,
            "ml.t3.small" => AppInstanceType::MlT3Small,
            "ml.t3.xlarge" => AppInstanceType::MlT3Xlarge,
            "system" => AppInstanceType::System,
            other => AppInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppInstanceType::from(s))
    }
}
impl AppInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            AppInstanceType::MlC512Xlarge => "ml.c5.12xlarge",
            AppInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            AppInstanceType::MlC524Xlarge => "ml.c5.24xlarge",
            AppInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            AppInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            AppInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            AppInstanceType::MlC5Large => "ml.c5.large",
            AppInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            AppInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            AppInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            AppInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            AppInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            AppInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            AppInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            AppInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            AppInstanceType::MlM516Xlarge => "ml.m5.16xlarge",
            AppInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            AppInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            AppInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            AppInstanceType::MlM58Xlarge => "ml.m5.8xlarge",
            AppInstanceType::MlM5Large => "ml.m5.large",
            AppInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            AppInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            AppInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            AppInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            AppInstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            AppInstanceType::MlT3Large => "ml.t3.large",
            AppInstanceType::MlT3Medium => "ml.t3.medium",
            AppInstanceType::MlT3Micro => "ml.t3.micro",
            AppInstanceType::MlT3Small => "ml.t3.small",
            AppInstanceType::MlT3Xlarge => "ml.t3.xlarge",
            AppInstanceType::System => "system",
            AppInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c5.12xlarge",
            "ml.c5.18xlarge",
            "ml.c5.24xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.large",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.16xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.8xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.micro",
            "ml.t3.small",
            "ml.t3.xlarge",
            "system",
        ]
    }
}
impl AsRef<str> for AppInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The KernelGateway app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelGatewayAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    /// <p>A list of custom SageMaker images that are configured to run as a KernelGateway app.</p>
    pub custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
}
impl std::fmt::Debug for KernelGatewayAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelGatewayAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.field("custom_images", &self.custom_images);
        formatter.finish()
    }
}
/// See [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
pub mod kernel_gateway_app_settings {
    /// A builder for [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
        pub(crate) custom_images: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        pub fn custom_images(mut self, input: impl Into<crate::model::CustomImage>) -> Self {
            let mut v = self.custom_images.unwrap_or_default();
            v.push(input.into());
            self.custom_images = Some(v);
            self
        }
        pub fn set_custom_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CustomImage>>,
        ) -> Self {
            self.custom_images = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
        pub fn build(self) -> crate::model::KernelGatewayAppSettings {
            crate::model::KernelGatewayAppSettings {
                default_resource_spec: self.default_resource_spec,
                custom_images: self.custom_images,
            }
        }
    }
}
impl KernelGatewayAppSettings {
    /// Creates a new builder-style object to manufacture [`KernelGatewayAppSettings`](crate::model::KernelGatewayAppSettings)
    pub fn builder() -> crate::model::kernel_gateway_app_settings::Builder {
        crate::model::kernel_gateway_app_settings::Builder::default()
    }
}

/// <p>A custom SageMaker image. For more information, see
/// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/studio-byoi.html">Bring your own SageMaker image</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomImage {
    /// <p>The name of the CustomImage. Must be unique to your account.</p>
    pub image_name: std::option::Option<std::string::String>,
    /// <p>The version number of the CustomImage.</p>
    pub image_version_number: std::option::Option<i32>,
    /// <p>The name of the AppImageConfig.</p>
    pub app_image_config_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomImage");
        formatter.field("image_name", &self.image_name);
        formatter.field("image_version_number", &self.image_version_number);
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.finish()
    }
}
/// See [`CustomImage`](crate::model::CustomImage)
pub mod custom_image {
    /// A builder for [`CustomImage`](crate::model::CustomImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_name: std::option::Option<std::string::String>,
        pub(crate) image_version_number: std::option::Option<i32>,
        pub(crate) app_image_config_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the CustomImage. Must be unique to your account.</p>
        pub fn image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_name = Some(input.into());
            self
        }
        pub fn set_image_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_name = input;
            self
        }
        /// <p>The version number of the CustomImage.</p>
        pub fn image_version_number(mut self, input: i32) -> Self {
            self.image_version_number = Some(input);
            self
        }
        pub fn set_image_version_number(mut self, input: std::option::Option<i32>) -> Self {
            self.image_version_number = input;
            self
        }
        /// <p>The name of the AppImageConfig.</p>
        pub fn app_image_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_name = Some(input.into());
            self
        }
        pub fn set_app_image_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomImage`](crate::model::CustomImage)
        pub fn build(self) -> crate::model::CustomImage {
            crate::model::CustomImage {
                image_name: self.image_name,
                image_version_number: self.image_version_number,
                app_image_config_name: self.app_image_config_name,
            }
        }
    }
}
impl CustomImage {
    /// Creates a new builder-style object to manufacture [`CustomImage`](crate::model::CustomImage)
    pub fn builder() -> crate::model::custom_image::Builder {
        crate::model::custom_image::Builder::default()
    }
}

/// <p>The JupyterServer app settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JupyterServerAppSettings {
    /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.</p>
    pub default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
}
impl std::fmt::Debug for JupyterServerAppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JupyterServerAppSettings");
        formatter.field("default_resource_spec", &self.default_resource_spec);
        formatter.finish()
    }
}
/// See [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
pub mod jupyter_server_app_settings {
    /// A builder for [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_resource_spec: std::option::Option<crate::model::ResourceSpec>,
    }
    impl Builder {
        /// <p>The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.</p>
        pub fn default_resource_spec(mut self, input: crate::model::ResourceSpec) -> Self {
            self.default_resource_spec = Some(input);
            self
        }
        pub fn set_default_resource_spec(
            mut self,
            input: std::option::Option<crate::model::ResourceSpec>,
        ) -> Self {
            self.default_resource_spec = input;
            self
        }
        /// Consumes the builder and constructs a [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
        pub fn build(self) -> crate::model::JupyterServerAppSettings {
            crate::model::JupyterServerAppSettings {
                default_resource_spec: self.default_resource_spec,
            }
        }
    }
}
impl JupyterServerAppSettings {
    /// Creates a new builder-style object to manufacture [`JupyterServerAppSettings`](crate::model::JupyterServerAppSettings)
    pub fn builder() -> crate::model::jupyter_server_app_settings::Builder {
        crate::model::jupyter_server_app_settings::Builder::default()
    }
}

/// <p>Specifies options for sharing SageMaker Studio notebooks. These settings are
/// specified as part of <code>DefaultUserSettings</code> when the <code>CreateDomain</code>
/// API is called, and as part of <code>UserSettings</code> when the <code>CreateUserProfile</code>
/// API is called. When <code>SharingSettings</code> is not specified, notebook sharing
/// isn't allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharingSettings {
    /// <p>Whether to include the notebook cell output when sharing the notebook. The default
    /// is <code>Disabled</code>.</p>
    pub notebook_output_option: std::option::Option<crate::model::NotebookOutputOption>,
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used
    /// to store the shared notebook snapshots.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS)
    /// encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
    pub s3_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SharingSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharingSettings");
        formatter.field("notebook_output_option", &self.notebook_output_option);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("s3_kms_key_id", &self.s3_kms_key_id);
        formatter.finish()
    }
}
/// See [`SharingSettings`](crate::model::SharingSettings)
pub mod sharing_settings {
    /// A builder for [`SharingSettings`](crate::model::SharingSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_output_option: std::option::Option<crate::model::NotebookOutputOption>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) s3_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to include the notebook cell output when sharing the notebook. The default
        /// is <code>Disabled</code>.</p>
        pub fn notebook_output_option(mut self, input: crate::model::NotebookOutputOption) -> Self {
            self.notebook_output_option = Some(input);
            self
        }
        pub fn set_notebook_output_option(
            mut self,
            input: std::option::Option<crate::model::NotebookOutputOption>,
        ) -> Self {
            self.notebook_output_option = input;
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon S3 bucket used
        /// to store the shared notebook snapshots.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>When <code>NotebookOutputOption</code> is <code>Allowed</code>, the Amazon Web Services Key Management Service (KMS)
        /// encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.</p>
        pub fn s3_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_kms_key_id = Some(input.into());
            self
        }
        pub fn set_s3_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SharingSettings`](crate::model::SharingSettings)
        pub fn build(self) -> crate::model::SharingSettings {
            crate::model::SharingSettings {
                notebook_output_option: self.notebook_output_option,
                s3_output_path: self.s3_output_path,
                s3_kms_key_id: self.s3_kms_key_id,
            }
        }
    }
}
impl SharingSettings {
    /// Creates a new builder-style object to manufacture [`SharingSettings`](crate::model::SharingSettings)
    pub fn builder() -> crate::model::sharing_settings::Builder {
        crate::model::sharing_settings::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookOutputOption {
    Allowed,
    Disabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookOutputOption {
    fn from(s: &str) -> Self {
        match s {
            "Allowed" => NotebookOutputOption::Allowed,
            "Disabled" => NotebookOutputOption::Disabled,
            other => NotebookOutputOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookOutputOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookOutputOption::from(s))
    }
}
impl NotebookOutputOption {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookOutputOption::Allowed => "Allowed",
            NotebookOutputOption::Disabled => "Disabled",
            NotebookOutputOption::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Allowed", "Disabled"]
    }
}
impl AsRef<str> for NotebookOutputOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents an input or output artifact of a trial component. You specify
/// <code>TrialComponentArtifact</code> as part of the <code>InputArtifacts</code> and
/// <code>OutputArtifacts</code> parameters in the <a>CreateTrialComponent</a>
/// request.</p>
/// <p>Examples of input artifacts are datasets, algorithms, hyperparameters, source code, and
/// instance types. Examples of output artifacts are metrics, snapshots, logs, and images.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentArtifact {
    /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The
    /// media type consists of a <i>type</i> and a <i>subtype</i>
    /// concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The
    /// type specifies the category of the media. The subtype specifies the kind of data.</p>
    pub media_type: std::option::Option<std::string::String>,
    /// <p>The location of the artifact.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrialComponentArtifact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentArtifact");
        formatter.field("media_type", &self.media_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
pub mod trial_component_artifact {
    /// A builder for [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The media type of the artifact, which indicates the type of data in the artifact file. The
        /// media type consists of a <i>type</i> and a <i>subtype</i>
        /// concatenated with a slash (/) character, for example, text/csv, image/jpeg, and s3/uri. The
        /// type specifies the category of the media. The subtype specifies the kind of data.</p>
        pub fn media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_type = Some(input.into());
            self
        }
        pub fn set_media_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_type = input;
            self
        }
        /// <p>The location of the artifact.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
        pub fn build(self) -> crate::model::TrialComponentArtifact {
            crate::model::TrialComponentArtifact {
                media_type: self.media_type,
                value: self.value,
            }
        }
    }
}
impl TrialComponentArtifact {
    /// Creates a new builder-style object to manufacture [`TrialComponentArtifact`](crate::model::TrialComponentArtifact)
    pub fn builder() -> crate::model::trial_component_artifact::Builder {
        crate::model::trial_component_artifact::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum TrialComponentParameterValue {
    /// <p>The numeric value of a numeric hyperparameter. If you specify a value for this parameter,
    /// you can't specify the <code>StringValue</code> parameter.</p>
    NumberValue(f64),
    /// <p>The string value of a categorical hyperparameter. If you specify a value for this
    /// parameter, you can't specify the <code>NumberValue</code> parameter.</p>
    StringValue(std::string::String),
}
impl TrialComponentParameterValue {
    pub fn as_number_value(&self) -> Result<&f64, &Self> {
        if let TrialComponentParameterValue::NumberValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_number_value(&self) -> bool {
        self.as_number_value().is_ok()
    }
    pub fn as_string_value(&self) -> Result<&std::string::String, &Self> {
        if let TrialComponentParameterValue::StringValue(val) = &self {
            Ok(&val)
        } else {
            Err(&self)
        }
    }
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
}

/// <p>The status of the trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentStatus {
    /// <p>The status of the trial component.</p>
    pub primary_status: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
    /// <p>If the component failed, a message describing why.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrialComponentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentStatus");
        formatter.field("primary_status", &self.primary_status);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`TrialComponentStatus`](crate::model::TrialComponentStatus)
pub mod trial_component_status {
    /// A builder for [`TrialComponentStatus`](crate::model::TrialComponentStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_status: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the trial component.</p>
        pub fn primary_status(mut self, input: crate::model::TrialComponentPrimaryStatus) -> Self {
            self.primary_status = Some(input);
            self
        }
        pub fn set_primary_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentPrimaryStatus>,
        ) -> Self {
            self.primary_status = input;
            self
        }
        /// <p>If the component failed, a message describing why.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentStatus`](crate::model::TrialComponentStatus)
        pub fn build(self) -> crate::model::TrialComponentStatus {
            crate::model::TrialComponentStatus {
                primary_status: self.primary_status,
                message: self.message,
            }
        }
    }
}
impl TrialComponentStatus {
    /// Creates a new builder-style object to manufacture [`TrialComponentStatus`](crate::model::TrialComponentStatus)
    pub fn builder() -> crate::model::trial_component_status::Builder {
        crate::model::trial_component_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrialComponentPrimaryStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrialComponentPrimaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TrialComponentPrimaryStatus::Completed,
            "Failed" => TrialComponentPrimaryStatus::Failed,
            "InProgress" => TrialComponentPrimaryStatus::InProgress,
            "Stopped" => TrialComponentPrimaryStatus::Stopped,
            "Stopping" => TrialComponentPrimaryStatus::Stopping,
            other => TrialComponentPrimaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrialComponentPrimaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrialComponentPrimaryStatus::from(s))
    }
}
impl TrialComponentPrimaryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TrialComponentPrimaryStatus::Completed => "Completed",
            TrialComponentPrimaryStatus::Failed => "Failed",
            TrialComponentPrimaryStatus::InProgress => "InProgress",
            TrialComponentPrimaryStatus::Stopped => "Stopped",
            TrialComponentPrimaryStatus::Stopping => "Stopping",
            TrialComponentPrimaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TrialComponentPrimaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for profiling rules.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub rule_evaluator_image: std::option::Option<std::string::String>,
    /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub volume_size_in_gb: i32,
    /// <p>Runtime configuration for rule container.</p>
    pub rule_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ProfilerRuleConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerRuleConfiguration");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("rule_evaluator_image", &self.rule_evaluator_image);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("rule_parameters", &self.rule_parameters);
        formatter.finish()
    }
}
/// See [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
pub mod profiler_rule_configuration {
    /// A builder for [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) rule_evaluator_image: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) rule_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule configuration. It must be unique relative to other rule configuration names.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to <code>/opt/ml/processing/output/rule/</code>. </p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn rule_evaluator_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluator_image = Some(input.into());
            self
        }
        pub fn set_rule_evaluator_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluator_image = input;
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for profiling a training job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        pub fn rule_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.rule_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.rule_parameters = Some(hash_map);
            self
        }
        pub fn set_rule_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.rule_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
        pub fn build(self) -> crate::model::ProfilerRuleConfiguration {
            crate::model::ProfilerRuleConfiguration {
                rule_configuration_name: self.rule_configuration_name,
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                rule_evaluator_image: self.rule_evaluator_image,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                rule_parameters: self.rule_parameters,
            }
        }
    }
}
impl ProfilerRuleConfiguration {
    /// Creates a new builder-style object to manufacture [`ProfilerRuleConfiguration`](crate::model::ProfilerRuleConfiguration)
    pub fn builder() -> crate::model::profiler_rule_configuration::Builder {
        crate::model::profiler_rule_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingInstanceType {
    MlC42Xlarge,
    MlC44Xlarge,
    MlC48Xlarge,
    MlC4Xlarge,
    MlC518Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Xlarge,
    MlG4Dn12Xlarge,
    MlG4Dn16Xlarge,
    MlG4Dn2Xlarge,
    MlG4Dn4Xlarge,
    MlG4Dn8Xlarge,
    MlG4DnXlarge,
    MlM410Xlarge,
    MlM416Xlarge,
    MlM42Xlarge,
    MlM44Xlarge,
    MlM4Xlarge,
    MlM512Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM5Large,
    MlM5Xlarge,
    MlP216Xlarge,
    MlP28Xlarge,
    MlP2Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    MlR512Xlarge,
    MlR516Xlarge,
    MlR524Xlarge,
    MlR52Xlarge,
    MlR54Xlarge,
    MlR58Xlarge,
    MlR5Large,
    MlR5Xlarge,
    MlT32Xlarge,
    MlT3Large,
    MlT3Medium,
    MlT3Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => ProcessingInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => ProcessingInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => ProcessingInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => ProcessingInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => ProcessingInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => ProcessingInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => ProcessingInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => ProcessingInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => ProcessingInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => ProcessingInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => ProcessingInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => ProcessingInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => ProcessingInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => ProcessingInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => ProcessingInstanceType::MlG4DnXlarge,
            "ml.m4.10xlarge" => ProcessingInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => ProcessingInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => ProcessingInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => ProcessingInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => ProcessingInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => ProcessingInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => ProcessingInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => ProcessingInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => ProcessingInstanceType::MlM54Xlarge,
            "ml.m5.large" => ProcessingInstanceType::MlM5Large,
            "ml.m5.xlarge" => ProcessingInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => ProcessingInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => ProcessingInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => ProcessingInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => ProcessingInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => ProcessingInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => ProcessingInstanceType::MlP38Xlarge,
            "ml.r5.12xlarge" => ProcessingInstanceType::MlR512Xlarge,
            "ml.r5.16xlarge" => ProcessingInstanceType::MlR516Xlarge,
            "ml.r5.24xlarge" => ProcessingInstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => ProcessingInstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => ProcessingInstanceType::MlR54Xlarge,
            "ml.r5.8xlarge" => ProcessingInstanceType::MlR58Xlarge,
            "ml.r5.large" => ProcessingInstanceType::MlR5Large,
            "ml.r5.xlarge" => ProcessingInstanceType::MlR5Xlarge,
            "ml.t3.2xlarge" => ProcessingInstanceType::MlT32Xlarge,
            "ml.t3.large" => ProcessingInstanceType::MlT3Large,
            "ml.t3.medium" => ProcessingInstanceType::MlT3Medium,
            "ml.t3.xlarge" => ProcessingInstanceType::MlT3Xlarge,
            other => ProcessingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingInstanceType::from(s))
    }
}
impl ProcessingInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            ProcessingInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            ProcessingInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            ProcessingInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            ProcessingInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            ProcessingInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            ProcessingInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            ProcessingInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            ProcessingInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            ProcessingInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            ProcessingInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            ProcessingInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            ProcessingInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            ProcessingInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            ProcessingInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            ProcessingInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            ProcessingInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            ProcessingInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            ProcessingInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            ProcessingInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            ProcessingInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            ProcessingInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            ProcessingInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            ProcessingInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            ProcessingInstanceType::MlM5Large => "ml.m5.large",
            ProcessingInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            ProcessingInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            ProcessingInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            ProcessingInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            ProcessingInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            ProcessingInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            ProcessingInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            ProcessingInstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            ProcessingInstanceType::MlR516Xlarge => "ml.r5.16xlarge",
            ProcessingInstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            ProcessingInstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            ProcessingInstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            ProcessingInstanceType::MlR58Xlarge => "ml.r5.8xlarge",
            ProcessingInstanceType::MlR5Large => "ml.r5.large",
            ProcessingInstanceType::MlR5Xlarge => "ml.r5.xlarge",
            ProcessingInstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            ProcessingInstanceType::MlT3Large => "ml.t3.large",
            ProcessingInstanceType::MlT3Medium => "ml.t3.medium",
            ProcessingInstanceType::MlT3Xlarge => "ml.t3.xlarge",
            ProcessingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.r5.12xlarge",
            "ml.r5.16xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.8xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.xlarge",
        ]
    }
}
impl AsRef<str> for ProcessingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration information for updating the Debugger profile parameters, system and framework metrics configurations, and
/// storage paths.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerConfigForUpdate {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are
    /// 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub profiling_interval_in_milliseconds: std::option::Option<i64>,
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are
    /// <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>.
    /// The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about
    /// how to configure the <code>ProfilingParameters</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.
    /// </p>
    pub profiling_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
    pub disable_profiler: bool,
}
impl std::fmt::Debug for ProfilerConfigForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerConfigForUpdate");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field(
            "profiling_interval_in_milliseconds",
            &self.profiling_interval_in_milliseconds,
        );
        formatter.field("profiling_parameters", &self.profiling_parameters);
        formatter.field("disable_profiler", &self.disable_profiler);
        formatter.finish()
    }
}
/// See [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
pub mod profiler_config_for_update {
    /// A builder for [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) profiling_interval_in_milliseconds: std::option::Option<i64>,
        pub(crate) profiling_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) disable_profiler: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are
        /// 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn profiling_interval_in_milliseconds(mut self, input: i64) -> Self {
            self.profiling_interval_in_milliseconds = Some(input);
            self
        }
        pub fn set_profiling_interval_in_milliseconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.profiling_interval_in_milliseconds = input;
            self
        }
        pub fn profiling_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.profiling_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.profiling_parameters = Some(hash_map);
            self
        }
        pub fn set_profiling_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.profiling_parameters = input;
            self
        }
        /// <p>To disable Debugger monitoring and profiling, set to <code>True</code>.</p>
        pub fn disable_profiler(mut self, input: bool) -> Self {
            self.disable_profiler = Some(input);
            self
        }
        pub fn set_disable_profiler(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_profiler = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
        pub fn build(self) -> crate::model::ProfilerConfigForUpdate {
            crate::model::ProfilerConfigForUpdate {
                s3_output_path: self.s3_output_path,
                profiling_interval_in_milliseconds: self.profiling_interval_in_milliseconds,
                profiling_parameters: self.profiling_parameters,
                disable_profiler: self.disable_profiler.unwrap_or_default(),
            }
        }
    }
}
impl ProfilerConfigForUpdate {
    /// Creates a new builder-style object to manufacture [`ProfilerConfigForUpdate`](crate::model::ProfilerConfigForUpdate)
    pub fn builder() -> crate::model::profiler_config_for_update::Builder {
        crate::model::profiler_config_for_update::Builder::default()
    }
}

/// <p>Contains the notebook instance lifecycle configuration script.</p>
/// <p>Each lifecycle configuration script has a limit of 16384 characters.</p>
/// <p>The value of the <code>$PATH</code> environment variable that is available to both
/// scripts is <code>/sbin:bin:/usr/sbin:/usr/bin</code>.</p>
/// <p>View CloudWatch Logs for notebook instance lifecycle configurations in log group
/// <code>/aws/sagemaker/NotebookInstances</code> in log stream
/// <code>[notebook-instance-name]/[LifecycleConfigHook]</code>.</p>
/// <p>Lifecycle configuration scripts cannot run for longer than 5 minutes. If a script runs
/// for longer than 5 minutes, it fails and the notebook instance is not created or
/// started.</p>
/// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step
/// 2.1: (Optional) Customize a Notebook Instance</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceLifecycleHook {
    /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle
    /// configuration.</p>
    pub content: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotebookInstanceLifecycleHook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceLifecycleHook");
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
pub mod notebook_instance_lifecycle_hook {
    /// A builder for [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A base64-encoded string that contains a shell script for a notebook instance lifecycle
        /// configuration.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
        pub fn build(self) -> crate::model::NotebookInstanceLifecycleHook {
            crate::model::NotebookInstanceLifecycleHook {
                content: self.content,
            }
        }
    }
}
impl NotebookInstanceLifecycleHook {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceLifecycleHook`](crate::model::NotebookInstanceLifecycleHook)
    pub fn builder() -> crate::model::notebook_instance_lifecycle_hook::Builder {
        crate::model::notebook_instance_lifecycle_hook::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RootAccess {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RootAccess {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => RootAccess::Disabled,
            "Enabled" => RootAccess::Enabled,
            other => RootAccess::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RootAccess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RootAccess::from(s))
    }
}
impl RootAccess {
    pub fn as_str(&self) -> &str {
        match self {
            RootAccess::Disabled => "Disabled",
            RootAccess::Enabled => "Enabled",
            RootAccess::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for RootAccess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceAcceleratorType {
    MlEia1Large,
    MlEia1Medium,
    MlEia1Xlarge,
    MlEia2Large,
    MlEia2Medium,
    MlEia2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceAcceleratorType {
    fn from(s: &str) -> Self {
        match s {
            "ml.eia1.large" => NotebookInstanceAcceleratorType::MlEia1Large,
            "ml.eia1.medium" => NotebookInstanceAcceleratorType::MlEia1Medium,
            "ml.eia1.xlarge" => NotebookInstanceAcceleratorType::MlEia1Xlarge,
            "ml.eia2.large" => NotebookInstanceAcceleratorType::MlEia2Large,
            "ml.eia2.medium" => NotebookInstanceAcceleratorType::MlEia2Medium,
            "ml.eia2.xlarge" => NotebookInstanceAcceleratorType::MlEia2Xlarge,
            other => NotebookInstanceAcceleratorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceAcceleratorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceAcceleratorType::from(s))
    }
}
impl NotebookInstanceAcceleratorType {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceAcceleratorType::MlEia1Large => "ml.eia1.large",
            NotebookInstanceAcceleratorType::MlEia1Medium => "ml.eia1.medium",
            NotebookInstanceAcceleratorType::MlEia1Xlarge => "ml.eia1.xlarge",
            NotebookInstanceAcceleratorType::MlEia2Large => "ml.eia2.large",
            NotebookInstanceAcceleratorType::MlEia2Medium => "ml.eia2.medium",
            NotebookInstanceAcceleratorType::MlEia2Xlarge => "ml.eia2.xlarge",
            NotebookInstanceAcceleratorType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.eia1.large",
            "ml.eia1.medium",
            "ml.eia1.xlarge",
            "ml.eia2.large",
            "ml.eia2.medium",
            "ml.eia2.xlarge",
        ]
    }
}
impl AsRef<str> for NotebookInstanceAcceleratorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceType {
    MlC42Xlarge,
    MlC44Xlarge,
    MlC48Xlarge,
    MlC4Xlarge,
    MlC518Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Xlarge,
    MlC5D18Xlarge,
    MlC5D2Xlarge,
    MlC5D4Xlarge,
    MlC5D9Xlarge,
    MlC5DXlarge,
    MlM410Xlarge,
    MlM416Xlarge,
    MlM42Xlarge,
    MlM44Xlarge,
    MlM4Xlarge,
    MlM512Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM5Xlarge,
    MlP216Xlarge,
    MlP28Xlarge,
    MlP2Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    MlT22Xlarge,
    MlT2Large,
    MlT2Medium,
    MlT2Xlarge,
    MlT32Xlarge,
    MlT3Large,
    MlT3Medium,
    MlT3Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => InstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => InstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => InstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => InstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => InstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => InstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => InstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => InstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => InstanceType::MlC5Xlarge,
            "ml.c5d.18xlarge" => InstanceType::MlC5D18Xlarge,
            "ml.c5d.2xlarge" => InstanceType::MlC5D2Xlarge,
            "ml.c5d.4xlarge" => InstanceType::MlC5D4Xlarge,
            "ml.c5d.9xlarge" => InstanceType::MlC5D9Xlarge,
            "ml.c5d.xlarge" => InstanceType::MlC5DXlarge,
            "ml.m4.10xlarge" => InstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => InstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => InstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => InstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => InstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => InstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => InstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => InstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => InstanceType::MlM54Xlarge,
            "ml.m5.xlarge" => InstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => InstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => InstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => InstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => InstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => InstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => InstanceType::MlP38Xlarge,
            "ml.t2.2xlarge" => InstanceType::MlT22Xlarge,
            "ml.t2.large" => InstanceType::MlT2Large,
            "ml.t2.medium" => InstanceType::MlT2Medium,
            "ml.t2.xlarge" => InstanceType::MlT2Xlarge,
            "ml.t3.2xlarge" => InstanceType::MlT32Xlarge,
            "ml.t3.large" => InstanceType::MlT3Large,
            "ml.t3.medium" => InstanceType::MlT3Medium,
            "ml.t3.xlarge" => InstanceType::MlT3Xlarge,
            other => InstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceType::from(s))
    }
}
impl InstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            InstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            InstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            InstanceType::MlC4Xlarge => "ml.c4.xlarge",
            InstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            InstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            InstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            InstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            InstanceType::MlC5Xlarge => "ml.c5.xlarge",
            InstanceType::MlC5D18Xlarge => "ml.c5d.18xlarge",
            InstanceType::MlC5D2Xlarge => "ml.c5d.2xlarge",
            InstanceType::MlC5D4Xlarge => "ml.c5d.4xlarge",
            InstanceType::MlC5D9Xlarge => "ml.c5d.9xlarge",
            InstanceType::MlC5DXlarge => "ml.c5d.xlarge",
            InstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            InstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            InstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            InstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            InstanceType::MlM4Xlarge => "ml.m4.xlarge",
            InstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            InstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            InstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            InstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            InstanceType::MlM5Xlarge => "ml.m5.xlarge",
            InstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            InstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            InstanceType::MlP2Xlarge => "ml.p2.xlarge",
            InstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            InstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            InstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            InstanceType::MlT22Xlarge => "ml.t2.2xlarge",
            InstanceType::MlT2Large => "ml.t2.large",
            InstanceType::MlT2Medium => "ml.t2.medium",
            InstanceType::MlT2Xlarge => "ml.t2.xlarge",
            InstanceType::MlT32Xlarge => "ml.t3.2xlarge",
            InstanceType::MlT3Large => "ml.t3.large",
            InstanceType::MlT3Medium => "ml.t3.medium",
            InstanceType::MlT3Xlarge => "ml.t3.xlarge",
            InstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.c5d.18xlarge",
            "ml.c5d.2xlarge",
            "ml.c5d.4xlarge",
            "ml.c5d.9xlarge",
            "ml.c5d.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.t2.2xlarge",
            "ml.t2.large",
            "ml.t2.medium",
            "ml.t2.xlarge",
            "ml.t3.2xlarge",
            "ml.t3.large",
            "ml.t3.medium",
            "ml.t3.xlarge",
        ]
    }
}
impl AsRef<str> for InstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configures the monitoring schedule and defines the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringScheduleConfig {
    /// <p>Configures the monitoring schedule.</p>
    pub schedule_config: std::option::Option<crate::model::ScheduleConfig>,
    /// <p>Defines the monitoring job.</p>
    pub monitoring_job_definition: std::option::Option<crate::model::MonitoringJobDefinition>,
    /// <p>The name of the monitoring job definition to schedule.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl std::fmt::Debug for MonitoringScheduleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringScheduleConfig");
        formatter.field("schedule_config", &self.schedule_config);
        formatter.field("monitoring_job_definition", &self.monitoring_job_definition);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
pub mod monitoring_schedule_config {
    /// A builder for [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_config: std::option::Option<crate::model::ScheduleConfig>,
        pub(crate) monitoring_job_definition:
            std::option::Option<crate::model::MonitoringJobDefinition>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>Configures the monitoring schedule.</p>
        pub fn schedule_config(mut self, input: crate::model::ScheduleConfig) -> Self {
            self.schedule_config = Some(input);
            self
        }
        pub fn set_schedule_config(
            mut self,
            input: std::option::Option<crate::model::ScheduleConfig>,
        ) -> Self {
            self.schedule_config = input;
            self
        }
        /// <p>Defines the monitoring job.</p>
        pub fn monitoring_job_definition(
            mut self,
            input: crate::model::MonitoringJobDefinition,
        ) -> Self {
            self.monitoring_job_definition = Some(input);
            self
        }
        pub fn set_monitoring_job_definition(
            mut self,
            input: std::option::Option<crate::model::MonitoringJobDefinition>,
        ) -> Self {
            self.monitoring_job_definition = input;
            self
        }
        /// <p>The name of the monitoring job definition to schedule.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
        pub fn build(self) -> crate::model::MonitoringScheduleConfig {
            crate::model::MonitoringScheduleConfig {
                schedule_config: self.schedule_config,
                monitoring_job_definition: self.monitoring_job_definition,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringScheduleConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringScheduleConfig`](crate::model::MonitoringScheduleConfig)
    pub fn builder() -> crate::model::monitoring_schedule_config::Builder {
        crate::model::monitoring_schedule_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringType {
    DataQuality,
    ModelBias,
    ModelExplainability,
    ModelQuality,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringType {
    fn from(s: &str) -> Self {
        match s {
            "DataQuality" => MonitoringType::DataQuality,
            "ModelBias" => MonitoringType::ModelBias,
            "ModelExplainability" => MonitoringType::ModelExplainability,
            "ModelQuality" => MonitoringType::ModelQuality,
            other => MonitoringType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringType::from(s))
    }
}
impl MonitoringType {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringType::DataQuality => "DataQuality",
            MonitoringType::ModelBias => "ModelBias",
            MonitoringType::ModelExplainability => "ModelExplainability",
            MonitoringType::ModelQuality => "ModelQuality",
            MonitoringType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "DataQuality",
            "ModelBias",
            "ModelExplainability",
            "ModelQuality",
        ]
    }
}
impl AsRef<str> for MonitoringType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringJobDefinition {
    /// <p>Baseline configuration used to validate that the data conforms to the specified
    /// constraints and statistics</p>
    pub baseline_config: std::option::Option<crate::model::MonitoringBaselineConfig>,
    /// <p>The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker
    /// Endpoint.</p>
    pub monitoring_inputs: std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
    /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage
    /// Service (Amazon S3).</p>
    pub monitoring_output_config: std::option::Option<crate::model::MonitoringOutputConfig>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
    /// monitoring job. In distributed processing, you specify more than one instance.</p>
    pub monitoring_resources: std::option::Option<crate::model::MonitoringResources>,
    /// <p>Configures the monitoring job to run a specified Docker container image.</p>
    pub monitoring_app_specification: std::option::Option<crate::model::MonitoringAppSpecification>,
    /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
    pub stopping_condition: std::option::Option<crate::model::MonitoringStoppingCondition>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies networking options for an monitoring job.</p>
    pub network_config: std::option::Option<crate::model::NetworkConfig>,
    /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on
    /// your behalf.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringJobDefinition");
        formatter.field("baseline_config", &self.baseline_config);
        formatter.field("monitoring_inputs", &self.monitoring_inputs);
        formatter.field("monitoring_output_config", &self.monitoring_output_config);
        formatter.field("monitoring_resources", &self.monitoring_resources);
        formatter.field(
            "monitoring_app_specification",
            &self.monitoring_app_specification,
        );
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
pub mod monitoring_job_definition {
    /// A builder for [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baseline_config: std::option::Option<crate::model::MonitoringBaselineConfig>,
        pub(crate) monitoring_inputs:
            std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
        pub(crate) monitoring_output_config:
            std::option::Option<crate::model::MonitoringOutputConfig>,
        pub(crate) monitoring_resources: std::option::Option<crate::model::MonitoringResources>,
        pub(crate) monitoring_app_specification:
            std::option::Option<crate::model::MonitoringAppSpecification>,
        pub(crate) stopping_condition:
            std::option::Option<crate::model::MonitoringStoppingCondition>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) network_config: std::option::Option<crate::model::NetworkConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Baseline configuration used to validate that the data conforms to the specified
        /// constraints and statistics</p>
        pub fn baseline_config(mut self, input: crate::model::MonitoringBaselineConfig) -> Self {
            self.baseline_config = Some(input);
            self
        }
        pub fn set_baseline_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringBaselineConfig>,
        ) -> Self {
            self.baseline_config = input;
            self
        }
        pub fn monitoring_inputs(
            mut self,
            input: impl Into<crate::model::MonitoringInput>,
        ) -> Self {
            let mut v = self.monitoring_inputs.unwrap_or_default();
            v.push(input.into());
            self.monitoring_inputs = Some(v);
            self
        }
        pub fn set_monitoring_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringInput>>,
        ) -> Self {
            self.monitoring_inputs = input;
            self
        }
        /// <p>The array of outputs from the monitoring job to be uploaded to Amazon Simple Storage
        /// Service (Amazon S3).</p>
        pub fn monitoring_output_config(
            mut self,
            input: crate::model::MonitoringOutputConfig,
        ) -> Self {
            self.monitoring_output_config = Some(input);
            self
        }
        pub fn set_monitoring_output_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringOutputConfig>,
        ) -> Self {
            self.monitoring_output_config = input;
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
        /// monitoring job. In distributed processing, you specify more than one instance.</p>
        pub fn monitoring_resources(mut self, input: crate::model::MonitoringResources) -> Self {
            self.monitoring_resources = Some(input);
            self
        }
        pub fn set_monitoring_resources(
            mut self,
            input: std::option::Option<crate::model::MonitoringResources>,
        ) -> Self {
            self.monitoring_resources = input;
            self
        }
        /// <p>Configures the monitoring job to run a specified Docker container image.</p>
        pub fn monitoring_app_specification(
            mut self,
            input: crate::model::MonitoringAppSpecification,
        ) -> Self {
            self.monitoring_app_specification = Some(input);
            self
        }
        pub fn set_monitoring_app_specification(
            mut self,
            input: std::option::Option<crate::model::MonitoringAppSpecification>,
        ) -> Self {
            self.monitoring_app_specification = input;
            self
        }
        /// <p>Specifies a time limit for how long the monitoring job is allowed to run.</p>
        pub fn stopping_condition(
            mut self,
            input: crate::model::MonitoringStoppingCondition,
        ) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::MonitoringStoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Specifies networking options for an monitoring job.</p>
        pub fn network_config(mut self, input: crate::model::NetworkConfig) -> Self {
            self.network_config = Some(input);
            self
        }
        pub fn set_network_config(
            mut self,
            input: std::option::Option<crate::model::NetworkConfig>,
        ) -> Self {
            self.network_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on
        /// your behalf.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
        pub fn build(self) -> crate::model::MonitoringJobDefinition {
            crate::model::MonitoringJobDefinition {
                baseline_config: self.baseline_config,
                monitoring_inputs: self.monitoring_inputs,
                monitoring_output_config: self.monitoring_output_config,
                monitoring_resources: self.monitoring_resources,
                monitoring_app_specification: self.monitoring_app_specification,
                stopping_condition: self.stopping_condition,
                environment: self.environment,
                network_config: self.network_config,
                role_arn: self.role_arn,
            }
        }
    }
}
impl MonitoringJobDefinition {
    /// Creates a new builder-style object to manufacture [`MonitoringJobDefinition`](crate::model::MonitoringJobDefinition)
    pub fn builder() -> crate::model::monitoring_job_definition::Builder {
        crate::model::monitoring_job_definition::Builder::default()
    }
}

/// <p>Networking options for a job, such as network traffic encryption between containers,
/// whether to allow inbound and outbound network calls to and from containers, and the VPC
/// subnets and security groups to use for VPC-enabled jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkConfig {
    /// <p>Whether to encrypt all communications between distributed processing jobs. Choose
    /// <code>True</code> to encrypt communications. Encryption provides greater security for distributed
    /// processing jobs, but the processing might take longer.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for
    /// the processing job.</p>
    pub enable_network_isolation: bool,
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control
    /// access to and from your training and model containers by configuring the VPC. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
    /// by Using an Amazon Virtual Private Cloud</a>. </p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl std::fmt::Debug for NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkConfig");
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`NetworkConfig`](crate::model::NetworkConfig)
pub mod network_config {
    /// A builder for [`NetworkConfig`](crate::model::NetworkConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>Whether to encrypt all communications between distributed processing jobs. Choose
        /// <code>True</code> to encrypt communications. Encryption provides greater security for distributed
        /// processing jobs, but the processing might take longer.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for
        /// the processing job.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control
        /// access to and from your training and model containers by configuring the VPC. For more
        /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
        /// by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConfig`](crate::model::NetworkConfig)
        pub fn build(self) -> crate::model::NetworkConfig {
            crate::model::NetworkConfig {
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl NetworkConfig {
    /// Creates a new builder-style object to manufacture [`NetworkConfig`](crate::model::NetworkConfig)
    pub fn builder() -> crate::model::network_config::Builder {
        crate::model::network_config::Builder::default()
    }
}

/// <p>Specifies a VPC that your training jobs and hosted models have access to. Control
/// access to and from your training and model containers by configuring the VPC. For more
/// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
/// by Using an Amazon Virtual Private Cloud</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcConfig {
    /// <p>The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for
    /// the VPC that is specified in the <code>Subnets</code> field.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the subnets in the VPC to which you want to connect your training job or
    /// model. For information about the availability of specific instance types, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">Supported
    /// Instance Types and Availability Zones</a>.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for VpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcConfig");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig)
pub mod vpc_config {
    /// A builder for [`VpcConfig`](crate::model::VpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig)
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                security_group_ids: self.security_group_ids,
                subnets: self.subnets,
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig)
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>A time limit for how long the monitoring job is allowed to run before stopping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringStoppingCondition {
    /// <p>The maximum runtime allowed in seconds.</p>
    /// <note>
    /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and
    /// model explainability, this can be up to 3600 seconds for an hourly schedule. For model
    /// bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
    /// </note>
    pub max_runtime_in_seconds: i32,
}
impl std::fmt::Debug for MonitoringStoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringStoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.finish()
    }
}
/// See [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
pub mod monitoring_stopping_condition {
    /// A builder for [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum runtime allowed in seconds.</p>
        /// <note>
        /// <p>The <code>MaxRuntimeInSeconds</code> cannot exceed the frequency of the job. For data quality and
        /// model explainability, this can be up to 3600 seconds for an hourly schedule. For model
        /// bias and model quality hourly schedules, this can be up to 1800 seconds.</p>
        /// </note>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
        pub fn build(self) -> crate::model::MonitoringStoppingCondition {
            crate::model::MonitoringStoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
            }
        }
    }
}
impl MonitoringStoppingCondition {
    /// Creates a new builder-style object to manufacture [`MonitoringStoppingCondition`](crate::model::MonitoringStoppingCondition)
    pub fn builder() -> crate::model::monitoring_stopping_condition::Builder {
        crate::model::monitoring_stopping_condition::Builder::default()
    }
}

/// <p>Container image configuration object for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringAppSpecification {
    /// <p>The container image to be run by the monitoring job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the entrypoint for a container used to run the monitoring job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
    /// base64 decode the payload and convert it into a flatted json so that the built-in container
    /// can use the converted data. Applicable only for the built-in (first party)
    /// containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
    /// Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.finish()
    }
}
/// See [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
pub mod monitoring_app_specification {
    /// A builder for [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The container image to be run by the monitoring job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
        /// base64 decode the payload and convert it into a flatted json so that the built-in container
        /// can use the converted data. Applicable only for the built-in (first party)
        /// containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
        /// Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
        pub fn build(self) -> crate::model::MonitoringAppSpecification {
            crate::model::MonitoringAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
            }
        }
    }
}
impl MonitoringAppSpecification {
    /// Creates a new builder-style object to manufacture [`MonitoringAppSpecification`](crate::model::MonitoringAppSpecification)
    pub fn builder() -> crate::model::monitoring_app_specification::Builder {
        crate::model::monitoring_app_specification::Builder::default()
    }
}

/// <p>Identifies the resources to deploy for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringResources {
    /// <p>The configuration for the cluster resources used to run the processing job.</p>
    pub cluster_config: std::option::Option<crate::model::MonitoringClusterConfig>,
}
impl std::fmt::Debug for MonitoringResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringResources");
        formatter.field("cluster_config", &self.cluster_config);
        formatter.finish()
    }
}
/// See [`MonitoringResources`](crate::model::MonitoringResources)
pub mod monitoring_resources {
    /// A builder for [`MonitoringResources`](crate::model::MonitoringResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_config: std::option::Option<crate::model::MonitoringClusterConfig>,
    }
    impl Builder {
        /// <p>The configuration for the cluster resources used to run the processing job.</p>
        pub fn cluster_config(mut self, input: crate::model::MonitoringClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringResources`](crate::model::MonitoringResources)
        pub fn build(self) -> crate::model::MonitoringResources {
            crate::model::MonitoringResources {
                cluster_config: self.cluster_config,
            }
        }
    }
}
impl MonitoringResources {
    /// Creates a new builder-style object to manufacture [`MonitoringResources`](crate::model::MonitoringResources)
    pub fn builder() -> crate::model::monitoring_resources::Builder {
        crate::model::monitoring_resources::Builder::default()
    }
}

/// <p>Configuration for the cluster used to run model monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringClusterConfig {
    /// <p>The number of ML compute instances to use in the model monitoring job. For distributed
    /// processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type for the processing job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must
    /// specify sufficient ML storage for your scenario.</p>
    pub volume_size_in_gb: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data
    /// on the storage volume attached to the ML compute instance(s) that run the model monitoring
    /// job.</p>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringClusterConfig");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
pub mod monitoring_cluster_config {
    /// A builder for [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of ML compute instances to use in the model monitoring job. For distributed
        /// processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size of the ML storage volume, in gigabytes, that you want to provision. You must
        /// specify sufficient ML storage for your scenario.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data
        /// on the storage volume attached to the ML compute instance(s) that run the model monitoring
        /// job.</p>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
        pub fn build(self) -> crate::model::MonitoringClusterConfig {
            crate::model::MonitoringClusterConfig {
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl MonitoringClusterConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringClusterConfig`](crate::model::MonitoringClusterConfig)
    pub fn builder() -> crate::model::monitoring_cluster_config::Builder {
        crate::model::monitoring_cluster_config::Builder::default()
    }
}

/// <p>The output configuration for monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringOutputConfig {
    /// <p>Monitoring outputs for monitoring jobs. This is where the output of the periodic
    /// monitoring jobs is uploaded.</p>
    pub monitoring_outputs: std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model
    /// artifacts at rest using Amazon S3 server-side encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringOutputConfig");
        formatter.field("monitoring_outputs", &self.monitoring_outputs);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
pub mod monitoring_output_config {
    /// A builder for [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_outputs:
            std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn monitoring_outputs(
            mut self,
            input: impl Into<crate::model::MonitoringOutput>,
        ) -> Self {
            let mut v = self.monitoring_outputs.unwrap_or_default();
            v.push(input.into());
            self.monitoring_outputs = Some(v);
            self
        }
        pub fn set_monitoring_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringOutput>>,
        ) -> Self {
            self.monitoring_outputs = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model
        /// artifacts at rest using Amazon S3 server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
        pub fn build(self) -> crate::model::MonitoringOutputConfig {
            crate::model::MonitoringOutputConfig {
                monitoring_outputs: self.monitoring_outputs,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl MonitoringOutputConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringOutputConfig`](crate::model::MonitoringOutputConfig)
    pub fn builder() -> crate::model::monitoring_output_config::Builder {
        crate::model::monitoring_output_config::Builder::default()
    }
}

/// <p>The output object for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringOutput {
    /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
    pub s3_output: std::option::Option<crate::model::MonitoringS3Output>,
}
impl std::fmt::Debug for MonitoringOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringOutput");
        formatter.field("s3_output", &self.s3_output);
        formatter.finish()
    }
}
/// See [`MonitoringOutput`](crate::model::MonitoringOutput)
pub mod monitoring_output {
    /// A builder for [`MonitoringOutput`](crate::model::MonitoringOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output: std::option::Option<crate::model::MonitoringS3Output>,
    }
    impl Builder {
        /// <p>The Amazon S3 storage location where the results of a monitoring job are saved.</p>
        pub fn s3_output(mut self, input: crate::model::MonitoringS3Output) -> Self {
            self.s3_output = Some(input);
            self
        }
        pub fn set_s3_output(
            mut self,
            input: std::option::Option<crate::model::MonitoringS3Output>,
        ) -> Self {
            self.s3_output = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringOutput`](crate::model::MonitoringOutput)
        pub fn build(self) -> crate::model::MonitoringOutput {
            crate::model::MonitoringOutput {
                s3_output: self.s3_output,
            }
        }
    }
}
impl MonitoringOutput {
    /// Creates a new builder-style object to manufacture [`MonitoringOutput`](crate::model::MonitoringOutput)
    pub fn builder() -> crate::model::monitoring_output::Builder {
        crate::model::monitoring_output::Builder::default()
    }
}

/// <p>Information about where and how you want to store the results of a monitoring
/// job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringS3Output {
    /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a
    /// monitoring job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a
    /// monitoring job. LocalPath is an absolute path for the output data.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether to upload the results of the monitoring job continuously or after the job
    /// completes.</p>
    pub s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
}
impl std::fmt::Debug for MonitoringS3Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringS3Output");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_upload_mode", &self.s3_upload_mode);
        formatter.finish()
    }
}
/// See [`MonitoringS3Output`](crate::model::MonitoringS3Output)
pub mod monitoring_s3_output {
    /// A builder for [`MonitoringS3Output`](crate::model::MonitoringS3Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
    }
    impl Builder {
        /// <p>A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a
        /// monitoring job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a
        /// monitoring job. LocalPath is an absolute path for the output data.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether to upload the results of the monitoring job continuously or after the job
        /// completes.</p>
        pub fn s3_upload_mode(mut self, input: crate::model::ProcessingS3UploadMode) -> Self {
            self.s3_upload_mode = Some(input);
            self
        }
        pub fn set_s3_upload_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3UploadMode>,
        ) -> Self {
            self.s3_upload_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringS3Output`](crate::model::MonitoringS3Output)
        pub fn build(self) -> crate::model::MonitoringS3Output {
            crate::model::MonitoringS3Output {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_upload_mode: self.s3_upload_mode,
            }
        }
    }
}
impl MonitoringS3Output {
    /// Creates a new builder-style object to manufacture [`MonitoringS3Output`](crate::model::MonitoringS3Output)
    pub fn builder() -> crate::model::monitoring_s3_output::Builder {
        crate::model::monitoring_s3_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3UploadMode {
    Continuous,
    EndOfJob,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3UploadMode {
    fn from(s: &str) -> Self {
        match s {
            "Continuous" => ProcessingS3UploadMode::Continuous,
            "EndOfJob" => ProcessingS3UploadMode::EndOfJob,
            other => ProcessingS3UploadMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3UploadMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3UploadMode::from(s))
    }
}
impl ProcessingS3UploadMode {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3UploadMode::Continuous => "Continuous",
            ProcessingS3UploadMode::EndOfJob => "EndOfJob",
            ProcessingS3UploadMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Continuous", "EndOfJob"]
    }
}
impl AsRef<str> for ProcessingS3UploadMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The inputs for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringInput {
    /// <p>The endpoint for a monitoring job.</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl std::fmt::Debug for MonitoringInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`MonitoringInput`](crate::model::MonitoringInput)
pub mod monitoring_input {
    /// A builder for [`MonitoringInput`](crate::model::MonitoringInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>The endpoint for a monitoring job.</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringInput`](crate::model::MonitoringInput)
        pub fn build(self) -> crate::model::MonitoringInput {
            crate::model::MonitoringInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl MonitoringInput {
    /// Creates a new builder-style object to manufacture [`MonitoringInput`](crate::model::MonitoringInput)
    pub fn builder() -> crate::model::monitoring_input::Builder {
        crate::model::monitoring_input::Builder::default()
    }
}

/// <p>Input object for the endpoint</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointInput {
    /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code>
    /// enabled.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for
    /// transfering data for the monitoring job. <code>Pipe</code> mode is recommended for large
    /// datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to
    /// <code>File</code>.</p>
    pub s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
    /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key.
    /// Defaults to <code>FullyReplicated</code>
    /// </p>
    pub s3_data_distribution_type:
        std::option::Option<crate::model::ProcessingS3DataDistributionType>,
    /// <p>The attributes of the input data that are the input features.</p>
    pub features_attribute: std::option::Option<std::string::String>,
    /// <p>The attribute of the input data that represents the ground truth label.</p>
    pub inference_attribute: std::option::Option<std::string::String>,
    /// <p>In a classification problem, the attribute that represents the class probability.</p>
    pub probability_attribute: std::option::Option<std::string::String>,
    /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
    pub probability_threshold_attribute: std::option::Option<f64>,
    /// <p>If specified, monitoring jobs substract this time from the start time. For information
    /// about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model
    /// Quality Monitoring Jobs</a>.</p>
    pub start_time_offset: std::option::Option<std::string::String>,
    /// <p>If specified, monitoring jobs substract this time from the end time. For information
    /// about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model
    /// Quality Monitoring Jobs</a>.</p>
    pub end_time_offset: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointInput");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_input_mode", &self.s3_input_mode);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("features_attribute", &self.features_attribute);
        formatter.field("inference_attribute", &self.inference_attribute);
        formatter.field("probability_attribute", &self.probability_attribute);
        formatter.field(
            "probability_threshold_attribute",
            &self.probability_threshold_attribute,
        );
        formatter.field("start_time_offset", &self.start_time_offset);
        formatter.field("end_time_offset", &self.end_time_offset);
        formatter.finish()
    }
}
/// See [`EndpointInput`](crate::model::EndpointInput)
pub mod endpoint_input {
    /// A builder for [`EndpointInput`](crate::model::EndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
        pub(crate) s3_data_distribution_type:
            std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        pub(crate) features_attribute: std::option::Option<std::string::String>,
        pub(crate) inference_attribute: std::option::Option<std::string::String>,
        pub(crate) probability_attribute: std::option::Option<std::string::String>,
        pub(crate) probability_threshold_attribute: std::option::Option<f64>,
        pub(crate) start_time_offset: std::option::Option<std::string::String>,
        pub(crate) end_time_offset: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An endpoint in customer's account which has enabled <code>DataCaptureConfig</code>
        /// enabled.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Path to the filesystem where the endpoint data is available to the container.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether the <code>Pipe</code> or <code>File</code> is used as the input mode for
        /// transfering data for the monitoring job. <code>Pipe</code> mode is recommended for large
        /// datasets. <code>File</code> mode is useful for small files that fit in memory. Defaults to
        /// <code>File</code>.</p>
        pub fn s3_input_mode(mut self, input: crate::model::ProcessingS3InputMode) -> Self {
            self.s3_input_mode = Some(input);
            self
        }
        pub fn set_s3_input_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3InputMode>,
        ) -> Self {
            self.s3_input_mode = input;
            self
        }
        /// <p>Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key.
        /// Defaults to <code>FullyReplicated</code>
        /// </p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::ProcessingS3DataDistributionType,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        /// <p>The attributes of the input data that are the input features.</p>
        pub fn features_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.features_attribute = Some(input.into());
            self
        }
        pub fn set_features_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.features_attribute = input;
            self
        }
        /// <p>The attribute of the input data that represents the ground truth label.</p>
        pub fn inference_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.inference_attribute = Some(input.into());
            self
        }
        pub fn set_inference_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inference_attribute = input;
            self
        }
        /// <p>In a classification problem, the attribute that represents the class probability.</p>
        pub fn probability_attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.probability_attribute = Some(input.into());
            self
        }
        pub fn set_probability_attribute(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.probability_attribute = input;
            self
        }
        /// <p>The threshold for the class probability to be evaluated as a positive result.</p>
        pub fn probability_threshold_attribute(mut self, input: f64) -> Self {
            self.probability_threshold_attribute = Some(input);
            self
        }
        pub fn set_probability_threshold_attribute(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.probability_threshold_attribute = input;
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the start time. For information
        /// about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model
        /// Quality Monitoring Jobs</a>.</p>
        pub fn start_time_offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time_offset = Some(input.into());
            self
        }
        pub fn set_start_time_offset(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_time_offset = input;
            self
        }
        /// <p>If specified, monitoring jobs substract this time from the end time. For information
        /// about using offsets for scheduling monitoring jobs, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor-model-quality-schedule.html">Schedule Model
        /// Quality Monitoring Jobs</a>.</p>
        pub fn end_time_offset(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_time_offset = Some(input.into());
            self
        }
        pub fn set_end_time_offset(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_time_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointInput`](crate::model::EndpointInput)
        pub fn build(self) -> crate::model::EndpointInput {
            crate::model::EndpointInput {
                endpoint_name: self.endpoint_name,
                local_path: self.local_path,
                s3_input_mode: self.s3_input_mode,
                s3_data_distribution_type: self.s3_data_distribution_type,
                features_attribute: self.features_attribute,
                inference_attribute: self.inference_attribute,
                probability_attribute: self.probability_attribute,
                probability_threshold_attribute: self.probability_threshold_attribute,
                start_time_offset: self.start_time_offset,
                end_time_offset: self.end_time_offset,
            }
        }
    }
}
impl EndpointInput {
    /// Creates a new builder-style object to manufacture [`EndpointInput`](crate::model::EndpointInput)
    pub fn builder() -> crate::model::endpoint_input::Builder {
        crate::model::endpoint_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3DataDistributionType {
    Fullyreplicated,
    Shardedbys3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3DataDistributionType {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => ProcessingS3DataDistributionType::Fullyreplicated,
            "ShardedByS3Key" => ProcessingS3DataDistributionType::Shardedbys3Key,
            other => ProcessingS3DataDistributionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3DataDistributionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3DataDistributionType::from(s))
    }
}
impl ProcessingS3DataDistributionType {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3DataDistributionType::Fullyreplicated => "FullyReplicated",
            ProcessingS3DataDistributionType::Shardedbys3Key => "ShardedByS3Key",
            ProcessingS3DataDistributionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for ProcessingS3DataDistributionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3InputMode {
    File,
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3InputMode {
    fn from(s: &str) -> Self {
        match s {
            "File" => ProcessingS3InputMode::File,
            "Pipe" => ProcessingS3InputMode::Pipe,
            other => ProcessingS3InputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3InputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3InputMode::from(s))
    }
}
impl ProcessingS3InputMode {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3InputMode::File => "File",
            ProcessingS3InputMode::Pipe => "Pipe",
            ProcessingS3InputMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["File", "Pipe"]
    }
}
impl AsRef<str> for ProcessingS3InputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline
/// resources are compared against the results of the current job from the series of jobs
/// scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should
    /// validated against.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
    /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be
    /// validated against.</p>
    pub statistics_resource: std::option::Option<crate::model::MonitoringStatisticsResource>,
}
impl std::fmt::Debug for MonitoringBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.field("statistics_resource", &self.statistics_resource);
        formatter.finish()
    }
}
/// See [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
pub mod monitoring_baseline_config {
    /// A builder for [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
        pub(crate) statistics_resource:
            std::option::Option<crate::model::MonitoringStatisticsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The baseline constraint file in Amazon S3 that the current monitoring job should
        /// validated against.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// <p>The baseline statistics file in Amazon S3 that the current monitoring job should be
        /// validated against.</p>
        pub fn statistics_resource(
            mut self,
            input: crate::model::MonitoringStatisticsResource,
        ) -> Self {
            self.statistics_resource = Some(input);
            self
        }
        pub fn set_statistics_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringStatisticsResource>,
        ) -> Self {
            self.statistics_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
        pub fn build(self) -> crate::model::MonitoringBaselineConfig {
            crate::model::MonitoringBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
                statistics_resource: self.statistics_resource,
            }
        }
    }
}
impl MonitoringBaselineConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringBaselineConfig`](crate::model::MonitoringBaselineConfig)
    pub fn builder() -> crate::model::monitoring_baseline_config::Builder {
        crate::model::monitoring_baseline_config::Builder::default()
    }
}

/// <p>The statistics resource for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringStatisticsResource {
    /// <p>The Amazon S3 URI for the statistics resource.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringStatisticsResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringStatisticsResource");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
pub mod monitoring_statistics_resource {
    /// A builder for [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 URI for the statistics resource.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
        pub fn build(self) -> crate::model::MonitoringStatisticsResource {
            crate::model::MonitoringStatisticsResource {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringStatisticsResource {
    /// Creates a new builder-style object to manufacture [`MonitoringStatisticsResource`](crate::model::MonitoringStatisticsResource)
    pub fn builder() -> crate::model::monitoring_statistics_resource::Builder {
        crate::model::monitoring_statistics_resource::Builder::default()
    }
}

/// <p>The constraints resource for a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConstraintsResource {
    /// <p>The Amazon S3 URI for the constraints resource.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringConstraintsResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConstraintsResource");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
pub mod monitoring_constraints_resource {
    /// A builder for [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 URI for the constraints resource.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
        pub fn build(self) -> crate::model::MonitoringConstraintsResource {
            crate::model::MonitoringConstraintsResource {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringConstraintsResource {
    /// Creates a new builder-style object to manufacture [`MonitoringConstraintsResource`](crate::model::MonitoringConstraintsResource)
    pub fn builder() -> crate::model::monitoring_constraints_resource::Builder {
        crate::model::monitoring_constraints_resource::Builder::default()
    }
}

/// <p>Configuration details about the monitoring schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduleConfig {
    /// <p>A cron expression that describes details about the monitoring schedule.</p>
    /// <p>Currently the only supported cron expressions are:</p>
    /// <ul>
    /// <li>
    /// <p>If you want to set the job to start every hour, please use the following:</p>
    /// <p>
    /// <code>Hourly: cron(0 * ? * * *)</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If you want to start the job daily:</p>
    /// <p>
    /// <code>cron(0 [00-23] ? * * *)</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li>
    /// <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>To support running every 6, 12 hours, the following are also supported:</p>
    /// <p>
    /// <code>cron(0 [00-23]/[01-24] ? * * *)</code>
    /// </p>
    /// <p>For example, the following are valid cron expressions:</p>
    /// <ul>
    /// <li>
    /// <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <ul>
    /// <li>
    /// <p>Even though the cron expression is set to start at 5PM UTC, note that there
    /// could be a delay of 0-20 minutes from the actual requested time to run the
    /// execution. </p>
    /// </li>
    /// <li>
    /// <p>We recommend that if you would like a daily schedule, you do not provide this
    /// parameter. Amazon SageMaker will pick a time for running every day.</p>
    /// </li>
    /// </ul>
    /// </note>
    pub schedule_expression: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduleConfig");
        formatter.field("schedule_expression", &self.schedule_expression);
        formatter.finish()
    }
}
/// See [`ScheduleConfig`](crate::model::ScheduleConfig)
pub mod schedule_config {
    /// A builder for [`ScheduleConfig`](crate::model::ScheduleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A cron expression that describes details about the monitoring schedule.</p>
        /// <p>Currently the only supported cron expressions are:</p>
        /// <ul>
        /// <li>
        /// <p>If you want to set the job to start every hour, please use the following:</p>
        /// <p>
        /// <code>Hourly: cron(0 * ? * * *)</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If you want to start the job daily:</p>
        /// <p>
        /// <code>cron(0 [00-23] ? * * *)</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li>
        /// <p>Daily at noon UTC: <code>cron(0 12 ? * * *)</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Daily at midnight UTC: <code>cron(0 0 ? * * *)</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>To support running every 6, 12 hours, the following are also supported:</p>
        /// <p>
        /// <code>cron(0 [00-23]/[01-24] ? * * *)</code>
        /// </p>
        /// <p>For example, the following are valid cron expressions:</p>
        /// <ul>
        /// <li>
        /// <p>Every 12 hours, starting at 5pm UTC: <code>cron(0 17/12 ? * * *)</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Every two hours starting at midnight: <code>cron(0 0/2 ? * * *)</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <ul>
        /// <li>
        /// <p>Even though the cron expression is set to start at 5PM UTC, note that there
        /// could be a delay of 0-20 minutes from the actual requested time to run the
        /// execution. </p>
        /// </li>
        /// <li>
        /// <p>We recommend that if you would like a daily schedule, you do not provide this
        /// parameter. Amazon SageMaker will pick a time for running every day.</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn schedule_expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_expression = Some(input.into());
            self
        }
        pub fn set_schedule_expression(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleConfig`](crate::model::ScheduleConfig)
        pub fn build(self) -> crate::model::ScheduleConfig {
            crate::model::ScheduleConfig {
                schedule_expression: self.schedule_expression,
            }
        }
    }
}
impl ScheduleConfig {
    /// Creates a new builder-style object to manufacture [`ScheduleConfig`](crate::model::ScheduleConfig)
    pub fn builder() -> crate::model::schedule_config::Builder {
        crate::model::schedule_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelApprovalStatus {
    Approved,
    PendingManualApproval,
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelApprovalStatus {
    fn from(s: &str) -> Self {
        match s {
            "Approved" => ModelApprovalStatus::Approved,
            "PendingManualApproval" => ModelApprovalStatus::PendingManualApproval,
            "Rejected" => ModelApprovalStatus::Rejected,
            other => ModelApprovalStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelApprovalStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelApprovalStatus::from(s))
    }
}
impl ModelApprovalStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ModelApprovalStatus::Approved => "Approved",
            ModelApprovalStatus::PendingManualApproval => "PendingManualApproval",
            ModelApprovalStatus::Rejected => "Rejected",
            ModelApprovalStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Approved", "PendingManualApproval", "Rejected"]
    }
}
impl AsRef<str> for ModelApprovalStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies weight and capacity values for a production variant.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DesiredWeightAndCapacity {
    /// <p>The name of the
    /// variant
    /// to update.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>The variant's weight.</p>
    pub desired_weight: std::option::Option<f32>,
    /// <p>The variant's capacity.</p>
    pub desired_instance_count: std::option::Option<i32>,
}
impl std::fmt::Debug for DesiredWeightAndCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DesiredWeightAndCapacity");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("desired_weight", &self.desired_weight);
        formatter.field("desired_instance_count", &self.desired_instance_count);
        formatter.finish()
    }
}
/// See [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
pub mod desired_weight_and_capacity {
    /// A builder for [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) desired_weight: std::option::Option<f32>,
        pub(crate) desired_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the
        /// variant
        /// to update.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// <p>The variant's weight.</p>
        pub fn desired_weight(mut self, input: f32) -> Self {
            self.desired_weight = Some(input);
            self
        }
        pub fn set_desired_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.desired_weight = input;
            self
        }
        /// <p>The variant's capacity.</p>
        pub fn desired_instance_count(mut self, input: i32) -> Self {
            self.desired_instance_count = Some(input);
            self
        }
        pub fn set_desired_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
        pub fn build(self) -> crate::model::DesiredWeightAndCapacity {
            crate::model::DesiredWeightAndCapacity {
                variant_name: self.variant_name,
                desired_weight: self.desired_weight,
                desired_instance_count: self.desired_instance_count,
            }
        }
    }
}
impl DesiredWeightAndCapacity {
    /// Creates a new builder-style object to manufacture [`DesiredWeightAndCapacity`](crate::model::DesiredWeightAndCapacity)
    pub fn builder() -> crate::model::desired_weight_and_capacity::Builder {
        crate::model::desired_weight_and_capacity::Builder::default()
    }
}

/// <p>Currently, the <code>DeploymentConfig</code> API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentConfig {
    /// <p></p>
    pub blue_green_update_policy: std::option::Option<crate::model::BlueGreenUpdatePolicy>,
    /// <p></p>
    pub auto_rollback_configuration: std::option::Option<crate::model::AutoRollbackConfig>,
}
impl std::fmt::Debug for DeploymentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentConfig");
        formatter.field("blue_green_update_policy", &self.blue_green_update_policy);
        formatter.field(
            "auto_rollback_configuration",
            &self.auto_rollback_configuration,
        );
        formatter.finish()
    }
}
/// See [`DeploymentConfig`](crate::model::DeploymentConfig)
pub mod deployment_config {
    /// A builder for [`DeploymentConfig`](crate::model::DeploymentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blue_green_update_policy:
            std::option::Option<crate::model::BlueGreenUpdatePolicy>,
        pub(crate) auto_rollback_configuration:
            std::option::Option<crate::model::AutoRollbackConfig>,
    }
    impl Builder {
        /// <p></p>
        pub fn blue_green_update_policy(
            mut self,
            input: crate::model::BlueGreenUpdatePolicy,
        ) -> Self {
            self.blue_green_update_policy = Some(input);
            self
        }
        pub fn set_blue_green_update_policy(
            mut self,
            input: std::option::Option<crate::model::BlueGreenUpdatePolicy>,
        ) -> Self {
            self.blue_green_update_policy = input;
            self
        }
        /// <p></p>
        pub fn auto_rollback_configuration(
            mut self,
            input: crate::model::AutoRollbackConfig,
        ) -> Self {
            self.auto_rollback_configuration = Some(input);
            self
        }
        pub fn set_auto_rollback_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoRollbackConfig>,
        ) -> Self {
            self.auto_rollback_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfig`](crate::model::DeploymentConfig)
        pub fn build(self) -> crate::model::DeploymentConfig {
            crate::model::DeploymentConfig {
                blue_green_update_policy: self.blue_green_update_policy,
                auto_rollback_configuration: self.auto_rollback_configuration,
            }
        }
    }
}
impl DeploymentConfig {
    /// Creates a new builder-style object to manufacture [`DeploymentConfig`](crate::model::DeploymentConfig)
    pub fn builder() -> crate::model::deployment_config::Builder {
        crate::model::deployment_config::Builder::default()
    }
}

/// <p>Currently, the <code>AutoRollbackConfig</code> API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoRollbackConfig {
    /// <p></p>
    pub alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
}
impl std::fmt::Debug for AutoRollbackConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoRollbackConfig");
        formatter.field("alarms", &self.alarms);
        formatter.finish()
    }
}
/// See [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
pub mod auto_rollback_config {
    /// A builder for [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
    }
    impl Builder {
        pub fn alarms(mut self, input: impl Into<crate::model::Alarm>) -> Self {
            let mut v = self.alarms.unwrap_or_default();
            v.push(input.into());
            self.alarms = Some(v);
            self
        }
        pub fn set_alarms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
        ) -> Self {
            self.alarms = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
        pub fn build(self) -> crate::model::AutoRollbackConfig {
            crate::model::AutoRollbackConfig {
                alarms: self.alarms,
            }
        }
    }
}
impl AutoRollbackConfig {
    /// Creates a new builder-style object to manufacture [`AutoRollbackConfig`](crate::model::AutoRollbackConfig)
    pub fn builder() -> crate::model::auto_rollback_config::Builder {
        crate::model::auto_rollback_config::Builder::default()
    }
}

/// <p>This API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Alarm {
    /// <p></p>
    pub alarm_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Alarm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Alarm");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.finish()
    }
}
/// See [`Alarm`](crate::model::Alarm)
pub mod alarm {
    /// A builder for [`Alarm`](crate::model::Alarm)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Alarm`](crate::model::Alarm)
        pub fn build(self) -> crate::model::Alarm {
            crate::model::Alarm {
                alarm_name: self.alarm_name,
            }
        }
    }
}
impl Alarm {
    /// Creates a new builder-style object to manufacture [`Alarm`](crate::model::Alarm)
    pub fn builder() -> crate::model::alarm::Builder {
        crate::model::alarm::Builder::default()
    }
}

/// <p>Currently, the <code>BlueGreenUpdatePolicy</code> API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlueGreenUpdatePolicy {
    /// <p></p>
    pub traffic_routing_configuration: std::option::Option<crate::model::TrafficRoutingConfig>,
    /// <p></p>
    pub termination_wait_in_seconds: std::option::Option<i32>,
    /// <p></p>
    pub maximum_execution_timeout_in_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for BlueGreenUpdatePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlueGreenUpdatePolicy");
        formatter.field(
            "traffic_routing_configuration",
            &self.traffic_routing_configuration,
        );
        formatter.field(
            "termination_wait_in_seconds",
            &self.termination_wait_in_seconds,
        );
        formatter.field(
            "maximum_execution_timeout_in_seconds",
            &self.maximum_execution_timeout_in_seconds,
        );
        formatter.finish()
    }
}
/// See [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
pub mod blue_green_update_policy {
    /// A builder for [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) traffic_routing_configuration:
            std::option::Option<crate::model::TrafficRoutingConfig>,
        pub(crate) termination_wait_in_seconds: std::option::Option<i32>,
        pub(crate) maximum_execution_timeout_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p></p>
        pub fn traffic_routing_configuration(
            mut self,
            input: crate::model::TrafficRoutingConfig,
        ) -> Self {
            self.traffic_routing_configuration = Some(input);
            self
        }
        pub fn set_traffic_routing_configuration(
            mut self,
            input: std::option::Option<crate::model::TrafficRoutingConfig>,
        ) -> Self {
            self.traffic_routing_configuration = input;
            self
        }
        /// <p></p>
        pub fn termination_wait_in_seconds(mut self, input: i32) -> Self {
            self.termination_wait_in_seconds = Some(input);
            self
        }
        pub fn set_termination_wait_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.termination_wait_in_seconds = input;
            self
        }
        /// <p></p>
        pub fn maximum_execution_timeout_in_seconds(mut self, input: i32) -> Self {
            self.maximum_execution_timeout_in_seconds = Some(input);
            self
        }
        pub fn set_maximum_execution_timeout_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.maximum_execution_timeout_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
        pub fn build(self) -> crate::model::BlueGreenUpdatePolicy {
            crate::model::BlueGreenUpdatePolicy {
                traffic_routing_configuration: self.traffic_routing_configuration,
                termination_wait_in_seconds: self.termination_wait_in_seconds,
                maximum_execution_timeout_in_seconds: self.maximum_execution_timeout_in_seconds,
            }
        }
    }
}
impl BlueGreenUpdatePolicy {
    /// Creates a new builder-style object to manufacture [`BlueGreenUpdatePolicy`](crate::model::BlueGreenUpdatePolicy)
    pub fn builder() -> crate::model::blue_green_update_policy::Builder {
        crate::model::blue_green_update_policy::Builder::default()
    }
}

/// <p>Currently, the <code>TrafficRoutingConfig</code> API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrafficRoutingConfig {
    /// <p></p>
    pub r#type: std::option::Option<crate::model::TrafficRoutingConfigType>,
    /// <p></p>
    pub wait_interval_in_seconds: std::option::Option<i32>,
    /// <p></p>
    pub canary_size: std::option::Option<crate::model::CapacitySize>,
}
impl std::fmt::Debug for TrafficRoutingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrafficRoutingConfig");
        formatter.field("r#type", &self.r#type);
        formatter.field("wait_interval_in_seconds", &self.wait_interval_in_seconds);
        formatter.field("canary_size", &self.canary_size);
        formatter.finish()
    }
}
/// See [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
pub mod traffic_routing_config {
    /// A builder for [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::TrafficRoutingConfigType>,
        pub(crate) wait_interval_in_seconds: std::option::Option<i32>,
        pub(crate) canary_size: std::option::Option<crate::model::CapacitySize>,
    }
    impl Builder {
        /// <p></p>
        pub fn r#type(mut self, input: crate::model::TrafficRoutingConfigType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TrafficRoutingConfigType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn wait_interval_in_seconds(mut self, input: i32) -> Self {
            self.wait_interval_in_seconds = Some(input);
            self
        }
        pub fn set_wait_interval_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.wait_interval_in_seconds = input;
            self
        }
        /// <p></p>
        pub fn canary_size(mut self, input: crate::model::CapacitySize) -> Self {
            self.canary_size = Some(input);
            self
        }
        pub fn set_canary_size(
            mut self,
            input: std::option::Option<crate::model::CapacitySize>,
        ) -> Self {
            self.canary_size = input;
            self
        }
        /// Consumes the builder and constructs a [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
        pub fn build(self) -> crate::model::TrafficRoutingConfig {
            crate::model::TrafficRoutingConfig {
                r#type: self.r#type,
                wait_interval_in_seconds: self.wait_interval_in_seconds,
                canary_size: self.canary_size,
            }
        }
    }
}
impl TrafficRoutingConfig {
    /// Creates a new builder-style object to manufacture [`TrafficRoutingConfig`](crate::model::TrafficRoutingConfig)
    pub fn builder() -> crate::model::traffic_routing_config::Builder {
        crate::model::traffic_routing_config::Builder::default()
    }
}

/// <p>Currently, the <code>CapacitySize</code> API is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacitySize {
    /// <p>This API is not supported.</p>
    pub r#type: std::option::Option<crate::model::CapacitySizeType>,
    /// <p></p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for CapacitySize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacitySize");
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`CapacitySize`](crate::model::CapacitySize)
pub mod capacity_size {
    /// A builder for [`CapacitySize`](crate::model::CapacitySize)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::CapacitySizeType>,
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>This API is not supported.</p>
        pub fn r#type(mut self, input: crate::model::CapacitySizeType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CapacitySizeType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p></p>
        pub fn value(mut self, input: i32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<i32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacitySize`](crate::model::CapacitySize)
        pub fn build(self) -> crate::model::CapacitySize {
            crate::model::CapacitySize {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl CapacitySize {
    /// Creates a new builder-style object to manufacture [`CapacitySize`](crate::model::CapacitySize)
    pub fn builder() -> crate::model::capacity_size::Builder {
        crate::model::capacity_size::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CapacitySizeType {
    CapacityPercent,
    InstanceCount,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CapacitySizeType {
    fn from(s: &str) -> Self {
        match s {
            "CAPACITY_PERCENT" => CapacitySizeType::CapacityPercent,
            "INSTANCE_COUNT" => CapacitySizeType::InstanceCount,
            other => CapacitySizeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CapacitySizeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CapacitySizeType::from(s))
    }
}
impl CapacitySizeType {
    pub fn as_str(&self) -> &str {
        match self {
            CapacitySizeType::CapacityPercent => "CAPACITY_PERCENT",
            CapacitySizeType::InstanceCount => "INSTANCE_COUNT",
            CapacitySizeType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CAPACITY_PERCENT", "INSTANCE_COUNT"]
    }
}
impl AsRef<str> for CapacitySizeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrafficRoutingConfigType {
    AllAtOnce,
    Canary,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrafficRoutingConfigType {
    fn from(s: &str) -> Self {
        match s {
            "ALL_AT_ONCE" => TrafficRoutingConfigType::AllAtOnce,
            "CANARY" => TrafficRoutingConfigType::Canary,
            other => TrafficRoutingConfigType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrafficRoutingConfigType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrafficRoutingConfigType::from(s))
    }
}
impl TrafficRoutingConfigType {
    pub fn as_str(&self) -> &str {
        match self {
            TrafficRoutingConfigType::AllAtOnce => "ALL_AT_ONCE",
            TrafficRoutingConfigType::Canary => "CANARY",
            TrafficRoutingConfigType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ALL_AT_ONCE", "CANARY"]
    }
}
impl AsRef<str> for TrafficRoutingConfigType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a production variant property type for an Endpoint.</p>
/// <p>If you are updating an endpoint with the <a>UpdateEndpointInput$RetainAllVariantProperties</a> option set to
/// <code>true</code>, the <code>VariantProperty</code> objects listed in <a>UpdateEndpointInput$ExcludeRetainedVariantProperties</a> override the
/// existing variant properties of the endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VariantProperty {
    /// <p>The type of variant property. The supported values are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DesiredInstanceCount</code>: Overrides the existing variant instance
    /// counts using the <a>ProductionVariant$InitialInstanceCount</a> values
    /// in the <a>CreateEndpointConfigInput$ProductionVariants</a>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DesiredWeight</code>: Overrides the existing variant weights using the
    /// <a>ProductionVariant$InitialVariantWeight</a> values in the <a>CreateEndpointConfigInput$ProductionVariants</a>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DataCaptureConfig</code>: (Not currently supported.)</p>
    /// </li>
    /// </ul>
    pub variant_property_type: std::option::Option<crate::model::VariantPropertyType>,
}
impl std::fmt::Debug for VariantProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VariantProperty");
        formatter.field("variant_property_type", &self.variant_property_type);
        formatter.finish()
    }
}
/// See [`VariantProperty`](crate::model::VariantProperty)
pub mod variant_property {
    /// A builder for [`VariantProperty`](crate::model::VariantProperty)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_property_type: std::option::Option<crate::model::VariantPropertyType>,
    }
    impl Builder {
        /// <p>The type of variant property. The supported values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DesiredInstanceCount</code>: Overrides the existing variant instance
        /// counts using the <a>ProductionVariant$InitialInstanceCount</a> values
        /// in the <a>CreateEndpointConfigInput$ProductionVariants</a>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DesiredWeight</code>: Overrides the existing variant weights using the
        /// <a>ProductionVariant$InitialVariantWeight</a> values in the <a>CreateEndpointConfigInput$ProductionVariants</a>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DataCaptureConfig</code>: (Not currently supported.)</p>
        /// </li>
        /// </ul>
        pub fn variant_property_type(mut self, input: crate::model::VariantPropertyType) -> Self {
            self.variant_property_type = Some(input);
            self
        }
        pub fn set_variant_property_type(
            mut self,
            input: std::option::Option<crate::model::VariantPropertyType>,
        ) -> Self {
            self.variant_property_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VariantProperty`](crate::model::VariantProperty)
        pub fn build(self) -> crate::model::VariantProperty {
            crate::model::VariantProperty {
                variant_property_type: self.variant_property_type,
            }
        }
    }
}
impl VariantProperty {
    /// Creates a new builder-style object to manufacture [`VariantProperty`](crate::model::VariantProperty)
    pub fn builder() -> crate::model::variant_property::Builder {
        crate::model::variant_property::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VariantPropertyType {
    DataCaptureConfig,
    DesiredInstanceCount,
    DesiredWeight,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for VariantPropertyType {
    fn from(s: &str) -> Self {
        match s {
            "DataCaptureConfig" => VariantPropertyType::DataCaptureConfig,
            "DesiredInstanceCount" => VariantPropertyType::DesiredInstanceCount,
            "DesiredWeight" => VariantPropertyType::DesiredWeight,
            other => VariantPropertyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for VariantPropertyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VariantPropertyType::from(s))
    }
}
impl VariantPropertyType {
    pub fn as_str(&self) -> &str {
        match self {
            VariantPropertyType::DataCaptureConfig => "DataCaptureConfig",
            VariantPropertyType::DesiredInstanceCount => "DesiredInstanceCount",
            VariantPropertyType::DesiredWeight => "DesiredWeight",
            VariantPropertyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DataCaptureConfig", "DesiredInstanceCount", "DesiredWeight"]
    }
}
impl AsRef<str> for VariantPropertyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information of a particular device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Device {
    /// <p>The name of the device.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Description of the device.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
    pub iot_thing_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Device {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Device");
        formatter.field("device_name", &self.device_name);
        formatter.field("description", &self.description);
        formatter.field("iot_thing_name", &self.iot_thing_name);
        formatter.finish()
    }
}
/// See [`Device`](crate::model::Device)
pub mod device {
    /// A builder for [`Device`](crate::model::Device)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) iot_thing_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Description of the device.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Amazon Web Services Internet of Things (IoT) object name.</p>
        pub fn iot_thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.iot_thing_name = Some(input.into());
            self
        }
        pub fn set_iot_thing_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iot_thing_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Device`](crate::model::Device)
        pub fn build(self) -> crate::model::Device {
            crate::model::Device {
                device_name: self.device_name,
                description: self.description,
                iot_thing_name: self.iot_thing_name,
            }
        }
    }
}
impl Device {
    /// Creates a new builder-style object to manufacture [`Device`](crate::model::Device)
    pub fn builder() -> crate::model::device::Builder {
        crate::model::device::Builder::default()
    }
}

/// <p>The output configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeOutputConfig {
    /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
    pub s3_output_location: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job.
    /// If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The deployment type SageMaker Edge Manager will create.
    /// Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub preset_deployment_type: std::option::Option<crate::model::EdgePresetDeploymentType>,
    /// <p>The configuration used to create deployment artifacts.
    /// Specify configuration options with a JSON string. The available configuration options for each type are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified,
    /// the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager
    /// packaging job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ComponentDescription</code> (optional) - Description of the component.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ComponentVersion</code> (optional) - The version of the component.</p>
    /// <note>
    /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i>
    /// major.minor.patch</i> number system. For example, version 1.0.0 represents the first
    /// major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PlatformOS</code> (optional) - The name of the operating system for the platform.
    /// Supported platforms include Windows and Linux.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p>
    /// <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p>
    /// <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p>
    /// </li>
    /// </ul>
    pub preset_deployment_config: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EdgeOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeOutputConfig");
        formatter.field("s3_output_location", &self.s3_output_location);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("preset_deployment_type", &self.preset_deployment_type);
        formatter.field("preset_deployment_config", &self.preset_deployment_config);
        formatter.finish()
    }
}
/// See [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
pub mod edge_output_config {
    /// A builder for [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_location: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) preset_deployment_type:
            std::option::Option<crate::model::EdgePresetDeploymentType>,
        pub(crate) preset_deployment_config: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage (S3) bucker URI.</p>
        pub fn s3_output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_location = Some(input.into());
            self
        }
        pub fn set_s3_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_location = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume after compilation job.
        /// If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The deployment type SageMaker Edge Manager will create.
        /// Currently only supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn preset_deployment_type(
            mut self,
            input: crate::model::EdgePresetDeploymentType,
        ) -> Self {
            self.preset_deployment_type = Some(input);
            self
        }
        pub fn set_preset_deployment_type(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentType>,
        ) -> Self {
            self.preset_deployment_type = input;
            self
        }
        /// <p>The configuration used to create deployment artifacts.
        /// Specify configuration options with a JSON string. The available configuration options for each type are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ComponentName</code> (optional) - Name of the GreenGrass V2 component. If not specified,
        /// the default name generated consists of "SagemakerEdgeManager" and the name of your SageMaker Edge Manager
        /// packaging job.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ComponentDescription</code> (optional) - Description of the component.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ComponentVersion</code> (optional) - The version of the component.</p>
        /// <note>
        /// <p>Amazon Web Services IoT Greengrass uses semantic versions for components. Semantic versions follow a<i>
        /// major.minor.patch</i> number system. For example, version 1.0.0 represents the first
        /// major release for a component. For more information, see the <a href="https://semver.org/">semantic version specification</a>.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PlatformOS</code> (optional) - The name of the operating system for the platform.
        /// Supported platforms include Windows and Linux.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PlatformArchitecture</code> (optional) - The processor architecture for the platform. </p>
        /// <p>Supported architectures Windows include: Windows32_x86, Windows64_x64.</p>
        /// <p>Supported architectures for Linux include: Linux x86_64, Linux ARMV8.</p>
        /// </li>
        /// </ul>
        pub fn preset_deployment_config(mut self, input: impl Into<std::string::String>) -> Self {
            self.preset_deployment_config = Some(input.into());
            self
        }
        pub fn set_preset_deployment_config(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preset_deployment_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
        pub fn build(self) -> crate::model::EdgeOutputConfig {
            crate::model::EdgeOutputConfig {
                s3_output_location: self.s3_output_location,
                kms_key_id: self.kms_key_id,
                preset_deployment_type: self.preset_deployment_type,
                preset_deployment_config: self.preset_deployment_config,
            }
        }
    }
}
impl EdgeOutputConfig {
    /// Creates a new builder-style object to manufacture [`EdgeOutputConfig`](crate::model::EdgeOutputConfig)
    pub fn builder() -> crate::model::edge_output_config::Builder {
        crate::model::edge_output_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePresetDeploymentType {
    GreengrassV2Component,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePresetDeploymentType {
    fn from(s: &str) -> Self {
        match s {
            "GreengrassV2Component" => EdgePresetDeploymentType::GreengrassV2Component,
            other => EdgePresetDeploymentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePresetDeploymentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePresetDeploymentType::from(s))
    }
}
impl EdgePresetDeploymentType {
    pub fn as_str(&self) -> &str {
        match self {
            EdgePresetDeploymentType::GreengrassV2Component => "GreengrassV2Component",
            EdgePresetDeploymentType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["GreengrassV2Component"]
    }
}
impl AsRef<str> for EdgePresetDeploymentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies configuration details for a Git repository when the repository is
/// updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GitConfigForUpdate {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the
    /// credentials used to access the git repository. The secret must have a staging label of
    /// <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p>
    /// <code>{"username": <i>UserName</i>, "password":
    /// <i>Password</i>}</code>
    /// </p>
    pub secret_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GitConfigForUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GitConfigForUpdate");
        formatter.field("secret_arn", &self.secret_arn);
        formatter.finish()
    }
}
/// See [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
pub mod git_config_for_update {
    /// A builder for [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the
        /// credentials used to access the git repository. The secret must have a staging label of
        /// <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p>
        /// <code>{"username": <i>UserName</i>, "password":
        /// <i>Password</i>}</code>
        /// </p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
        pub fn build(self) -> crate::model::GitConfigForUpdate {
            crate::model::GitConfigForUpdate {
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl GitConfigForUpdate {
    /// Creates a new builder-style object to manufacture [`GitConfigForUpdate`](crate::model::GitConfigForUpdate)
    pub fn builder() -> crate::model::git_config_for_update::Builder {
        crate::model::git_config_for_update::Builder::default()
    }
}

/// <p>The configuration for the file system and kernels in a SageMaker image running as a
/// KernelGateway app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelGatewayImageConfig {
    /// <p>The specification of the Jupyter kernels in the image.</p>
    pub kernel_specs: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
    /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
    pub file_system_config: std::option::Option<crate::model::FileSystemConfig>,
}
impl std::fmt::Debug for KernelGatewayImageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelGatewayImageConfig");
        formatter.field("kernel_specs", &self.kernel_specs);
        formatter.field("file_system_config", &self.file_system_config);
        formatter.finish()
    }
}
/// See [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
pub mod kernel_gateway_image_config {
    /// A builder for [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kernel_specs: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
        pub(crate) file_system_config: std::option::Option<crate::model::FileSystemConfig>,
    }
    impl Builder {
        pub fn kernel_specs(mut self, input: impl Into<crate::model::KernelSpec>) -> Self {
            let mut v = self.kernel_specs.unwrap_or_default();
            v.push(input.into());
            self.kernel_specs = Some(v);
            self
        }
        pub fn set_kernel_specs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KernelSpec>>,
        ) -> Self {
            self.kernel_specs = input;
            self
        }
        /// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
        pub fn file_system_config(mut self, input: crate::model::FileSystemConfig) -> Self {
            self.file_system_config = Some(input);
            self
        }
        pub fn set_file_system_config(
            mut self,
            input: std::option::Option<crate::model::FileSystemConfig>,
        ) -> Self {
            self.file_system_config = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
        pub fn build(self) -> crate::model::KernelGatewayImageConfig {
            crate::model::KernelGatewayImageConfig {
                kernel_specs: self.kernel_specs,
                file_system_config: self.file_system_config,
            }
        }
    }
}
impl KernelGatewayImageConfig {
    /// Creates a new builder-style object to manufacture [`KernelGatewayImageConfig`](crate::model::KernelGatewayImageConfig)
    pub fn builder() -> crate::model::kernel_gateway_image_config::Builder {
        crate::model::kernel_gateway_image_config::Builder::default()
    }
}

/// <p>The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemConfig {
    /// <p>The path within the image to mount the user's EFS home directory. The directory
    /// should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
    pub mount_path: std::option::Option<std::string::String>,
    /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
    pub default_uid: std::option::Option<i32>,
    /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
    pub default_gid: std::option::Option<i32>,
}
impl std::fmt::Debug for FileSystemConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemConfig");
        formatter.field("mount_path", &self.mount_path);
        formatter.field("default_uid", &self.default_uid);
        formatter.field("default_gid", &self.default_gid);
        formatter.finish()
    }
}
/// See [`FileSystemConfig`](crate::model::FileSystemConfig)
pub mod file_system_config {
    /// A builder for [`FileSystemConfig`](crate::model::FileSystemConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mount_path: std::option::Option<std::string::String>,
        pub(crate) default_uid: std::option::Option<i32>,
        pub(crate) default_gid: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The path within the image to mount the user's EFS home directory. The directory
        /// should be empty. If not specified, defaults to <i>/home/sagemaker-user</i>.</p>
        pub fn mount_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_path = Some(input.into());
            self
        }
        pub fn set_mount_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_path = input;
            self
        }
        /// <p>The default POSIX user ID (UID). If not specified, defaults to <code>1000</code>.</p>
        pub fn default_uid(mut self, input: i32) -> Self {
            self.default_uid = Some(input);
            self
        }
        pub fn set_default_uid(mut self, input: std::option::Option<i32>) -> Self {
            self.default_uid = input;
            self
        }
        /// <p>The default POSIX group ID (GID). If not specified, defaults to <code>100</code>.</p>
        pub fn default_gid(mut self, input: i32) -> Self {
            self.default_gid = Some(input);
            self
        }
        pub fn set_default_gid(mut self, input: std::option::Option<i32>) -> Self {
            self.default_gid = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemConfig`](crate::model::FileSystemConfig)
        pub fn build(self) -> crate::model::FileSystemConfig {
            crate::model::FileSystemConfig {
                mount_path: self.mount_path,
                default_uid: self.default_uid,
                default_gid: self.default_gid,
            }
        }
    }
}
impl FileSystemConfig {
    /// Creates a new builder-style object to manufacture [`FileSystemConfig`](crate::model::FileSystemConfig)
    pub fn builder() -> crate::model::file_system_config::Builder {
        crate::model::file_system_config::Builder::default()
    }
}

/// <p>The specification of a Jupyter kernel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KernelSpec {
    /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The display name of the kernel.</p>
    pub display_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KernelSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KernelSpec");
        formatter.field("name", &self.name);
        formatter.field("display_name", &self.display_name);
        formatter.finish()
    }
}
/// See [`KernelSpec`](crate::model::KernelSpec)
pub mod kernel_spec {
    /// A builder for [`KernelSpec`](crate::model::KernelSpec)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Jupyter kernel in the image. This value is case sensitive.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The display name of the kernel.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`KernelSpec`](crate::model::KernelSpec)
        pub fn build(self) -> crate::model::KernelSpec {
            crate::model::KernelSpec {
                name: self.name,
                display_name: self.display_name,
            }
        }
    }
}
impl KernelSpec {
    /// Creates a new builder-style object to manufacture [`KernelSpec`](crate::model::KernelSpec)
    pub fn builder() -> crate::model::kernel_spec::Builder {
        crate::model::kernel_spec::Builder::default()
    }
}

/// **NOTE:** `ActionStatus::Unknown` has been renamed to `::UnknownValue`.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// **NOTE:** `::Unknown` has been renamed to `::UnknownValue`.
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ActionStatus::Completed,
            "Failed" => ActionStatus::Failed,
            "InProgress" => ActionStatus::InProgress,
            "Stopped" => ActionStatus::Stopped,
            "Stopping" => ActionStatus::Stopping,
            "Unknown" => ActionStatus::UnknownValue,
            other => ActionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionStatus::from(s))
    }
}
impl ActionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ActionStatus::Completed => "Completed",
            ActionStatus::Failed => "Failed",
            ActionStatus::InProgress => "InProgress",
            ActionStatus::Stopped => "Stopped",
            ActionStatus::Stopping => "Stopping",
            ActionStatus::UnknownValue => "Unknown",
            ActionStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Failed",
            "InProgress",
            "Stopped",
            "Stopping",
            "Unknown",
        ]
    }
}
impl AsRef<str> for ActionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Assigns a value to a named Pipeline parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parameter {
    /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The literal value for the parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Parameter`](crate::model::Parameter)
pub mod parameter {
    /// A builder for [`Parameter`](crate::model::Parameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter to assign a value to. This parameter name must match a named parameter in the pipeline definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The literal value for the parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter)
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter)
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

/// <p>An output parameter of a pipeline step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputParameter {
    /// <p>The name of the output parameter.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the output parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OutputParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputParameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`OutputParameter`](crate::model::OutputParameter)
pub mod output_parameter {
    /// A builder for [`OutputParameter`](crate::model::OutputParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the output parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the output parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputParameter`](crate::model::OutputParameter)
        pub fn build(self) -> crate::model::OutputParameter {
            crate::model::OutputParameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl OutputParameter {
    /// Creates a new builder-style object to manufacture [`OutputParameter`](crate::model::OutputParameter)
    pub fn builder() -> crate::model::output_parameter::Builder {
        crate::model::output_parameter::Builder::default()
    }
}

/// <p>A single resource returned as part of the <a>Search</a> API response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchRecord {
    /// <p>The properties of a training job.</p>
    pub training_job: std::option::Option<crate::model::TrainingJob>,
    /// <p>The properties of an experiment.</p>
    pub experiment: std::option::Option<crate::model::Experiment>,
    /// <p>The properties of a trial.</p>
    pub trial: std::option::Option<crate::model::Trial>,
    /// <p>The properties of a trial component.</p>
    pub trial_component: std::option::Option<crate::model::TrialComponent>,
    /// <p>A hosted endpoint for real-time inference.</p>
    pub endpoint: std::option::Option<crate::model::Endpoint>,
    /// <p>A versioned model that can be deployed for SageMaker inference.</p>
    pub model_package: std::option::Option<crate::model::ModelPackage>,
    /// <p>A group of versioned models in the model registry.</p>
    pub model_package_group: std::option::Option<crate::model::ModelPackageGroup>,
    /// <p>A SageMaker Model Building Pipeline instance.</p>
    pub pipeline: std::option::Option<crate::model::Pipeline>,
    /// <p>An execution of a pipeline.</p>
    pub pipeline_execution: std::option::Option<crate::model::PipelineExecution>,
    /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group.
    /// A Feature Group can be visualized as a table which has rows,
    /// with a unique identifier for each row where each column in the table is a feature.
    /// In principle, a Feature Group is composed of features and values per features.</p>
    pub feature_group: std::option::Option<crate::model::FeatureGroup>,
}
impl std::fmt::Debug for SearchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchRecord");
        formatter.field("training_job", &self.training_job);
        formatter.field("experiment", &self.experiment);
        formatter.field("trial", &self.trial);
        formatter.field("trial_component", &self.trial_component);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("model_package", &self.model_package);
        formatter.field("model_package_group", &self.model_package_group);
        formatter.field("pipeline", &self.pipeline);
        formatter.field("pipeline_execution", &self.pipeline_execution);
        formatter.field("feature_group", &self.feature_group);
        formatter.finish()
    }
}
/// See [`SearchRecord`](crate::model::SearchRecord)
pub mod search_record {
    /// A builder for [`SearchRecord`](crate::model::SearchRecord)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job: std::option::Option<crate::model::TrainingJob>,
        pub(crate) experiment: std::option::Option<crate::model::Experiment>,
        pub(crate) trial: std::option::Option<crate::model::Trial>,
        pub(crate) trial_component: std::option::Option<crate::model::TrialComponent>,
        pub(crate) endpoint: std::option::Option<crate::model::Endpoint>,
        pub(crate) model_package: std::option::Option<crate::model::ModelPackage>,
        pub(crate) model_package_group: std::option::Option<crate::model::ModelPackageGroup>,
        pub(crate) pipeline: std::option::Option<crate::model::Pipeline>,
        pub(crate) pipeline_execution: std::option::Option<crate::model::PipelineExecution>,
        pub(crate) feature_group: std::option::Option<crate::model::FeatureGroup>,
    }
    impl Builder {
        /// <p>The properties of a training job.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJob) -> Self {
            self.training_job = Some(input);
            self
        }
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJob>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>The properties of an experiment.</p>
        pub fn experiment(mut self, input: crate::model::Experiment) -> Self {
            self.experiment = Some(input);
            self
        }
        pub fn set_experiment(
            mut self,
            input: std::option::Option<crate::model::Experiment>,
        ) -> Self {
            self.experiment = input;
            self
        }
        /// <p>The properties of a trial.</p>
        pub fn trial(mut self, input: crate::model::Trial) -> Self {
            self.trial = Some(input);
            self
        }
        pub fn set_trial(mut self, input: std::option::Option<crate::model::Trial>) -> Self {
            self.trial = input;
            self
        }
        /// <p>The properties of a trial component.</p>
        pub fn trial_component(mut self, input: crate::model::TrialComponent) -> Self {
            self.trial_component = Some(input);
            self
        }
        pub fn set_trial_component(
            mut self,
            input: std::option::Option<crate::model::TrialComponent>,
        ) -> Self {
            self.trial_component = input;
            self
        }
        /// <p>A hosted endpoint for real-time inference.</p>
        pub fn endpoint(mut self, input: crate::model::Endpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<crate::model::Endpoint>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>A versioned model that can be deployed for SageMaker inference.</p>
        pub fn model_package(mut self, input: crate::model::ModelPackage) -> Self {
            self.model_package = Some(input);
            self
        }
        pub fn set_model_package(
            mut self,
            input: std::option::Option<crate::model::ModelPackage>,
        ) -> Self {
            self.model_package = input;
            self
        }
        /// <p>A group of versioned models in the model registry.</p>
        pub fn model_package_group(mut self, input: crate::model::ModelPackageGroup) -> Self {
            self.model_package_group = Some(input);
            self
        }
        pub fn set_model_package_group(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroup>,
        ) -> Self {
            self.model_package_group = input;
            self
        }
        /// <p>A SageMaker Model Building Pipeline instance.</p>
        pub fn pipeline(mut self, input: crate::model::Pipeline) -> Self {
            self.pipeline = Some(input);
            self
        }
        pub fn set_pipeline(mut self, input: std::option::Option<crate::model::Pipeline>) -> Self {
            self.pipeline = input;
            self
        }
        /// <p>An execution of a pipeline.</p>
        pub fn pipeline_execution(mut self, input: crate::model::PipelineExecution) -> Self {
            self.pipeline_execution = Some(input);
            self
        }
        pub fn set_pipeline_execution(
            mut self,
            input: std::option::Option<crate::model::PipelineExecution>,
        ) -> Self {
            self.pipeline_execution = input;
            self
        }
        /// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group.
        /// A Feature Group can be visualized as a table which has rows,
        /// with a unique identifier for each row where each column in the table is a feature.
        /// In principle, a Feature Group is composed of features and values per features.</p>
        pub fn feature_group(mut self, input: crate::model::FeatureGroup) -> Self {
            self.feature_group = Some(input);
            self
        }
        pub fn set_feature_group(
            mut self,
            input: std::option::Option<crate::model::FeatureGroup>,
        ) -> Self {
            self.feature_group = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchRecord`](crate::model::SearchRecord)
        pub fn build(self) -> crate::model::SearchRecord {
            crate::model::SearchRecord {
                training_job: self.training_job,
                experiment: self.experiment,
                trial: self.trial,
                trial_component: self.trial_component,
                endpoint: self.endpoint,
                model_package: self.model_package,
                model_package_group: self.model_package_group,
                pipeline: self.pipeline,
                pipeline_execution: self.pipeline_execution,
                feature_group: self.feature_group,
            }
        }
    }
}
impl SearchRecord {
    /// Creates a new builder-style object to manufacture [`SearchRecord`](crate::model::SearchRecord)
    pub fn builder() -> crate::model::search_record::Builder {
        crate::model::search_record::Builder::default()
    }
}

/// <p>Amazon SageMaker Feature Store stores features in a collection called Feature Group.
/// A Feature Group can be visualized as a table which has rows,
/// with a unique identifier for each row where each column in the table is a feature.
/// In principle, a Feature Group is composed of features and values per features.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureGroup {
    /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
    pub feature_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the <code>FeatureGroup</code>.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the <code>Feature</code> whose value uniquely identifies a
    /// <code>Record</code> defined in the <code>FeatureGroup</code>
    /// <code>FeatureDefinitions</code>.</p>
    pub record_identifier_feature_name: std::option::Option<std::string::String>,
    /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a
    /// <code>FeatureGroup</code>.</p>
    /// <p>A <code>EventTime</code> is point in time when a new event
    /// occurs that corresponds to the creation or update of a <code>Record</code> in
    /// <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code>
    /// must have a corresponding <code>EventTime</code>.</p>
    pub event_time_feature_name: std::option::Option<std::string::String>,
    /// <p>A list of <code>Feature</code>s. Each <code>Feature</code> must include a
    /// <code>FeatureName</code> and a <code>FeatureType</code>. </p>
    /// <p>Valid <code>FeatureType</code>s are <code>Integral</code>, <code>Fractional</code> and
    /// <code>String</code>. </p>
    /// <p>
    /// <code>FeatureName</code>s cannot be any of the following: <code>is_deleted</code>,
    /// <code>write_time</code>, <code>api_invocation_time</code>.</p>
    /// <p>You can create up to 2,500 <code>FeatureDefinition</code>s per
    /// <code>FeatureGroup</code>.</p>
    pub feature_definitions: std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
    /// <p>The time a <code>FeatureGroup</code> was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or
    /// <code>KMSKeyId</code>, for at rest data encryption. You can turn
    /// <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag
    /// at General Assembly; the default value is <code>False</code>.</p>
    pub online_store_config: std::option::Option<crate::model::OnlineStoreConfig>,
    /// <p>The configuration of an <code>OfflineStore</code>.</p>
    /// <p>Provide an <code>OfflineStoreConfig</code> in a request to
    /// <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
    /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key
    /// Management Service (KMS) key ID, or <code>KMSKeyId</code>, in
    /// <code>S3StorageConfig</code>.</p>
    pub offline_store_config: std::option::Option<crate::model::OfflineStoreConfig>,
    /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature
    /// group.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A <code>FeatureGroup</code> status.</p>
    pub feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>The status of <code>OfflineStore</code>.</p>
    pub offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
    /// <p>The reason that the <code>FeatureGroup</code> failed to
    /// be replicated in the <code>OfflineStore</code>. This is
    /// failure may be due to a failure to create a <code>FeatureGroup</code> in
    /// or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>A free form description of a <code>FeatureGroup</code>.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Tags used to define a <code>FeatureGroup</code>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for FeatureGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureGroup");
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field(
            "record_identifier_feature_name",
            &self.record_identifier_feature_name,
        );
        formatter.field("event_time_feature_name", &self.event_time_feature_name);
        formatter.field("feature_definitions", &self.feature_definitions);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("online_store_config", &self.online_store_config);
        formatter.field("offline_store_config", &self.offline_store_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("feature_group_status", &self.feature_group_status);
        formatter.field("offline_store_status", &self.offline_store_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`FeatureGroup`](crate::model::FeatureGroup)
pub mod feature_group {
    /// A builder for [`FeatureGroup`](crate::model::FeatureGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_arn: std::option::Option<std::string::String>,
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
        pub(crate) record_identifier_feature_name: std::option::Option<std::string::String>,
        pub(crate) event_time_feature_name: std::option::Option<std::string::String>,
        pub(crate) feature_definitions:
            std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) online_store_config: std::option::Option<crate::model::OnlineStoreConfig>,
        pub(crate) offline_store_config: std::option::Option<crate::model::OfflineStoreConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
        pub(crate) offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a <code>FeatureGroup</code>.</p>
        pub fn feature_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_arn = Some(input.into());
            self
        }
        pub fn set_feature_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_arn = input;
            self
        }
        /// <p>The name of the <code>FeatureGroup</code>.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// <p>The name of the <code>Feature</code> whose value uniquely identifies a
        /// <code>Record</code> defined in the <code>FeatureGroup</code>
        /// <code>FeatureDefinitions</code>.</p>
        pub fn record_identifier_feature_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_identifier_feature_name = Some(input.into());
            self
        }
        pub fn set_record_identifier_feature_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_identifier_feature_name = input;
            self
        }
        /// <p>The name of the feature that stores the <code>EventTime</code> of a Record in a
        /// <code>FeatureGroup</code>.</p>
        /// <p>A <code>EventTime</code> is point in time when a new event
        /// occurs that corresponds to the creation or update of a <code>Record</code> in
        /// <code>FeatureGroup</code>. All <code>Records</code> in the <code>FeatureGroup</code>
        /// must have a corresponding <code>EventTime</code>.</p>
        pub fn event_time_feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_time_feature_name = Some(input.into());
            self
        }
        pub fn set_event_time_feature_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_time_feature_name = input;
            self
        }
        pub fn feature_definitions(
            mut self,
            input: impl Into<crate::model::FeatureDefinition>,
        ) -> Self {
            let mut v = self.feature_definitions.unwrap_or_default();
            v.push(input.into());
            self.feature_definitions = Some(v);
            self
        }
        pub fn set_feature_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FeatureDefinition>>,
        ) -> Self {
            self.feature_definitions = input;
            self
        }
        /// <p>The time a <code>FeatureGroup</code> was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or
        /// <code>KMSKeyId</code>, for at rest data encryption. You can turn
        /// <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag
        /// at General Assembly; the default value is <code>False</code>.</p>
        pub fn online_store_config(mut self, input: crate::model::OnlineStoreConfig) -> Self {
            self.online_store_config = Some(input);
            self
        }
        pub fn set_online_store_config(
            mut self,
            input: std::option::Option<crate::model::OnlineStoreConfig>,
        ) -> Self {
            self.online_store_config = input;
            self
        }
        /// <p>The configuration of an <code>OfflineStore</code>.</p>
        /// <p>Provide an <code>OfflineStoreConfig</code> in a request to
        /// <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
        /// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key
        /// Management Service (KMS) key ID, or <code>KMSKeyId</code>, in
        /// <code>S3StorageConfig</code>.</p>
        pub fn offline_store_config(mut self, input: crate::model::OfflineStoreConfig) -> Self {
            self.offline_store_config = Some(input);
            self
        }
        pub fn set_offline_store_config(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreConfig>,
        ) -> Self {
            self.offline_store_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM execution role used to create the feature
        /// group.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>A <code>FeatureGroup</code> status.</p>
        pub fn feature_group_status(mut self, input: crate::model::FeatureGroupStatus) -> Self {
            self.feature_group_status = Some(input);
            self
        }
        pub fn set_feature_group_status(
            mut self,
            input: std::option::Option<crate::model::FeatureGroupStatus>,
        ) -> Self {
            self.feature_group_status = input;
            self
        }
        /// <p>The status of <code>OfflineStore</code>.</p>
        pub fn offline_store_status(mut self, input: crate::model::OfflineStoreStatus) -> Self {
            self.offline_store_status = Some(input);
            self
        }
        pub fn set_offline_store_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatus>,
        ) -> Self {
            self.offline_store_status = input;
            self
        }
        /// <p>The reason that the <code>FeatureGroup</code> failed to
        /// be replicated in the <code>OfflineStore</code>. This is
        /// failure may be due to a failure to create a <code>FeatureGroup</code> in
        /// or delete a <code>FeatureGroup</code> from the <code>OfflineStore</code>.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>A free form description of a <code>FeatureGroup</code>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureGroup`](crate::model::FeatureGroup)
        pub fn build(self) -> crate::model::FeatureGroup {
            crate::model::FeatureGroup {
                feature_group_arn: self.feature_group_arn,
                feature_group_name: self.feature_group_name,
                record_identifier_feature_name: self.record_identifier_feature_name,
                event_time_feature_name: self.event_time_feature_name,
                feature_definitions: self.feature_definitions,
                creation_time: self.creation_time,
                online_store_config: self.online_store_config,
                offline_store_config: self.offline_store_config,
                role_arn: self.role_arn,
                feature_group_status: self.feature_group_status,
                offline_store_status: self.offline_store_status,
                failure_reason: self.failure_reason,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl FeatureGroup {
    /// Creates a new builder-style object to manufacture [`FeatureGroup`](crate::model::FeatureGroup)
    pub fn builder() -> crate::model::feature_group::Builder {
        crate::model::feature_group::Builder::default()
    }
}

/// <p>A tag object that consists of a key and an optional value, used to manage metadata
/// for Amazon SageMaker Amazon Web Services resources.</p>
/// <p>You can add tags to notebook instances, training jobs, hyperparameter tuning jobs,
/// batch transform jobs, models, labeling jobs, work teams, endpoint configurations, and
/// endpoints. For more information on adding tags to Amazon SageMaker resources, see <a>AddTags</a>.</p>
/// <p>For more information on adding metadata to your Amazon Web Services resources with tagging, see
/// <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
/// resources</a>. For advice on best practices for managing Amazon Web Services resources with
/// tagging, see <a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">Tagging
/// Best Practices: Implement an Effective Amazon Web Services Resource Tagging Strategy</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The tag key. Tag keys must be unique per resource.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key. Tag keys must be unique per resource.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The status of <code>OfflineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OfflineStoreStatus {
    /// <p>An <code>OfflineStore</code> status.</p>
    pub status: std::option::Option<crate::model::OfflineStoreStatusValue>,
    /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
    pub blocked_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OfflineStoreStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OfflineStoreStatus");
        formatter.field("status", &self.status);
        formatter.field("blocked_reason", &self.blocked_reason);
        formatter.finish()
    }
}
/// See [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
pub mod offline_store_status {
    /// A builder for [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::OfflineStoreStatusValue>,
        pub(crate) blocked_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An <code>OfflineStore</code> status.</p>
        pub fn status(mut self, input: crate::model::OfflineStoreStatusValue) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatusValue>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The justification for why the OfflineStoreStatus is Blocked (if applicable).</p>
        pub fn blocked_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.blocked_reason = Some(input.into());
            self
        }
        pub fn set_blocked_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.blocked_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
        pub fn build(self) -> crate::model::OfflineStoreStatus {
            crate::model::OfflineStoreStatus {
                status: self.status,
                blocked_reason: self.blocked_reason,
            }
        }
    }
}
impl OfflineStoreStatus {
    /// Creates a new builder-style object to manufacture [`OfflineStoreStatus`](crate::model::OfflineStoreStatus)
    pub fn builder() -> crate::model::offline_store_status::Builder {
        crate::model::offline_store_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OfflineStoreStatusValue {
    Active,
    Blocked,
    Disabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OfflineStoreStatusValue {
    fn from(s: &str) -> Self {
        match s {
            "Active" => OfflineStoreStatusValue::Active,
            "Blocked" => OfflineStoreStatusValue::Blocked,
            "Disabled" => OfflineStoreStatusValue::Disabled,
            other => OfflineStoreStatusValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OfflineStoreStatusValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OfflineStoreStatusValue::from(s))
    }
}
impl OfflineStoreStatusValue {
    pub fn as_str(&self) -> &str {
        match self {
            OfflineStoreStatusValue::Active => "Active",
            OfflineStoreStatusValue::Blocked => "Blocked",
            OfflineStoreStatusValue::Disabled => "Disabled",
            OfflineStoreStatusValue::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Active", "Blocked", "Disabled"]
    }
}
impl AsRef<str> for OfflineStoreStatusValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupStatus {
    CreateFailed,
    Created,
    Creating,
    DeleteFailed,
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "CreateFailed" => FeatureGroupStatus::CreateFailed,
            "Created" => FeatureGroupStatus::Created,
            "Creating" => FeatureGroupStatus::Creating,
            "DeleteFailed" => FeatureGroupStatus::DeleteFailed,
            "Deleting" => FeatureGroupStatus::Deleting,
            other => FeatureGroupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupStatus::from(s))
    }
}
impl FeatureGroupStatus {
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupStatus::CreateFailed => "CreateFailed",
            FeatureGroupStatus::Created => "Created",
            FeatureGroupStatus::Creating => "Creating",
            FeatureGroupStatus::DeleteFailed => "DeleteFailed",
            FeatureGroupStatus::Deleting => "Deleting",
            FeatureGroupStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreateFailed",
            "Created",
            "Creating",
            "DeleteFailed",
            "Deleting",
        ]
    }
}
impl AsRef<str> for FeatureGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of an <code>OfflineStore</code>.</p>
/// <p>Provide an <code>OfflineStoreConfig</code> in a request to
/// <code>CreateFeatureGroup</code> to create an <code>OfflineStore</code>.</p>
/// <p>To encrypt an <code>OfflineStore</code> using at rest data encryption, specify Amazon Web Services Key
/// Management Service (KMS) key ID, or <code>KMSKeyId</code>, in
/// <code>S3StorageConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OfflineStoreConfig {
    /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
    pub s3_storage_config: std::option::Option<crate::model::S3StorageConfig>,
    /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when
    /// configuring an <code>OfflineStore</code>.</p>
    pub disable_glue_table_creation: bool,
    /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code>
    /// is created. </p>
    pub data_catalog_config: std::option::Option<crate::model::DataCatalogConfig>,
}
impl std::fmt::Debug for OfflineStoreConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OfflineStoreConfig");
        formatter.field("s3_storage_config", &self.s3_storage_config);
        formatter.field(
            "disable_glue_table_creation",
            &self.disable_glue_table_creation,
        );
        formatter.field("data_catalog_config", &self.data_catalog_config);
        formatter.finish()
    }
}
/// See [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
pub mod offline_store_config {
    /// A builder for [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_storage_config: std::option::Option<crate::model::S3StorageConfig>,
        pub(crate) disable_glue_table_creation: std::option::Option<bool>,
        pub(crate) data_catalog_config: std::option::Option<crate::model::DataCatalogConfig>,
    }
    impl Builder {
        /// <p>The Amazon Simple Storage (Amazon S3) location of <code>OfflineStore</code>.</p>
        pub fn s3_storage_config(mut self, input: crate::model::S3StorageConfig) -> Self {
            self.s3_storage_config = Some(input);
            self
        }
        pub fn set_s3_storage_config(
            mut self,
            input: std::option::Option<crate::model::S3StorageConfig>,
        ) -> Self {
            self.s3_storage_config = input;
            self
        }
        /// <p>Set to <code>True</code> to disable the automatic creation of an Amazon Web Services Glue table when
        /// configuring an <code>OfflineStore</code>.</p>
        pub fn disable_glue_table_creation(mut self, input: bool) -> Self {
            self.disable_glue_table_creation = Some(input);
            self
        }
        pub fn set_disable_glue_table_creation(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_glue_table_creation = input;
            self
        }
        /// <p>The meta data of the Glue table that is autogenerated when an <code>OfflineStore</code>
        /// is created. </p>
        pub fn data_catalog_config(mut self, input: crate::model::DataCatalogConfig) -> Self {
            self.data_catalog_config = Some(input);
            self
        }
        pub fn set_data_catalog_config(
            mut self,
            input: std::option::Option<crate::model::DataCatalogConfig>,
        ) -> Self {
            self.data_catalog_config = input;
            self
        }
        /// Consumes the builder and constructs a [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
        pub fn build(self) -> crate::model::OfflineStoreConfig {
            crate::model::OfflineStoreConfig {
                s3_storage_config: self.s3_storage_config,
                disable_glue_table_creation: self.disable_glue_table_creation.unwrap_or_default(),
                data_catalog_config: self.data_catalog_config,
            }
        }
    }
}
impl OfflineStoreConfig {
    /// Creates a new builder-style object to manufacture [`OfflineStoreConfig`](crate::model::OfflineStoreConfig)
    pub fn builder() -> crate::model::offline_store_config::Builder {
        crate::model::offline_store_config::Builder::default()
    }
}

/// <p>The meta data of the Glue table which serves as data catalog for the
/// <code>OfflineStore</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCatalogConfig {
    /// <p>The name of the Glue table.</p>
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The name of the Glue table catalog.</p>
    pub catalog: std::option::Option<std::string::String>,
    /// <p>The name of the Glue table database.</p>
    pub database: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataCatalogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCatalogConfig");
        formatter.field("table_name", &self.table_name);
        formatter.field("catalog", &self.catalog);
        formatter.field("database", &self.database);
        formatter.finish()
    }
}
/// See [`DataCatalogConfig`](crate::model::DataCatalogConfig)
pub mod data_catalog_config {
    /// A builder for [`DataCatalogConfig`](crate::model::DataCatalogConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) catalog: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Glue table.</p>
        pub fn table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_name = Some(input.into());
            self
        }
        pub fn set_table_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.table_name = input;
            self
        }
        /// <p>The name of the Glue table catalog.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The name of the Glue table database.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCatalogConfig`](crate::model::DataCatalogConfig)
        pub fn build(self) -> crate::model::DataCatalogConfig {
            crate::model::DataCatalogConfig {
                table_name: self.table_name,
                catalog: self.catalog,
                database: self.database,
            }
        }
    }
}
impl DataCatalogConfig {
    /// Creates a new builder-style object to manufacture [`DataCatalogConfig`](crate::model::DataCatalogConfig)
    pub fn builder() -> crate::model::data_catalog_config::Builder {
        crate::model::data_catalog_config::Builder::default()
    }
}

/// <p>The Amazon Simple Storage (Amazon S3) location and and security configuration for <code>OfflineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3StorageConfig {
    /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
    /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects
    /// written into the <code>OfflineStore</code> S3 location.</p>
    /// <p>The IAM <code>roleARN</code> that is passed as a parameter to
    /// <code>CreateFeatureGroup</code> must have below permissions to the
    /// <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"kms:GenerateDataKey"</code>
    /// </p>
    /// </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The S3 path where offline records are written.</p>
    pub resolved_output_s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for S3StorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3StorageConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("resolved_output_s3_uri", &self.resolved_output_s3_uri);
        formatter.finish()
    }
}
/// See [`S3StorageConfig`](crate::model::S3StorageConfig)
pub mod s3_storage_config {
    /// A builder for [`S3StorageConfig`](crate::model::S3StorageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) resolved_output_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 URI, or location in Amazon S3, of <code>OfflineStore</code>.</p>
        /// <p>S3 URIs have a format similar to the following: <code>s3://example-bucket/prefix/</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (KMS) key ID of the key used to encrypt any objects
        /// written into the <code>OfflineStore</code> S3 location.</p>
        /// <p>The IAM <code>roleARN</code> that is passed as a parameter to
        /// <code>CreateFeatureGroup</code> must have below permissions to the
        /// <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"kms:GenerateDataKey"</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The S3 path where offline records are written.</p>
        pub fn resolved_output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_output_s3_uri = Some(input.into());
            self
        }
        pub fn set_resolved_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_output_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`S3StorageConfig`](crate::model::S3StorageConfig)
        pub fn build(self) -> crate::model::S3StorageConfig {
            crate::model::S3StorageConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
                resolved_output_s3_uri: self.resolved_output_s3_uri,
            }
        }
    }
}
impl S3StorageConfig {
    /// Creates a new builder-style object to manufacture [`S3StorageConfig`](crate::model::S3StorageConfig)
    pub fn builder() -> crate::model::s3_storage_config::Builder {
        crate::model::s3_storage_config::Builder::default()
    }
}

/// <p>Use this to specify the Amazon Web Services Key Management Service (KMS) Key ID, or
/// <code>KMSKeyId</code>, for at rest data encryption. You can turn
/// <code>OnlineStore</code> on or off by specifying the <code>EnableOnlineStore</code> flag
/// at General Assembly; the default value is <code>False</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnlineStoreConfig {
    /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your
    /// <code>OnlineStore</code>.</p>
    pub security_config: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
    /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code>
    /// for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code>
    /// on by specifying <code>True</code>
    /// for the <code>EnableOnlineStore</code> flag. </p>
    /// <p>The default value is <code>False</code>.</p>
    pub enable_online_store: bool,
}
impl std::fmt::Debug for OnlineStoreConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnlineStoreConfig");
        formatter.field("security_config", &self.security_config);
        formatter.field("enable_online_store", &self.enable_online_store);
        formatter.finish()
    }
}
/// See [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
pub mod online_store_config {
    /// A builder for [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_config: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
        pub(crate) enable_online_store: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Use to specify KMS Key ID (<code>KMSKeyId</code>) for at-rest encryption of your
        /// <code>OnlineStore</code>.</p>
        pub fn security_config(mut self, input: crate::model::OnlineStoreSecurityConfig) -> Self {
            self.security_config = Some(input);
            self
        }
        pub fn set_security_config(
            mut self,
            input: std::option::Option<crate::model::OnlineStoreSecurityConfig>,
        ) -> Self {
            self.security_config = input;
            self
        }
        /// <p>Turn <code>OnlineStore</code> off by specifying <code>False</code>
        /// for the <code>EnableOnlineStore</code> flag. Turn <code>OnlineStore</code>
        /// on by specifying <code>True</code>
        /// for the <code>EnableOnlineStore</code> flag. </p>
        /// <p>The default value is <code>False</code>.</p>
        pub fn enable_online_store(mut self, input: bool) -> Self {
            self.enable_online_store = Some(input);
            self
        }
        pub fn set_enable_online_store(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_online_store = input;
            self
        }
        /// Consumes the builder and constructs a [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
        pub fn build(self) -> crate::model::OnlineStoreConfig {
            crate::model::OnlineStoreConfig {
                security_config: self.security_config,
                enable_online_store: self.enable_online_store.unwrap_or_default(),
            }
        }
    }
}
impl OnlineStoreConfig {
    /// Creates a new builder-style object to manufacture [`OnlineStoreConfig`](crate::model::OnlineStoreConfig)
    pub fn builder() -> crate::model::online_store_config::Builder {
        crate::model::online_store_config::Builder::default()
    }
}

/// <p>The security configuration for <code>OnlineStore</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OnlineStoreSecurityConfig {
    /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses
    /// to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
    /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have
    /// below permissions to the <code>OnlineStore</code>
    /// <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"kms:Encrypt"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:Decrypt"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:DescribeKey"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:CreateGrant"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:RetireGrant"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:ReEncryptFrom"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:ReEncryptTo"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:GenerateDataKey"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:ListAliases"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:ListGrants"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"kms:RevokeGrant"</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>The caller (either IAM user or IAM role) to all DataPlane operations
    /// (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have
    /// the following permissions to the <code>KmsKeyId</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"kms:Decrypt"</code>
    /// </p>
    /// </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OnlineStoreSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OnlineStoreSecurityConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
pub mod online_store_security_config {
    /// A builder for [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Amazon Web Services Key Management Service (Amazon Web Services KMS) key that SageMaker Feature Store uses
        /// to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.</p>
        /// <p>The caller (either IAM user or IAM role) of <code>CreateFeatureGroup</code> must have
        /// below permissions to the <code>OnlineStore</code>
        /// <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"kms:Encrypt"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:Decrypt"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:DescribeKey"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:CreateGrant"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:RetireGrant"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:ReEncryptFrom"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:ReEncryptTo"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:GenerateDataKey"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:ListAliases"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:ListGrants"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"kms:RevokeGrant"</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>The caller (either IAM user or IAM role) to all DataPlane operations
        /// (<code>PutRecord</code>, <code>GetRecord</code>, <code>DeleteRecord</code>) must have
        /// the following permissions to the <code>KmsKeyId</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"kms:Decrypt"</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
        pub fn build(self) -> crate::model::OnlineStoreSecurityConfig {
            crate::model::OnlineStoreSecurityConfig {
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl OnlineStoreSecurityConfig {
    /// Creates a new builder-style object to manufacture [`OnlineStoreSecurityConfig`](crate::model::OnlineStoreSecurityConfig)
    pub fn builder() -> crate::model::online_store_security_config::Builder {
        crate::model::online_store_security_config::Builder::default()
    }
}

/// <p>A list of features. You must include <code>FeatureName</code> and
/// <code>FeatureType</code>. Valid feature <code>FeatureType</code>s are
/// <code>Integral</code>, <code>Fractional</code> and <code>String</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureDefinition {
    /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any
    /// of the following: <code>is_deleted</code>, <code>write_time</code>,
    /// <code>api_invocation_time</code>.</p>
    pub feature_name: std::option::Option<std::string::String>,
    /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
    pub feature_type: std::option::Option<crate::model::FeatureType>,
}
impl std::fmt::Debug for FeatureDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureDefinition");
        formatter.field("feature_name", &self.feature_name);
        formatter.field("feature_type", &self.feature_type);
        formatter.finish()
    }
}
/// See [`FeatureDefinition`](crate::model::FeatureDefinition)
pub mod feature_definition {
    /// A builder for [`FeatureDefinition`](crate::model::FeatureDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_name: std::option::Option<std::string::String>,
        pub(crate) feature_type: std::option::Option<crate::model::FeatureType>,
    }
    impl Builder {
        /// <p>The name of a feature. The type must be a string. <code>FeatureName</code> cannot be any
        /// of the following: <code>is_deleted</code>, <code>write_time</code>,
        /// <code>api_invocation_time</code>.</p>
        pub fn feature_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_name = Some(input.into());
            self
        }
        pub fn set_feature_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.feature_name = input;
            self
        }
        /// <p>The value type of a feature. Valid values are Integral, Fractional, or String.</p>
        pub fn feature_type(mut self, input: crate::model::FeatureType) -> Self {
            self.feature_type = Some(input);
            self
        }
        pub fn set_feature_type(
            mut self,
            input: std::option::Option<crate::model::FeatureType>,
        ) -> Self {
            self.feature_type = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureDefinition`](crate::model::FeatureDefinition)
        pub fn build(self) -> crate::model::FeatureDefinition {
            crate::model::FeatureDefinition {
                feature_name: self.feature_name,
                feature_type: self.feature_type,
            }
        }
    }
}
impl FeatureDefinition {
    /// Creates a new builder-style object to manufacture [`FeatureDefinition`](crate::model::FeatureDefinition)
    pub fn builder() -> crate::model::feature_definition::Builder {
        crate::model::feature_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureType {
    Fractional,
    Integral,
    String,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureType {
    fn from(s: &str) -> Self {
        match s {
            "Fractional" => FeatureType::Fractional,
            "Integral" => FeatureType::Integral,
            "String" => FeatureType::String,
            other => FeatureType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureType::from(s))
    }
}
impl FeatureType {
    pub fn as_str(&self) -> &str {
        match self {
            FeatureType::Fractional => "Fractional",
            FeatureType::Integral => "Integral",
            FeatureType::String => "String",
            FeatureType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Fractional", "Integral", "String"]
    }
}
impl AsRef<str> for FeatureType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An execution of a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecution {
    /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline status.</p>
    pub pipeline_execution_status: std::option::Option<crate::model::PipelineExecutionStatus>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: std::option::Option<std::string::String>,
    /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
    pub pipeline_experiment_config: std::option::Option<crate::model::PipelineExperimentConfig>,
    /// <p>If the execution failed, a message describing why.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The creation time of the pipeline execution.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the pipeline execution was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Contains a list of pipeline parameters. This list can be empty. </p>
    pub pipeline_parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
}
impl std::fmt::Debug for PipelineExecution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecution");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.field("pipeline_execution_status", &self.pipeline_execution_status);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_experiment_config",
            &self.pipeline_experiment_config,
        );
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("pipeline_parameters", &self.pipeline_parameters);
        formatter.finish()
    }
}
/// See [`PipelineExecution`](crate::model::PipelineExecution)
pub mod pipeline_execution {
    /// A builder for [`PipelineExecution`](crate::model::PipelineExecution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_status:
            std::option::Option<crate::model::PipelineExecutionStatus>,
        pub(crate) pipeline_execution_description: std::option::Option<std::string::String>,
        pub(crate) pipeline_experiment_config:
            std::option::Option<crate::model::PipelineExperimentConfig>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) pipeline_parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline that was executed.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn pipeline_execution_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_execution_arn = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_arn = input;
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn pipeline_execution_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = input;
            self
        }
        /// <p>The status of the pipeline status.</p>
        pub fn pipeline_execution_status(
            mut self,
            input: crate::model::PipelineExecutionStatus,
        ) -> Self {
            self.pipeline_execution_status = Some(input);
            self
        }
        pub fn set_pipeline_execution_status(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStatus>,
        ) -> Self {
            self.pipeline_execution_status = input;
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn pipeline_execution_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = input;
            self
        }
        /// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
        pub fn pipeline_experiment_config(
            mut self,
            input: crate::model::PipelineExperimentConfig,
        ) -> Self {
            self.pipeline_experiment_config = Some(input);
            self
        }
        pub fn set_pipeline_experiment_config(
            mut self,
            input: std::option::Option<crate::model::PipelineExperimentConfig>,
        ) -> Self {
            self.pipeline_experiment_config = input;
            self
        }
        /// <p>If the execution failed, a message describing why.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The creation time of the pipeline execution.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline execution was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        pub fn pipeline_parameters(mut self, input: impl Into<crate::model::Parameter>) -> Self {
            let mut v = self.pipeline_parameters.unwrap_or_default();
            v.push(input.into());
            self.pipeline_parameters = Some(v);
            self
        }
        pub fn set_pipeline_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.pipeline_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecution`](crate::model::PipelineExecution)
        pub fn build(self) -> crate::model::PipelineExecution {
            crate::model::PipelineExecution {
                pipeline_arn: self.pipeline_arn,
                pipeline_execution_arn: self.pipeline_execution_arn,
                pipeline_execution_display_name: self.pipeline_execution_display_name,
                pipeline_execution_status: self.pipeline_execution_status,
                pipeline_execution_description: self.pipeline_execution_description,
                pipeline_experiment_config: self.pipeline_experiment_config,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                created_by: self.created_by,
                last_modified_by: self.last_modified_by,
                pipeline_parameters: self.pipeline_parameters,
            }
        }
    }
}
impl PipelineExecution {
    /// Creates a new builder-style object to manufacture [`PipelineExecution`](crate::model::PipelineExecution)
    pub fn builder() -> crate::model::pipeline_execution::Builder {
        crate::model::pipeline_execution::Builder::default()
    }
}

/// <p>Information about the user who created or modified an experiment, trial, or trial
/// component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserContext {
    /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
    pub user_profile_arn: std::option::Option<std::string::String>,
    /// <p>The name of the user's profile.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The domain associated with the user.</p>
    pub domain_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserContext");
        formatter.field("user_profile_arn", &self.user_profile_arn);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("domain_id", &self.domain_id);
        formatter.finish()
    }
}
/// See [`UserContext`](crate::model::UserContext)
pub mod user_context {
    /// A builder for [`UserContext`](crate::model::UserContext)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_profile_arn: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the user's profile.</p>
        pub fn user_profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_arn = Some(input.into());
            self
        }
        pub fn set_user_profile_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_arn = input;
            self
        }
        /// <p>The name of the user's profile.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The domain associated with the user.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserContext`](crate::model::UserContext)
        pub fn build(self) -> crate::model::UserContext {
            crate::model::UserContext {
                user_profile_arn: self.user_profile_arn,
                user_profile_name: self.user_profile_name,
                domain_id: self.domain_id,
            }
        }
    }
}
impl UserContext {
    /// Creates a new builder-style object to manufacture [`UserContext`](crate::model::UserContext)
    pub fn builder() -> crate::model::user_context::Builder {
        crate::model::user_context::Builder::default()
    }
}

/// <p>Specifies the names of the experiment and trial created by a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExperimentConfig {
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PipelineExperimentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExperimentConfig");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.finish()
    }
}
/// See [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
pub mod pipeline_experiment_config {
    /// A builder for [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
        pub fn build(self) -> crate::model::PipelineExperimentConfig {
            crate::model::PipelineExperimentConfig {
                experiment_name: self.experiment_name,
                trial_name: self.trial_name,
            }
        }
    }
}
impl PipelineExperimentConfig {
    /// Creates a new builder-style object to manufacture [`PipelineExperimentConfig`](crate::model::PipelineExperimentConfig)
    pub fn builder() -> crate::model::pipeline_experiment_config::Builder {
        crate::model::pipeline_experiment_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PipelineExecutionStatus {
    Executing,
    Failed,
    Stopped,
    Stopping,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PipelineExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Executing" => PipelineExecutionStatus::Executing,
            "Failed" => PipelineExecutionStatus::Failed,
            "Stopped" => PipelineExecutionStatus::Stopped,
            "Stopping" => PipelineExecutionStatus::Stopping,
            "Succeeded" => PipelineExecutionStatus::Succeeded,
            other => PipelineExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PipelineExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PipelineExecutionStatus::from(s))
    }
}
impl PipelineExecutionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            PipelineExecutionStatus::Executing => "Executing",
            PipelineExecutionStatus::Failed => "Failed",
            PipelineExecutionStatus::Stopped => "Stopped",
            PipelineExecutionStatus::Stopping => "Stopping",
            PipelineExecutionStatus::Succeeded => "Succeeded",
            PipelineExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Executing", "Failed", "Stopped", "Stopping", "Succeeded"]
    }
}
impl AsRef<str> for PipelineExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A SageMaker Model Building Pipeline instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Pipeline {
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    pub pipeline_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of the pipeline.</p>
    pub pipeline_status: std::option::Option<crate::model::PipelineStatus>,
    /// <p>The creation time of the pipeline.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the pipeline was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the pipeline was last run.</p>
    pub last_run_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>A list of tags that apply to the pipeline.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Pipeline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Pipeline");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("pipeline_status", &self.pipeline_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_run_time", &self.last_run_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Pipeline`](crate::model::Pipeline)
pub mod pipeline {
    /// A builder for [`Pipeline`](crate::model::Pipeline)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_description: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_status: std::option::Option<crate::model::PipelineStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_run_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_name = Some(input.into());
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_name = input;
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn pipeline_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_display_name = Some(input.into());
            self
        }
        pub fn set_pipeline_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_display_name = input;
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn pipeline_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_description = Some(input.into());
            self
        }
        pub fn set_pipeline_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the role that created the pipeline.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The status of the pipeline.</p>
        pub fn pipeline_status(mut self, input: crate::model::PipelineStatus) -> Self {
            self.pipeline_status = Some(input);
            self
        }
        pub fn set_pipeline_status(
            mut self,
            input: std::option::Option<crate::model::PipelineStatus>,
        ) -> Self {
            self.pipeline_status = input;
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The time when the pipeline was last run.</p>
        pub fn last_run_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_run_time = Some(input);
            self
        }
        pub fn set_last_run_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_run_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Pipeline`](crate::model::Pipeline)
        pub fn build(self) -> crate::model::Pipeline {
            crate::model::Pipeline {
                pipeline_arn: self.pipeline_arn,
                pipeline_name: self.pipeline_name,
                pipeline_display_name: self.pipeline_display_name,
                pipeline_description: self.pipeline_description,
                role_arn: self.role_arn,
                pipeline_status: self.pipeline_status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                last_run_time: self.last_run_time,
                created_by: self.created_by,
                last_modified_by: self.last_modified_by,
                tags: self.tags,
            }
        }
    }
}
impl Pipeline {
    /// Creates a new builder-style object to manufacture [`Pipeline`](crate::model::Pipeline)
    pub fn builder() -> crate::model::pipeline::Builder {
        crate::model::pipeline::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PipelineStatus {
    Active,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PipelineStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => PipelineStatus::Active,
            other => PipelineStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PipelineStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PipelineStatus::from(s))
    }
}
impl PipelineStatus {
    pub fn as_str(&self) -> &str {
        match self {
            PipelineStatus::Active => "Active",
            PipelineStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Active"]
    }
}
impl AsRef<str> for PipelineStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A group of versioned models in the model registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageGroup {
    /// <p>The name of the model group.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub model_package_group_arn: std::option::Option<std::string::String>,
    /// <p>The description for the model group.</p>
    pub model_package_group_description: std::option::Option<std::string::String>,
    /// <p>The time that the model group was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>The status of the model group. This can be one of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - The model group is pending being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_PROGRESS</code> - The model group is in the process of being
    /// created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>COMPLETED</code> - The model group was successfully created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - The model group failed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The model group is in the process of being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p>
    /// </li>
    /// </ul>
    pub model_package_group_status: std::option::Option<crate::model::ModelPackageGroupStatus>,
    /// <p>A list of the tags associated with the model group. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
    /// resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ModelPackageGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageGroup");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field(
            "model_package_group_status",
            &self.model_package_group_status,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ModelPackageGroup`](crate::model::ModelPackageGroup)
pub mod model_package_group {
    /// A builder for [`ModelPackageGroup`](crate::model::ModelPackageGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_group_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) model_package_group_status:
            std::option::Option<crate::model::ModelPackageGroupStatus>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the model group.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn model_package_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_arn = Some(input.into());
            self
        }
        pub fn set_model_package_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_arn = input;
            self
        }
        /// <p>The description for the model group.</p>
        pub fn model_package_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_package_group_description = Some(input.into());
            self
        }
        pub fn set_model_package_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_description = input;
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The status of the model group. This can be one of the following values.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - The model group is pending being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_PROGRESS</code> - The model group is in the process of being
        /// created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>COMPLETED</code> - The model group was successfully created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - The model group failed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The model group is in the process of being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETE_FAILED</code> - SageMaker failed to delete the model group.</p>
        /// </li>
        /// </ul>
        pub fn model_package_group_status(
            mut self,
            input: crate::model::ModelPackageGroupStatus,
        ) -> Self {
            self.model_package_group_status = Some(input);
            self
        }
        pub fn set_model_package_group_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroupStatus>,
        ) -> Self {
            self.model_package_group_status = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageGroup`](crate::model::ModelPackageGroup)
        pub fn build(self) -> crate::model::ModelPackageGroup {
            crate::model::ModelPackageGroup {
                model_package_group_name: self.model_package_group_name,
                model_package_group_arn: self.model_package_group_arn,
                model_package_group_description: self.model_package_group_description,
                creation_time: self.creation_time,
                created_by: self.created_by,
                model_package_group_status: self.model_package_group_status,
                tags: self.tags,
            }
        }
    }
}
impl ModelPackageGroup {
    /// Creates a new builder-style object to manufacture [`ModelPackageGroup`](crate::model::ModelPackageGroup)
    pub fn builder() -> crate::model::model_package_group::Builder {
        crate::model::model_package_group::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageGroupStatus {
    Completed,
    DeleteFailed,
    Deleting,
    Failed,
    InProgress,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageGroupStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ModelPackageGroupStatus::Completed,
            "DeleteFailed" => ModelPackageGroupStatus::DeleteFailed,
            "Deleting" => ModelPackageGroupStatus::Deleting,
            "Failed" => ModelPackageGroupStatus::Failed,
            "InProgress" => ModelPackageGroupStatus::InProgress,
            "Pending" => ModelPackageGroupStatus::Pending,
            other => ModelPackageGroupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageGroupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageGroupStatus::from(s))
    }
}
impl ModelPackageGroupStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageGroupStatus::Completed => "Completed",
            ModelPackageGroupStatus::DeleteFailed => "DeleteFailed",
            ModelPackageGroupStatus::Deleting => "Deleting",
            ModelPackageGroupStatus::Failed => "Failed",
            ModelPackageGroupStatus::InProgress => "InProgress",
            ModelPackageGroupStatus::Pending => "Pending",
            ModelPackageGroupStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "DeleteFailed",
            "Deleting",
            "Failed",
            "InProgress",
            "Pending",
        ]
    }
}
impl AsRef<str> for ModelPackageGroupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A versioned model that can be deployed for SageMaker inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackage {
    /// <p>The name of the model.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>The model group to which the model belongs.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The version number of a versioned model.</p>
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>The description of the model package.</p>
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>The time that the model package was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Defines how to perform inference generation after a training job is run.</p>
    pub inference_specification: std::option::Option<crate::model::InferenceSpecification>,
    /// <p>A list of algorithms that were used to create a model package.</p>
    pub source_algorithm_specification:
        std::option::Option<crate::model::SourceAlgorithmSpecification>,
    /// <p>Specifies batch transform jobs that Amazon SageMaker runs to validate your model package.</p>
    pub validation_specification:
        std::option::Option<crate::model::ModelPackageValidationSpecification>,
    /// <p>The status of the model package. This can be one of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - The model package is pending being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_PROGRESS</code> - The model package is in the process of being
    /// created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>COMPLETED</code> - The model package was successfully created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - The model package failed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The model package is in the process of being deleted.</p>
    /// </li>
    /// </ul>
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>Specifies the validation and image scan statuses of the model package.</p>
    pub model_package_status_details: std::option::Option<crate::model::ModelPackageStatusDetails>,
    /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For
    /// information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your
    /// Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
    pub certify_for_marketplace: bool,
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>APPROVED</code> - The model is approved</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>REJECTED</code> - The model is rejected.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual
    /// approval.</p>
    /// </li>
    /// </ul>
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>Metrics for the model.</p>
    pub model_metrics: std::option::Option<crate::model::ModelMetrics>,
    /// <p>The last time the model package was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>A description provided when the model approval is set.</p>
    pub approval_description: std::option::Option<std::string::String>,
    /// <p>A list of the tags associated with the model package. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
    /// resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ModelPackage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackage");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("inference_specification", &self.inference_specification);
        formatter.field(
            "source_algorithm_specification",
            &self.source_algorithm_specification,
        );
        formatter.field("validation_specification", &self.validation_specification);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field(
            "model_package_status_details",
            &self.model_package_status_details,
        );
        formatter.field("certify_for_marketplace", &self.certify_for_marketplace);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.field("created_by", &self.created_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("model_metrics", &self.model_metrics);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("approval_description", &self.approval_description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ModelPackage`](crate::model::ModelPackage)
pub mod model_package {
    /// A builder for [`ModelPackage`](crate::model::ModelPackage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_version: std::option::Option<i32>,
        pub(crate) model_package_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) inference_specification:
            std::option::Option<crate::model::InferenceSpecification>,
        pub(crate) source_algorithm_specification:
            std::option::Option<crate::model::SourceAlgorithmSpecification>,
        pub(crate) validation_specification:
            std::option::Option<crate::model::ModelPackageValidationSpecification>,
        pub(crate) model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
        pub(crate) model_package_status_details:
            std::option::Option<crate::model::ModelPackageStatusDetails>,
        pub(crate) certify_for_marketplace: std::option::Option<bool>,
        pub(crate) model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) model_metrics: std::option::Option<crate::model::ModelMetrics>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) approval_description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>The model group to which the model belongs.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The version number of a versioned model.</p>
        pub fn model_package_version(mut self, input: i32) -> Self {
            self.model_package_version = Some(input);
            self
        }
        pub fn set_model_package_version(mut self, input: std::option::Option<i32>) -> Self {
            self.model_package_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn model_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_arn = Some(input.into());
            self
        }
        pub fn set_model_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_arn = input;
            self
        }
        /// <p>The description of the model package.</p>
        pub fn model_package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_description = Some(input.into());
            self
        }
        pub fn set_model_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_description = input;
            self
        }
        /// <p>The time that the model package was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Defines how to perform inference generation after a training job is run.</p>
        pub fn inference_specification(
            mut self,
            input: crate::model::InferenceSpecification,
        ) -> Self {
            self.inference_specification = Some(input);
            self
        }
        pub fn set_inference_specification(
            mut self,
            input: std::option::Option<crate::model::InferenceSpecification>,
        ) -> Self {
            self.inference_specification = input;
            self
        }
        /// <p>A list of algorithms that were used to create a model package.</p>
        pub fn source_algorithm_specification(
            mut self,
            input: crate::model::SourceAlgorithmSpecification,
        ) -> Self {
            self.source_algorithm_specification = Some(input);
            self
        }
        pub fn set_source_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::SourceAlgorithmSpecification>,
        ) -> Self {
            self.source_algorithm_specification = input;
            self
        }
        /// <p>Specifies batch transform jobs that Amazon SageMaker runs to validate your model package.</p>
        pub fn validation_specification(
            mut self,
            input: crate::model::ModelPackageValidationSpecification,
        ) -> Self {
            self.validation_specification = Some(input);
            self
        }
        pub fn set_validation_specification(
            mut self,
            input: std::option::Option<crate::model::ModelPackageValidationSpecification>,
        ) -> Self {
            self.validation_specification = input;
            self
        }
        /// <p>The status of the model package. This can be one of the following values.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - The model package is pending being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_PROGRESS</code> - The model package is in the process of being
        /// created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>COMPLETED</code> - The model package was successfully created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - The model package failed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The model package is in the process of being deleted.</p>
        /// </li>
        /// </ul>
        pub fn model_package_status(mut self, input: crate::model::ModelPackageStatus) -> Self {
            self.model_package_status = Some(input);
            self
        }
        pub fn set_model_package_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatus>,
        ) -> Self {
            self.model_package_status = input;
            self
        }
        /// <p>Specifies the validation and image scan statuses of the model package.</p>
        pub fn model_package_status_details(
            mut self,
            input: crate::model::ModelPackageStatusDetails,
        ) -> Self {
            self.model_package_status_details = Some(input);
            self
        }
        pub fn set_model_package_status_details(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatusDetails>,
        ) -> Self {
            self.model_package_status_details = input;
            self
        }
        /// <p>Whether the model package is to be certified to be listed on Amazon Web Services Marketplace. For
        /// information about listing model packages on Amazon Web Services Marketplace, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-list.html">List Your
        /// Algorithm or Model Package on Amazon Web Services Marketplace</a>.</p>
        pub fn certify_for_marketplace(mut self, input: bool) -> Self {
            self.certify_for_marketplace = Some(input);
            self
        }
        pub fn set_certify_for_marketplace(mut self, input: std::option::Option<bool>) -> Self {
            self.certify_for_marketplace = input;
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>APPROVED</code> - The model is approved</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REJECTED</code> - The model is rejected.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual
        /// approval.</p>
        /// </li>
        /// </ul>
        pub fn model_approval_status(mut self, input: crate::model::ModelApprovalStatus) -> Self {
            self.model_approval_status = Some(input);
            self
        }
        pub fn set_model_approval_status(
            mut self,
            input: std::option::Option<crate::model::ModelApprovalStatus>,
        ) -> Self {
            self.model_approval_status = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        /// <p>Metrics for the model.</p>
        pub fn model_metrics(mut self, input: crate::model::ModelMetrics) -> Self {
            self.model_metrics = Some(input);
            self
        }
        pub fn set_model_metrics(
            mut self,
            input: std::option::Option<crate::model::ModelMetrics>,
        ) -> Self {
            self.model_metrics = input;
            self
        }
        /// <p>The last time the model package was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>A description provided when the model approval is set.</p>
        pub fn approval_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.approval_description = Some(input.into());
            self
        }
        pub fn set_approval_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.approval_description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackage`](crate::model::ModelPackage)
        pub fn build(self) -> crate::model::ModelPackage {
            crate::model::ModelPackage {
                model_package_name: self.model_package_name,
                model_package_group_name: self.model_package_group_name,
                model_package_version: self.model_package_version,
                model_package_arn: self.model_package_arn,
                model_package_description: self.model_package_description,
                creation_time: self.creation_time,
                inference_specification: self.inference_specification,
                source_algorithm_specification: self.source_algorithm_specification,
                validation_specification: self.validation_specification,
                model_package_status: self.model_package_status,
                model_package_status_details: self.model_package_status_details,
                certify_for_marketplace: self.certify_for_marketplace.unwrap_or_default(),
                model_approval_status: self.model_approval_status,
                created_by: self.created_by,
                metadata_properties: self.metadata_properties,
                model_metrics: self.model_metrics,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                approval_description: self.approval_description,
                tags: self.tags,
            }
        }
    }
}
impl ModelPackage {
    /// Creates a new builder-style object to manufacture [`ModelPackage`](crate::model::ModelPackage)
    pub fn builder() -> crate::model::model_package::Builder {
        crate::model::model_package::Builder::default()
    }
}

/// <p>Contains metrics captured from a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelMetrics {
    /// <p>Metrics that measure the quality of a model.</p>
    pub model_quality: std::option::Option<crate::model::ModelQuality>,
    /// <p>Metrics that measure the quality of the input data for a model.</p>
    pub model_data_quality: std::option::Option<crate::model::ModelDataQuality>,
    /// <p>Metrics that measure bais in a model.</p>
    pub bias: std::option::Option<crate::model::Bias>,
    /// <p>Metrics that help explain a model.</p>
    pub explainability: std::option::Option<crate::model::Explainability>,
}
impl std::fmt::Debug for ModelMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelMetrics");
        formatter.field("model_quality", &self.model_quality);
        formatter.field("model_data_quality", &self.model_data_quality);
        formatter.field("bias", &self.bias);
        formatter.field("explainability", &self.explainability);
        formatter.finish()
    }
}
/// See [`ModelMetrics`](crate::model::ModelMetrics)
pub mod model_metrics {
    /// A builder for [`ModelMetrics`](crate::model::ModelMetrics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_quality: std::option::Option<crate::model::ModelQuality>,
        pub(crate) model_data_quality: std::option::Option<crate::model::ModelDataQuality>,
        pub(crate) bias: std::option::Option<crate::model::Bias>,
        pub(crate) explainability: std::option::Option<crate::model::Explainability>,
    }
    impl Builder {
        /// <p>Metrics that measure the quality of a model.</p>
        pub fn model_quality(mut self, input: crate::model::ModelQuality) -> Self {
            self.model_quality = Some(input);
            self
        }
        pub fn set_model_quality(
            mut self,
            input: std::option::Option<crate::model::ModelQuality>,
        ) -> Self {
            self.model_quality = input;
            self
        }
        /// <p>Metrics that measure the quality of the input data for a model.</p>
        pub fn model_data_quality(mut self, input: crate::model::ModelDataQuality) -> Self {
            self.model_data_quality = Some(input);
            self
        }
        pub fn set_model_data_quality(
            mut self,
            input: std::option::Option<crate::model::ModelDataQuality>,
        ) -> Self {
            self.model_data_quality = input;
            self
        }
        /// <p>Metrics that measure bais in a model.</p>
        pub fn bias(mut self, input: crate::model::Bias) -> Self {
            self.bias = Some(input);
            self
        }
        pub fn set_bias(mut self, input: std::option::Option<crate::model::Bias>) -> Self {
            self.bias = input;
            self
        }
        /// <p>Metrics that help explain a model.</p>
        pub fn explainability(mut self, input: crate::model::Explainability) -> Self {
            self.explainability = Some(input);
            self
        }
        pub fn set_explainability(
            mut self,
            input: std::option::Option<crate::model::Explainability>,
        ) -> Self {
            self.explainability = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelMetrics`](crate::model::ModelMetrics)
        pub fn build(self) -> crate::model::ModelMetrics {
            crate::model::ModelMetrics {
                model_quality: self.model_quality,
                model_data_quality: self.model_data_quality,
                bias: self.bias,
                explainability: self.explainability,
            }
        }
    }
}
impl ModelMetrics {
    /// Creates a new builder-style object to manufacture [`ModelMetrics`](crate::model::ModelMetrics)
    pub fn builder() -> crate::model::model_metrics::Builder {
        crate::model::model_metrics::Builder::default()
    }
}

/// <p>Contains explainability metrics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Explainability {
    /// <p>The explainability report for a model.</p>
    pub report: std::option::Option<crate::model::MetricsSource>,
}
impl std::fmt::Debug for Explainability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Explainability");
        formatter.field("report", &self.report);
        formatter.finish()
    }
}
/// See [`Explainability`](crate::model::Explainability)
pub mod explainability {
    /// A builder for [`Explainability`](crate::model::Explainability)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) report: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>The explainability report for a model.</p>
        pub fn report(mut self, input: crate::model::MetricsSource) -> Self {
            self.report = Some(input);
            self
        }
        pub fn set_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.report = input;
            self
        }
        /// Consumes the builder and constructs a [`Explainability`](crate::model::Explainability)
        pub fn build(self) -> crate::model::Explainability {
            crate::model::Explainability {
                report: self.report,
            }
        }
    }
}
impl Explainability {
    /// Creates a new builder-style object to manufacture [`Explainability`](crate::model::Explainability)
    pub fn builder() -> crate::model::explainability::Builder {
        crate::model::explainability::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricsSource {
    /// <p></p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p></p>
    pub content_digest: std::option::Option<std::string::String>,
    /// <p></p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricsSource");
        formatter.field("content_type", &self.content_type);
        formatter.field("content_digest", &self.content_digest);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MetricsSource`](crate::model::MetricsSource)
pub mod metrics_source {
    /// A builder for [`MetricsSource`](crate::model::MetricsSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) content_digest: std::option::Option<std::string::String>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p></p>
        pub fn content_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_digest = Some(input.into());
            self
        }
        pub fn set_content_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_digest = input;
            self
        }
        /// <p></p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricsSource`](crate::model::MetricsSource)
        pub fn build(self) -> crate::model::MetricsSource {
            crate::model::MetricsSource {
                content_type: self.content_type,
                content_digest: self.content_digest,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MetricsSource {
    /// Creates a new builder-style object to manufacture [`MetricsSource`](crate::model::MetricsSource)
    pub fn builder() -> crate::model::metrics_source::Builder {
        crate::model::metrics_source::Builder::default()
    }
}

/// <p>Contains bias metrics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Bias {
    /// <p>The bias report for a model</p>
    pub report: std::option::Option<crate::model::MetricsSource>,
}
impl std::fmt::Debug for Bias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Bias");
        formatter.field("report", &self.report);
        formatter.finish()
    }
}
/// See [`Bias`](crate::model::Bias)
pub mod bias {
    /// A builder for [`Bias`](crate::model::Bias)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) report: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>The bias report for a model</p>
        pub fn report(mut self, input: crate::model::MetricsSource) -> Self {
            self.report = Some(input);
            self
        }
        pub fn set_report(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.report = input;
            self
        }
        /// Consumes the builder and constructs a [`Bias`](crate::model::Bias)
        pub fn build(self) -> crate::model::Bias {
            crate::model::Bias {
                report: self.report,
            }
        }
    }
}
impl Bias {
    /// Creates a new builder-style object to manufacture [`Bias`](crate::model::Bias)
    pub fn builder() -> crate::model::bias::Builder {
        crate::model::bias::Builder::default()
    }
}

/// <p>Data quality constraints and statistics for a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDataQuality {
    /// <p>Data quality statistics for a model.</p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p>Data quality constraints for a model.</p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl std::fmt::Debug for ModelDataQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDataQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`ModelDataQuality`](crate::model::ModelDataQuality)
pub mod model_data_quality {
    /// A builder for [`ModelDataQuality`](crate::model::ModelDataQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>Data quality statistics for a model.</p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>Data quality constraints for a model.</p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDataQuality`](crate::model::ModelDataQuality)
        pub fn build(self) -> crate::model::ModelDataQuality {
            crate::model::ModelDataQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl ModelDataQuality {
    /// Creates a new builder-style object to manufacture [`ModelDataQuality`](crate::model::ModelDataQuality)
    pub fn builder() -> crate::model::model_data_quality::Builder {
        crate::model::model_data_quality::Builder::default()
    }
}

/// <p>Model quality statistics and constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQuality {
    /// <p>Model quality statistics.</p>
    pub statistics: std::option::Option<crate::model::MetricsSource>,
    /// <p>Model quality constraints.</p>
    pub constraints: std::option::Option<crate::model::MetricsSource>,
}
impl std::fmt::Debug for ModelQuality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQuality");
        formatter.field("statistics", &self.statistics);
        formatter.field("constraints", &self.constraints);
        formatter.finish()
    }
}
/// See [`ModelQuality`](crate::model::ModelQuality)
pub mod model_quality {
    /// A builder for [`ModelQuality`](crate::model::ModelQuality)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statistics: std::option::Option<crate::model::MetricsSource>,
        pub(crate) constraints: std::option::Option<crate::model::MetricsSource>,
    }
    impl Builder {
        /// <p>Model quality statistics.</p>
        pub fn statistics(mut self, input: crate::model::MetricsSource) -> Self {
            self.statistics = Some(input);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>Model quality constraints.</p>
        pub fn constraints(mut self, input: crate::model::MetricsSource) -> Self {
            self.constraints = Some(input);
            self
        }
        pub fn set_constraints(
            mut self,
            input: std::option::Option<crate::model::MetricsSource>,
        ) -> Self {
            self.constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQuality`](crate::model::ModelQuality)
        pub fn build(self) -> crate::model::ModelQuality {
            crate::model::ModelQuality {
                statistics: self.statistics,
                constraints: self.constraints,
            }
        }
    }
}
impl ModelQuality {
    /// Creates a new builder-style object to manufacture [`ModelQuality`](crate::model::ModelQuality)
    pub fn builder() -> crate::model::model_quality::Builder {
        crate::model::model_quality::Builder::default()
    }
}

/// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetadataProperties {
    /// <p>The commit ID.</p>
    pub commit_id: std::option::Option<std::string::String>,
    /// <p>The repository.</p>
    pub repository: std::option::Option<std::string::String>,
    /// <p>The entity this entity was generated by.</p>
    pub generated_by: std::option::Option<std::string::String>,
    /// <p>The project ID.</p>
    pub project_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetadataProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetadataProperties");
        formatter.field("commit_id", &self.commit_id);
        formatter.field("repository", &self.repository);
        formatter.field("generated_by", &self.generated_by);
        formatter.field("project_id", &self.project_id);
        formatter.finish()
    }
}
/// See [`MetadataProperties`](crate::model::MetadataProperties)
pub mod metadata_properties {
    /// A builder for [`MetadataProperties`](crate::model::MetadataProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) commit_id: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) generated_by: std::option::Option<std::string::String>,
        pub(crate) project_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The commit ID.</p>
        pub fn commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.commit_id = Some(input.into());
            self
        }
        pub fn set_commit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.commit_id = input;
            self
        }
        /// <p>The repository.</p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The entity this entity was generated by.</p>
        pub fn generated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_by = Some(input.into());
            self
        }
        pub fn set_generated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.generated_by = input;
            self
        }
        /// <p>The project ID.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MetadataProperties`](crate::model::MetadataProperties)
        pub fn build(self) -> crate::model::MetadataProperties {
            crate::model::MetadataProperties {
                commit_id: self.commit_id,
                repository: self.repository,
                generated_by: self.generated_by,
                project_id: self.project_id,
            }
        }
    }
}
impl MetadataProperties {
    /// Creates a new builder-style object to manufacture [`MetadataProperties`](crate::model::MetadataProperties)
    pub fn builder() -> crate::model::metadata_properties::Builder {
        crate::model::metadata_properties::Builder::default()
    }
}

/// <p>Specifies the validation and image scan statuses of the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageStatusDetails {
    /// <p>The validation status of the model package.</p>
    pub validation_statuses:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
    /// <p>The status of the scan of the Docker image container for the model package.</p>
    pub image_scan_statuses:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
}
impl std::fmt::Debug for ModelPackageStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageStatusDetails");
        formatter.field("validation_statuses", &self.validation_statuses);
        formatter.field("image_scan_statuses", &self.image_scan_statuses);
        formatter.finish()
    }
}
/// See [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
pub mod model_package_status_details {
    /// A builder for [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_statuses:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        pub(crate) image_scan_statuses:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
    }
    impl Builder {
        pub fn validation_statuses(
            mut self,
            input: impl Into<crate::model::ModelPackageStatusItem>,
        ) -> Self {
            let mut v = self.validation_statuses.unwrap_or_default();
            v.push(input.into());
            self.validation_statuses = Some(v);
            self
        }
        pub fn set_validation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        ) -> Self {
            self.validation_statuses = input;
            self
        }
        pub fn image_scan_statuses(
            mut self,
            input: impl Into<crate::model::ModelPackageStatusItem>,
        ) -> Self {
            let mut v = self.image_scan_statuses.unwrap_or_default();
            v.push(input.into());
            self.image_scan_statuses = Some(v);
            self
        }
        pub fn set_image_scan_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageStatusItem>>,
        ) -> Self {
            self.image_scan_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
        pub fn build(self) -> crate::model::ModelPackageStatusDetails {
            crate::model::ModelPackageStatusDetails {
                validation_statuses: self.validation_statuses,
                image_scan_statuses: self.image_scan_statuses,
            }
        }
    }
}
impl ModelPackageStatusDetails {
    /// Creates a new builder-style object to manufacture [`ModelPackageStatusDetails`](crate::model::ModelPackageStatusDetails)
    pub fn builder() -> crate::model::model_package_status_details::Builder {
        crate::model::model_package_status_details::Builder::default()
    }
}

/// <p>Represents the overall status of a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageStatusItem {
    /// <p>The name of the model package for which the overall status is being reported.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status.</p>
    pub status: std::option::Option<crate::model::DetailedModelPackageStatus>,
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelPackageStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageStatusItem");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
pub mod model_package_status_item {
    /// A builder for [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DetailedModelPackageStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the model package for which the overall status is being reported.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current status.</p>
        pub fn status(mut self, input: crate::model::DetailedModelPackageStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DetailedModelPackageStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
        pub fn build(self) -> crate::model::ModelPackageStatusItem {
            crate::model::ModelPackageStatusItem {
                name: self.name,
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl ModelPackageStatusItem {
    /// Creates a new builder-style object to manufacture [`ModelPackageStatusItem`](crate::model::ModelPackageStatusItem)
    pub fn builder() -> crate::model::model_package_status_item::Builder {
        crate::model::model_package_status_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetailedModelPackageStatus {
    Completed,
    Failed,
    InProgress,
    NotStarted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DetailedModelPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => DetailedModelPackageStatus::Completed,
            "Failed" => DetailedModelPackageStatus::Failed,
            "InProgress" => DetailedModelPackageStatus::InProgress,
            "NotStarted" => DetailedModelPackageStatus::NotStarted,
            other => DetailedModelPackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DetailedModelPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetailedModelPackageStatus::from(s))
    }
}
impl DetailedModelPackageStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DetailedModelPackageStatus::Completed => "Completed",
            DetailedModelPackageStatus::Failed => "Failed",
            DetailedModelPackageStatus::InProgress => "InProgress",
            DetailedModelPackageStatus::NotStarted => "NotStarted",
            DetailedModelPackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "NotStarted"]
    }
}
impl AsRef<str> for DetailedModelPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageStatus {
    Completed,
    Deleting,
    Failed,
    InProgress,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ModelPackageStatus::Completed,
            "Deleting" => ModelPackageStatus::Deleting,
            "Failed" => ModelPackageStatus::Failed,
            "InProgress" => ModelPackageStatus::InProgress,
            "Pending" => ModelPackageStatus::Pending,
            other => ModelPackageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageStatus::from(s))
    }
}
impl ModelPackageStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageStatus::Completed => "Completed",
            ModelPackageStatus::Deleting => "Deleting",
            ModelPackageStatus::Failed => "Failed",
            ModelPackageStatus::InProgress => "InProgress",
            ModelPackageStatus::Pending => "Pending",
            ModelPackageStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Deleting", "Failed", "InProgress", "Pending"]
    }
}
impl AsRef<str> for ModelPackageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies batch transform jobs that Amazon SageMaker runs to validate your model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageValidationSpecification {
    /// <p>The IAM roles to be used for the validation of the model package.</p>
    pub validation_role: std::option::Option<std::string::String>,
    /// <p>An array of <code>ModelPackageValidationProfile</code> objects, each of which
    /// specifies a batch transform job that Amazon SageMaker runs to validate your model package.</p>
    pub validation_profiles:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
}
impl std::fmt::Debug for ModelPackageValidationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageValidationSpecification");
        formatter.field("validation_role", &self.validation_role);
        formatter.field("validation_profiles", &self.validation_profiles);
        formatter.finish()
    }
}
/// See [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
pub mod model_package_validation_specification {
    /// A builder for [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_role: std::option::Option<std::string::String>,
        pub(crate) validation_profiles:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
    }
    impl Builder {
        /// <p>The IAM roles to be used for the validation of the model package.</p>
        pub fn validation_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_role = Some(input.into());
            self
        }
        pub fn set_validation_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_role = input;
            self
        }
        pub fn validation_profiles(
            mut self,
            input: impl Into<crate::model::ModelPackageValidationProfile>,
        ) -> Self {
            let mut v = self.validation_profiles.unwrap_or_default();
            v.push(input.into());
            self.validation_profiles = Some(v);
            self
        }
        pub fn set_validation_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelPackageValidationProfile>>,
        ) -> Self {
            self.validation_profiles = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
        pub fn build(self) -> crate::model::ModelPackageValidationSpecification {
            crate::model::ModelPackageValidationSpecification {
                validation_role: self.validation_role,
                validation_profiles: self.validation_profiles,
            }
        }
    }
}
impl ModelPackageValidationSpecification {
    /// Creates a new builder-style object to manufacture [`ModelPackageValidationSpecification`](crate::model::ModelPackageValidationSpecification)
    pub fn builder() -> crate::model::model_package_validation_specification::Builder {
        crate::model::model_package_validation_specification::Builder::default()
    }
}

/// <p>Contains data, such as the inputs and targeted instance types that are used in the
/// process of validating the model package.</p>
/// <p>The data provided in the validation profile is made available to your buyers on Amazon Web Services
/// Marketplace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageValidationProfile {
    /// <p>The name of the profile for the model package.</p>
    pub profile_name: std::option::Option<std::string::String>,
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used
    /// for the validation of the model package.</p>
    pub transform_job_definition: std::option::Option<crate::model::TransformJobDefinition>,
}
impl std::fmt::Debug for ModelPackageValidationProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageValidationProfile");
        formatter.field("profile_name", &self.profile_name);
        formatter.field("transform_job_definition", &self.transform_job_definition);
        formatter.finish()
    }
}
/// See [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
pub mod model_package_validation_profile {
    /// A builder for [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_definition:
            std::option::Option<crate::model::TransformJobDefinition>,
    }
    impl Builder {
        /// <p>The name of the profile for the model package.</p>
        pub fn profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_name = Some(input.into());
            self
        }
        pub fn set_profile_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_name = input;
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job used
        /// for the validation of the model package.</p>
        pub fn transform_job_definition(
            mut self,
            input: crate::model::TransformJobDefinition,
        ) -> Self {
            self.transform_job_definition = Some(input);
            self
        }
        pub fn set_transform_job_definition(
            mut self,
            input: std::option::Option<crate::model::TransformJobDefinition>,
        ) -> Self {
            self.transform_job_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
        pub fn build(self) -> crate::model::ModelPackageValidationProfile {
            crate::model::ModelPackageValidationProfile {
                profile_name: self.profile_name,
                transform_job_definition: self.transform_job_definition,
            }
        }
    }
}
impl ModelPackageValidationProfile {
    /// Creates a new builder-style object to manufacture [`ModelPackageValidationProfile`](crate::model::ModelPackageValidationProfile)
    pub fn builder() -> crate::model::model_package_validation_profile::Builder {
        crate::model::model_package_validation_profile::Builder::default()
    }
}

/// <p>Defines the input needed to run a transform job using the inference specification
/// specified in the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobDefinition {
    /// <p>The maximum number of parallel requests that can be sent to each instance in a
    /// transform job. The default value is 1.</p>
    pub max_concurrent_transforms: std::option::Option<i32>,
    /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record
    /// (without metadata).</p>
    pub max_payload_in_mb: std::option::Option<i32>,
    /// <p>A string that determines the number of records included in a single mini-batch.</p>
    /// <p>
    /// <code>SingleRecord</code> means only one record is used per mini-batch.
    /// <code>MultiRecord</code> means a mini-batch is set to contain as many records that
    /// can fit within the <code>MaxPayloadInMB</code> limit.</p>
    pub batch_strategy: std::option::Option<crate::model::BatchStrategy>,
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and
    /// values entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A description of the input source and the way the transform job consumes it.</p>
    pub transform_input: std::option::Option<crate::model::TransformInput>,
    /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results
    /// from the transform job.</p>
    pub transform_output: std::option::Option<crate::model::TransformOutput>,
    /// <p>Identifies the ML compute instances for the transform job.</p>
    pub transform_resources: std::option::Option<crate::model::TransformResources>,
}
impl std::fmt::Debug for TransformJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobDefinition");
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.finish()
    }
}
/// See [`TransformJobDefinition`](crate::model::TransformJobDefinition)
pub mod transform_job_definition {
    /// A builder for [`TransformJobDefinition`](crate::model::TransformJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_concurrent_transforms: std::option::Option<i32>,
        pub(crate) max_payload_in_mb: std::option::Option<i32>,
        pub(crate) batch_strategy: std::option::Option<crate::model::BatchStrategy>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transform_input: std::option::Option<crate::model::TransformInput>,
        pub(crate) transform_output: std::option::Option<crate::model::TransformOutput>,
        pub(crate) transform_resources: std::option::Option<crate::model::TransformResources>,
    }
    impl Builder {
        /// <p>The maximum number of parallel requests that can be sent to each instance in a
        /// transform job. The default value is 1.</p>
        pub fn max_concurrent_transforms(mut self, input: i32) -> Self {
            self.max_concurrent_transforms = Some(input);
            self
        }
        pub fn set_max_concurrent_transforms(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_transforms = input;
            self
        }
        /// <p>The maximum payload size allowed, in MB. A payload is the data portion of a record
        /// (without metadata).</p>
        pub fn max_payload_in_mb(mut self, input: i32) -> Self {
            self.max_payload_in_mb = Some(input);
            self
        }
        pub fn set_max_payload_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.max_payload_in_mb = input;
            self
        }
        /// <p>A string that determines the number of records included in a single mini-batch.</p>
        /// <p>
        /// <code>SingleRecord</code> means only one record is used per mini-batch.
        /// <code>MultiRecord</code> means a mini-batch is set to contain as many records that
        /// can fit within the <code>MaxPayloadInMB</code> limit.</p>
        pub fn batch_strategy(mut self, input: crate::model::BatchStrategy) -> Self {
            self.batch_strategy = Some(input);
            self
        }
        pub fn set_batch_strategy(
            mut self,
            input: std::option::Option<crate::model::BatchStrategy>,
        ) -> Self {
            self.batch_strategy = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>A description of the input source and the way the transform job consumes it.</p>
        pub fn transform_input(mut self, input: crate::model::TransformInput) -> Self {
            self.transform_input = Some(input);
            self
        }
        pub fn set_transform_input(
            mut self,
            input: std::option::Option<crate::model::TransformInput>,
        ) -> Self {
            self.transform_input = input;
            self
        }
        /// <p>Identifies the Amazon S3 location where you want Amazon SageMaker to save the results
        /// from the transform job.</p>
        pub fn transform_output(mut self, input: crate::model::TransformOutput) -> Self {
            self.transform_output = Some(input);
            self
        }
        pub fn set_transform_output(
            mut self,
            input: std::option::Option<crate::model::TransformOutput>,
        ) -> Self {
            self.transform_output = input;
            self
        }
        /// <p>Identifies the ML compute instances for the transform job.</p>
        pub fn transform_resources(mut self, input: crate::model::TransformResources) -> Self {
            self.transform_resources = Some(input);
            self
        }
        pub fn set_transform_resources(
            mut self,
            input: std::option::Option<crate::model::TransformResources>,
        ) -> Self {
            self.transform_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobDefinition`](crate::model::TransformJobDefinition)
        pub fn build(self) -> crate::model::TransformJobDefinition {
            crate::model::TransformJobDefinition {
                max_concurrent_transforms: self.max_concurrent_transforms,
                max_payload_in_mb: self.max_payload_in_mb,
                batch_strategy: self.batch_strategy,
                environment: self.environment,
                transform_input: self.transform_input,
                transform_output: self.transform_output,
                transform_resources: self.transform_resources,
            }
        }
    }
}
impl TransformJobDefinition {
    /// Creates a new builder-style object to manufacture [`TransformJobDefinition`](crate::model::TransformJobDefinition)
    pub fn builder() -> crate::model::transform_job_definition::Builder {
        crate::model::transform_job_definition::Builder::default()
    }
}

/// <p>Describes the resources, including ML instance types and ML instance count, to use for
/// transform job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformResources {
    /// <p>The ML compute instance type for the transform job. If you are using built-in
    /// algorithms to
    /// transform
    /// moderately sized datasets, we recommend using ml.m4.xlarge or
    /// <code>ml.m5.large</code>instance types.</p>
    pub instance_type: std::option::Option<crate::model::TransformInstanceType>,
    /// <p>The number of
    /// ML
    /// compute instances to use in the transform job. For distributed
    /// transform jobs, specify a value greater than 1. The default value is
    /// <code>1</code>.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume
    /// attached to the ML compute instance(s) that run the batch transform job.</p>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance
    /// type. Local storage volumes are encrypted using a hardware module on the instance.
    /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
    /// local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
    /// Instance Store Volumes</a>.</p>
    /// </note>
    /// <p>
    /// The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Key ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name: <code>alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransformResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformResources");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`TransformResources`](crate::model::TransformResources)
pub mod transform_resources {
    /// A builder for [`TransformResources`](crate::model::TransformResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::TransformInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ML compute instance type for the transform job. If you are using built-in
        /// algorithms to
        /// transform
        /// moderately sized datasets, we recommend using ml.m4.xlarge or
        /// <code>ml.m5.large</code>instance types.</p>
        pub fn instance_type(mut self, input: crate::model::TransformInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::TransformInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of
        /// ML
        /// compute instances to use in the transform job. For distributed
        /// transform jobs, specify a value greater than 1. The default value is
        /// <code>1</code>.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume
        /// attached to the ML compute instance(s) that run the batch transform job.</p>
        /// <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance
        /// type. Local storage volumes are encrypted using a hardware module on the instance.
        /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
        /// local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
        /// Instance Store Volumes</a>.</p>
        /// </note>
        /// <p>
        /// The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Key ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name: <code>alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformResources`](crate::model::TransformResources)
        pub fn build(self) -> crate::model::TransformResources {
            crate::model::TransformResources {
                instance_type: self.instance_type,
                instance_count: self.instance_count,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl TransformResources {
    /// Creates a new builder-style object to manufacture [`TransformResources`](crate::model::TransformResources)
    pub fn builder() -> crate::model::transform_resources::Builder {
        crate::model::transform_resources::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformInstanceType {
    MlC42Xlarge,
    MlC44Xlarge,
    MlC48Xlarge,
    MlC4Xlarge,
    MlC518Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Xlarge,
    MlG4Dn12Xlarge,
    MlG4Dn16Xlarge,
    MlG4Dn2Xlarge,
    MlG4Dn4Xlarge,
    MlG4Dn8Xlarge,
    MlG4DnXlarge,
    MlM410Xlarge,
    MlM416Xlarge,
    MlM42Xlarge,
    MlM44Xlarge,
    MlM4Xlarge,
    MlM512Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM5Large,
    MlM5Xlarge,
    MlP216Xlarge,
    MlP28Xlarge,
    MlP2Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransformInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => TransformInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => TransformInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => TransformInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => TransformInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => TransformInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => TransformInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => TransformInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => TransformInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => TransformInstanceType::MlC5Xlarge,
            "ml.g4dn.12xlarge" => TransformInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => TransformInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => TransformInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => TransformInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => TransformInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => TransformInstanceType::MlG4DnXlarge,
            "ml.m4.10xlarge" => TransformInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => TransformInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => TransformInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => TransformInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => TransformInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => TransformInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => TransformInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => TransformInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => TransformInstanceType::MlM54Xlarge,
            "ml.m5.large" => TransformInstanceType::MlM5Large,
            "ml.m5.xlarge" => TransformInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => TransformInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => TransformInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => TransformInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => TransformInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => TransformInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => TransformInstanceType::MlP38Xlarge,
            other => TransformInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransformInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformInstanceType::from(s))
    }
}
impl TransformInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            TransformInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            TransformInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            TransformInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            TransformInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            TransformInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            TransformInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            TransformInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            TransformInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            TransformInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            TransformInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            TransformInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            TransformInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            TransformInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            TransformInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            TransformInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            TransformInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            TransformInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            TransformInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            TransformInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            TransformInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            TransformInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            TransformInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            TransformInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            TransformInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            TransformInstanceType::MlM5Large => "ml.m5.large",
            TransformInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            TransformInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            TransformInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            TransformInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            TransformInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            TransformInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            TransformInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            TransformInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
        ]
    }
}
impl AsRef<str> for TransformInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the results of a transform job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformOutput {
    /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For
    /// example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    /// <p>For every S3 object used as input for the transform job, batch transform stores the
    /// transformed data with an .<code>out</code> suffix in a corresponding subfolder in the
    /// location in the output prefix. For example, for the input data stored at
    /// <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform
    /// stores the transformed data at
    /// <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>.
    /// Batch transform doesn't upload partially processed objects. For an input S3 object that
    /// contains multiple records, it creates an .<code>out</code> file only if the transform
    /// job succeeds on the entire file. When the input contains multiple S3 objects, the batch
    /// transform job processes the listed S3 objects and uploads only the output for
    /// successfully processed objects. If any object fails in the transform job batch transform
    /// marks the job as failed to prompt investigation.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http
    /// call to transfer data from the transform job.</p>
    pub accept: std::option::Option<std::string::String>,
    /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose
    /// a format that is most convenient to you. To concatenate the results in binary format,
    /// specify <code>None</code>. To add a newline character at the end of every transformed
    /// record, specify
    /// <code>Line</code>.</p>
    pub assemble_with: std::option::Option<crate::model::AssemblyType>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using
    /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
    /// formats: </p>
    /// <ul>
    /// <li>
    /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Key ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name: <code>alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your
    /// role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the
    /// <i>Amazon Simple Storage Service
    /// Developer Guide.</i>
    /// </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
    /// <a>CreateModel</a> request. For more information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using
    /// Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer
    /// Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransformOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformOutput");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("accept", &self.accept);
        formatter.field("assemble_with", &self.assemble_with);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`TransformOutput`](crate::model::TransformOutput)
pub mod transform_output {
    /// A builder for [`TransformOutput`](crate::model::TransformOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) accept: std::option::Option<std::string::String>,
        pub(crate) assemble_with: std::option::Option<crate::model::AssemblyType>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job. For
        /// example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        /// <p>For every S3 object used as input for the transform job, batch transform stores the
        /// transformed data with an .<code>out</code> suffix in a corresponding subfolder in the
        /// location in the output prefix. For example, for the input data stored at
        /// <code>s3://bucket-name/input-name-prefix/dataset01/data.csv</code>, batch transform
        /// stores the transformed data at
        /// <code>s3://bucket-name/output-name-prefix/input-name-prefix/data.csv.out</code>.
        /// Batch transform doesn't upload partially processed objects. For an input S3 object that
        /// contains multiple records, it creates an .<code>out</code> file only if the transform
        /// job succeeds on the entire file. When the input contains multiple S3 objects, the batch
        /// transform job processes the listed S3 objects and uploads only the output for
        /// successfully processed objects. If any object fails in the transform job batch transform
        /// marks the job as failed to prompt investigation.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http
        /// call to transfer data from the transform job.</p>
        pub fn accept(mut self, input: impl Into<std::string::String>) -> Self {
            self.accept = Some(input.into());
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accept = input;
            self
        }
        /// <p>Defines how to assemble the results of the transform job as a single S3 object. Choose
        /// a format that is most convenient to you. To concatenate the results in binary format,
        /// specify <code>None</code>. To add a newline character at the end of every transformed
        /// record, specify
        /// <code>Line</code>.</p>
        pub fn assemble_with(mut self, input: crate::model::AssemblyType) -> Self {
            self.assemble_with = Some(input);
            self
        }
        pub fn set_assemble_with(
            mut self,
            input: std::option::Option<crate::model::AssemblyType>,
        ) -> Self {
            self.assemble_with = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using
        /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
        /// formats: </p>
        /// <ul>
        /// <li>
        /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Key ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name: <code>alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your
        /// role's account. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the
        /// <i>Amazon Simple Storage Service
        /// Developer Guide.</i>
        /// </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
        /// <a>CreateModel</a> request. For more information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using
        /// Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer
        /// Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformOutput`](crate::model::TransformOutput)
        pub fn build(self) -> crate::model::TransformOutput {
            crate::model::TransformOutput {
                s3_output_path: self.s3_output_path,
                accept: self.accept,
                assemble_with: self.assemble_with,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl TransformOutput {
    /// Creates a new builder-style object to manufacture [`TransformOutput`](crate::model::TransformOutput)
    pub fn builder() -> crate::model::transform_output::Builder {
        crate::model::transform_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssemblyType {
    Line,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssemblyType {
    fn from(s: &str) -> Self {
        match s {
            "Line" => AssemblyType::Line,
            "None" => AssemblyType::None,
            other => AssemblyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssemblyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssemblyType::from(s))
    }
}
impl AssemblyType {
    pub fn as_str(&self) -> &str {
        match self {
            AssemblyType::Line => "Line",
            AssemblyType::None => "None",
            AssemblyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Line", "None"]
    }
}
impl AsRef<str> for AssemblyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the input source of a transform job and the way the transform job consumes
/// it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformInput {
    /// <p>Describes the location of
    /// the
    /// channel data, which is, the S3 location of the input data that the
    /// model can consume.</p>
    pub data_source: std::option::Option<crate::model::TransformDataSource>,
    /// <p>The multipurpose internet mail extension
    /// (MIME)
    /// type of the data. Amazon SageMaker uses the MIME type with each http call to
    /// transfer data to the transform job.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>If your transform data
    /// is
    /// compressed, specify the compression type. Amazon SageMaker automatically
    /// decompresses the data for the transform job accordingly. The default value is
    /// <code>None</code>.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>The method to use to split the transform job's data files into smaller batches.
    /// Splitting is necessary when the total size of each object is too large to fit in a
    /// single request. You can also use data splitting to improve performance by processing
    /// multiple concurrent mini-batches. The default value for <code>SplitType</code> is
    /// <code>None</code>, which indicates that input data files are not split, and request
    /// payloads contain the entire contents of an input object. Set the value of this parameter
    /// to <code>Line</code> to split records on a newline character boundary.
    /// <code>SplitType</code> also supports a number of record-oriented binary data
    /// formats. Currently, the supported record formats are:</p>
    /// <ul>
    /// <li>
    /// <p>RecordIO</p>
    /// </li>
    /// <li>
    /// <p>TFRecord</p>
    /// </li>
    /// </ul>
    /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the
    /// <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the
    /// value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum
    /// number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the
    /// value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual
    /// records in each request.</p>
    /// <note>
    /// <p>Some data formats represent a record as a binary payload wrapped with extra
    /// padding bytes. When splitting is applied to a binary data format, padding is removed
    /// if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>.
    /// Padding is not removed if the value of <code>BatchStrategy</code> is set to
    /// <code>MultiRecord</code>.</p>
    /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using
    /// RecordIO</a> in the MXNet documentation. For more information about
    /// <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
    /// </note>
    pub split_type: std::option::Option<crate::model::SplitType>,
}
impl std::fmt::Debug for TransformInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformInput");
        formatter.field("data_source", &self.data_source);
        formatter.field("content_type", &self.content_type);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("split_type", &self.split_type);
        formatter.finish()
    }
}
/// See [`TransformInput`](crate::model::TransformInput)
pub mod transform_input {
    /// A builder for [`TransformInput`](crate::model::TransformInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::TransformDataSource>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) split_type: std::option::Option<crate::model::SplitType>,
    }
    impl Builder {
        /// <p>Describes the location of
        /// the
        /// channel data, which is, the S3 location of the input data that the
        /// model can consume.</p>
        pub fn data_source(mut self, input: crate::model::TransformDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::TransformDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The multipurpose internet mail extension
        /// (MIME)
        /// type of the data. Amazon SageMaker uses the MIME type with each http call to
        /// transfer data to the transform job.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>If your transform data
        /// is
        /// compressed, specify the compression type. Amazon SageMaker automatically
        /// decompresses the data for the transform job accordingly. The default value is
        /// <code>None</code>.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p>The method to use to split the transform job's data files into smaller batches.
        /// Splitting is necessary when the total size of each object is too large to fit in a
        /// single request. You can also use data splitting to improve performance by processing
        /// multiple concurrent mini-batches. The default value for <code>SplitType</code> is
        /// <code>None</code>, which indicates that input data files are not split, and request
        /// payloads contain the entire contents of an input object. Set the value of this parameter
        /// to <code>Line</code> to split records on a newline character boundary.
        /// <code>SplitType</code> also supports a number of record-oriented binary data
        /// formats. Currently, the supported record formats are:</p>
        /// <ul>
        /// <li>
        /// <p>RecordIO</p>
        /// </li>
        /// <li>
        /// <p>TFRecord</p>
        /// </li>
        /// </ul>
        /// <p>When splitting is enabled, the size of a mini-batch depends on the values of the
        /// <code>BatchStrategy</code> and <code>MaxPayloadInMB</code> parameters. When the
        /// value of <code>BatchStrategy</code> is <code>MultiRecord</code>, Amazon SageMaker sends the maximum
        /// number of records in each request, up to the <code>MaxPayloadInMB</code> limit. If the
        /// value of <code>BatchStrategy</code> is <code>SingleRecord</code>, Amazon SageMaker sends individual
        /// records in each request.</p>
        /// <note>
        /// <p>Some data formats represent a record as a binary payload wrapped with extra
        /// padding bytes. When splitting is applied to a binary data format, padding is removed
        /// if the value of <code>BatchStrategy</code> is set to <code>SingleRecord</code>.
        /// Padding is not removed if the value of <code>BatchStrategy</code> is set to
        /// <code>MultiRecord</code>.</p>
        /// <p>For more information about <code>RecordIO</code>, see <a href="https://mxnet.apache.org/api/faq/recordio">Create a Dataset Using
        /// RecordIO</a> in the MXNet documentation. For more information about
        /// <code>TFRecord</code>, see <a href="https://www.tensorflow.org/guide/data#consuming_tfrecord_data">Consuming TFRecord data</a> in the TensorFlow documentation.</p>
        /// </note>
        pub fn split_type(mut self, input: crate::model::SplitType) -> Self {
            self.split_type = Some(input);
            self
        }
        pub fn set_split_type(
            mut self,
            input: std::option::Option<crate::model::SplitType>,
        ) -> Self {
            self.split_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformInput`](crate::model::TransformInput)
        pub fn build(self) -> crate::model::TransformInput {
            crate::model::TransformInput {
                data_source: self.data_source,
                content_type: self.content_type,
                compression_type: self.compression_type,
                split_type: self.split_type,
            }
        }
    }
}
impl TransformInput {
    /// Creates a new builder-style object to manufacture [`TransformInput`](crate::model::TransformInput)
    pub fn builder() -> crate::model::transform_input::Builder {
        crate::model::transform_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SplitType {
    Line,
    None,
    Recordio,
    Tfrecord,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SplitType {
    fn from(s: &str) -> Self {
        match s {
            "Line" => SplitType::Line,
            "None" => SplitType::None,
            "RecordIO" => SplitType::Recordio,
            "TFRecord" => SplitType::Tfrecord,
            other => SplitType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SplitType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SplitType::from(s))
    }
}
impl SplitType {
    pub fn as_str(&self) -> &str {
        match self {
            SplitType::Line => "Line",
            SplitType::None => "None",
            SplitType::Recordio => "RecordIO",
            SplitType::Tfrecord => "TFRecord",
            SplitType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Line", "None", "RecordIO", "TFRecord"]
    }
}
impl AsRef<str> for SplitType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CompressionType {
    Gzip,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CompressionType {
    fn from(s: &str) -> Self {
        match s {
            "Gzip" => CompressionType::Gzip,
            "None" => CompressionType::None,
            other => CompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CompressionType::from(s))
    }
}
impl CompressionType {
    pub fn as_str(&self) -> &str {
        match self {
            CompressionType::Gzip => "Gzip",
            CompressionType::None => "None",
            CompressionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Gzip", "None"]
    }
}
impl AsRef<str> for CompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the location of the channel data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformDataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub s3_data_source: std::option::Option<crate::model::TransformS3DataSource>,
}
impl std::fmt::Debug for TransformDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.finish()
    }
}
/// See [`TransformDataSource`](crate::model::TransformDataSource)
pub mod transform_data_source {
    /// A builder for [`TransformDataSource`](crate::model::TransformDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::TransformS3DataSource>,
    }
    impl Builder {
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn s3_data_source(mut self, input: crate::model::TransformS3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::TransformS3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformDataSource`](crate::model::TransformDataSource)
        pub fn build(self) -> crate::model::TransformDataSource {
            crate::model::TransformDataSource {
                s3_data_source: self.s3_data_source,
            }
        }
    }
}
impl TransformDataSource {
    /// Creates a new builder-style object to manufacture [`TransformDataSource`](crate::model::TransformDataSource)
    pub fn builder() -> crate::model::transform_data_source::Builder {
        crate::model::transform_data_source::Builder::default()
    }
}

/// <p>Describes the S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformS3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix.
    /// Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that
    /// is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch
    /// transform. </p>
    /// <p>The following values are compatible: <code>ManifestFile</code>,
    /// <code>S3Prefix</code>
    /// </p>
    /// <p>The following value is not compatible: <code>AugmentedManifestFile</code>
    /// </p>
    pub s3_data_type: std::option::Option<crate::model::S3DataType>,
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a
    /// key name prefix or a manifest. For example:</p>
    /// <ul>
    /// <li>
    /// <p> A key name prefix might look like this:
    /// <code>s3://bucketname/exampleprefix</code>. </p>
    /// </li>
    /// <li>
    /// <p> A manifest might look like this:
    /// <code>s3://bucketname/example.manifest</code>
    /// </p>
    /// <p> The manifest is an S3 object which is a JSON file with the following format: </p>
    /// <p>
    /// <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code>
    /// </p>
    /// <p>
    /// <code>"relative/path/to/custdata-1",</code>
    /// </p>
    /// <p>
    /// <code>"relative/path/custdata-2",</code>
    /// </p>
    /// <p>
    /// <code>...</code>
    /// </p>
    /// <p>
    /// <code>"relative/path/custdata-N"</code>
    /// </p>
    /// <p>
    /// <code>]</code>
    /// </p>
    /// <p> The preceding JSON matches the following <code>S3Uris</code>: </p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code>
    /// </p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code>
    /// </p>
    /// <p>
    /// <code>...</code>
    /// </p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code>
    /// </p>
    /// <p> The complete set of <code>S3Uris</code> in this manifest constitutes the
    /// input data for the channel for this datasource. The object that each
    /// <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker
    /// uses to perform tasks on your behalf.</p>
    /// </li>
    /// </ul>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransformS3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformS3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`TransformS3DataSource`](crate::model::TransformS3DataSource)
pub mod transform_s3_data_source {
    /// A builder for [`TransformS3DataSource`](crate::model::TransformS3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::S3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix.
        /// Amazon SageMaker uses all objects with the specified key name prefix for batch transform. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that
        /// is a manifest file containing a list of object keys that you want Amazon SageMaker to use for batch
        /// transform. </p>
        /// <p>The following values are compatible: <code>ManifestFile</code>,
        /// <code>S3Prefix</code>
        /// </p>
        /// <p>The following value is not compatible: <code>AugmentedManifestFile</code>
        /// </p>
        pub fn s3_data_type(mut self, input: crate::model::S3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::S3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either a
        /// key name prefix or a manifest. For example:</p>
        /// <ul>
        /// <li>
        /// <p> A key name prefix might look like this:
        /// <code>s3://bucketname/exampleprefix</code>. </p>
        /// </li>
        /// <li>
        /// <p> A manifest might look like this:
        /// <code>s3://bucketname/example.manifest</code>
        /// </p>
        /// <p> The manifest is an S3 object which is a JSON file with the following format: </p>
        /// <p>
        /// <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code>
        /// </p>
        /// <p>
        /// <code>"relative/path/to/custdata-1",</code>
        /// </p>
        /// <p>
        /// <code>"relative/path/custdata-2",</code>
        /// </p>
        /// <p>
        /// <code>...</code>
        /// </p>
        /// <p>
        /// <code>"relative/path/custdata-N"</code>
        /// </p>
        /// <p>
        /// <code>]</code>
        /// </p>
        /// <p> The preceding JSON matches the following <code>S3Uris</code>: </p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code>
        /// </p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code>
        /// </p>
        /// <p>
        /// <code>...</code>
        /// </p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code>
        /// </p>
        /// <p> The complete set of <code>S3Uris</code> in this manifest constitutes the
        /// input data for the channel for this datasource. The object that each
        /// <code>S3Uris</code> points to must be readable by the IAM role that Amazon SageMaker
        /// uses to perform tasks on your behalf.</p>
        /// </li>
        /// </ul>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformS3DataSource`](crate::model::TransformS3DataSource)
        pub fn build(self) -> crate::model::TransformS3DataSource {
            crate::model::TransformS3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl TransformS3DataSource {
    /// Creates a new builder-style object to manufacture [`TransformS3DataSource`](crate::model::TransformS3DataSource)
    pub fn builder() -> crate::model::transform_s3_data_source::Builder {
        crate::model::transform_s3_data_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3DataType {
    AugmentedManifestFile,
    ManifestFile,
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3DataType {
    fn from(s: &str) -> Self {
        match s {
            "AugmentedManifestFile" => S3DataType::AugmentedManifestFile,
            "ManifestFile" => S3DataType::ManifestFile,
            "S3Prefix" => S3DataType::S3Prefix,
            other => S3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3DataType::from(s))
    }
}
impl S3DataType {
    pub fn as_str(&self) -> &str {
        match self {
            S3DataType::AugmentedManifestFile => "AugmentedManifestFile",
            S3DataType::ManifestFile => "ManifestFile",
            S3DataType::S3Prefix => "S3Prefix",
            S3DataType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AugmentedManifestFile", "ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for S3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchStrategy {
    MultiRecord,
    SingleRecord,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BatchStrategy {
    fn from(s: &str) -> Self {
        match s {
            "MultiRecord" => BatchStrategy::MultiRecord,
            "SingleRecord" => BatchStrategy::SingleRecord,
            other => BatchStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BatchStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatchStrategy::from(s))
    }
}
impl BatchStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            BatchStrategy::MultiRecord => "MultiRecord",
            BatchStrategy::SingleRecord => "SingleRecord",
            BatchStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["MultiRecord", "SingleRecord"]
    }
}
impl AsRef<str> for BatchStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of algorithms that were used to create a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAlgorithmSpecification {
    /// <p>A list of the algorithms that were used to create a model package.</p>
    pub source_algorithms: std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
}
impl std::fmt::Debug for SourceAlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAlgorithmSpecification");
        formatter.field("source_algorithms", &self.source_algorithms);
        formatter.finish()
    }
}
/// See [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
pub mod source_algorithm_specification {
    /// A builder for [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_algorithms:
            std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
    }
    impl Builder {
        pub fn source_algorithms(
            mut self,
            input: impl Into<crate::model::SourceAlgorithm>,
        ) -> Self {
            let mut v = self.source_algorithms.unwrap_or_default();
            v.push(input.into());
            self.source_algorithms = Some(v);
            self
        }
        pub fn set_source_algorithms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceAlgorithm>>,
        ) -> Self {
            self.source_algorithms = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
        pub fn build(self) -> crate::model::SourceAlgorithmSpecification {
            crate::model::SourceAlgorithmSpecification {
                source_algorithms: self.source_algorithms,
            }
        }
    }
}
impl SourceAlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`SourceAlgorithmSpecification`](crate::model::SourceAlgorithmSpecification)
    pub fn builder() -> crate::model::source_algorithm_specification::Builder {
        crate::model::source_algorithm_specification::Builder::default()
    }
}

/// <p>Specifies an algorithm that was used to create the model package. The algorithm must
/// be either an algorithm resource in your Amazon SageMaker account or an algorithm in Amazon Web Services Marketplace that you
/// are subscribed to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAlgorithm {
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored.
    /// This path must point to a single <code>gzip</code> compressed tar archive
    /// (<code>.tar.gz</code> suffix).</p>
    /// <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
    /// algorithm.</p>
    /// </note>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The name of an algorithm that was used to create the model package. The algorithm must
    /// be either an algorithm resource in your Amazon SageMaker account or an algorithm in Amazon Web Services Marketplace that you
    /// are subscribed to.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceAlgorithm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAlgorithm");
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.finish()
    }
}
/// See [`SourceAlgorithm`](crate::model::SourceAlgorithm)
pub mod source_algorithm {
    /// A builder for [`SourceAlgorithm`](crate::model::SourceAlgorithm)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored.
        /// This path must point to a single <code>gzip</code> compressed tar archive
        /// (<code>.tar.gz</code> suffix).</p>
        /// <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
        /// algorithm.</p>
        /// </note>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// <p>The name of an algorithm that was used to create the model package. The algorithm must
        /// be either an algorithm resource in your Amazon SageMaker account or an algorithm in Amazon Web Services Marketplace that you
        /// are subscribed to.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAlgorithm`](crate::model::SourceAlgorithm)
        pub fn build(self) -> crate::model::SourceAlgorithm {
            crate::model::SourceAlgorithm {
                model_data_url: self.model_data_url,
                algorithm_name: self.algorithm_name,
            }
        }
    }
}
impl SourceAlgorithm {
    /// Creates a new builder-style object to manufacture [`SourceAlgorithm`](crate::model::SourceAlgorithm)
    pub fn builder() -> crate::model::source_algorithm::Builder {
        crate::model::source_algorithm::Builder::default()
    }
}

/// <p>Defines how to perform inference generation after a training job is run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the inference code.</p>
    pub containers:
        std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
    /// <p>A list of the instance types on which a transformation job can be run or on which an
    /// endpoint can be deployed.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned
    /// models.</p>
    pub supported_transform_instance_types:
        std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
    /// <p>A list of the instance types that are used to generate inferences in real-time.</p>
    /// <p>This parameter is required for unversioned models, and optional for versioned
    /// models.</p>
    pub supported_realtime_inference_instance_types:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
    /// <p>The supported MIME types for the input data.</p>
    pub supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The supported MIME types for the output data.</p>
    pub supported_response_mime_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for InferenceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceSpecification");
        formatter.field("containers", &self.containers);
        formatter.field(
            "supported_transform_instance_types",
            &self.supported_transform_instance_types,
        );
        formatter.field(
            "supported_realtime_inference_instance_types",
            &self.supported_realtime_inference_instance_types,
        );
        formatter.field("supported_content_types", &self.supported_content_types);
        formatter.field(
            "supported_response_mime_types",
            &self.supported_response_mime_types,
        );
        formatter.finish()
    }
}
/// See [`InferenceSpecification`](crate::model::InferenceSpecification)
pub mod inference_specification {
    /// A builder for [`InferenceSpecification`](crate::model::InferenceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) containers:
            std::option::Option<std::vec::Vec<crate::model::ModelPackageContainerDefinition>>,
        pub(crate) supported_transform_instance_types:
            std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        pub(crate) supported_realtime_inference_instance_types:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        pub(crate) supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supported_response_mime_types:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn containers(
            mut self,
            input: impl Into<crate::model::ModelPackageContainerDefinition>,
        ) -> Self {
            let mut v = self.containers.unwrap_or_default();
            v.push(input.into());
            self.containers = Some(v);
            self
        }
        pub fn set_containers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ModelPackageContainerDefinition>,
            >,
        ) -> Self {
            self.containers = input;
            self
        }
        pub fn supported_transform_instance_types(
            mut self,
            input: impl Into<crate::model::TransformInstanceType>,
        ) -> Self {
            let mut v = self.supported_transform_instance_types.unwrap_or_default();
            v.push(input.into());
            self.supported_transform_instance_types = Some(v);
            self
        }
        pub fn set_supported_transform_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TransformInstanceType>>,
        ) -> Self {
            self.supported_transform_instance_types = input;
            self
        }
        pub fn supported_realtime_inference_instance_types(
            mut self,
            input: impl Into<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            let mut v = self
                .supported_realtime_inference_instance_types
                .unwrap_or_default();
            v.push(input.into());
            self.supported_realtime_inference_instance_types = Some(v);
            self
        }
        pub fn set_supported_realtime_inference_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantInstanceType>>,
        ) -> Self {
            self.supported_realtime_inference_instance_types = input;
            self
        }
        pub fn supported_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supported_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_content_types = Some(v);
            self
        }
        pub fn set_supported_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_content_types = input;
            self
        }
        pub fn supported_response_mime_types(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.supported_response_mime_types.unwrap_or_default();
            v.push(input.into());
            self.supported_response_mime_types = Some(v);
            self
        }
        pub fn set_supported_response_mime_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_response_mime_types = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceSpecification`](crate::model::InferenceSpecification)
        pub fn build(self) -> crate::model::InferenceSpecification {
            crate::model::InferenceSpecification {
                containers: self.containers,
                supported_transform_instance_types: self.supported_transform_instance_types,
                supported_realtime_inference_instance_types: self
                    .supported_realtime_inference_instance_types,
                supported_content_types: self.supported_content_types,
                supported_response_mime_types: self.supported_response_mime_types,
            }
        }
    }
}
impl InferenceSpecification {
    /// Creates a new builder-style object to manufacture [`InferenceSpecification`](crate::model::InferenceSpecification)
    pub fn builder() -> crate::model::inference_specification::Builder {
        crate::model::inference_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductionVariantInstanceType {
    MlC42Xlarge,
    MlC44Xlarge,
    MlC48Xlarge,
    MlC4Large,
    MlC4Xlarge,
    MlC518Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Large,
    MlC5Xlarge,
    MlC5D18Xlarge,
    MlC5D2Xlarge,
    MlC5D4Xlarge,
    MlC5D9Xlarge,
    MlC5DLarge,
    MlC5DXlarge,
    MlG4Dn12Xlarge,
    MlG4Dn16Xlarge,
    MlG4Dn2Xlarge,
    MlG4Dn4Xlarge,
    MlG4Dn8Xlarge,
    MlG4DnXlarge,
    MlInf124Xlarge,
    MlInf12Xlarge,
    MlInf16Xlarge,
    MlInf1Xlarge,
    MlM410Xlarge,
    MlM416Xlarge,
    MlM42Xlarge,
    MlM44Xlarge,
    MlM4Xlarge,
    MlM512Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM5Large,
    MlM5Xlarge,
    MlM5D12Xlarge,
    MlM5D24Xlarge,
    MlM5D2Xlarge,
    MlM5D4Xlarge,
    MlM5DLarge,
    MlM5DXlarge,
    MlP216Xlarge,
    MlP28Xlarge,
    MlP2Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    MlR512Xlarge,
    MlR524Xlarge,
    MlR52Xlarge,
    MlR54Xlarge,
    MlR5Large,
    MlR5Xlarge,
    MlR5D12Xlarge,
    MlR5D24Xlarge,
    MlR5D2Xlarge,
    MlR5D4Xlarge,
    MlR5DLarge,
    MlR5DXlarge,
    MlT22Xlarge,
    MlT2Large,
    MlT2Medium,
    MlT2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProductionVariantInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => ProductionVariantInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => ProductionVariantInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => ProductionVariantInstanceType::MlC48Xlarge,
            "ml.c4.large" => ProductionVariantInstanceType::MlC4Large,
            "ml.c4.xlarge" => ProductionVariantInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => ProductionVariantInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => ProductionVariantInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => ProductionVariantInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => ProductionVariantInstanceType::MlC59Xlarge,
            "ml.c5.large" => ProductionVariantInstanceType::MlC5Large,
            "ml.c5.xlarge" => ProductionVariantInstanceType::MlC5Xlarge,
            "ml.c5d.18xlarge" => ProductionVariantInstanceType::MlC5D18Xlarge,
            "ml.c5d.2xlarge" => ProductionVariantInstanceType::MlC5D2Xlarge,
            "ml.c5d.4xlarge" => ProductionVariantInstanceType::MlC5D4Xlarge,
            "ml.c5d.9xlarge" => ProductionVariantInstanceType::MlC5D9Xlarge,
            "ml.c5d.large" => ProductionVariantInstanceType::MlC5DLarge,
            "ml.c5d.xlarge" => ProductionVariantInstanceType::MlC5DXlarge,
            "ml.g4dn.12xlarge" => ProductionVariantInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => ProductionVariantInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => ProductionVariantInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => ProductionVariantInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => ProductionVariantInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => ProductionVariantInstanceType::MlG4DnXlarge,
            "ml.inf1.24xlarge" => ProductionVariantInstanceType::MlInf124Xlarge,
            "ml.inf1.2xlarge" => ProductionVariantInstanceType::MlInf12Xlarge,
            "ml.inf1.6xlarge" => ProductionVariantInstanceType::MlInf16Xlarge,
            "ml.inf1.xlarge" => ProductionVariantInstanceType::MlInf1Xlarge,
            "ml.m4.10xlarge" => ProductionVariantInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => ProductionVariantInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => ProductionVariantInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => ProductionVariantInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => ProductionVariantInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => ProductionVariantInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => ProductionVariantInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => ProductionVariantInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => ProductionVariantInstanceType::MlM54Xlarge,
            "ml.m5.large" => ProductionVariantInstanceType::MlM5Large,
            "ml.m5.xlarge" => ProductionVariantInstanceType::MlM5Xlarge,
            "ml.m5d.12xlarge" => ProductionVariantInstanceType::MlM5D12Xlarge,
            "ml.m5d.24xlarge" => ProductionVariantInstanceType::MlM5D24Xlarge,
            "ml.m5d.2xlarge" => ProductionVariantInstanceType::MlM5D2Xlarge,
            "ml.m5d.4xlarge" => ProductionVariantInstanceType::MlM5D4Xlarge,
            "ml.m5d.large" => ProductionVariantInstanceType::MlM5DLarge,
            "ml.m5d.xlarge" => ProductionVariantInstanceType::MlM5DXlarge,
            "ml.p2.16xlarge" => ProductionVariantInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => ProductionVariantInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => ProductionVariantInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => ProductionVariantInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => ProductionVariantInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => ProductionVariantInstanceType::MlP38Xlarge,
            "ml.r5.12xlarge" => ProductionVariantInstanceType::MlR512Xlarge,
            "ml.r5.24xlarge" => ProductionVariantInstanceType::MlR524Xlarge,
            "ml.r5.2xlarge" => ProductionVariantInstanceType::MlR52Xlarge,
            "ml.r5.4xlarge" => ProductionVariantInstanceType::MlR54Xlarge,
            "ml.r5.large" => ProductionVariantInstanceType::MlR5Large,
            "ml.r5.xlarge" => ProductionVariantInstanceType::MlR5Xlarge,
            "ml.r5d.12xlarge" => ProductionVariantInstanceType::MlR5D12Xlarge,
            "ml.r5d.24xlarge" => ProductionVariantInstanceType::MlR5D24Xlarge,
            "ml.r5d.2xlarge" => ProductionVariantInstanceType::MlR5D2Xlarge,
            "ml.r5d.4xlarge" => ProductionVariantInstanceType::MlR5D4Xlarge,
            "ml.r5d.large" => ProductionVariantInstanceType::MlR5DLarge,
            "ml.r5d.xlarge" => ProductionVariantInstanceType::MlR5DXlarge,
            "ml.t2.2xlarge" => ProductionVariantInstanceType::MlT22Xlarge,
            "ml.t2.large" => ProductionVariantInstanceType::MlT2Large,
            "ml.t2.medium" => ProductionVariantInstanceType::MlT2Medium,
            "ml.t2.xlarge" => ProductionVariantInstanceType::MlT2Xlarge,
            other => ProductionVariantInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProductionVariantInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductionVariantInstanceType::from(s))
    }
}
impl ProductionVariantInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            ProductionVariantInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            ProductionVariantInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            ProductionVariantInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            ProductionVariantInstanceType::MlC4Large => "ml.c4.large",
            ProductionVariantInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            ProductionVariantInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            ProductionVariantInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            ProductionVariantInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            ProductionVariantInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            ProductionVariantInstanceType::MlC5Large => "ml.c5.large",
            ProductionVariantInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            ProductionVariantInstanceType::MlC5D18Xlarge => "ml.c5d.18xlarge",
            ProductionVariantInstanceType::MlC5D2Xlarge => "ml.c5d.2xlarge",
            ProductionVariantInstanceType::MlC5D4Xlarge => "ml.c5d.4xlarge",
            ProductionVariantInstanceType::MlC5D9Xlarge => "ml.c5d.9xlarge",
            ProductionVariantInstanceType::MlC5DLarge => "ml.c5d.large",
            ProductionVariantInstanceType::MlC5DXlarge => "ml.c5d.xlarge",
            ProductionVariantInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            ProductionVariantInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            ProductionVariantInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            ProductionVariantInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            ProductionVariantInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            ProductionVariantInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            ProductionVariantInstanceType::MlInf124Xlarge => "ml.inf1.24xlarge",
            ProductionVariantInstanceType::MlInf12Xlarge => "ml.inf1.2xlarge",
            ProductionVariantInstanceType::MlInf16Xlarge => "ml.inf1.6xlarge",
            ProductionVariantInstanceType::MlInf1Xlarge => "ml.inf1.xlarge",
            ProductionVariantInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            ProductionVariantInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            ProductionVariantInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            ProductionVariantInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            ProductionVariantInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            ProductionVariantInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            ProductionVariantInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            ProductionVariantInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            ProductionVariantInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            ProductionVariantInstanceType::MlM5Large => "ml.m5.large",
            ProductionVariantInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            ProductionVariantInstanceType::MlM5D12Xlarge => "ml.m5d.12xlarge",
            ProductionVariantInstanceType::MlM5D24Xlarge => "ml.m5d.24xlarge",
            ProductionVariantInstanceType::MlM5D2Xlarge => "ml.m5d.2xlarge",
            ProductionVariantInstanceType::MlM5D4Xlarge => "ml.m5d.4xlarge",
            ProductionVariantInstanceType::MlM5DLarge => "ml.m5d.large",
            ProductionVariantInstanceType::MlM5DXlarge => "ml.m5d.xlarge",
            ProductionVariantInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            ProductionVariantInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            ProductionVariantInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            ProductionVariantInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            ProductionVariantInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            ProductionVariantInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            ProductionVariantInstanceType::MlR512Xlarge => "ml.r5.12xlarge",
            ProductionVariantInstanceType::MlR524Xlarge => "ml.r5.24xlarge",
            ProductionVariantInstanceType::MlR52Xlarge => "ml.r5.2xlarge",
            ProductionVariantInstanceType::MlR54Xlarge => "ml.r5.4xlarge",
            ProductionVariantInstanceType::MlR5Large => "ml.r5.large",
            ProductionVariantInstanceType::MlR5Xlarge => "ml.r5.xlarge",
            ProductionVariantInstanceType::MlR5D12Xlarge => "ml.r5d.12xlarge",
            ProductionVariantInstanceType::MlR5D24Xlarge => "ml.r5d.24xlarge",
            ProductionVariantInstanceType::MlR5D2Xlarge => "ml.r5d.2xlarge",
            ProductionVariantInstanceType::MlR5D4Xlarge => "ml.r5d.4xlarge",
            ProductionVariantInstanceType::MlR5DLarge => "ml.r5d.large",
            ProductionVariantInstanceType::MlR5DXlarge => "ml.r5d.xlarge",
            ProductionVariantInstanceType::MlT22Xlarge => "ml.t2.2xlarge",
            ProductionVariantInstanceType::MlT2Large => "ml.t2.large",
            ProductionVariantInstanceType::MlT2Medium => "ml.t2.medium",
            ProductionVariantInstanceType::MlT2Xlarge => "ml.t2.xlarge",
            ProductionVariantInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.large",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.large",
            "ml.c5.xlarge",
            "ml.c5d.18xlarge",
            "ml.c5d.2xlarge",
            "ml.c5d.4xlarge",
            "ml.c5d.9xlarge",
            "ml.c5d.large",
            "ml.c5d.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.inf1.24xlarge",
            "ml.inf1.2xlarge",
            "ml.inf1.6xlarge",
            "ml.inf1.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.m5d.12xlarge",
            "ml.m5d.24xlarge",
            "ml.m5d.2xlarge",
            "ml.m5d.4xlarge",
            "ml.m5d.large",
            "ml.m5d.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.r5.12xlarge",
            "ml.r5.24xlarge",
            "ml.r5.2xlarge",
            "ml.r5.4xlarge",
            "ml.r5.large",
            "ml.r5.xlarge",
            "ml.r5d.12xlarge",
            "ml.r5d.24xlarge",
            "ml.r5d.2xlarge",
            "ml.r5d.4xlarge",
            "ml.r5d.large",
            "ml.r5d.xlarge",
            "ml.t2.2xlarge",
            "ml.t2.large",
            "ml.t2.medium",
            "ml.t2.xlarge",
        ]
    }
}
impl AsRef<str> for ProductionVariantInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Docker container for the model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageContainerDefinition {
    /// <p>The DNS host name for the Docker container.</p>
    pub container_hostname: std::option::Option<std::string::String>,
    /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
    /// <p>If you are using your own custom algorithm instead of an algorithm provided by Amazon SageMaker,
    /// the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both
    /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
    /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
    /// SageMaker</a>.</p>
    pub image: std::option::Option<std::string::String>,
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for
    /// training.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored.
    /// This path must point to a single <code>gzip</code> compressed tar archive
    /// (<code>.tar.gz</code> suffix).</p>
    /// <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
    /// model package.</p>
    /// </note>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the Docker container. Each key and value in the
    /// <code>Environment</code> string to string map can have length of up to 1024. We
    /// support up to 16 entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ModelPackageContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageContainerDefinition");
        formatter.field("container_hostname", &self.container_hostname);
        formatter.field("image", &self.image);
        formatter.field("image_digest", &self.image_digest);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("product_id", &self.product_id);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
pub mod model_package_container_definition {
    /// A builder for [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_hostname: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The DNS host name for the Docker container.</p>
        pub fn container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_hostname = Some(input.into());
            self
        }
        pub fn set_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_hostname = input;
            self
        }
        /// <p>The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.</p>
        /// <p>If you are using your own custom algorithm instead of an algorithm provided by Amazon SageMaker,
        /// the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both
        /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
        /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
        /// SageMaker</a>.</p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for
        /// training.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        /// <p>The Amazon S3 path where the model artifacts, which result from model training, are stored.
        /// This path must point to a single <code>gzip</code> compressed tar archive
        /// (<code>.tar.gz</code> suffix).</p>
        /// <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
        /// model package.</p>
        /// </note>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        /// <p>The Amazon Web Services Marketplace product ID of the model package.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
        pub fn build(self) -> crate::model::ModelPackageContainerDefinition {
            crate::model::ModelPackageContainerDefinition {
                container_hostname: self.container_hostname,
                image: self.image,
                image_digest: self.image_digest,
                model_data_url: self.model_data_url,
                product_id: self.product_id,
                environment: self.environment,
            }
        }
    }
}
impl ModelPackageContainerDefinition {
    /// Creates a new builder-style object to manufacture [`ModelPackageContainerDefinition`](crate::model::ModelPackageContainerDefinition)
    pub fn builder() -> crate::model::model_package_container_definition::Builder {
        crate::model::model_package_container_definition::Builder::default()
    }
}

/// <p>A hosted endpoint for real-time inference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Endpoint {
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>The endpoint configuration associated with the endpoint.</p>
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>A list of the production variants hosted on the endpoint. Each production variant is a
    /// model.</p>
    pub production_variants:
        std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
    /// <p></p>
    pub data_capture_config: std::option::Option<crate::model::DataCaptureConfigSummary>,
    /// <p>The status of the endpoint.</p>
    pub endpoint_status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>If the endpoint failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the endpoint was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time the endpoint was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A list of monitoring schedules for the endpoint. For information about model
    /// monitoring, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model Monitor</a>.</p>
    pub monitoring_schedules: std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
    /// <p>A list of the tags associated with the endpoint. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
    /// resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Endpoint");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("production_variants", &self.production_variants);
        formatter.field("data_capture_config", &self.data_capture_config);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("monitoring_schedules", &self.monitoring_schedules);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Endpoint`](crate::model::Endpoint)
pub mod endpoint {
    /// A builder for [`Endpoint`](crate::model::Endpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
        pub(crate) endpoint_config_name: std::option::Option<std::string::String>,
        pub(crate) production_variants:
            std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
        pub(crate) data_capture_config: std::option::Option<crate::model::DataCaptureConfigSummary>,
        pub(crate) endpoint_status: std::option::Option<crate::model::EndpointStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring_schedules:
            std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// <p>The endpoint configuration associated with the endpoint.</p>
        pub fn endpoint_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_name = Some(input.into());
            self
        }
        pub fn set_endpoint_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_name = input;
            self
        }
        pub fn production_variants(
            mut self,
            input: impl Into<crate::model::ProductionVariantSummary>,
        ) -> Self {
            let mut v = self.production_variants.unwrap_or_default();
            v.push(input.into());
            self.production_variants = Some(v);
            self
        }
        pub fn set_production_variants(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductionVariantSummary>>,
        ) -> Self {
            self.production_variants = input;
            self
        }
        /// <p></p>
        pub fn data_capture_config(
            mut self,
            input: crate::model::DataCaptureConfigSummary,
        ) -> Self {
            self.data_capture_config = Some(input);
            self
        }
        pub fn set_data_capture_config(
            mut self,
            input: std::option::Option<crate::model::DataCaptureConfigSummary>,
        ) -> Self {
            self.data_capture_config = input;
            self
        }
        /// <p>The status of the endpoint.</p>
        pub fn endpoint_status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.endpoint_status = Some(input);
            self
        }
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>If the endpoint failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the endpoint was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the endpoint was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        pub fn monitoring_schedules(
            mut self,
            input: impl Into<crate::model::MonitoringSchedule>,
        ) -> Self {
            let mut v = self.monitoring_schedules.unwrap_or_default();
            v.push(input.into());
            self.monitoring_schedules = Some(v);
            self
        }
        pub fn set_monitoring_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MonitoringSchedule>>,
        ) -> Self {
            self.monitoring_schedules = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint)
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                endpoint_name: self.endpoint_name,
                endpoint_arn: self.endpoint_arn,
                endpoint_config_name: self.endpoint_config_name,
                production_variants: self.production_variants,
                data_capture_config: self.data_capture_config,
                endpoint_status: self.endpoint_status,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedules: self.monitoring_schedules,
                tags: self.tags,
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint)
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>A schedule for a model monitoring job. For information about model monitor, see
/// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-monitor.html">Amazon SageMaker Model
/// Monitor</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringSchedule {
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - The schedule is pending being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - The schedule failed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SCHEDULED</code> - The schedule was successfully created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPED</code> - The schedule was stopped.</p>
    /// </li>
    /// </ul>
    pub monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
    /// <p>The type of the monitoring job definition to schedule.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
    /// <p>If the monitoring schedule failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the monitoring schedule was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time the monitoring schedule was changed.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
    pub monitoring_schedule_config: std::option::Option<crate::model::MonitoringScheduleConfig>,
    /// <p>The endpoint that hosts the model being monitored.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Summary of information about the last monitoring job to run.</p>
    pub last_monitoring_execution_summary:
        std::option::Option<crate::model::MonitoringExecutionSummary>,
    /// <p>A list of the tags associated with the monitoring schedlue. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
    /// resources</a> in the <i>Amazon Web Services General Reference Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for MonitoringSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringSchedule");
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field(
            "monitoring_schedule_status",
            &self.monitoring_schedule_status,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_schedule_config",
            &self.monitoring_schedule_config,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "last_monitoring_execution_summary",
            &self.last_monitoring_execution_summary,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`MonitoringSchedule`](crate::model::MonitoringSchedule)
pub mod monitoring_schedule {
    /// A builder for [`MonitoringSchedule`](crate::model::MonitoringSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring_schedule_config:
            std::option::Option<crate::model::MonitoringScheduleConfig>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) last_monitoring_execution_summary:
            std::option::Option<crate::model::MonitoringExecutionSummary>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The status of the monitoring schedule. This can be one of the following values.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - The schedule is pending being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - The schedule failed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SCHEDULED</code> - The schedule was successfully created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPED</code> - The schedule was stopped.</p>
        /// </li>
        /// </ul>
        pub fn monitoring_schedule_status(mut self, input: crate::model::ScheduleStatus) -> Self {
            self.monitoring_schedule_status = Some(input);
            self
        }
        pub fn set_monitoring_schedule_status(
            mut self,
            input: std::option::Option<crate::model::ScheduleStatus>,
        ) -> Self {
            self.monitoring_schedule_status = input;
            self
        }
        /// <p>The type of the monitoring job definition to schedule.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// <p>If the monitoring schedule failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the monitoring schedule was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the monitoring schedule was changed.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Configures the monitoring schedule and defines the monitoring job.</p>
        pub fn monitoring_schedule_config(
            mut self,
            input: crate::model::MonitoringScheduleConfig,
        ) -> Self {
            self.monitoring_schedule_config = Some(input);
            self
        }
        pub fn set_monitoring_schedule_config(
            mut self,
            input: std::option::Option<crate::model::MonitoringScheduleConfig>,
        ) -> Self {
            self.monitoring_schedule_config = input;
            self
        }
        /// <p>The endpoint that hosts the model being monitored.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Summary of information about the last monitoring job to run.</p>
        pub fn last_monitoring_execution_summary(
            mut self,
            input: crate::model::MonitoringExecutionSummary,
        ) -> Self {
            self.last_monitoring_execution_summary = Some(input);
            self
        }
        pub fn set_last_monitoring_execution_summary(
            mut self,
            input: std::option::Option<crate::model::MonitoringExecutionSummary>,
        ) -> Self {
            self.last_monitoring_execution_summary = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringSchedule`](crate::model::MonitoringSchedule)
        pub fn build(self) -> crate::model::MonitoringSchedule {
            crate::model::MonitoringSchedule {
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                monitoring_schedule_name: self.monitoring_schedule_name,
                monitoring_schedule_status: self.monitoring_schedule_status,
                monitoring_type: self.monitoring_type,
                failure_reason: self.failure_reason,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedule_config: self.monitoring_schedule_config,
                endpoint_name: self.endpoint_name,
                last_monitoring_execution_summary: self.last_monitoring_execution_summary,
                tags: self.tags,
            }
        }
    }
}
impl MonitoringSchedule {
    /// Creates a new builder-style object to manufacture [`MonitoringSchedule`](crate::model::MonitoringSchedule)
    pub fn builder() -> crate::model::monitoring_schedule::Builder {
        crate::model::monitoring_schedule::Builder::default()
    }
}

/// <p>Summary of information about the last monitoring job to run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringExecutionSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The time the monitoring job was scheduled.</p>
    pub scheduled_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the monitoring job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the monitoring job.</p>
    pub monitoring_execution_status: std::option::Option<crate::model::ExecutionStatus>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the endpoint used to run the monitoring job.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>Contains the reason a monitoring job failed, if it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring job.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl std::fmt::Debug for MonitoringExecutionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringExecutionSummary");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field("scheduled_time", &self.scheduled_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_execution_status",
            &self.monitoring_execution_status,
        );
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
pub mod monitoring_execution_summary {
    /// A builder for [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring_execution_status: std::option::Option<crate::model::ExecutionStatus>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The time the monitoring job was scheduled.</p>
        pub fn scheduled_time(mut self, input: smithy_types::Instant) -> Self {
            self.scheduled_time = Some(input);
            self
        }
        pub fn set_scheduled_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.scheduled_time = input;
            self
        }
        /// <p>The time at which the monitoring job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that indicates the last time the monitoring job was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the monitoring job.</p>
        pub fn monitoring_execution_status(mut self, input: crate::model::ExecutionStatus) -> Self {
            self.monitoring_execution_status = Some(input);
            self
        }
        pub fn set_monitoring_execution_status(
            mut self,
            input: std::option::Option<crate::model::ExecutionStatus>,
        ) -> Self {
            self.monitoring_execution_status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The name of the endpoint used to run the monitoring job.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>Contains the reason a monitoring job failed, if it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The name of the monitoring job.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
        pub fn build(self) -> crate::model::MonitoringExecutionSummary {
            crate::model::MonitoringExecutionSummary {
                monitoring_schedule_name: self.monitoring_schedule_name,
                scheduled_time: self.scheduled_time,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_execution_status: self.monitoring_execution_status,
                processing_job_arn: self.processing_job_arn,
                endpoint_name: self.endpoint_name,
                failure_reason: self.failure_reason,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringExecutionSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringExecutionSummary`](crate::model::MonitoringExecutionSummary)
    pub fn builder() -> crate::model::monitoring_execution_summary::Builder {
        crate::model::monitoring_execution_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutionStatus {
    Completed,
    CompletedWithViolations,
    Failed,
    InProgress,
    Pending,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ExecutionStatus::Completed,
            "CompletedWithViolations" => ExecutionStatus::CompletedWithViolations,
            "Failed" => ExecutionStatus::Failed,
            "InProgress" => ExecutionStatus::InProgress,
            "Pending" => ExecutionStatus::Pending,
            "Stopped" => ExecutionStatus::Stopped,
            "Stopping" => ExecutionStatus::Stopping,
            other => ExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExecutionStatus::from(s))
    }
}
impl ExecutionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ExecutionStatus::Completed => "Completed",
            ExecutionStatus::CompletedWithViolations => "CompletedWithViolations",
            ExecutionStatus::Failed => "Failed",
            ExecutionStatus::InProgress => "InProgress",
            ExecutionStatus::Pending => "Pending",
            ExecutionStatus::Stopped => "Stopped",
            ExecutionStatus::Stopping => "Stopping",
            ExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "CompletedWithViolations",
            "Failed",
            "InProgress",
            "Pending",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for ExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleStatus {
    Failed,
    Pending,
    Scheduled,
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduleStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ScheduleStatus::Failed,
            "Pending" => ScheduleStatus::Pending,
            "Scheduled" => ScheduleStatus::Scheduled,
            "Stopped" => ScheduleStatus::Stopped,
            other => ScheduleStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduleStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleStatus::from(s))
    }
}
impl ScheduleStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleStatus::Failed => "Failed",
            ScheduleStatus::Pending => "Pending",
            ScheduleStatus::Scheduled => "Scheduled",
            ScheduleStatus::Stopped => "Stopped",
            ScheduleStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Failed", "Pending", "Scheduled", "Stopped"]
    }
}
impl AsRef<str> for ScheduleStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointStatus {
    Creating,
    Deleting,
    Failed,
    InService,
    OutOfService,
    RollingBack,
    SystemUpdating,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "Creating" => EndpointStatus::Creating,
            "Deleting" => EndpointStatus::Deleting,
            "Failed" => EndpointStatus::Failed,
            "InService" => EndpointStatus::InService,
            "OutOfService" => EndpointStatus::OutOfService,
            "RollingBack" => EndpointStatus::RollingBack,
            "SystemUpdating" => EndpointStatus::SystemUpdating,
            "Updating" => EndpointStatus::Updating,
            other => EndpointStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointStatus::from(s))
    }
}
impl EndpointStatus {
    pub fn as_str(&self) -> &str {
        match self {
            EndpointStatus::Creating => "Creating",
            EndpointStatus::Deleting => "Deleting",
            EndpointStatus::Failed => "Failed",
            EndpointStatus::InService => "InService",
            EndpointStatus::OutOfService => "OutOfService",
            EndpointStatus::RollingBack => "RollingBack",
            EndpointStatus::SystemUpdating => "SystemUpdating",
            EndpointStatus::Updating => "Updating",
            EndpointStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Creating",
            "Deleting",
            "Failed",
            "InService",
            "OutOfService",
            "RollingBack",
            "SystemUpdating",
            "Updating",
        ]
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCaptureConfigSummary {
    /// <p></p>
    pub enable_capture: bool,
    /// <p></p>
    pub capture_status: std::option::Option<crate::model::CaptureStatus>,
    /// <p></p>
    pub current_sampling_percentage: std::option::Option<i32>,
    /// <p></p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p></p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataCaptureConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCaptureConfigSummary");
        formatter.field("enable_capture", &self.enable_capture);
        formatter.field("capture_status", &self.capture_status);
        formatter.field(
            "current_sampling_percentage",
            &self.current_sampling_percentage,
        );
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
pub mod data_capture_config_summary {
    /// A builder for [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_capture: std::option::Option<bool>,
        pub(crate) capture_status: std::option::Option<crate::model::CaptureStatus>,
        pub(crate) current_sampling_percentage: std::option::Option<i32>,
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn enable_capture(mut self, input: bool) -> Self {
            self.enable_capture = Some(input);
            self
        }
        pub fn set_enable_capture(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_capture = input;
            self
        }
        /// <p></p>
        pub fn capture_status(mut self, input: crate::model::CaptureStatus) -> Self {
            self.capture_status = Some(input);
            self
        }
        pub fn set_capture_status(
            mut self,
            input: std::option::Option<crate::model::CaptureStatus>,
        ) -> Self {
            self.capture_status = input;
            self
        }
        /// <p></p>
        pub fn current_sampling_percentage(mut self, input: i32) -> Self {
            self.current_sampling_percentage = Some(input);
            self
        }
        pub fn set_current_sampling_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.current_sampling_percentage = input;
            self
        }
        /// <p></p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p></p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
        pub fn build(self) -> crate::model::DataCaptureConfigSummary {
            crate::model::DataCaptureConfigSummary {
                enable_capture: self.enable_capture.unwrap_or_default(),
                capture_status: self.capture_status,
                current_sampling_percentage: self.current_sampling_percentage,
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl DataCaptureConfigSummary {
    /// Creates a new builder-style object to manufacture [`DataCaptureConfigSummary`](crate::model::DataCaptureConfigSummary)
    pub fn builder() -> crate::model::data_capture_config_summary::Builder {
        crate::model::data_capture_config_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CaptureStatus {
    Started,
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CaptureStatus {
    fn from(s: &str) -> Self {
        match s {
            "Started" => CaptureStatus::Started,
            "Stopped" => CaptureStatus::Stopped,
            other => CaptureStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CaptureStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CaptureStatus::from(s))
    }
}
impl CaptureStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CaptureStatus::Started => "Started",
            CaptureStatus::Stopped => "Stopped",
            CaptureStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Started", "Stopped"]
    }
}
impl AsRef<str> for CaptureStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes weight and capacities for a production variant associated with an
/// endpoint. If you sent a request to the <code>UpdateEndpointWeightsAndCapacities</code>
/// API and the endpoint status is <code>Updating</code>, you get different desired and
/// current values. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantSummary {
    /// <p>The name of the variant.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>An array of <code>DeployedImage</code> objects that specify the Amazon EC2 Container Registry paths of the
    /// inference images deployed on instances of this <code>ProductionVariant</code>.</p>
    pub deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
    /// <p>The weight associated with the variant.</p>
    pub current_weight: std::option::Option<f32>,
    /// <p>The requested weight, as specified in the
    /// <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub desired_weight: std::option::Option<f32>,
    /// <p>The number of instances associated with the variant.</p>
    pub current_instance_count: std::option::Option<i32>,
    /// <p>The number of instances requested in the
    /// <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
    pub desired_instance_count: std::option::Option<i32>,
}
impl std::fmt::Debug for ProductionVariantSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantSummary");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("deployed_images", &self.deployed_images);
        formatter.field("current_weight", &self.current_weight);
        formatter.field("desired_weight", &self.desired_weight);
        formatter.field("current_instance_count", &self.current_instance_count);
        formatter.field("desired_instance_count", &self.desired_instance_count);
        formatter.finish()
    }
}
/// See [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
pub mod production_variant_summary {
    /// A builder for [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) deployed_images: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        pub(crate) current_weight: std::option::Option<f32>,
        pub(crate) desired_weight: std::option::Option<f32>,
        pub(crate) current_instance_count: std::option::Option<i32>,
        pub(crate) desired_instance_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the variant.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        pub fn deployed_images(mut self, input: impl Into<crate::model::DeployedImage>) -> Self {
            let mut v = self.deployed_images.unwrap_or_default();
            v.push(input.into());
            self.deployed_images = Some(v);
            self
        }
        pub fn set_deployed_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeployedImage>>,
        ) -> Self {
            self.deployed_images = input;
            self
        }
        /// <p>The weight associated with the variant.</p>
        pub fn current_weight(mut self, input: f32) -> Self {
            self.current_weight = Some(input);
            self
        }
        pub fn set_current_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.current_weight = input;
            self
        }
        /// <p>The requested weight, as specified in the
        /// <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn desired_weight(mut self, input: f32) -> Self {
            self.desired_weight = Some(input);
            self
        }
        pub fn set_desired_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.desired_weight = input;
            self
        }
        /// <p>The number of instances associated with the variant.</p>
        pub fn current_instance_count(mut self, input: i32) -> Self {
            self.current_instance_count = Some(input);
            self
        }
        pub fn set_current_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.current_instance_count = input;
            self
        }
        /// <p>The number of instances requested in the
        /// <code>UpdateEndpointWeightsAndCapacities</code> request. </p>
        pub fn desired_instance_count(mut self, input: i32) -> Self {
            self.desired_instance_count = Some(input);
            self
        }
        pub fn set_desired_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_instance_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
        pub fn build(self) -> crate::model::ProductionVariantSummary {
            crate::model::ProductionVariantSummary {
                variant_name: self.variant_name,
                deployed_images: self.deployed_images,
                current_weight: self.current_weight,
                desired_weight: self.desired_weight,
                current_instance_count: self.current_instance_count,
                desired_instance_count: self.desired_instance_count,
            }
        }
    }
}
impl ProductionVariantSummary {
    /// Creates a new builder-style object to manufacture [`ProductionVariantSummary`](crate::model::ProductionVariantSummary)
    pub fn builder() -> crate::model::production_variant_summary::Builder {
        crate::model::production_variant_summary::Builder::default()
    }
}

/// <p>Gets the Amazon EC2 Container Registry path of the docker image of the model that is hosted in this <a>ProductionVariant</a>.</p>
/// <p>If you used the <code>registry/repository[:tag]</code> form to specify the image path
/// of the primary container when you created the model hosted in this
/// <code>ProductionVariant</code>, the path resolves to a path of the form
/// <code>registry/repository[@digest]</code>. A digest is a hash value that identifies
/// a specific version of an image. For information about Amazon ECR paths, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html">Pulling an Image</a> in the <i>Amazon ECR User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeployedImage {
    /// <p>The image path you specified when you created the model.</p>
    pub specified_image: std::option::Option<std::string::String>,
    /// <p>The specific digest path of the image hosted in this
    /// <code>ProductionVariant</code>.</p>
    pub resolved_image: std::option::Option<std::string::String>,
    /// <p>The date and time when the image path for the model resolved to the
    /// <code>ResolvedImage</code>
    /// </p>
    pub resolution_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DeployedImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeployedImage");
        formatter.field("specified_image", &self.specified_image);
        formatter.field("resolved_image", &self.resolved_image);
        formatter.field("resolution_time", &self.resolution_time);
        formatter.finish()
    }
}
/// See [`DeployedImage`](crate::model::DeployedImage)
pub mod deployed_image {
    /// A builder for [`DeployedImage`](crate::model::DeployedImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) specified_image: std::option::Option<std::string::String>,
        pub(crate) resolved_image: std::option::Option<std::string::String>,
        pub(crate) resolution_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The image path you specified when you created the model.</p>
        pub fn specified_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.specified_image = Some(input.into());
            self
        }
        pub fn set_specified_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.specified_image = input;
            self
        }
        /// <p>The specific digest path of the image hosted in this
        /// <code>ProductionVariant</code>.</p>
        pub fn resolved_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_image = Some(input.into());
            self
        }
        pub fn set_resolved_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_image = input;
            self
        }
        /// <p>The date and time when the image path for the model resolved to the
        /// <code>ResolvedImage</code>
        /// </p>
        pub fn resolution_time(mut self, input: smithy_types::Instant) -> Self {
            self.resolution_time = Some(input);
            self
        }
        pub fn set_resolution_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.resolution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DeployedImage`](crate::model::DeployedImage)
        pub fn build(self) -> crate::model::DeployedImage {
            crate::model::DeployedImage {
                specified_image: self.specified_image,
                resolved_image: self.resolved_image,
                resolution_time: self.resolution_time,
            }
        }
    }
}
impl DeployedImage {
    /// Creates a new builder-style object to manufacture [`DeployedImage`](crate::model::DeployedImage)
    pub fn builder() -> crate::model::deployed_image::Builder {
        crate::model::deployed_image::Builder::default()
    }
}

/// <p>The properties of a trial component as returned by the <a>Search</a>
/// API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponent {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialComponentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
    pub source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>The status of the trial component.</p>
    pub status: std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component ended.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the component was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The hyperparameters of the component.</p>
    pub parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentParameterValue>,
    >,
    /// <p>The input artifacts of the component.</p>
    pub input_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The output artifacts of the component.</p>
    pub output_artifacts: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
    >,
    /// <p>The metrics for the component.</p>
    pub metrics: std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>Details of the source of the component.</p>
    pub source_detail: std::option::Option<crate::model::TrialComponentSourceDetail>,
    /// <p>The list of tags that are associated with the component. You can use <a>Search</a> API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of the parents of the component. A parent is a trial the component is associated
    /// with and the experiment the trial is part of. A component might not have any parents.</p>
    pub parents: std::option::Option<std::vec::Vec<crate::model::Parent>>,
}
impl std::fmt::Debug for TrialComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponent");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("source", &self.source);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("parameters", &self.parameters);
        formatter.field("input_artifacts", &self.input_artifacts);
        formatter.field("output_artifacts", &self.output_artifacts);
        formatter.field("metrics", &self.metrics);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("source_detail", &self.source_detail);
        formatter.field("tags", &self.tags);
        formatter.field("parents", &self.parents);
        formatter.finish()
    }
}
/// See [`TrialComponent`](crate::model::TrialComponent)
pub mod trial_component {
    /// A builder for [`TrialComponent`](crate::model::TrialComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) status: std::option::Option<crate::model::TrialComponentStatus>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) parameters: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                crate::model::TrialComponentParameterValue,
            >,
        >,
        pub(crate) input_artifacts: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
        >,
        pub(crate) output_artifacts: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::TrialComponentArtifact>,
        >,
        pub(crate) metrics:
            std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) source_detail: std::option::Option<crate::model::TrialComponentSourceDetail>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) parents: std::option::Option<std::vec::Vec<crate::model::Parent>>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>TrialComponentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of the component.</p>
        pub fn source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The status of the trial component.</p>
        pub fn status(mut self, input: crate::model::TrialComponentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the component started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the component ended.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        pub fn parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::TrialComponentParameterValue>,
        ) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.parameters = Some(hash_map);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentParameterValue,
                >,
            >,
        ) -> Self {
            self.parameters = input;
            self
        }
        pub fn input_artifacts(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::TrialComponentArtifact>,
        ) -> Self {
            let mut hash_map = self.input_artifacts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.input_artifacts = Some(hash_map);
            self
        }
        pub fn set_input_artifacts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentArtifact,
                >,
            >,
        ) -> Self {
            self.input_artifacts = input;
            self
        }
        pub fn output_artifacts(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::TrialComponentArtifact>,
        ) -> Self {
            let mut hash_map = self.output_artifacts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.output_artifacts = Some(hash_map);
            self
        }
        pub fn set_output_artifacts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::TrialComponentArtifact,
                >,
            >,
        ) -> Self {
            self.output_artifacts = input;
            self
        }
        pub fn metrics(
            mut self,
            input: impl Into<crate::model::TrialComponentMetricSummary>,
        ) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrialComponentMetricSummary>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        /// <p>Details of the source of the component.</p>
        pub fn source_detail(mut self, input: crate::model::TrialComponentSourceDetail) -> Self {
            self.source_detail = Some(input);
            self
        }
        pub fn set_source_detail(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSourceDetail>,
        ) -> Self {
            self.source_detail = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn parents(mut self, input: impl Into<crate::model::Parent>) -> Self {
            let mut v = self.parents.unwrap_or_default();
            v.push(input.into());
            self.parents = Some(v);
            self
        }
        pub fn set_parents(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Parent>>,
        ) -> Self {
            self.parents = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponent`](crate::model::TrialComponent)
        pub fn build(self) -> crate::model::TrialComponent {
            crate::model::TrialComponent {
                trial_component_name: self.trial_component_name,
                display_name: self.display_name,
                trial_component_arn: self.trial_component_arn,
                source: self.source,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                parameters: self.parameters,
                input_artifacts: self.input_artifacts,
                output_artifacts: self.output_artifacts,
                metrics: self.metrics,
                metadata_properties: self.metadata_properties,
                source_detail: self.source_detail,
                tags: self.tags,
                parents: self.parents,
            }
        }
    }
}
impl TrialComponent {
    /// Creates a new builder-style object to manufacture [`TrialComponent`](crate::model::TrialComponent)
    pub fn builder() -> crate::model::trial_component::Builder {
        crate::model::trial_component::Builder::default()
    }
}

/// <p>The trial that a trial component is associated with and the experiment the trial is part
/// of. A component might not be associated with a trial. A component can be associated with
/// multiple trials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parent {
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Parent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parent");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.finish()
    }
}
/// See [`Parent`](crate::model::Parent)
pub mod parent {
    /// A builder for [`Parent`](crate::model::Parent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Parent`](crate::model::Parent)
        pub fn build(self) -> crate::model::Parent {
            crate::model::Parent {
                trial_name: self.trial_name,
                experiment_name: self.experiment_name,
            }
        }
    }
}
impl Parent {
    /// Creates a new builder-style object to manufacture [`Parent`](crate::model::Parent)
    pub fn builder() -> crate::model::parent::Builder {
        crate::model::parent::Builder::default()
    }
}

/// <p>Detailed information about the source of a trial component. Either
/// <code>ProcessingJob</code> or <code>TrainingJob</code> is returned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSourceDetail {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>Information about a training job that's the source of a trial component.</p>
    pub training_job: std::option::Option<crate::model::TrainingJob>,
    /// <p>Information about a processing job that's the source of a trial component.</p>
    pub processing_job: std::option::Option<crate::model::ProcessingJob>,
    /// <p>Information about a transform job that's the source of a trial component.</p>
    pub transform_job: std::option::Option<crate::model::TransformJob>,
}
impl std::fmt::Debug for TrialComponentSourceDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSourceDetail");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("training_job", &self.training_job);
        formatter.field("processing_job", &self.processing_job);
        formatter.field("transform_job", &self.transform_job);
        formatter.finish()
    }
}
/// See [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
pub mod trial_component_source_detail {
    /// A builder for [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) training_job: std::option::Option<crate::model::TrainingJob>,
        pub(crate) processing_job: std::option::Option<crate::model::ProcessingJob>,
        pub(crate) transform_job: std::option::Option<crate::model::TransformJob>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>Information about a training job that's the source of a trial component.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJob) -> Self {
            self.training_job = Some(input);
            self
        }
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJob>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>Information about a processing job that's the source of a trial component.</p>
        pub fn processing_job(mut self, input: crate::model::ProcessingJob) -> Self {
            self.processing_job = Some(input);
            self
        }
        pub fn set_processing_job(
            mut self,
            input: std::option::Option<crate::model::ProcessingJob>,
        ) -> Self {
            self.processing_job = input;
            self
        }
        /// <p>Information about a transform job that's the source of a trial component.</p>
        pub fn transform_job(mut self, input: crate::model::TransformJob) -> Self {
            self.transform_job = Some(input);
            self
        }
        pub fn set_transform_job(
            mut self,
            input: std::option::Option<crate::model::TransformJob>,
        ) -> Self {
            self.transform_job = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
        pub fn build(self) -> crate::model::TrialComponentSourceDetail {
            crate::model::TrialComponentSourceDetail {
                source_arn: self.source_arn,
                training_job: self.training_job,
                processing_job: self.processing_job,
                transform_job: self.transform_job,
            }
        }
    }
}
impl TrialComponentSourceDetail {
    /// Creates a new builder-style object to manufacture [`TrialComponentSourceDetail`](crate::model::TrialComponentSourceDetail)
    pub fn builder() -> crate::model::trial_component_source_detail::Builder {
        crate::model::trial_component_source_detail::Builder::default()
    }
}

/// <p>A batch transform job. For information about SageMaker batch transform, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform.html">Use Batch
/// Transform</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJob {
    /// <p>The name of the transform job.</p>
    pub transform_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub transform_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the transform job.</p>
    /// <p>Transform job statuses are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>InProgress</code> - The job is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The job has completed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The transform job has failed. To see the reason for the failure,
    /// see the <code>FailureReason</code> field in the response to a
    /// <code>DescribeTransformJob</code> call.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - The transform job is stopping.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The transform job has stopped.</p>
    /// </li>
    /// </ul>
    pub transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
    /// <p>If the transform job failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The name of the model associated with the transform job.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of parallel requests that can be sent to each instance in a transform
    /// job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the
    /// optional execution-parameters to determine the settings for your chosen algorithm. If the
    /// execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms,
    /// you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
    pub max_concurrent_transforms: std::option::Option<i32>,
    /// <p>Configures the timeout and maximum number of retries for processing a transform job
    /// invocation.</p>
    pub model_client_config: std::option::Option<crate::model::ModelClientConfig>,
    /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record
    /// (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal
    /// to, the size of a single record. To estimate the size of a record in MB, divide the size of
    /// your dataset by the number of records. To ensure that the records fit within the maximum
    /// payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases
    /// where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding,
    /// set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in
    /// algorithms do not support HTTP chunked encoding.</p>
    pub max_payload_in_mb: std::option::Option<i32>,
    /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request.
    /// A record is a single unit of input data that inference can be made on. For example, a single
    /// line in a CSV file is a record.</p>
    pub batch_strategy: std::option::Option<crate::model::BatchStrategy>,
    /// <p>The environment variables to set in the Docker container. We support up to 16 key and
    /// values entries in the map.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Describes the input source of a transform job and the way the transform job consumes
    /// it.</p>
    pub transform_input: std::option::Option<crate::model::TransformInput>,
    /// <p>Describes the results of a transform job.</p>
    pub transform_output: std::option::Option<crate::model::TransformOutput>,
    /// <p>Describes the resources, including ML instance types and ML instance count, to use for
    /// transform job.</p>
    pub transform_resources: std::option::Option<crate::model::TransformResources>,
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform job starts on ML instances. You are billed for the time
    /// interval between this time and the value of <code>TransformEndTime</code>.</p>
    pub transform_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are
    /// billed for the time interval between this time and the value of
    /// <code>TransformStartTime</code>.</p>
    pub transform_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) of the  labeling job that created the transform job.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The data structure used to specify the data to be used for inference in a batch
    /// transform job and to associate the data that is relevant to the prediction results in
    /// the output. The input filter provided allows you to exclude input data that is not
    /// needed for inference in a batch transform job. The output filter provided allows you to
    /// include input data relevant to interpreting the predictions in the output from the job.
    /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction
    /// Results with their Corresponding Input Records</a>.</p>
    pub data_processing: std::option::Option<crate::model::DataProcessing>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>A list of tags associated with the transform job.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TransformJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJob");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.field("transform_job_status", &self.transform_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("model_name", &self.model_name);
        formatter.field("max_concurrent_transforms", &self.max_concurrent_transforms);
        formatter.field("model_client_config", &self.model_client_config);
        formatter.field("max_payload_in_mb", &self.max_payload_in_mb);
        formatter.field("batch_strategy", &self.batch_strategy);
        formatter.field("environment", &self.environment);
        formatter.field("transform_input", &self.transform_input);
        formatter.field("transform_output", &self.transform_output);
        formatter.field("transform_resources", &self.transform_resources);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("transform_start_time", &self.transform_start_time);
        formatter.field("transform_end_time", &self.transform_end_time);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("data_processing", &self.data_processing);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TransformJob`](crate::model::TransformJob)
pub mod transform_job {
    /// A builder for [`TransformJob`](crate::model::TransformJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_job_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_arn: std::option::Option<std::string::String>,
        pub(crate) transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) max_concurrent_transforms: std::option::Option<i32>,
        pub(crate) model_client_config: std::option::Option<crate::model::ModelClientConfig>,
        pub(crate) max_payload_in_mb: std::option::Option<i32>,
        pub(crate) batch_strategy: std::option::Option<crate::model::BatchStrategy>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) transform_input: std::option::Option<crate::model::TransformInput>,
        pub(crate) transform_output: std::option::Option<crate::model::TransformOutput>,
        pub(crate) transform_resources: std::option::Option<crate::model::TransformResources>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) transform_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) transform_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) data_processing: std::option::Option<crate::model::DataProcessing>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the transform job.</p>
        pub fn transform_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_name = Some(input.into());
            self
        }
        pub fn set_transform_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn transform_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_arn = Some(input.into());
            self
        }
        pub fn set_transform_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_arn = input;
            self
        }
        /// <p>The status of the transform job.</p>
        /// <p>Transform job statuses are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>InProgress</code> - The job is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Completed</code> - The job has completed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code> - The transform job has failed. To see the reason for the failure,
        /// see the <code>FailureReason</code> field in the response to a
        /// <code>DescribeTransformJob</code> call.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopping</code> - The transform job is stopping.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopped</code> - The transform job has stopped.</p>
        /// </li>
        /// </ul>
        pub fn transform_job_status(mut self, input: crate::model::TransformJobStatus) -> Self {
            self.transform_job_status = Some(input);
            self
        }
        pub fn set_transform_job_status(
            mut self,
            input: std::option::Option<crate::model::TransformJobStatus>,
        ) -> Self {
            self.transform_job_status = input;
            self
        }
        /// <p>If the transform job failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The name of the model associated with the transform job.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The maximum number of parallel requests that can be sent to each instance in a transform
        /// job. If <code>MaxConcurrentTransforms</code> is set to 0 or left unset, SageMaker checks the
        /// optional execution-parameters to determine the settings for your chosen algorithm. If the
        /// execution-parameters endpoint is not enabled, the default value is 1. For built-in algorithms,
        /// you don't need to set a value for <code>MaxConcurrentTransforms</code>.</p>
        pub fn max_concurrent_transforms(mut self, input: i32) -> Self {
            self.max_concurrent_transforms = Some(input);
            self
        }
        pub fn set_max_concurrent_transforms(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_transforms = input;
            self
        }
        /// <p>Configures the timeout and maximum number of retries for processing a transform job
        /// invocation.</p>
        pub fn model_client_config(mut self, input: crate::model::ModelClientConfig) -> Self {
            self.model_client_config = Some(input);
            self
        }
        pub fn set_model_client_config(
            mut self,
            input: std::option::Option<crate::model::ModelClientConfig>,
        ) -> Self {
            self.model_client_config = input;
            self
        }
        /// <p>The maximum allowed size of the payload, in MB. A payload is the data portion of a record
        /// (without metadata). The value in <code>MaxPayloadInMB</code> must be greater than, or equal
        /// to, the size of a single record. To estimate the size of a record in MB, divide the size of
        /// your dataset by the number of records. To ensure that the records fit within the maximum
        /// payload size, we recommend using a slightly larger value. The default value is 6 MB. For cases
        /// where the payload might be arbitrarily large and is transmitted using HTTP chunked encoding,
        /// set the value to 0. This feature works only in supported algorithms. Currently, SageMaker built-in
        /// algorithms do not support HTTP chunked encoding.</p>
        pub fn max_payload_in_mb(mut self, input: i32) -> Self {
            self.max_payload_in_mb = Some(input);
            self
        }
        pub fn set_max_payload_in_mb(mut self, input: std::option::Option<i32>) -> Self {
            self.max_payload_in_mb = input;
            self
        }
        /// <p>Specifies the number of records to include in a mini-batch for an HTTP inference request.
        /// A record is a single unit of input data that inference can be made on. For example, a single
        /// line in a CSV file is a record.</p>
        pub fn batch_strategy(mut self, input: crate::model::BatchStrategy) -> Self {
            self.batch_strategy = Some(input);
            self
        }
        pub fn set_batch_strategy(
            mut self,
            input: std::option::Option<crate::model::BatchStrategy>,
        ) -> Self {
            self.batch_strategy = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Describes the input source of a transform job and the way the transform job consumes
        /// it.</p>
        pub fn transform_input(mut self, input: crate::model::TransformInput) -> Self {
            self.transform_input = Some(input);
            self
        }
        pub fn set_transform_input(
            mut self,
            input: std::option::Option<crate::model::TransformInput>,
        ) -> Self {
            self.transform_input = input;
            self
        }
        /// <p>Describes the results of a transform job.</p>
        pub fn transform_output(mut self, input: crate::model::TransformOutput) -> Self {
            self.transform_output = Some(input);
            self
        }
        pub fn set_transform_output(
            mut self,
            input: std::option::Option<crate::model::TransformOutput>,
        ) -> Self {
            self.transform_output = input;
            self
        }
        /// <p>Describes the resources, including ML instance types and ML instance count, to use for
        /// transform job.</p>
        pub fn transform_resources(mut self, input: crate::model::TransformResources) -> Self {
            self.transform_resources = Some(input);
            self
        }
        pub fn set_transform_resources(
            mut self,
            input: std::option::Option<crate::model::TransformResources>,
        ) -> Self {
            self.transform_resources = input;
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates when the transform job starts on ML instances. You are billed for the time
        /// interval between this time and the value of <code>TransformEndTime</code>.</p>
        pub fn transform_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.transform_start_time = Some(input);
            self
        }
        pub fn set_transform_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.transform_start_time = input;
            self
        }
        /// <p>Indicates when the transform job has been completed, or has stopped or failed. You are
        /// billed for the time interval between this time and the value of
        /// <code>TransformStartTime</code>.</p>
        pub fn transform_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.transform_end_time = Some(input);
            self
        }
        pub fn set_transform_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.transform_end_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the  labeling job that created the transform job.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job that created the transform job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The data structure used to specify the data to be used for inference in a batch
        /// transform job and to associate the data that is relevant to the prediction results in
        /// the output. The input filter provided allows you to exclude input data that is not
        /// needed for inference in a batch transform job. The output filter provided allows you to
        /// include input data relevant to interpreting the predictions in the output from the job.
        /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction
        /// Results with their Corresponding Input Records</a>.</p>
        pub fn data_processing(mut self, input: crate::model::DataProcessing) -> Self {
            self.data_processing = Some(input);
            self
        }
        pub fn set_data_processing(
            mut self,
            input: std::option::Option<crate::model::DataProcessing>,
        ) -> Self {
            self.data_processing = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
        /// you call the following APIs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a>CreateProcessingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTrainingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTransformJob</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJob`](crate::model::TransformJob)
        pub fn build(self) -> crate::model::TransformJob {
            crate::model::TransformJob {
                transform_job_name: self.transform_job_name,
                transform_job_arn: self.transform_job_arn,
                transform_job_status: self.transform_job_status,
                failure_reason: self.failure_reason,
                model_name: self.model_name,
                max_concurrent_transforms: self.max_concurrent_transforms,
                model_client_config: self.model_client_config,
                max_payload_in_mb: self.max_payload_in_mb,
                batch_strategy: self.batch_strategy,
                environment: self.environment,
                transform_input: self.transform_input,
                transform_output: self.transform_output,
                transform_resources: self.transform_resources,
                creation_time: self.creation_time,
                transform_start_time: self.transform_start_time,
                transform_end_time: self.transform_end_time,
                labeling_job_arn: self.labeling_job_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                data_processing: self.data_processing,
                experiment_config: self.experiment_config,
                tags: self.tags,
            }
        }
    }
}
impl TransformJob {
    /// Creates a new builder-style object to manufacture [`TransformJob`](crate::model::TransformJob)
    pub fn builder() -> crate::model::transform_job::Builder {
        crate::model::transform_job::Builder::default()
    }
}

/// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
/// you call the following APIs:</p>
/// <ul>
/// <li>
/// <p>
/// <a>CreateProcessingJob</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateTrainingJob</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a>CreateTransformJob</a>
/// </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentConfig {
    /// <p>The name of an existing experiment to associate the trial component with.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of an existing trial to associate the trial component with. If not specified, a
    /// new trial is created.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The display name for the trial component. If this key isn't specified, the display name is
    /// the trial component name.</p>
    pub trial_component_display_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExperimentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentConfig");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("trial_name", &self.trial_name);
        formatter.field(
            "trial_component_display_name",
            &self.trial_component_display_name,
        );
        formatter.finish()
    }
}
/// See [`ExperimentConfig`](crate::model::ExperimentConfig)
pub mod experiment_config {
    /// A builder for [`ExperimentConfig`](crate::model::ExperimentConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an existing experiment to associate the trial component with.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of an existing trial to associate the trial component with. If not specified, a
        /// new trial is created.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The display name for the trial component. If this key isn't specified, the display name is
        /// the trial component name.</p>
        pub fn trial_component_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.trial_component_display_name = Some(input.into());
            self
        }
        pub fn set_trial_component_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentConfig`](crate::model::ExperimentConfig)
        pub fn build(self) -> crate::model::ExperimentConfig {
            crate::model::ExperimentConfig {
                experiment_name: self.experiment_name,
                trial_name: self.trial_name,
                trial_component_display_name: self.trial_component_display_name,
            }
        }
    }
}
impl ExperimentConfig {
    /// Creates a new builder-style object to manufacture [`ExperimentConfig`](crate::model::ExperimentConfig)
    pub fn builder() -> crate::model::experiment_config::Builder {
        crate::model::experiment_config::Builder::default()
    }
}

/// <p>The data structure used to specify the data to be used for inference in a batch
/// transform job and to associate the data that is relevant to the prediction results in
/// the output. The input filter provided allows you to exclude input data that is not
/// needed for inference in a batch transform job. The output filter provided allows you to
/// include input data relevant to interpreting the predictions in the output from the job.
/// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html">Associate Prediction
/// Results with their Corresponding Input Records</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataProcessing {
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to
    /// the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an
    /// ID column, from the input. If you want Amazon SageMaker to pass the entire input dataset to the
    /// algorithm, accept the default value <code>$</code>.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code>
    /// </p>
    pub input_filter: std::option::Option<std::string::String>,
    /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save
    /// in the output file for a batch transform job. If you want Amazon SageMaker to store the entire input
    /// dataset in the output file, leave the default value, <code>$</code>. If you specify
    /// indexes that aren't within the dimension size of the joined dataset, you get an
    /// error.</p>
    /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>,
    /// <code>"$['id','SageMakerOutput']"</code>
    /// </p>
    pub output_filter: std::option::Option<std::string::String>,
    /// <p>Specifies the source of the data to join with the transformed data. The valid values
    /// are <code>None</code> and <code>Input</code>. The default value is <code>None</code>,
    /// which specifies not to join the input with the transformed data. If you want the batch
    /// transform job to join the original input data with the transformed data, set
    /// <code>JoinSource</code> to <code>Input</code>. You can specify
    /// <code>OutputFilter</code> as an additional filter to select a portion of the joined
    /// dataset and store it in the output file.</p>
    /// <p>For JSON or JSONLines objects, such as a JSON array, Amazon SageMaker adds the transformed data to
    /// the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined
    /// result for JSON must be a key-value pair object. If the input is not a key-value pair
    /// object, Amazon SageMaker creates a new JSON file. In the new JSON file, and the input data is stored
    /// under the <code>SageMakerInput</code> key and the results are stored in
    /// <code>SageMakerOutput</code>.</p>
    /// <p>For CSV data, Amazon SageMaker takes each row as a JSON array and joins the transformed data with
    /// the input by appending each transformed row to the end of the input. The joined data has
    /// the original input data followed by the transformed data and the output is a CSV
    /// file.</p>
    /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
    pub join_source: std::option::Option<crate::model::JoinSource>,
}
impl std::fmt::Debug for DataProcessing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataProcessing");
        formatter.field("input_filter", &self.input_filter);
        formatter.field("output_filter", &self.output_filter);
        formatter.field("join_source", &self.join_source);
        formatter.finish()
    }
}
/// See [`DataProcessing`](crate::model::DataProcessing)
pub mod data_processing {
    /// A builder for [`DataProcessing`](crate::model::DataProcessing)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_filter: std::option::Option<std::string::String>,
        pub(crate) output_filter: std::option::Option<std::string::String>,
        pub(crate) join_source: std::option::Option<crate::model::JoinSource>,
    }
    impl Builder {
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the input data to pass to
        /// the algorithm. Use the <code>InputFilter</code> parameter to exclude fields, such as an
        /// ID column, from the input. If you want Amazon SageMaker to pass the entire input dataset to the
        /// algorithm, accept the default value <code>$</code>.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[1:]"</code>, <code>"$.features"</code>
        /// </p>
        pub fn input_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_filter = Some(input.into());
            self
        }
        pub fn set_input_filter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_filter = input;
            self
        }
        /// <p>A <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#data-processing-operators">JSONPath</a> expression used to select a portion of the joined dataset to save
        /// in the output file for a batch transform job. If you want Amazon SageMaker to store the entire input
        /// dataset in the output file, leave the default value, <code>$</code>. If you specify
        /// indexes that aren't within the dimension size of the joined dataset, you get an
        /// error.</p>
        /// <p>Examples: <code>"$"</code>, <code>"$[0,5:]"</code>,
        /// <code>"$['id','SageMakerOutput']"</code>
        /// </p>
        pub fn output_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_filter = Some(input.into());
            self
        }
        pub fn set_output_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_filter = input;
            self
        }
        /// <p>Specifies the source of the data to join with the transformed data. The valid values
        /// are <code>None</code> and <code>Input</code>. The default value is <code>None</code>,
        /// which specifies not to join the input with the transformed data. If you want the batch
        /// transform job to join the original input data with the transformed data, set
        /// <code>JoinSource</code> to <code>Input</code>. You can specify
        /// <code>OutputFilter</code> as an additional filter to select a portion of the joined
        /// dataset and store it in the output file.</p>
        /// <p>For JSON or JSONLines objects, such as a JSON array, Amazon SageMaker adds the transformed data to
        /// the input JSON object in an attribute called <code>SageMakerOutput</code>. The joined
        /// result for JSON must be a key-value pair object. If the input is not a key-value pair
        /// object, Amazon SageMaker creates a new JSON file. In the new JSON file, and the input data is stored
        /// under the <code>SageMakerInput</code> key and the results are stored in
        /// <code>SageMakerOutput</code>.</p>
        /// <p>For CSV data, Amazon SageMaker takes each row as a JSON array and joins the transformed data with
        /// the input by appending each transformed row to the end of the input. The joined data has
        /// the original input data followed by the transformed data and the output is a CSV
        /// file.</p>
        /// <p>For information on how joining in applied, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/batch-transform-data-processing.html#batch-transform-data-processing-workflow">Workflow for Associating Inferences with Input Records</a>.</p>
        pub fn join_source(mut self, input: crate::model::JoinSource) -> Self {
            self.join_source = Some(input);
            self
        }
        pub fn set_join_source(
            mut self,
            input: std::option::Option<crate::model::JoinSource>,
        ) -> Self {
            self.join_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataProcessing`](crate::model::DataProcessing)
        pub fn build(self) -> crate::model::DataProcessing {
            crate::model::DataProcessing {
                input_filter: self.input_filter,
                output_filter: self.output_filter,
                join_source: self.join_source,
            }
        }
    }
}
impl DataProcessing {
    /// Creates a new builder-style object to manufacture [`DataProcessing`](crate::model::DataProcessing)
    pub fn builder() -> crate::model::data_processing::Builder {
        crate::model::data_processing::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JoinSource {
    Input,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for JoinSource {
    fn from(s: &str) -> Self {
        match s {
            "Input" => JoinSource::Input,
            "None" => JoinSource::None,
            other => JoinSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for JoinSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JoinSource::from(s))
    }
}
impl JoinSource {
    pub fn as_str(&self) -> &str {
        match self {
            JoinSource::Input => "Input",
            JoinSource::None => "None",
            JoinSource::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Input", "None"]
    }
}
impl AsRef<str> for JoinSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configures the timeout and maximum number of retries for processing a transform job
/// invocation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelClientConfig {
    /// <p>The timeout value in seconds for an invocation request.</p>
    pub invocations_timeout_in_seconds: std::option::Option<i32>,
    /// <p>The maximum number of retries when invocation requests are failing.</p>
    pub invocations_max_retries: std::option::Option<i32>,
}
impl std::fmt::Debug for ModelClientConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelClientConfig");
        formatter.field(
            "invocations_timeout_in_seconds",
            &self.invocations_timeout_in_seconds,
        );
        formatter.field("invocations_max_retries", &self.invocations_max_retries);
        formatter.finish()
    }
}
/// See [`ModelClientConfig`](crate::model::ModelClientConfig)
pub mod model_client_config {
    /// A builder for [`ModelClientConfig`](crate::model::ModelClientConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invocations_timeout_in_seconds: std::option::Option<i32>,
        pub(crate) invocations_max_retries: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The timeout value in seconds for an invocation request.</p>
        pub fn invocations_timeout_in_seconds(mut self, input: i32) -> Self {
            self.invocations_timeout_in_seconds = Some(input);
            self
        }
        pub fn set_invocations_timeout_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.invocations_timeout_in_seconds = input;
            self
        }
        /// <p>The maximum number of retries when invocation requests are failing.</p>
        pub fn invocations_max_retries(mut self, input: i32) -> Self {
            self.invocations_max_retries = Some(input);
            self
        }
        pub fn set_invocations_max_retries(mut self, input: std::option::Option<i32>) -> Self {
            self.invocations_max_retries = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelClientConfig`](crate::model::ModelClientConfig)
        pub fn build(self) -> crate::model::ModelClientConfig {
            crate::model::ModelClientConfig {
                invocations_timeout_in_seconds: self.invocations_timeout_in_seconds,
                invocations_max_retries: self.invocations_max_retries,
            }
        }
    }
}
impl ModelClientConfig {
    /// Creates a new builder-style object to manufacture [`ModelClientConfig`](crate::model::ModelClientConfig)
    pub fn builder() -> crate::model::model_client_config::Builder {
        crate::model::model_client_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TransformJobStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TransformJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TransformJobStatus::Completed,
            "Failed" => TransformJobStatus::Failed,
            "InProgress" => TransformJobStatus::InProgress,
            "Stopped" => TransformJobStatus::Stopped,
            "Stopping" => TransformJobStatus::Stopping,
            other => TransformJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TransformJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TransformJobStatus::from(s))
    }
}
impl TransformJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TransformJobStatus::Completed => "Completed",
            TransformJobStatus::Failed => "Failed",
            TransformJobStatus::InProgress => "InProgress",
            TransformJobStatus::Stopped => "Stopped",
            TransformJobStatus::Stopping => "Stopping",
            TransformJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TransformJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An Amazon SageMaker processing job that is used to analyze data and evaluate models. For more information,
/// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/processing-job.html">Process
/// Data and Evaluate Models</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJob {
    /// <p>List of input configurations for the processing job.</p>
    pub processing_inputs: std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
    /// <p>Configuration for uploading output from the processing container.</p>
    pub processing_output_config: std::option::Option<crate::model::ProcessingOutputConfig>,
    /// <p>The name of the processing job.</p>
    pub processing_job_name: std::option::Option<std::string::String>,
    /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
    /// processing job. In distributed training, you specify more than one instance.</p>
    pub processing_resources: std::option::Option<crate::model::ProcessingResources>,
    /// <p>Configures conditions under which the processing job should be stopped, such as how long
    /// the processing job has been running. After the condition is met, the processing job is stopped.</p>
    pub stopping_condition: std::option::Option<crate::model::ProcessingStoppingCondition>,
    /// <p>Configuration to run a processing job in a specified container image.</p>
    pub app_specification: std::option::Option<crate::model::AppSpecification>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Networking options for a job, such as network traffic encryption between containers,
    /// whether to allow inbound and outbound network calls to and from containers, and the VPC
    /// subnets and security groups to use for VPC-enabled jobs.</p>
    pub network_config: std::option::Option<crate::model::NetworkConfig>,
    /// <p>The ARN of the role used to create the processing job.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>The ARN of the processing job.</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the processing job.</p>
    pub processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>A string, up to one KB in size, that contains metadata from the processing
    /// container when the processing job exits.</p>
    pub exit_message: std::option::Option<std::string::String>,
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if
    /// it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The time that the processing job ended.</p>
    pub processing_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the processing job started.</p>
    pub processing_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the processing job was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the processing job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing
    /// job.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the training job associated with this processing job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html#allocation-whatURL">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management
    /// User Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ProcessingJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJob");
        formatter.field("processing_inputs", &self.processing_inputs);
        formatter.field("processing_output_config", &self.processing_output_config);
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_resources", &self.processing_resources);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("app_specification", &self.app_specification);
        formatter.field("environment", &self.environment);
        formatter.field("network_config", &self.network_config);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("processing_job_status", &self.processing_job_status);
        formatter.field("exit_message", &self.exit_message);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("processing_end_time", &self.processing_end_time);
        formatter.field("processing_start_time", &self.processing_start_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ProcessingJob`](crate::model::ProcessingJob)
pub mod processing_job {
    /// A builder for [`ProcessingJob`](crate::model::ProcessingJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) processing_inputs:
            std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
        pub(crate) processing_output_config:
            std::option::Option<crate::model::ProcessingOutputConfig>,
        pub(crate) processing_job_name: std::option::Option<std::string::String>,
        pub(crate) processing_resources: std::option::Option<crate::model::ProcessingResources>,
        pub(crate) stopping_condition:
            std::option::Option<crate::model::ProcessingStoppingCondition>,
        pub(crate) app_specification: std::option::Option<crate::model::AppSpecification>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) network_config: std::option::Option<crate::model::NetworkConfig>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
        pub(crate) exit_message: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) processing_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) processing_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        pub fn processing_inputs(
            mut self,
            input: impl Into<crate::model::ProcessingInput>,
        ) -> Self {
            let mut v = self.processing_inputs.unwrap_or_default();
            v.push(input.into());
            self.processing_inputs = Some(v);
            self
        }
        pub fn set_processing_inputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProcessingInput>>,
        ) -> Self {
            self.processing_inputs = input;
            self
        }
        /// <p>Configuration for uploading output from the processing container.</p>
        pub fn processing_output_config(
            mut self,
            input: crate::model::ProcessingOutputConfig,
        ) -> Self {
            self.processing_output_config = Some(input);
            self
        }
        pub fn set_processing_output_config(
            mut self,
            input: std::option::Option<crate::model::ProcessingOutputConfig>,
        ) -> Self {
            self.processing_output_config = input;
            self
        }
        /// <p>The name of the processing job.</p>
        pub fn processing_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_name = Some(input.into());
            self
        }
        pub fn set_processing_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_name = input;
            self
        }
        /// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
        /// processing job. In distributed training, you specify more than one instance.</p>
        pub fn processing_resources(mut self, input: crate::model::ProcessingResources) -> Self {
            self.processing_resources = Some(input);
            self
        }
        pub fn set_processing_resources(
            mut self,
            input: std::option::Option<crate::model::ProcessingResources>,
        ) -> Self {
            self.processing_resources = input;
            self
        }
        /// <p>Configures conditions under which the processing job should be stopped, such as how long
        /// the processing job has been running. After the condition is met, the processing job is stopped.</p>
        pub fn stopping_condition(
            mut self,
            input: crate::model::ProcessingStoppingCondition,
        ) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::ProcessingStoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>Configuration to run a processing job in a specified container image.</p>
        pub fn app_specification(mut self, input: crate::model::AppSpecification) -> Self {
            self.app_specification = Some(input);
            self
        }
        pub fn set_app_specification(
            mut self,
            input: std::option::Option<crate::model::AppSpecification>,
        ) -> Self {
            self.app_specification = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>Networking options for a job, such as network traffic encryption between containers,
        /// whether to allow inbound and outbound network calls to and from containers, and the VPC
        /// subnets and security groups to use for VPC-enabled jobs.</p>
        pub fn network_config(mut self, input: crate::model::NetworkConfig) -> Self {
            self.network_config = Some(input);
            self
        }
        pub fn set_network_config(
            mut self,
            input: std::option::Option<crate::model::NetworkConfig>,
        ) -> Self {
            self.network_config = input;
            self
        }
        /// <p>The ARN of the role used to create the processing job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
        /// you call the following APIs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a>CreateProcessingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTrainingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTransformJob</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        /// <p>The ARN of the processing job.</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn processing_job_status(mut self, input: crate::model::ProcessingJobStatus) -> Self {
            self.processing_job_status = Some(input);
            self
        }
        pub fn set_processing_job_status(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStatus>,
        ) -> Self {
            self.processing_job_status = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains metadata from the processing
        /// container when the processing job exits.</p>
        pub fn exit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.exit_message = Some(input.into());
            self
        }
        pub fn set_exit_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.exit_message = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if
        /// it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The time that the processing job ended.</p>
        pub fn processing_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.processing_end_time = Some(input);
            self
        }
        pub fn set_processing_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.processing_end_time = input;
            self
        }
        /// <p>The time that the processing job started.</p>
        pub fn processing_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.processing_start_time = Some(input);
            self
        }
        pub fn set_processing_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.processing_start_time = input;
            self
        }
        /// <p>The time the processing job was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The time the processing job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The ARN of a monitoring schedule for an endpoint associated with this processing
        /// job.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AutoML job associated with this processing job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The ARN of the training job associated with this processing job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJob`](crate::model::ProcessingJob)
        pub fn build(self) -> crate::model::ProcessingJob {
            crate::model::ProcessingJob {
                processing_inputs: self.processing_inputs,
                processing_output_config: self.processing_output_config,
                processing_job_name: self.processing_job_name,
                processing_resources: self.processing_resources,
                stopping_condition: self.stopping_condition,
                app_specification: self.app_specification,
                environment: self.environment,
                network_config: self.network_config,
                role_arn: self.role_arn,
                experiment_config: self.experiment_config,
                processing_job_arn: self.processing_job_arn,
                processing_job_status: self.processing_job_status,
                exit_message: self.exit_message,
                failure_reason: self.failure_reason,
                processing_end_time: self.processing_end_time,
                processing_start_time: self.processing_start_time,
                last_modified_time: self.last_modified_time,
                creation_time: self.creation_time,
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                training_job_arn: self.training_job_arn,
                tags: self.tags,
            }
        }
    }
}
impl ProcessingJob {
    /// Creates a new builder-style object to manufacture [`ProcessingJob`](crate::model::ProcessingJob)
    pub fn builder() -> crate::model::processing_job::Builder {
        crate::model::processing_job::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingJobStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => ProcessingJobStatus::Completed,
            "Failed" => ProcessingJobStatus::Failed,
            "InProgress" => ProcessingJobStatus::InProgress,
            "Stopped" => ProcessingJobStatus::Stopped,
            "Stopping" => ProcessingJobStatus::Stopping,
            other => ProcessingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingJobStatus::from(s))
    }
}
impl ProcessingJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingJobStatus::Completed => "Completed",
            ProcessingJobStatus::Failed => "Failed",
            ProcessingJobStatus::InProgress => "InProgress",
            ProcessingJobStatus::Stopped => "Stopped",
            ProcessingJobStatus::Stopping => "Stopping",
            ProcessingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for ProcessingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration to run a processing job in a specified container image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppSpecification {
    /// <p>The container image to be run by the processing job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The entrypoint for a container used to run a processing job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The arguments for a container used to run a processing job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for AppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.finish()
    }
}
/// See [`AppSpecification`](crate::model::AppSpecification)
pub mod app_specification {
    /// A builder for [`AppSpecification`](crate::model::AppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The container image to be run by the processing job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// Consumes the builder and constructs a [`AppSpecification`](crate::model::AppSpecification)
        pub fn build(self) -> crate::model::AppSpecification {
            crate::model::AppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
            }
        }
    }
}
impl AppSpecification {
    /// Creates a new builder-style object to manufacture [`AppSpecification`](crate::model::AppSpecification)
    pub fn builder() -> crate::model::app_specification::Builder {
        crate::model::app_specification::Builder::default()
    }
}

/// <p>Configures conditions under which the processing job should be stopped, such as how long
/// the processing job has been running. After the condition is met, the processing job is stopped.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingStoppingCondition {
    /// <p>Specifies the maximum runtime in seconds.</p>
    pub max_runtime_in_seconds: i32,
}
impl std::fmt::Debug for ProcessingStoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingStoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.finish()
    }
}
/// See [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
pub mod processing_stopping_condition {
    /// A builder for [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies the maximum runtime in seconds.</p>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
        pub fn build(self) -> crate::model::ProcessingStoppingCondition {
            crate::model::ProcessingStoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
            }
        }
    }
}
impl ProcessingStoppingCondition {
    /// Creates a new builder-style object to manufacture [`ProcessingStoppingCondition`](crate::model::ProcessingStoppingCondition)
    pub fn builder() -> crate::model::processing_stopping_condition::Builder {
        crate::model::processing_stopping_condition::Builder::default()
    }
}

/// <p>Identifies the resources, ML compute instances, and ML storage volumes to deploy for a
/// processing job. In distributed training, you specify more than one instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingResources {
    /// <p>The configuration for the resources in a cluster used to run the processing
    /// job.</p>
    pub cluster_config: std::option::Option<crate::model::ProcessingClusterConfig>,
}
impl std::fmt::Debug for ProcessingResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingResources");
        formatter.field("cluster_config", &self.cluster_config);
        formatter.finish()
    }
}
/// See [`ProcessingResources`](crate::model::ProcessingResources)
pub mod processing_resources {
    /// A builder for [`ProcessingResources`](crate::model::ProcessingResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_config: std::option::Option<crate::model::ProcessingClusterConfig>,
    }
    impl Builder {
        /// <p>The configuration for the resources in a cluster used to run the processing
        /// job.</p>
        pub fn cluster_config(mut self, input: crate::model::ProcessingClusterConfig) -> Self {
            self.cluster_config = Some(input);
            self
        }
        pub fn set_cluster_config(
            mut self,
            input: std::option::Option<crate::model::ProcessingClusterConfig>,
        ) -> Self {
            self.cluster_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingResources`](crate::model::ProcessingResources)
        pub fn build(self) -> crate::model::ProcessingResources {
            crate::model::ProcessingResources {
                cluster_config: self.cluster_config,
            }
        }
    }
}
impl ProcessingResources {
    /// Creates a new builder-style object to manufacture [`ProcessingResources`](crate::model::ProcessingResources)
    pub fn builder() -> crate::model::processing_resources::Builder {
        crate::model::processing_resources::Builder::default()
    }
}

/// <p>Configuration for the cluster used to run a processing job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingClusterConfig {
    /// <p>The number of ML compute instances to use in the processing job. For distributed
    /// processing jobs, specify a value greater than 1. The default value is 1.</p>
    pub instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type for the processing job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must
    /// specify sufficient ML storage for your scenario.</p>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size,
    /// dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts
    /// the local instance storage instead of Amazon EBS gp2 storage. You can't request a
    /// <code>VolumeSizeInGB</code> greater than the total size of the local instance
    /// storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the
    /// total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_size_in_gb: std::option::Option<i32>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the
    /// storage volume attached to the ML compute instance(s) that run the processing job.
    /// </p>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance
    /// type. Local storage volumes are encrypted using a hardware module on the instance.
    /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
    /// local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
    /// Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessingClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingClusterConfig");
        formatter.field("instance_count", &self.instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
pub mod processing_cluster_config {
    /// A builder for [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of ML compute instances to use in the processing job. For distributed
        /// processing jobs, specify a value greater than 1. The default value is 1.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The ML compute instance type for the processing job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size of the ML storage volume in gigabytes that you want to provision. You must
        /// specify sufficient ML storage for your scenario.</p>
        /// <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size,
        /// dependent on the instance type. When using these instances for processing, Amazon SageMaker mounts
        /// the local instance storage instead of Amazon EBS gp2 storage. You can't request a
        /// <code>VolumeSizeInGB</code> greater than the total size of the local instance
        /// storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the
        /// total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the
        /// storage volume attached to the ML compute instance(s) that run the processing job.
        /// </p>
        /// <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance
        /// type. Local storage volumes are encrypted using a hardware module on the instance.
        /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
        /// local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
        /// Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
        pub fn build(self) -> crate::model::ProcessingClusterConfig {
            crate::model::ProcessingClusterConfig {
                instance_count: self.instance_count,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb,
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl ProcessingClusterConfig {
    /// Creates a new builder-style object to manufacture [`ProcessingClusterConfig`](crate::model::ProcessingClusterConfig)
    pub fn builder() -> crate::model::processing_cluster_config::Builder {
        crate::model::processing_cluster_config::Builder::default()
    }
}

/// <p>Configuration for uploading output from the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingOutputConfig {
    /// <p>An array of outputs configuring the data to upload from the processing container.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing
    /// job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of
    /// a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all
    /// outputs.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessingOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingOutputConfig");
        formatter.field("outputs", &self.outputs);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
pub mod processing_output_config {
    /// A builder for [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn outputs(mut self, input: impl Into<crate::model::ProcessingOutput>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(input.into());
            self.outputs = Some(v);
            self
        }
        pub fn set_outputs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProcessingOutput>>,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the processing
        /// job output. <code>KmsKeyId</code> can be an ID of a KMS key, ARN of a KMS key, alias of
        /// a KMS key, or alias of a KMS key. The <code>KmsKeyId</code> is applied to all
        /// outputs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
        pub fn build(self) -> crate::model::ProcessingOutputConfig {
            crate::model::ProcessingOutputConfig {
                outputs: self.outputs,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl ProcessingOutputConfig {
    /// Creates a new builder-style object to manufacture [`ProcessingOutputConfig`](crate::model::ProcessingOutputConfig)
    pub fn builder() -> crate::model::processing_output_config::Builder {
        crate::model::processing_output_config::Builder::default()
    }
}

/// <p>Describes the results of a processing job. The processing output must specify exactly one of
/// either <code>S3Output</code> or <code>FeatureStoreOutput</code> types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingOutput {
    /// <p>The name for the processing job output.</p>
    pub output_name: std::option::Option<std::string::String>,
    /// <p>Configuration for processing job outputs in Amazon S3.</p>
    pub s3_output: std::option::Option<crate::model::ProcessingS3Output>,
    /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output
    /// type is only supported when <code>AppManaged</code> is specified. </p>
    pub feature_store_output: std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
    /// <p>When <code>True</code>, output operations such as data upload are managed natively by the
    /// processing job application. When <code>False</code> (default), output operations are managed by
    /// Amazon SageMaker.</p>
    pub app_managed: bool,
}
impl std::fmt::Debug for ProcessingOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingOutput");
        formatter.field("output_name", &self.output_name);
        formatter.field("s3_output", &self.s3_output);
        formatter.field("feature_store_output", &self.feature_store_output);
        formatter.field("app_managed", &self.app_managed);
        formatter.finish()
    }
}
/// See [`ProcessingOutput`](crate::model::ProcessingOutput)
pub mod processing_output {
    /// A builder for [`ProcessingOutput`](crate::model::ProcessingOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_name: std::option::Option<std::string::String>,
        pub(crate) s3_output: std::option::Option<crate::model::ProcessingS3Output>,
        pub(crate) feature_store_output:
            std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
        pub(crate) app_managed: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name for the processing job output.</p>
        pub fn output_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_name = Some(input.into());
            self
        }
        pub fn set_output_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_name = input;
            self
        }
        /// <p>Configuration for processing job outputs in Amazon S3.</p>
        pub fn s3_output(mut self, input: crate::model::ProcessingS3Output) -> Self {
            self.s3_output = Some(input);
            self
        }
        pub fn set_s3_output(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3Output>,
        ) -> Self {
            self.s3_output = input;
            self
        }
        /// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store. This processing output
        /// type is only supported when <code>AppManaged</code> is specified. </p>
        pub fn feature_store_output(
            mut self,
            input: crate::model::ProcessingFeatureStoreOutput,
        ) -> Self {
            self.feature_store_output = Some(input);
            self
        }
        pub fn set_feature_store_output(
            mut self,
            input: std::option::Option<crate::model::ProcessingFeatureStoreOutput>,
        ) -> Self {
            self.feature_store_output = input;
            self
        }
        /// <p>When <code>True</code>, output operations such as data upload are managed natively by the
        /// processing job application. When <code>False</code> (default), output operations are managed by
        /// Amazon SageMaker.</p>
        pub fn app_managed(mut self, input: bool) -> Self {
            self.app_managed = Some(input);
            self
        }
        pub fn set_app_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.app_managed = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingOutput`](crate::model::ProcessingOutput)
        pub fn build(self) -> crate::model::ProcessingOutput {
            crate::model::ProcessingOutput {
                output_name: self.output_name,
                s3_output: self.s3_output,
                feature_store_output: self.feature_store_output,
                app_managed: self.app_managed.unwrap_or_default(),
            }
        }
    }
}
impl ProcessingOutput {
    /// Creates a new builder-style object to manufacture [`ProcessingOutput`](crate::model::ProcessingOutput)
    pub fn builder() -> crate::model::processing_output::Builder {
        crate::model::processing_output::Builder::default()
    }
}

/// <p>Configuration for processing job outputs in Amazon SageMaker Feature Store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingFeatureStoreOutput {
    /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your
    /// processing script is responsible for putting records into your Feature Store.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessingFeatureStoreOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingFeatureStoreOutput");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.finish()
    }
}
/// See [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
pub mod processing_feature_store_output {
    /// A builder for [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon SageMaker FeatureGroup to use as the destination for processing job output. Note that your
        /// processing script is responsible for putting records into your Feature Store.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
        pub fn build(self) -> crate::model::ProcessingFeatureStoreOutput {
            crate::model::ProcessingFeatureStoreOutput {
                feature_group_name: self.feature_group_name,
            }
        }
    }
}
impl ProcessingFeatureStoreOutput {
    /// Creates a new builder-style object to manufacture [`ProcessingFeatureStoreOutput`](crate::model::ProcessingFeatureStoreOutput)
    pub fn builder() -> crate::model::processing_feature_store_output::Builder {
        crate::model::processing_feature_store_output::Builder::default()
    }
}

/// <p>Configuration for uploading output data to Amazon S3 from the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingS3Output {
    /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of
    /// a processing job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3.
    /// <code>LocalPath</code> is an absolute path to a directory containing output files.
    /// This directory will be created by the platform and exist when your container's
    /// entrypoint is invoked.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether to upload the results of the processing job continuously or after the job
    /// completes.</p>
    pub s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
}
impl std::fmt::Debug for ProcessingS3Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingS3Output");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_upload_mode", &self.s3_upload_mode);
        formatter.finish()
    }
}
/// See [`ProcessingS3Output`](crate::model::ProcessingS3Output)
pub mod processing_s3_output {
    /// A builder for [`ProcessingS3Output`](crate::model::ProcessingS3Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_upload_mode: std::option::Option<crate::model::ProcessingS3UploadMode>,
    }
    impl Builder {
        /// <p>A URI that identifies the Amazon S3 bucket where you want Amazon SageMaker to save the results of
        /// a processing job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path of a directory where you want Amazon SageMaker to upload its contents to Amazon S3.
        /// <code>LocalPath</code> is an absolute path to a directory containing output files.
        /// This directory will be created by the platform and exist when your container's
        /// entrypoint is invoked.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether to upload the results of the processing job continuously or after the job
        /// completes.</p>
        pub fn s3_upload_mode(mut self, input: crate::model::ProcessingS3UploadMode) -> Self {
            self.s3_upload_mode = Some(input);
            self
        }
        pub fn set_s3_upload_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3UploadMode>,
        ) -> Self {
            self.s3_upload_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingS3Output`](crate::model::ProcessingS3Output)
        pub fn build(self) -> crate::model::ProcessingS3Output {
            crate::model::ProcessingS3Output {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_upload_mode: self.s3_upload_mode,
            }
        }
    }
}
impl ProcessingS3Output {
    /// Creates a new builder-style object to manufacture [`ProcessingS3Output`](crate::model::ProcessingS3Output)
    pub fn builder() -> crate::model::processing_s3_output::Builder {
        crate::model::processing_s3_output::Builder::default()
    }
}

/// <p>The inputs for a processing job. The processing input must specify exactly one of either
/// <code>S3Input</code> or <code>DatasetDefinition</code> types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingInput {
    /// <p>The name for the processing job input.</p>
    pub input_name: std::option::Option<std::string::String>,
    /// <p>When <code>True</code>, input operations such as data download are managed natively by the
    /// processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
    pub app_managed: bool,
    /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
    pub s3_input: std::option::Option<crate::model::ProcessingS3Input>,
    /// <p>Configuration for a Dataset Definition input. </p>
    pub dataset_definition: std::option::Option<crate::model::DatasetDefinition>,
}
impl std::fmt::Debug for ProcessingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingInput");
        formatter.field("input_name", &self.input_name);
        formatter.field("app_managed", &self.app_managed);
        formatter.field("s3_input", &self.s3_input);
        formatter.field("dataset_definition", &self.dataset_definition);
        formatter.finish()
    }
}
/// See [`ProcessingInput`](crate::model::ProcessingInput)
pub mod processing_input {
    /// A builder for [`ProcessingInput`](crate::model::ProcessingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_name: std::option::Option<std::string::String>,
        pub(crate) app_managed: std::option::Option<bool>,
        pub(crate) s3_input: std::option::Option<crate::model::ProcessingS3Input>,
        pub(crate) dataset_definition: std::option::Option<crate::model::DatasetDefinition>,
    }
    impl Builder {
        /// <p>The name for the processing job input.</p>
        pub fn input_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_name = Some(input.into());
            self
        }
        pub fn set_input_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_name = input;
            self
        }
        /// <p>When <code>True</code>, input operations such as data download are managed natively by the
        /// processing job application. When <code>False</code> (default), input operations are managed by Amazon SageMaker.</p>
        pub fn app_managed(mut self, input: bool) -> Self {
            self.app_managed = Some(input);
            self
        }
        pub fn set_app_managed(mut self, input: std::option::Option<bool>) -> Self {
            self.app_managed = input;
            self
        }
        /// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
        pub fn s3_input(mut self, input: crate::model::ProcessingS3Input) -> Self {
            self.s3_input = Some(input);
            self
        }
        pub fn set_s3_input(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3Input>,
        ) -> Self {
            self.s3_input = input;
            self
        }
        /// <p>Configuration for a Dataset Definition input. </p>
        pub fn dataset_definition(mut self, input: crate::model::DatasetDefinition) -> Self {
            self.dataset_definition = Some(input);
            self
        }
        pub fn set_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::DatasetDefinition>,
        ) -> Self {
            self.dataset_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingInput`](crate::model::ProcessingInput)
        pub fn build(self) -> crate::model::ProcessingInput {
            crate::model::ProcessingInput {
                input_name: self.input_name,
                app_managed: self.app_managed.unwrap_or_default(),
                s3_input: self.s3_input,
                dataset_definition: self.dataset_definition,
            }
        }
    }
}
impl ProcessingInput {
    /// Creates a new builder-style object to manufacture [`ProcessingInput`](crate::model::ProcessingInput)
    pub fn builder() -> crate::model::processing_input::Builder {
        crate::model::processing_input::Builder::default()
    }
}

/// <p>Configuration for Dataset Definition inputs. The Dataset Definition input must specify
/// exactly one of either <code>AthenaDatasetDefinition</code> or <code>RedshiftDatasetDefinition</code>
/// types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DatasetDefinition {
    /// <p>Configuration for Athena Dataset Definition input.</p>
    pub athena_dataset_definition: std::option::Option<crate::model::AthenaDatasetDefinition>,
    /// <p>Configuration for Redshift Dataset Definition input.</p>
    pub redshift_dataset_definition: std::option::Option<crate::model::RedshiftDatasetDefinition>,
    /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a
    /// processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required
    /// parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether the generated dataset is <code>FullyReplicated</code> or
    /// <code>ShardedByS3Key</code> (default).</p>
    pub data_distribution_type: std::option::Option<crate::model::DataDistributionType>,
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode,
    /// Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store
    /// (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used
    /// input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your
    /// algorithm without using the EBS volume.</p>
    pub input_mode: std::option::Option<crate::model::InputMode>,
}
impl std::fmt::Debug for DatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DatasetDefinition");
        formatter.field("athena_dataset_definition", &self.athena_dataset_definition);
        formatter.field(
            "redshift_dataset_definition",
            &self.redshift_dataset_definition,
        );
        formatter.field("local_path", &self.local_path);
        formatter.field("data_distribution_type", &self.data_distribution_type);
        formatter.field("input_mode", &self.input_mode);
        formatter.finish()
    }
}
/// See [`DatasetDefinition`](crate::model::DatasetDefinition)
pub mod dataset_definition {
    /// A builder for [`DatasetDefinition`](crate::model::DatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) athena_dataset_definition:
            std::option::Option<crate::model::AthenaDatasetDefinition>,
        pub(crate) redshift_dataset_definition:
            std::option::Option<crate::model::RedshiftDatasetDefinition>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) data_distribution_type: std::option::Option<crate::model::DataDistributionType>,
        pub(crate) input_mode: std::option::Option<crate::model::InputMode>,
    }
    impl Builder {
        /// <p>Configuration for Athena Dataset Definition input.</p>
        pub fn athena_dataset_definition(
            mut self,
            input: crate::model::AthenaDatasetDefinition,
        ) -> Self {
            self.athena_dataset_definition = Some(input);
            self
        }
        pub fn set_athena_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::AthenaDatasetDefinition>,
        ) -> Self {
            self.athena_dataset_definition = input;
            self
        }
        /// <p>Configuration for Redshift Dataset Definition input.</p>
        pub fn redshift_dataset_definition(
            mut self,
            input: crate::model::RedshiftDatasetDefinition,
        ) -> Self {
            self.redshift_dataset_definition = Some(input);
            self
        }
        pub fn set_redshift_dataset_definition(
            mut self,
            input: std::option::Option<crate::model::RedshiftDatasetDefinition>,
        ) -> Self {
            self.redshift_dataset_definition = input;
            self
        }
        /// <p>The local path where you want Amazon SageMaker to download the Dataset Definition inputs to run a
        /// processing job. <code>LocalPath</code> is an absolute path to the input data. This is a required
        /// parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether the generated dataset is <code>FullyReplicated</code> or
        /// <code>ShardedByS3Key</code> (default).</p>
        pub fn data_distribution_type(mut self, input: crate::model::DataDistributionType) -> Self {
            self.data_distribution_type = Some(input);
            self
        }
        pub fn set_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::DataDistributionType>,
        ) -> Self {
            self.data_distribution_type = input;
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In <code>File</code> (default) mode,
        /// Amazon SageMaker copies the data from the input source onto the local Amazon Elastic Block Store
        /// (Amazon EBS) volumes before starting your training algorithm. This is the most commonly used
        /// input mode. In <code>Pipe</code> mode, Amazon SageMaker streams input data from the source directly to your
        /// algorithm without using the EBS volume.</p>
        pub fn input_mode(mut self, input: crate::model::InputMode) -> Self {
            self.input_mode = Some(input);
            self
        }
        pub fn set_input_mode(
            mut self,
            input: std::option::Option<crate::model::InputMode>,
        ) -> Self {
            self.input_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetDefinition`](crate::model::DatasetDefinition)
        pub fn build(self) -> crate::model::DatasetDefinition {
            crate::model::DatasetDefinition {
                athena_dataset_definition: self.athena_dataset_definition,
                redshift_dataset_definition: self.redshift_dataset_definition,
                local_path: self.local_path,
                data_distribution_type: self.data_distribution_type,
                input_mode: self.input_mode,
            }
        }
    }
}
impl DatasetDefinition {
    /// Creates a new builder-style object to manufacture [`DatasetDefinition`](crate::model::DatasetDefinition)
    pub fn builder() -> crate::model::dataset_definition::Builder {
        crate::model::dataset_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InputMode {
    File,
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InputMode {
    fn from(s: &str) -> Self {
        match s {
            "File" => InputMode::File,
            "Pipe" => InputMode::Pipe,
            other => InputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InputMode::from(s))
    }
}
impl InputMode {
    pub fn as_str(&self) -> &str {
        match self {
            InputMode::File => "File",
            InputMode::Pipe => "Pipe",
            InputMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["File", "Pipe"]
    }
}
impl AsRef<str> for InputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataDistributionType {
    Fullyreplicated,
    Shardedbys3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataDistributionType {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => DataDistributionType::Fullyreplicated,
            "ShardedByS3Key" => DataDistributionType::Shardedbys3Key,
            other => DataDistributionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataDistributionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataDistributionType::from(s))
    }
}
impl DataDistributionType {
    pub fn as_str(&self) -> &str {
        match self {
            DataDistributionType::Fullyreplicated => "FullyReplicated",
            DataDistributionType::Shardedbys3Key => "ShardedByS3Key",
            DataDistributionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for DataDistributionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for Redshift Dataset Definition input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedshiftDatasetDefinition {
    /// <p>The Redshift cluster Identifier.</p>
    pub cluster_id: std::option::Option<std::string::String>,
    /// <p>The name of the Redshift database used in Redshift query execution.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The database user name used in Redshift query execution.</p>
    pub db_user: std::option::Option<std::string::String>,
    /// <p>The SQL query statements to be executed.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
    pub cluster_role_arn: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
    pub output_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a
    /// Redshift execution.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The data storage format for Redshift query results.</p>
    pub output_format: std::option::Option<crate::model::RedshiftResultFormat>,
    /// <p>The compression used for Redshift query results.</p>
    pub output_compression: std::option::Option<crate::model::RedshiftResultCompressionType>,
}
impl std::fmt::Debug for RedshiftDatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedshiftDatasetDefinition");
        formatter.field("cluster_id", &self.cluster_id);
        formatter.field("database", &self.database);
        formatter.field("db_user", &self.db_user);
        formatter.field("query_string", &self.query_string);
        formatter.field("cluster_role_arn", &self.cluster_role_arn);
        formatter.field("output_s3_uri", &self.output_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("output_format", &self.output_format);
        formatter.field("output_compression", &self.output_compression);
        formatter.finish()
    }
}
/// See [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
pub mod redshift_dataset_definition {
    /// A builder for [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_id: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) db_user: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) cluster_role_arn: std::option::Option<std::string::String>,
        pub(crate) output_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<crate::model::RedshiftResultFormat>,
        pub(crate) output_compression:
            std::option::Option<crate::model::RedshiftResultCompressionType>,
    }
    impl Builder {
        /// <p>The Redshift cluster Identifier.</p>
        pub fn cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_id = Some(input.into());
            self
        }
        pub fn set_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_id = input;
            self
        }
        /// <p>The name of the Redshift database used in Redshift query execution.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The database user name used in Redshift query execution.</p>
        pub fn db_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_user = Some(input.into());
            self
        }
        pub fn set_db_user(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_user = input;
            self
        }
        /// <p>The SQL query statements to be executed.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The IAM role attached to your Redshift cluster that Amazon SageMaker uses to generate datasets.</p>
        pub fn cluster_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_role_arn = Some(input.into());
            self
        }
        pub fn set_cluster_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_role_arn = input;
            self
        }
        /// <p>The location in Amazon S3 where the Redshift query results are stored.</p>
        pub fn output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_uri = Some(input.into());
            self
        }
        pub fn set_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data from a
        /// Redshift execution.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The data storage format for Redshift query results.</p>
        pub fn output_format(mut self, input: crate::model::RedshiftResultFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::RedshiftResultFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p>The compression used for Redshift query results.</p>
        pub fn output_compression(
            mut self,
            input: crate::model::RedshiftResultCompressionType,
        ) -> Self {
            self.output_compression = Some(input);
            self
        }
        pub fn set_output_compression(
            mut self,
            input: std::option::Option<crate::model::RedshiftResultCompressionType>,
        ) -> Self {
            self.output_compression = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
        pub fn build(self) -> crate::model::RedshiftDatasetDefinition {
            crate::model::RedshiftDatasetDefinition {
                cluster_id: self.cluster_id,
                database: self.database,
                db_user: self.db_user,
                query_string: self.query_string,
                cluster_role_arn: self.cluster_role_arn,
                output_s3_uri: self.output_s3_uri,
                kms_key_id: self.kms_key_id,
                output_format: self.output_format,
                output_compression: self.output_compression,
            }
        }
    }
}
impl RedshiftDatasetDefinition {
    /// Creates a new builder-style object to manufacture [`RedshiftDatasetDefinition`](crate::model::RedshiftDatasetDefinition)
    pub fn builder() -> crate::model::redshift_dataset_definition::Builder {
        crate::model::redshift_dataset_definition::Builder::default()
    }
}

/// <p>The compression used for Redshift query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedshiftResultCompressionType {
    Bzip2,
    Gzip,
    None,
    Snappy,
    Zstd,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedshiftResultCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "BZIP2" => RedshiftResultCompressionType::Bzip2,
            "GZIP" => RedshiftResultCompressionType::Gzip,
            "None" => RedshiftResultCompressionType::None,
            "SNAPPY" => RedshiftResultCompressionType::Snappy,
            "ZSTD" => RedshiftResultCompressionType::Zstd,
            other => RedshiftResultCompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedshiftResultCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedshiftResultCompressionType::from(s))
    }
}
impl RedshiftResultCompressionType {
    pub fn as_str(&self) -> &str {
        match self {
            RedshiftResultCompressionType::Bzip2 => "BZIP2",
            RedshiftResultCompressionType::Gzip => "GZIP",
            RedshiftResultCompressionType::None => "None",
            RedshiftResultCompressionType::Snappy => "SNAPPY",
            RedshiftResultCompressionType::Zstd => "ZSTD",
            RedshiftResultCompressionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["BZIP2", "GZIP", "None", "SNAPPY", "ZSTD"]
    }
}
impl AsRef<str> for RedshiftResultCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data storage format for Redshift query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RedshiftResultFormat {
    Csv,
    Parquet,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RedshiftResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => RedshiftResultFormat::Csv,
            "PARQUET" => RedshiftResultFormat::Parquet,
            other => RedshiftResultFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RedshiftResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RedshiftResultFormat::from(s))
    }
}
impl RedshiftResultFormat {
    pub fn as_str(&self) -> &str {
        match self {
            RedshiftResultFormat::Csv => "CSV",
            RedshiftResultFormat::Parquet => "PARQUET",
            RedshiftResultFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CSV", "PARQUET"]
    }
}
impl AsRef<str> for RedshiftResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for Athena Dataset Definition input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AthenaDatasetDefinition {
    /// <p>The name of the data catalog used in Athena query execution.</p>
    pub catalog: std::option::Option<std::string::String>,
    /// <p>The name of the database used in the Athena query execution.</p>
    pub database: std::option::Option<std::string::String>,
    /// <p>The SQL query statements, to be executed.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The name of the workgroup in which the Athena query is being started.</p>
    pub work_group: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where Athena query results are stored.</p>
    pub output_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from
    /// an Athena query execution.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The data storage format for Athena query results.</p>
    pub output_format: std::option::Option<crate::model::AthenaResultFormat>,
    /// <p>The compression used for Athena query results.</p>
    pub output_compression: std::option::Option<crate::model::AthenaResultCompressionType>,
}
impl std::fmt::Debug for AthenaDatasetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AthenaDatasetDefinition");
        formatter.field("catalog", &self.catalog);
        formatter.field("database", &self.database);
        formatter.field("query_string", &self.query_string);
        formatter.field("work_group", &self.work_group);
        formatter.field("output_s3_uri", &self.output_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("output_format", &self.output_format);
        formatter.field("output_compression", &self.output_compression);
        formatter.finish()
    }
}
/// See [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
pub mod athena_dataset_definition {
    /// A builder for [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) catalog: std::option::Option<std::string::String>,
        pub(crate) database: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) work_group: std::option::Option<std::string::String>,
        pub(crate) output_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<crate::model::AthenaResultFormat>,
        pub(crate) output_compression:
            std::option::Option<crate::model::AthenaResultCompressionType>,
    }
    impl Builder {
        /// <p>The name of the data catalog used in Athena query execution.</p>
        pub fn catalog(mut self, input: impl Into<std::string::String>) -> Self {
            self.catalog = Some(input.into());
            self
        }
        pub fn set_catalog(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.catalog = input;
            self
        }
        /// <p>The name of the database used in the Athena query execution.</p>
        pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
            self.database = Some(input.into());
            self
        }
        pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.database = input;
            self
        }
        /// <p>The SQL query statements, to be executed.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The name of the workgroup in which the Athena query is being started.</p>
        pub fn work_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_group = Some(input.into());
            self
        }
        pub fn set_work_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.work_group = input;
            self
        }
        /// <p>The location in Amazon S3 where Athena query results are stored.</p>
        pub fn output_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_s3_uri = Some(input.into());
            self
        }
        pub fn set_output_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data generated from
        /// an Athena query execution.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The data storage format for Athena query results.</p>
        pub fn output_format(mut self, input: crate::model::AthenaResultFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::AthenaResultFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// <p>The compression used for Athena query results.</p>
        pub fn output_compression(
            mut self,
            input: crate::model::AthenaResultCompressionType,
        ) -> Self {
            self.output_compression = Some(input);
            self
        }
        pub fn set_output_compression(
            mut self,
            input: std::option::Option<crate::model::AthenaResultCompressionType>,
        ) -> Self {
            self.output_compression = input;
            self
        }
        /// Consumes the builder and constructs a [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
        pub fn build(self) -> crate::model::AthenaDatasetDefinition {
            crate::model::AthenaDatasetDefinition {
                catalog: self.catalog,
                database: self.database,
                query_string: self.query_string,
                work_group: self.work_group,
                output_s3_uri: self.output_s3_uri,
                kms_key_id: self.kms_key_id,
                output_format: self.output_format,
                output_compression: self.output_compression,
            }
        }
    }
}
impl AthenaDatasetDefinition {
    /// Creates a new builder-style object to manufacture [`AthenaDatasetDefinition`](crate::model::AthenaDatasetDefinition)
    pub fn builder() -> crate::model::athena_dataset_definition::Builder {
        crate::model::athena_dataset_definition::Builder::default()
    }
}

/// <p>The compression used for Athena query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AthenaResultCompressionType {
    Gzip,
    Snappy,
    Zlib,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AthenaResultCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "GZIP" => AthenaResultCompressionType::Gzip,
            "SNAPPY" => AthenaResultCompressionType::Snappy,
            "ZLIB" => AthenaResultCompressionType::Zlib,
            other => AthenaResultCompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AthenaResultCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AthenaResultCompressionType::from(s))
    }
}
impl AthenaResultCompressionType {
    pub fn as_str(&self) -> &str {
        match self {
            AthenaResultCompressionType::Gzip => "GZIP",
            AthenaResultCompressionType::Snappy => "SNAPPY",
            AthenaResultCompressionType::Zlib => "ZLIB",
            AthenaResultCompressionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["GZIP", "SNAPPY", "ZLIB"]
    }
}
impl AsRef<str> for AthenaResultCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data storage format for Athena query results.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AthenaResultFormat {
    Avro,
    Json,
    Orc,
    Parquet,
    Textfile,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AthenaResultFormat {
    fn from(s: &str) -> Self {
        match s {
            "AVRO" => AthenaResultFormat::Avro,
            "JSON" => AthenaResultFormat::Json,
            "ORC" => AthenaResultFormat::Orc,
            "PARQUET" => AthenaResultFormat::Parquet,
            "TEXTFILE" => AthenaResultFormat::Textfile,
            other => AthenaResultFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AthenaResultFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AthenaResultFormat::from(s))
    }
}
impl AthenaResultFormat {
    pub fn as_str(&self) -> &str {
        match self {
            AthenaResultFormat::Avro => "AVRO",
            AthenaResultFormat::Json => "JSON",
            AthenaResultFormat::Orc => "ORC",
            AthenaResultFormat::Parquet => "PARQUET",
            AthenaResultFormat::Textfile => "TEXTFILE",
            AthenaResultFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AVRO", "JSON", "ORC", "PARQUET", "TEXTFILE"]
    }
}
impl AsRef<str> for AthenaResultFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for downloading input data from Amazon S3 into the processing container.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingS3Input {
    /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The local path in your container where you want Amazon SageMaker to write input data to.
    /// <code>LocalPath</code> is an absolute path to the input data and must begin with
    /// <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required
    /// parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for
    /// the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key
    /// name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing
    /// job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object
    /// that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for
    /// the processing job.</p>
    pub s3_data_type: std::option::Option<crate::model::ProcessingS3DataType>,
    /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data
    /// from the input source onto the local ML storage volume before starting your processing
    /// container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker
    /// streams input data from the source directly to your processing container into named
    /// pipes without using the ML storage volume.</p>
    pub s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
    /// <p>Whether to distribute the data from Amazon S3 to all processing instances with
    /// <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key,
    /// downloading one shard of data to each processing instance.</p>
    pub s3_data_distribution_type:
        std::option::Option<crate::model::ProcessingS3DataDistributionType>,
    /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing
    /// container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is
    /// specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input
    /// data from the source directly to your container without using the EBS volume.</p>
    pub s3_compression_type: std::option::Option<crate::model::ProcessingS3CompressionType>,
}
impl std::fmt::Debug for ProcessingS3Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingS3Input");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_input_mode", &self.s3_input_mode);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("s3_compression_type", &self.s3_compression_type);
        formatter.finish()
    }
}
/// See [`ProcessingS3Input`](crate::model::ProcessingS3Input)
pub mod processing_s3_input {
    /// A builder for [`ProcessingS3Input`](crate::model::ProcessingS3Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_data_type: std::option::Option<crate::model::ProcessingS3DataType>,
        pub(crate) s3_input_mode: std::option::Option<crate::model::ProcessingS3InputMode>,
        pub(crate) s3_data_distribution_type:
            std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        pub(crate) s3_compression_type:
            std::option::Option<crate::model::ProcessingS3CompressionType>,
    }
    impl Builder {
        /// <p>The URI of the Amazon S3 prefix Amazon SageMaker downloads data required to run a processing job.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The local path in your container where you want Amazon SageMaker to write input data to.
        /// <code>LocalPath</code> is an absolute path to the input data and must begin with
        /// <code>/opt/ml/processing/</code>. <code>LocalPath</code> is a required
        /// parameter when <code>AppManaged</code> is <code>False</code> (default).</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Whether you use an <code>S3Prefix</code> or a <code>ManifestFile</code> for
        /// the data type. If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key
        /// name prefix. Amazon SageMaker uses all objects with the specified key name prefix for the processing
        /// job. If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object
        /// that is a manifest file containing a list of object keys that you want Amazon SageMaker to use for
        /// the processing job.</p>
        pub fn s3_data_type(mut self, input: crate::model::ProcessingS3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Whether to use <code>File</code> or <code>Pipe</code> input mode. In File mode, Amazon SageMaker copies the data
        /// from the input source onto the local ML storage volume before starting your processing
        /// container. This is the most commonly used input mode. In <code>Pipe</code> mode, Amazon SageMaker
        /// streams input data from the source directly to your processing container into named
        /// pipes without using the ML storage volume.</p>
        pub fn s3_input_mode(mut self, input: crate::model::ProcessingS3InputMode) -> Self {
            self.s3_input_mode = Some(input);
            self
        }
        pub fn set_s3_input_mode(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3InputMode>,
        ) -> Self {
            self.s3_input_mode = input;
            self
        }
        /// <p>Whether to distribute the data from Amazon S3 to all processing instances with
        /// <code>FullyReplicated</code>, or whether the data from Amazon S3 is shared by Amazon S3 key,
        /// downloading one shard of data to each processing instance.</p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::ProcessingS3DataDistributionType,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3DataDistributionType>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        /// <p>Whether to GZIP-decompress the data in Amazon S3 as it is streamed into the processing
        /// container. <code>Gzip</code> can only be used when <code>Pipe</code> mode is
        /// specified as the <code>S3InputMode</code>. In <code>Pipe</code> mode, Amazon SageMaker streams input
        /// data from the source directly to your container without using the EBS volume.</p>
        pub fn s3_compression_type(
            mut self,
            input: crate::model::ProcessingS3CompressionType,
        ) -> Self {
            self.s3_compression_type = Some(input);
            self
        }
        pub fn set_s3_compression_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingS3CompressionType>,
        ) -> Self {
            self.s3_compression_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingS3Input`](crate::model::ProcessingS3Input)
        pub fn build(self) -> crate::model::ProcessingS3Input {
            crate::model::ProcessingS3Input {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
                s3_data_type: self.s3_data_type,
                s3_input_mode: self.s3_input_mode,
                s3_data_distribution_type: self.s3_data_distribution_type,
                s3_compression_type: self.s3_compression_type,
            }
        }
    }
}
impl ProcessingS3Input {
    /// Creates a new builder-style object to manufacture [`ProcessingS3Input`](crate::model::ProcessingS3Input)
    pub fn builder() -> crate::model::processing_s3_input::Builder {
        crate::model::processing_s3_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3CompressionType {
    Gzip,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3CompressionType {
    fn from(s: &str) -> Self {
        match s {
            "Gzip" => ProcessingS3CompressionType::Gzip,
            "None" => ProcessingS3CompressionType::None,
            other => ProcessingS3CompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3CompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3CompressionType::from(s))
    }
}
impl ProcessingS3CompressionType {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3CompressionType::Gzip => "Gzip",
            ProcessingS3CompressionType::None => "None",
            ProcessingS3CompressionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Gzip", "None"]
    }
}
impl AsRef<str> for ProcessingS3CompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProcessingS3DataType {
    ManifestFile,
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProcessingS3DataType {
    fn from(s: &str) -> Self {
        match s {
            "ManifestFile" => ProcessingS3DataType::ManifestFile,
            "S3Prefix" => ProcessingS3DataType::S3Prefix,
            other => ProcessingS3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProcessingS3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProcessingS3DataType::from(s))
    }
}
impl ProcessingS3DataType {
    pub fn as_str(&self) -> &str {
        match self {
            ProcessingS3DataType::ManifestFile => "ManifestFile",
            ProcessingS3DataType::S3Prefix => "S3Prefix",
            ProcessingS3DataType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for ProcessingS3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJob {
    /// <p>The name of the training job.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the
    /// training job was launched by a hyperparameter tuning job.</p>
    pub tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>Information about the Amazon S3 location that is configured for storing model
    /// artifacts.</p>
    pub model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
    /// <p>The status of the
    /// training
    /// job.</p>
    /// <p>Training job statuses are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>InProgress</code> - The training is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The training job has completed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The training job has failed. To see the reason for the
    /// failure, see the <code>FailureReason</code> field in the response to a
    /// <code>DescribeTrainingJobResponse</code> call.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - The training job is stopping.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The training job has stopped.</p>
    /// </li>
    /// </ul>
    /// <p>For
    /// more detailed information, see <code>SecondaryStatus</code>. </p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    /// <p> Provides detailed information about the state of the training job. For detailed
    /// information about the secondary status of the training job, see
    /// <code>StatusMessage</code> under <a>SecondaryStatusTransition</a>.</p>
    /// <p>Amazon SageMaker provides primary statuses and secondary statuses that apply to each of
    /// them:</p>
    /// <dl>
    /// <dt>InProgress</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Starting</code>
    /// - Starting the training job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Downloading</code> - An optional stage for algorithms that
    /// support <code>File</code> training input mode. It indicates that
    /// data is being downloaded to the ML storage volumes.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Training</code> - Training is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Uploading</code> - Training is complete and the model
    /// artifacts are being uploaded to the S3 location.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The training job has completed.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The training job has failed. The reason for
    /// the failure is returned in the <code>FailureReason</code> field of
    /// <code>DescribeTrainingJobResponse</code>.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopped</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MaxRuntimeExceeded</code> - The job stopped because it
    /// exceeded the maximum allowed runtime.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The training job has stopped.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopping</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - Stopping the training job.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <important>
    /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
    /// </important>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>LaunchingMLInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PreparingTrainingStack</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DownloadingTrainingImage</code>
    /// </p>
    /// </li>
    /// </ul>
    pub secondary_status: std::option::Option<crate::model::SecondaryStatus>,
    /// <p>If the training job failed, the reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Algorithm-specific parameters.</p>
    pub hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
    pub algorithm_specification: std::option::Option<crate::model::AlgorithmSpecification>,
    /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An array of <code>Channel</code> objects that describes each data input
    /// channel.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>The S3 path where model artifacts that you configured when creating the job are
    /// stored. Amazon SageMaker creates subfolders for model artifacts.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>Resources, including ML compute instances and ML storage volumes, that are configured
    /// for model training.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>A <a>VpcConfig</a> object that specifies the VPC that this training job has
    /// access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon
    /// Virtual Private Cloud</a>.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
    /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
    /// ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, Amazon SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays
    /// job termination for 120 seconds. Algorithms can use this 120-second window to save the
    /// model artifacts, so the results of training are not lost. </p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>A timestamp that indicates when the training job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the time when the training job starts on training instances. You are billed
    /// for the time interval between this time and the value of <code>TrainingEndTime</code>.
    /// The start time in CloudWatch Logs might be later than this time. The difference is due to the time
    /// it takes to download the training data and to the size of the training container.</p>
    pub training_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates the time when the training job ends on training instances. You are billed
    /// for the time interval between the value of <code>TrainingStartTime</code> and this time.
    /// For successful jobs and stopped jobs, this is the time after model artifacts are
    /// uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.</p>
    pub training_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that indicates when the status of the training job was last
    /// modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>A history of all of the secondary statuses that the training job has transitioned
    /// through.</p>
    pub secondary_status_transitions:
        std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
    /// <p>A list of final metric values that are set when the training job completes. Used only
    /// if the training job was configured to use metrics.</p>
    pub final_metric_data_list: std::option::Option<std::vec::Vec<crate::model::MetricData>>,
    /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set
    /// to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond
    /// the VPC they run in.</p>
    pub enable_network_isolation: bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training,
    /// choose <code>True</code>. Encryption provides greater security for distributed training,
    /// but training might take longer. How long it takes depends on the amount of communication
    /// between compute instances, especially if you use a deep learning algorithm in
    /// distributed training.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run
    /// training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
    pub enable_managed_spot_training: bool,
    /// <p>Contains information about the output location for managed spot training checkpoint
    /// data. </p>
    pub checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
    /// <p>The training time in seconds.</p>
    pub training_time_in_seconds: std::option::Option<i32>,
    /// <p>The billable time in seconds.</p>
    pub billable_time_in_seconds: std::option::Option<i32>,
    /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and
    /// storage paths. To learn more about
    /// how to configure the <code>DebugHookConfig</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
    pub debug_hook_config: std::option::Option<crate::model::DebugHookConfig>,
    /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
    /// you call the following APIs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateProcessingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTrainingJob</a>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>CreateTransformJob</a>
    /// </p>
    /// </li>
    /// </ul>
    pub experiment_config: std::option::Option<crate::model::ExperimentConfig>,
    /// <p>Information about the debug rule configuration.</p>
    pub debug_rule_configurations:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
    /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
    pub tensor_board_output_config: std::option::Option<crate::model::TensorBoardOutputConfig>,
    /// <p>Information about the evaluation status of the rules for the training job.</p>
    pub debug_rule_evaluation_statuses:
        std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
    /// <p>The environment variables to set in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The number of times to retry the job when the job fails due to an
    /// <code>InternalServerError</code>.</p>
    pub retry_strategy: std::option::Option<crate::model::RetryStrategy>,
    /// <p>An array of key-value pairs. You can use tags to categorize your Amazon Web Services resources in
    /// different ways, for example, by purpose, owner, or environment. For more information,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services
    /// Resources</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TrainingJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJob");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tuning_job_arn", &self.tuning_job_arn);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("model_artifacts", &self.model_artifacts);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.field("secondary_status", &self.secondary_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "secondary_status_transitions",
            &self.secondary_status_transitions,
        );
        formatter.field("final_metric_data_list", &self.final_metric_data_list);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("training_time_in_seconds", &self.training_time_in_seconds);
        formatter.field("billable_time_in_seconds", &self.billable_time_in_seconds);
        formatter.field("debug_hook_config", &self.debug_hook_config);
        formatter.field("experiment_config", &self.experiment_config);
        formatter.field("debug_rule_configurations", &self.debug_rule_configurations);
        formatter.field(
            "tensor_board_output_config",
            &self.tensor_board_output_config,
        );
        formatter.field(
            "debug_rule_evaluation_statuses",
            &self.debug_rule_evaluation_statuses,
        );
        formatter.field("environment", &self.environment);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TrainingJob`](crate::model::TrainingJob)
pub mod training_job {
    /// A builder for [`TrainingJob`](crate::model::TrainingJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tuning_job_arn: std::option::Option<std::string::String>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) model_artifacts: std::option::Option<crate::model::ModelArtifacts>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
        pub(crate) secondary_status: std::option::Option<crate::model::SecondaryStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) algorithm_specification:
            std::option::Option<crate::model::AlgorithmSpecification>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) secondary_status_transitions:
            std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
        pub(crate) final_metric_data_list:
            std::option::Option<std::vec::Vec<crate::model::MetricData>>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_managed_spot_training: std::option::Option<bool>,
        pub(crate) checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
        pub(crate) training_time_in_seconds: std::option::Option<i32>,
        pub(crate) billable_time_in_seconds: std::option::Option<i32>,
        pub(crate) debug_hook_config: std::option::Option<crate::model::DebugHookConfig>,
        pub(crate) experiment_config: std::option::Option<crate::model::ExperimentConfig>,
        pub(crate) debug_rule_configurations:
            std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
        pub(crate) tensor_board_output_config:
            std::option::Option<crate::model::TensorBoardOutputConfig>,
        pub(crate) debug_rule_evaluation_statuses:
            std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) retry_strategy: std::option::Option<crate::model::RetryStrategy>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the training job.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the associated hyperparameter tuning job if the
        /// training job was launched by a hyperparameter tuning job.</p>
        pub fn tuning_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_job_arn = Some(input.into());
            self
        }
        pub fn set_tuning_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the labeling job.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>Information about the Amazon S3 location that is configured for storing model
        /// artifacts.</p>
        pub fn model_artifacts(mut self, input: crate::model::ModelArtifacts) -> Self {
            self.model_artifacts = Some(input);
            self
        }
        pub fn set_model_artifacts(
            mut self,
            input: std::option::Option<crate::model::ModelArtifacts>,
        ) -> Self {
            self.model_artifacts = input;
            self
        }
        /// <p>The status of the
        /// training
        /// job.</p>
        /// <p>Training job statuses are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>InProgress</code> - The training is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Completed</code> - The training job has completed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code> - The training job has failed. To see the reason for the
        /// failure, see the <code>FailureReason</code> field in the response to a
        /// <code>DescribeTrainingJobResponse</code> call.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopping</code> - The training job is stopping.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopped</code> - The training job has stopped.</p>
        /// </li>
        /// </ul>
        /// <p>For
        /// more detailed information, see <code>SecondaryStatus</code>. </p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        /// <p> Provides detailed information about the state of the training job. For detailed
        /// information about the secondary status of the training job, see
        /// <code>StatusMessage</code> under <a>SecondaryStatusTransition</a>.</p>
        /// <p>Amazon SageMaker provides primary statuses and secondary statuses that apply to each of
        /// them:</p>
        /// <dl>
        /// <dt>InProgress</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Starting</code>
        /// - Starting the training job.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Downloading</code> - An optional stage for algorithms that
        /// support <code>File</code> training input mode. It indicates that
        /// data is being downloaded to the ML storage volumes.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Training</code> - Training is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Uploading</code> - Training is complete and the model
        /// artifacts are being uploaded to the S3 location.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Completed</code> - The training job has completed.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Failed</code> - The training job has failed. The reason for
        /// the failure is returned in the <code>FailureReason</code> field of
        /// <code>DescribeTrainingJobResponse</code>.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Stopped</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MaxRuntimeExceeded</code> - The job stopped because it
        /// exceeded the maximum allowed runtime.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopped</code> - The training job has stopped.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Stopping</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Stopping</code> - Stopping the training job.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <important>
        /// <p>Valid values for <code>SecondaryStatus</code> are subject to change. </p>
        /// </important>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LaunchingMLInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PreparingTrainingStack</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DownloadingTrainingImage</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn secondary_status(mut self, input: crate::model::SecondaryStatus) -> Self {
            self.secondary_status = Some(input);
            self
        }
        pub fn set_secondary_status(
            mut self,
            input: std::option::Option<crate::model::SecondaryStatus>,
        ) -> Self {
            self.secondary_status = input;
            self
        }
        /// <p>If the training job failed, the reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        pub fn hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hyper_parameters = Some(hash_map);
            self
        }
        pub fn set_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hyper_parameters = input;
            self
        }
        /// <p>Information about the algorithm used for training, and algorithm metadata.</p>
        pub fn algorithm_specification(
            mut self,
            input: crate::model::AlgorithmSpecification,
        ) -> Self {
            self.algorithm_specification = Some(input);
            self
        }
        pub fn set_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::AlgorithmSpecification>,
        ) -> Self {
            self.algorithm_specification = input;
            self
        }
        /// <p>The Amazon Web Services Identity and Access Management (IAM) role configured for the training job.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        pub fn input_data_config(mut self, input: impl Into<crate::model::Channel>) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input.into());
            self.input_data_config = Some(v);
            self
        }
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The S3 path where model artifacts that you configured when creating the job are
        /// stored. Amazon SageMaker creates subfolders for model artifacts.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>Resources, including ML compute instances and ML storage volumes, that are configured
        /// for model training.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>A <a>VpcConfig</a> object that specifies the VPC that this training job has
        /// access to. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs by Using an Amazon
        /// Virtual Private Cloud</a>.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
        /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
        /// ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, Amazon SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays
        /// job termination for 120 seconds. Algorithms can use this 120-second window to save the
        /// model artifacts, so the results of training are not lost. </p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>A timestamp that indicates when the training job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates the time when the training job starts on training instances. You are billed
        /// for the time interval between this time and the value of <code>TrainingEndTime</code>.
        /// The start time in CloudWatch Logs might be later than this time. The difference is due to the time
        /// it takes to download the training data and to the size of the training container.</p>
        pub fn training_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.training_start_time = Some(input);
            self
        }
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>Indicates the time when the training job ends on training instances. You are billed
        /// for the time interval between the value of <code>TrainingStartTime</code> and this time.
        /// For successful jobs and stopped jobs, this is the time after model artifacts are
        /// uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.</p>
        pub fn training_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.training_end_time = Some(input);
            self
        }
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>A timestamp that indicates when the status of the training job was last
        /// modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        pub fn secondary_status_transitions(
            mut self,
            input: impl Into<crate::model::SecondaryStatusTransition>,
        ) -> Self {
            let mut v = self.secondary_status_transitions.unwrap_or_default();
            v.push(input.into());
            self.secondary_status_transitions = Some(v);
            self
        }
        pub fn set_secondary_status_transitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SecondaryStatusTransition>>,
        ) -> Self {
            self.secondary_status_transitions = input;
            self
        }
        pub fn final_metric_data_list(
            mut self,
            input: impl Into<crate::model::MetricData>,
        ) -> Self {
            let mut v = self.final_metric_data_list.unwrap_or_default();
            v.push(input.into());
            self.final_metric_data_list = Some(v);
            self
        }
        pub fn set_final_metric_data_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricData>>,
        ) -> Self {
            self.final_metric_data_list = input;
            self
        }
        /// <p>If the <code>TrainingJob</code> was created with network isolation, the value is set
        /// to <code>true</code>. If network isolation is enabled, nodes can't communicate beyond
        /// the VPC they run in.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training,
        /// choose <code>True</code>. Encryption provides greater security for distributed training,
        /// but training might take longer. How long it takes depends on the amount of communication
        /// between compute instances, especially if you use a deep learning algorithm in
        /// distributed training.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>When true, enables managed spot training using Amazon EC2 Spot instances to run
        /// training jobs instead of on-demand instances. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-managed-spot-training.html">Managed Spot Training</a>.</p>
        pub fn enable_managed_spot_training(mut self, input: bool) -> Self {
            self.enable_managed_spot_training = Some(input);
            self
        }
        pub fn set_enable_managed_spot_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_managed_spot_training = input;
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint
        /// data. </p>
        pub fn checkpoint_config(mut self, input: crate::model::CheckpointConfig) -> Self {
            self.checkpoint_config = Some(input);
            self
        }
        pub fn set_checkpoint_config(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfig>,
        ) -> Self {
            self.checkpoint_config = input;
            self
        }
        /// <p>The training time in seconds.</p>
        pub fn training_time_in_seconds(mut self, input: i32) -> Self {
            self.training_time_in_seconds = Some(input);
            self
        }
        pub fn set_training_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.training_time_in_seconds = input;
            self
        }
        /// <p>The billable time in seconds.</p>
        pub fn billable_time_in_seconds(mut self, input: i32) -> Self {
            self.billable_time_in_seconds = Some(input);
            self
        }
        pub fn set_billable_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.billable_time_in_seconds = input;
            self
        }
        /// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and
        /// storage paths. To learn more about
        /// how to configure the <code>DebugHookConfig</code> parameter,
        /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
        pub fn debug_hook_config(mut self, input: crate::model::DebugHookConfig) -> Self {
            self.debug_hook_config = Some(input);
            self
        }
        pub fn set_debug_hook_config(
            mut self,
            input: std::option::Option<crate::model::DebugHookConfig>,
        ) -> Self {
            self.debug_hook_config = input;
            self
        }
        /// <p>Associates a SageMaker job as a trial component with an experiment and trial. Specified when
        /// you call the following APIs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a>CreateProcessingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTrainingJob</a>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>CreateTransformJob</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn experiment_config(mut self, input: crate::model::ExperimentConfig) -> Self {
            self.experiment_config = Some(input);
            self
        }
        pub fn set_experiment_config(
            mut self,
            input: std::option::Option<crate::model::ExperimentConfig>,
        ) -> Self {
            self.experiment_config = input;
            self
        }
        pub fn debug_rule_configurations(
            mut self,
            input: impl Into<crate::model::DebugRuleConfiguration>,
        ) -> Self {
            let mut v = self.debug_rule_configurations.unwrap_or_default();
            v.push(input.into());
            self.debug_rule_configurations = Some(v);
            self
        }
        pub fn set_debug_rule_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DebugRuleConfiguration>>,
        ) -> Self {
            self.debug_rule_configurations = input;
            self
        }
        /// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
        pub fn tensor_board_output_config(
            mut self,
            input: crate::model::TensorBoardOutputConfig,
        ) -> Self {
            self.tensor_board_output_config = Some(input);
            self
        }
        pub fn set_tensor_board_output_config(
            mut self,
            input: std::option::Option<crate::model::TensorBoardOutputConfig>,
        ) -> Self {
            self.tensor_board_output_config = input;
            self
        }
        pub fn debug_rule_evaluation_statuses(
            mut self,
            input: impl Into<crate::model::DebugRuleEvaluationStatus>,
        ) -> Self {
            let mut v = self.debug_rule_evaluation_statuses.unwrap_or_default();
            v.push(input.into());
            self.debug_rule_evaluation_statuses = Some(v);
            self
        }
        pub fn set_debug_rule_evaluation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DebugRuleEvaluationStatus>>,
        ) -> Self {
            self.debug_rule_evaluation_statuses = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an
        /// <code>InternalServerError</code>.</p>
        pub fn retry_strategy(mut self, input: crate::model::RetryStrategy) -> Self {
            self.retry_strategy = Some(input);
            self
        }
        pub fn set_retry_strategy(
            mut self,
            input: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.retry_strategy = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJob`](crate::model::TrainingJob)
        pub fn build(self) -> crate::model::TrainingJob {
            crate::model::TrainingJob {
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                tuning_job_arn: self.tuning_job_arn,
                labeling_job_arn: self.labeling_job_arn,
                auto_ml_job_arn: self.auto_ml_job_arn,
                model_artifacts: self.model_artifacts,
                training_job_status: self.training_job_status,
                secondary_status: self.secondary_status,
                failure_reason: self.failure_reason,
                hyper_parameters: self.hyper_parameters,
                algorithm_specification: self.algorithm_specification,
                role_arn: self.role_arn,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                vpc_config: self.vpc_config,
                stopping_condition: self.stopping_condition,
                creation_time: self.creation_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                last_modified_time: self.last_modified_time,
                secondary_status_transitions: self.secondary_status_transitions,
                final_metric_data_list: self.final_metric_data_list,
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_managed_spot_training: self.enable_managed_spot_training.unwrap_or_default(),
                checkpoint_config: self.checkpoint_config,
                training_time_in_seconds: self.training_time_in_seconds,
                billable_time_in_seconds: self.billable_time_in_seconds,
                debug_hook_config: self.debug_hook_config,
                experiment_config: self.experiment_config,
                debug_rule_configurations: self.debug_rule_configurations,
                tensor_board_output_config: self.tensor_board_output_config,
                debug_rule_evaluation_statuses: self.debug_rule_evaluation_statuses,
                environment: self.environment,
                retry_strategy: self.retry_strategy,
                tags: self.tags,
            }
        }
    }
}
impl TrainingJob {
    /// Creates a new builder-style object to manufacture [`TrainingJob`](crate::model::TrainingJob)
    pub fn builder() -> crate::model::training_job::Builder {
        crate::model::training_job::Builder::default()
    }
}

/// <p>The retry strategy to use when a training job fails due to an
/// <code>InternalServerError</code>. <code>RetryStrategy</code> is specified as part of
/// the <code>CreateTrainingJob</code> and <code>CreateHyperParameterTuningJob</code>
/// requests. You can add the <code>StoppingCondition</code> parameter to the request to
/// limit the training time for the complete job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RetryStrategy {
    /// <p>The number of times to retry the job. When the job is retried, it's
    /// <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
    pub maximum_retry_attempts: i32,
}
impl std::fmt::Debug for RetryStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RetryStrategy");
        formatter.field("maximum_retry_attempts", &self.maximum_retry_attempts);
        formatter.finish()
    }
}
/// See [`RetryStrategy`](crate::model::RetryStrategy)
pub mod retry_strategy {
    /// A builder for [`RetryStrategy`](crate::model::RetryStrategy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_retry_attempts: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of times to retry the job. When the job is retried, it's
        /// <code>SecondaryStatus</code> is changed to <code>STARTING</code>.</p>
        pub fn maximum_retry_attempts(mut self, input: i32) -> Self {
            self.maximum_retry_attempts = Some(input);
            self
        }
        pub fn set_maximum_retry_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_retry_attempts = input;
            self
        }
        /// Consumes the builder and constructs a [`RetryStrategy`](crate::model::RetryStrategy)
        pub fn build(self) -> crate::model::RetryStrategy {
            crate::model::RetryStrategy {
                maximum_retry_attempts: self.maximum_retry_attempts.unwrap_or_default(),
            }
        }
    }
}
impl RetryStrategy {
    /// Creates a new builder-style object to manufacture [`RetryStrategy`](crate::model::RetryStrategy)
    pub fn builder() -> crate::model::retry_strategy::Builder {
        crate::model::retry_strategy::Builder::default()
    }
}

/// <p>Information about the status of the rule evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub rule_evaluation_job_arn: std::option::Option<std::string::String>,
    /// <p>Status of the rule evaluation.</p>
    pub rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
    /// <p>Details from the rule evaluation.</p>
    pub status_details: std::option::Option<std::string::String>,
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DebugRuleEvaluationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugRuleEvaluationStatus");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("rule_evaluation_job_arn", &self.rule_evaluation_job_arn);
        formatter.field("rule_evaluation_status", &self.rule_evaluation_status);
        formatter.field("status_details", &self.status_details);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
pub mod debug_rule_evaluation_status {
    /// A builder for [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_job_arn: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the rule configuration.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn rule_evaluation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluation_job_arn = Some(input.into());
            self
        }
        pub fn set_rule_evaluation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluation_job_arn = input;
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn rule_evaluation_status(mut self, input: crate::model::RuleEvaluationStatus) -> Self {
            self.rule_evaluation_status = Some(input);
            self
        }
        pub fn set_rule_evaluation_status(
            mut self,
            input: std::option::Option<crate::model::RuleEvaluationStatus>,
        ) -> Self {
            self.rule_evaluation_status = input;
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
        pub fn build(self) -> crate::model::DebugRuleEvaluationStatus {
            crate::model::DebugRuleEvaluationStatus {
                rule_configuration_name: self.rule_configuration_name,
                rule_evaluation_job_arn: self.rule_evaluation_job_arn,
                rule_evaluation_status: self.rule_evaluation_status,
                status_details: self.status_details,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl DebugRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`DebugRuleEvaluationStatus`](crate::model::DebugRuleEvaluationStatus)
    pub fn builder() -> crate::model::debug_rule_evaluation_status::Builder {
        crate::model::debug_rule_evaluation_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuleEvaluationStatus {
    Error,
    InProgress,
    IssuesFound,
    NoIssuesFound,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RuleEvaluationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Error" => RuleEvaluationStatus::Error,
            "InProgress" => RuleEvaluationStatus::InProgress,
            "IssuesFound" => RuleEvaluationStatus::IssuesFound,
            "NoIssuesFound" => RuleEvaluationStatus::NoIssuesFound,
            "Stopped" => RuleEvaluationStatus::Stopped,
            "Stopping" => RuleEvaluationStatus::Stopping,
            other => RuleEvaluationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RuleEvaluationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuleEvaluationStatus::from(s))
    }
}
impl RuleEvaluationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            RuleEvaluationStatus::Error => "Error",
            RuleEvaluationStatus::InProgress => "InProgress",
            RuleEvaluationStatus::IssuesFound => "IssuesFound",
            RuleEvaluationStatus::NoIssuesFound => "NoIssuesFound",
            RuleEvaluationStatus::Stopped => "Stopped",
            RuleEvaluationStatus::Stopping => "Stopping",
            RuleEvaluationStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Error",
            "InProgress",
            "IssuesFound",
            "NoIssuesFound",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for RuleEvaluationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of storage locations for the Debugger TensorBoard output data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TensorBoardOutputConfig {
    /// <p>Path to local storage location for tensorBoard output. Defaults to
    /// <code>/opt/ml/output/tensorboard</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TensorBoardOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TensorBoardOutputConfig");
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
pub mod tensor_board_output_config {
    /// A builder for [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Path to local storage location for tensorBoard output. Defaults to
        /// <code>/opt/ml/output/tensorboard</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for TensorBoard output.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
        pub fn build(self) -> crate::model::TensorBoardOutputConfig {
            crate::model::TensorBoardOutputConfig {
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl TensorBoardOutputConfig {
    /// Creates a new builder-style object to manufacture [`TensorBoardOutputConfig`](crate::model::TensorBoardOutputConfig)
    pub fn builder() -> crate::model::tensor_board_output_config::Builder {
        crate::model::tensor_board_output_config::Builder::default()
    }
}

/// <p>Configuration information for SageMaker Debugger rules for debugging. To learn more about
/// how to configure the <code>DebugRuleConfiguration</code> parameter,
/// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugRuleConfiguration {
    /// <p>The name of the rule configuration. It must be unique relative to other rule
    /// configuration names.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>Path to local storage location for output of rules. Defaults to
    /// <code>/opt/ml/processing/output/rule/</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for rules.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
    pub rule_evaluator_image: std::option::Option<std::string::String>,
    /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
    pub instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
    /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
    pub volume_size_in_gb: i32,
    /// <p>Runtime configuration for rule container.</p>
    pub rule_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DebugRuleConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugRuleConfiguration");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("rule_evaluator_image", &self.rule_evaluator_image);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("rule_parameters", &self.rule_parameters);
        formatter.finish()
    }
}
/// See [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
pub mod debug_rule_configuration {
    /// A builder for [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) rule_evaluator_image: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::ProcessingInstanceType>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) rule_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the rule configuration. It must be unique relative to other rule
        /// configuration names.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>Path to local storage location for output of rules. Defaults to
        /// <code>/opt/ml/processing/output/rule/</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for rules.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Elastic Container (ECR) Image for the managed rule evaluation.</p>
        pub fn rule_evaluator_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluator_image = Some(input.into());
            self
        }
        pub fn set_rule_evaluator_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluator_image = input;
            self
        }
        /// <p>The instance type to deploy a Debugger custom rule for debugging a training job.</p>
        pub fn instance_type(mut self, input: crate::model::ProcessingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProcessingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The size, in GB, of the ML storage volume attached to the processing instance.</p>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        pub fn rule_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.rule_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.rule_parameters = Some(hash_map);
            self
        }
        pub fn set_rule_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.rule_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
        pub fn build(self) -> crate::model::DebugRuleConfiguration {
            crate::model::DebugRuleConfiguration {
                rule_configuration_name: self.rule_configuration_name,
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                rule_evaluator_image: self.rule_evaluator_image,
                instance_type: self.instance_type,
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                rule_parameters: self.rule_parameters,
            }
        }
    }
}
impl DebugRuleConfiguration {
    /// Creates a new builder-style object to manufacture [`DebugRuleConfiguration`](crate::model::DebugRuleConfiguration)
    pub fn builder() -> crate::model::debug_rule_configuration::Builder {
        crate::model::debug_rule_configuration::Builder::default()
    }
}

/// <p>Configuration information for the Debugger hook parameters, metric and tensor collections, and
/// storage paths. To learn more about
/// how to configure the <code>DebugHookConfig</code> parameter,
/// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DebugHookConfig {
    /// <p>Path to local storage location for metrics and tensors. Defaults to
    /// <code>/opt/ml/output/tensors/</code>.</p>
    pub local_path: std::option::Option<std::string::String>,
    /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>Configuration information for the Debugger hook parameters.</p>
    pub hook_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Configuration information for Debugger tensor collections. To learn more about
    /// how to configure the <code>CollectionConfiguration</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.
    /// </p>
    pub collection_configurations:
        std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
}
impl std::fmt::Debug for DebugHookConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DebugHookConfig");
        formatter.field("local_path", &self.local_path);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("hook_parameters", &self.hook_parameters);
        formatter.field("collection_configurations", &self.collection_configurations);
        formatter.finish()
    }
}
/// See [`DebugHookConfig`](crate::model::DebugHookConfig)
pub mod debug_hook_config {
    /// A builder for [`DebugHookConfig`](crate::model::DebugHookConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_path: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) hook_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) collection_configurations:
            std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
    }
    impl Builder {
        /// <p>Path to local storage location for metrics and tensors. Defaults to
        /// <code>/opt/ml/output/tensors/</code>.</p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// <p>Path to Amazon S3 storage location for metrics and tensors.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        pub fn hook_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hook_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hook_parameters = Some(hash_map);
            self
        }
        pub fn set_hook_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hook_parameters = input;
            self
        }
        pub fn collection_configurations(
            mut self,
            input: impl Into<crate::model::CollectionConfiguration>,
        ) -> Self {
            let mut v = self.collection_configurations.unwrap_or_default();
            v.push(input.into());
            self.collection_configurations = Some(v);
            self
        }
        pub fn set_collection_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CollectionConfiguration>>,
        ) -> Self {
            self.collection_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`DebugHookConfig`](crate::model::DebugHookConfig)
        pub fn build(self) -> crate::model::DebugHookConfig {
            crate::model::DebugHookConfig {
                local_path: self.local_path,
                s3_output_path: self.s3_output_path,
                hook_parameters: self.hook_parameters,
                collection_configurations: self.collection_configurations,
            }
        }
    }
}
impl DebugHookConfig {
    /// Creates a new builder-style object to manufacture [`DebugHookConfig`](crate::model::DebugHookConfig)
    pub fn builder() -> crate::model::debug_hook_config::Builder {
        crate::model::debug_hook_config::Builder::default()
    }
}

/// <p>Configuration information for the Debugger output tensor collections.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CollectionConfiguration {
    /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
    pub collection_name: std::option::Option<std::string::String>,
    /// <p>Parameter values for the tensor collection. The allowed parameters are
    /// <code>"name"</code>, <code>"include_regex"</code>, <code>"reduction_config"</code>,
    /// <code>"save_config"</code>, <code>"tensor_names"</code>, and
    /// <code>"save_histogram"</code>.</p>
    pub collection_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CollectionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CollectionConfiguration");
        formatter.field("collection_name", &self.collection_name);
        formatter.field("collection_parameters", &self.collection_parameters);
        formatter.finish()
    }
}
/// See [`CollectionConfiguration`](crate::model::CollectionConfiguration)
pub mod collection_configuration {
    /// A builder for [`CollectionConfiguration`](crate::model::CollectionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) collection_name: std::option::Option<std::string::String>,
        pub(crate) collection_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the tensor collection. The name must be unique relative to other rule configuration names.</p>
        pub fn collection_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.collection_name = Some(input.into());
            self
        }
        pub fn set_collection_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.collection_name = input;
            self
        }
        pub fn collection_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.collection_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.collection_parameters = Some(hash_map);
            self
        }
        pub fn set_collection_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.collection_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CollectionConfiguration`](crate::model::CollectionConfiguration)
        pub fn build(self) -> crate::model::CollectionConfiguration {
            crate::model::CollectionConfiguration {
                collection_name: self.collection_name,
                collection_parameters: self.collection_parameters,
            }
        }
    }
}
impl CollectionConfiguration {
    /// Creates a new builder-style object to manufacture [`CollectionConfiguration`](crate::model::CollectionConfiguration)
    pub fn builder() -> crate::model::collection_configuration::Builder {
        crate::model::collection_configuration::Builder::default()
    }
}

/// <p>Contains information about the output location for managed spot training checkpoint
/// data. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CheckpointConfig {
    /// <p>Identifies the S3 path where you want Amazon SageMaker to store checkpoints. For example,
    /// <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>(Optional) The local directory where checkpoints are written. The default directory is
    /// <code>/opt/ml/checkpoints/</code>. </p>
    pub local_path: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CheckpointConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CheckpointConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("local_path", &self.local_path);
        formatter.finish()
    }
}
/// See [`CheckpointConfig`](crate::model::CheckpointConfig)
pub mod checkpoint_config {
    /// A builder for [`CheckpointConfig`](crate::model::CheckpointConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) local_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the S3 path where you want Amazon SageMaker to store checkpoints. For example,
        /// <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>(Optional) The local directory where checkpoints are written. The default directory is
        /// <code>/opt/ml/checkpoints/</code>. </p>
        pub fn local_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.local_path = Some(input.into());
            self
        }
        pub fn set_local_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.local_path = input;
            self
        }
        /// Consumes the builder and constructs a [`CheckpointConfig`](crate::model::CheckpointConfig)
        pub fn build(self) -> crate::model::CheckpointConfig {
            crate::model::CheckpointConfig {
                s3_uri: self.s3_uri,
                local_path: self.local_path,
            }
        }
    }
}
impl CheckpointConfig {
    /// Creates a new builder-style object to manufacture [`CheckpointConfig`](crate::model::CheckpointConfig)
    pub fn builder() -> crate::model::checkpoint_config::Builder {
        crate::model::checkpoint_config::Builder::default()
    }
}

/// <p>The name, value, and date and time of a metric that was emitted to Amazon CloudWatch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricData {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The value of the metric.</p>
    pub value: f32,
    /// <p>The date and time that the algorithm emitted the metric.</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for MetricData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricData");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`MetricData`](crate::model::MetricData)
pub mod metric_data {
    /// A builder for [`MetricData`](crate::model::MetricData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f32>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the metric.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// <p>The date and time that the algorithm emitted the metric.</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricData`](crate::model::MetricData)
        pub fn build(self) -> crate::model::MetricData {
            crate::model::MetricData {
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
                timestamp: self.timestamp,
            }
        }
    }
}
impl MetricData {
    /// Creates a new builder-style object to manufacture [`MetricData`](crate::model::MetricData)
    pub fn builder() -> crate::model::metric_data::Builder {
        crate::model::metric_data::Builder::default()
    }
}

/// <p>An array element of <a>DescribeTrainingJobResponse$SecondaryStatusTransitions</a>. It provides
/// additional details about a status that the training job has transitioned through. A
/// training job can be in one of several states, for example, starting, downloading,
/// training, or uploading. Within each state, there are a number of intermediate states.
/// For example, within the starting state, Amazon SageMaker could be starting the training job or
/// launching the ML instances. These transitional states are referred to as the job's
/// secondary
/// status.
/// </p>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SecondaryStatusTransition {
    /// <p>Contains a secondary status information from a training
    /// job.</p>
    /// <p>Status might be one of the following secondary statuses:</p>
    /// <dl>
    /// <dt>InProgress</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Starting</code>
    /// - Starting the training job.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Downloading</code> - An optional stage for algorithms that
    /// support <code>File</code> training input mode. It indicates that
    /// data is being downloaded to the ML storage volumes.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Training</code> - Training is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Uploading</code> - Training is complete and the model
    /// artifacts are being uploaded to the S3 location.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Completed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Completed</code> - The training job has completed.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Failed</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The training job has failed. The reason for
    /// the failure is returned in the <code>FailureReason</code> field of
    /// <code>DescribeTrainingJobResponse</code>.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopped</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MaxRuntimeExceeded</code> - The job stopped because it
    /// exceeded the maximum allowed runtime.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Stopped</code> - The training job has stopped.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Stopping</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Stopping</code> - Stopping the training job.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <p>We no longer support the following secondary statuses:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>LaunchingMLInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PreparingTrainingStack</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DownloadingTrainingImage</code>
    /// </p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::SecondaryStatus>,
    /// <p>A timestamp that shows when the training job transitioned to the current secondary
    /// status state.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the training job transitioned out of this secondary status
    /// state into another secondary status state or when the training job has ended.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>A detailed description of the progress within a secondary status.
    /// </p>
    /// <p>Amazon SageMaker provides secondary statuses and status messages that apply to each of
    /// them:</p>
    /// <dl>
    /// <dt>Starting</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>Starting the training job.</p>
    /// </li>
    /// <li>
    /// <p>Launching requested ML
    /// instances.</p>
    /// </li>
    /// <li>
    /// <p>Insufficient
    /// capacity error from EC2 while launching instances,
    /// retrying!</p>
    /// </li>
    /// <li>
    /// <p>Launched
    /// instance was unhealthy, replacing it!</p>
    /// </li>
    /// <li>
    /// <p>Preparing the instances for training.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>Training</dt>
    /// <dd>
    /// <ul>
    /// <li>
    /// <p>Downloading the training image.</p>
    /// </li>
    /// <li>
    /// <p>Training
    /// image download completed. Training in
    /// progress.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// </dl>
    /// <important>
    /// <p>Status messages are subject to change. Therefore, we recommend not including them
    /// in code that programmatically initiates actions. For examples, don't use status
    /// messages in if statements.</p>
    /// </important>
    /// <p>To have an overview of your training job's progress, view
    /// <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <a>DescribeTrainingJob</a>, and <code>StatusMessage</code> together. For
    /// example, at the start of a training job, you might see the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>TrainingJobStatus</code> - InProgress</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SecondaryStatus</code> - Training</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>StatusMessage</code> - Downloading the training image</p>
    /// </li>
    /// </ul>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SecondaryStatusTransition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SecondaryStatusTransition");
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
pub mod secondary_status_transition {
    /// A builder for [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::SecondaryStatus>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Contains a secondary status information from a training
        /// job.</p>
        /// <p>Status might be one of the following secondary statuses:</p>
        /// <dl>
        /// <dt>InProgress</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Starting</code>
        /// - Starting the training job.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Downloading</code> - An optional stage for algorithms that
        /// support <code>File</code> training input mode. It indicates that
        /// data is being downloaded to the ML storage volumes.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Training</code> - Training is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Uploading</code> - Training is complete and the model
        /// artifacts are being uploaded to the S3 location.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Completed</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Completed</code> - The training job has completed.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Failed</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Failed</code> - The training job has failed. The reason for
        /// the failure is returned in the <code>FailureReason</code> field of
        /// <code>DescribeTrainingJobResponse</code>.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Stopped</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MaxRuntimeExceeded</code> - The job stopped because it
        /// exceeded the maximum allowed runtime.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopped</code> - The training job has stopped.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Stopping</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Stopping</code> - Stopping the training job.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <p>We no longer support the following secondary statuses:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LaunchingMLInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PreparingTrainingStack</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DownloadingTrainingImage</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::SecondaryStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SecondaryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp that shows when the training job transitioned to the current secondary
        /// status state.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>A timestamp that shows when the training job transitioned out of this secondary status
        /// state into another secondary status state or when the training job has ended.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>A detailed description of the progress within a secondary status.
        /// </p>
        /// <p>Amazon SageMaker provides secondary statuses and status messages that apply to each of
        /// them:</p>
        /// <dl>
        /// <dt>Starting</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>Starting the training job.</p>
        /// </li>
        /// <li>
        /// <p>Launching requested ML
        /// instances.</p>
        /// </li>
        /// <li>
        /// <p>Insufficient
        /// capacity error from EC2 while launching instances,
        /// retrying!</p>
        /// </li>
        /// <li>
        /// <p>Launched
        /// instance was unhealthy, replacing it!</p>
        /// </li>
        /// <li>
        /// <p>Preparing the instances for training.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>Training</dt>
        /// <dd>
        /// <ul>
        /// <li>
        /// <p>Downloading the training image.</p>
        /// </li>
        /// <li>
        /// <p>Training
        /// image download completed. Training in
        /// progress.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// </dl>
        /// <important>
        /// <p>Status messages are subject to change. Therefore, we recommend not including them
        /// in code that programmatically initiates actions. For examples, don't use status
        /// messages in if statements.</p>
        /// </important>
        /// <p>To have an overview of your training job's progress, view
        /// <code>TrainingJobStatus</code> and <code>SecondaryStatus</code> in <a>DescribeTrainingJob</a>, and <code>StatusMessage</code> together. For
        /// example, at the start of a training job, you might see the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TrainingJobStatus</code> - InProgress</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SecondaryStatus</code> - Training</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>StatusMessage</code> - Downloading the training image</p>
        /// </li>
        /// </ul>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
        pub fn build(self) -> crate::model::SecondaryStatusTransition {
            crate::model::SecondaryStatusTransition {
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                status_message: self.status_message,
            }
        }
    }
}
impl SecondaryStatusTransition {
    /// Creates a new builder-style object to manufacture [`SecondaryStatusTransition`](crate::model::SecondaryStatusTransition)
    pub fn builder() -> crate::model::secondary_status_transition::Builder {
        crate::model::secondary_status_transition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SecondaryStatus {
    Completed,
    Downloading,
    DownloadingTrainingImage,
    Failed,
    Interrupted,
    LaunchingMlInstances,
    MaxRuntimeExceeded,
    MaxWaitTimeExceeded,
    PreparingTrainingStack,
    Restarting,
    Starting,
    Stopped,
    Stopping,
    Training,
    Updating,
    Uploading,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SecondaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => SecondaryStatus::Completed,
            "Downloading" => SecondaryStatus::Downloading,
            "DownloadingTrainingImage" => SecondaryStatus::DownloadingTrainingImage,
            "Failed" => SecondaryStatus::Failed,
            "Interrupted" => SecondaryStatus::Interrupted,
            "LaunchingMLInstances" => SecondaryStatus::LaunchingMlInstances,
            "MaxRuntimeExceeded" => SecondaryStatus::MaxRuntimeExceeded,
            "MaxWaitTimeExceeded" => SecondaryStatus::MaxWaitTimeExceeded,
            "PreparingTrainingStack" => SecondaryStatus::PreparingTrainingStack,
            "Restarting" => SecondaryStatus::Restarting,
            "Starting" => SecondaryStatus::Starting,
            "Stopped" => SecondaryStatus::Stopped,
            "Stopping" => SecondaryStatus::Stopping,
            "Training" => SecondaryStatus::Training,
            "Updating" => SecondaryStatus::Updating,
            "Uploading" => SecondaryStatus::Uploading,
            other => SecondaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SecondaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SecondaryStatus::from(s))
    }
}
impl SecondaryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SecondaryStatus::Completed => "Completed",
            SecondaryStatus::Downloading => "Downloading",
            SecondaryStatus::DownloadingTrainingImage => "DownloadingTrainingImage",
            SecondaryStatus::Failed => "Failed",
            SecondaryStatus::Interrupted => "Interrupted",
            SecondaryStatus::LaunchingMlInstances => "LaunchingMLInstances",
            SecondaryStatus::MaxRuntimeExceeded => "MaxRuntimeExceeded",
            SecondaryStatus::MaxWaitTimeExceeded => "MaxWaitTimeExceeded",
            SecondaryStatus::PreparingTrainingStack => "PreparingTrainingStack",
            SecondaryStatus::Restarting => "Restarting",
            SecondaryStatus::Starting => "Starting",
            SecondaryStatus::Stopped => "Stopped",
            SecondaryStatus::Stopping => "Stopping",
            SecondaryStatus::Training => "Training",
            SecondaryStatus::Updating => "Updating",
            SecondaryStatus::Uploading => "Uploading",
            SecondaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Downloading",
            "DownloadingTrainingImage",
            "Failed",
            "Interrupted",
            "LaunchingMLInstances",
            "MaxRuntimeExceeded",
            "MaxWaitTimeExceeded",
            "PreparingTrainingStack",
            "Restarting",
            "Starting",
            "Stopped",
            "Stopping",
            "Training",
            "Updating",
            "Uploading",
        ]
    }
}
impl AsRef<str> for SecondaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a limit to how long a model training job, model compilation job, or
/// hyperparameter tuning job can run. It also specifies how long a managed Spot training
/// job has to complete. When the job reaches the time limit, Amazon SageMaker ends the training or
/// compilation job. Use this API to cap model training costs.</p>
/// <p>To stop a job, Amazon SageMaker sends the algorithm the <code>SIGTERM</code> signal, which delays
/// job termination for 120 seconds. Algorithms can use this 120-second window to save the
/// model artifacts, so the results of training are not lost. </p>
/// <p>The training algorithms provided by Amazon SageMaker automatically save the intermediate results
/// of a model training job when possible. This attempt to save artifacts is only a best
/// effort case as model might not be in a state from which it can be saved. For example, if
/// training has just started, the model might not be ready to save. When saved, this
/// intermediate data is a valid model artifact. You can use it to create a model with
/// <code>CreateModel</code>.</p>
/// <note>
/// <p>The Neural Topic Model (NTM) currently does not support saving intermediate model
/// artifacts. When training NTMs, make sure that the maximum runtime is sufficient for
/// the training job to complete.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StoppingCondition {
    /// <p>The maximum length of time, in seconds, that a training or compilation job can run. If
    /// the job does not complete during this time, Amazon SageMaker ends the job.</p>
    /// <p>When <code>RetryStrategy</code> is specified in the job request,
    /// <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts
    /// in total, not each individual attempt.</p>
    /// <p>The default value is 1 day. The maximum value is 28 days.</p>
    pub max_runtime_in_seconds: i32,
    /// <p>The maximum length of time, in seconds, that a managed Spot training job has to
    /// complete. It is the amount of time spent waiting for Spot capacity plus the amount of
    /// time the job can run. It must be equal to or greater than
    /// <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time,
    /// Amazon SageMaker ends the job.</p>
    /// <p>When <code>RetryStrategy</code> is specified in the job request,
    /// <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts
    /// in total, not each individual attempt.</p>
    pub max_wait_time_in_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for StoppingCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StoppingCondition");
        formatter.field("max_runtime_in_seconds", &self.max_runtime_in_seconds);
        formatter.field("max_wait_time_in_seconds", &self.max_wait_time_in_seconds);
        formatter.finish()
    }
}
/// See [`StoppingCondition`](crate::model::StoppingCondition)
pub mod stopping_condition {
    /// A builder for [`StoppingCondition`](crate::model::StoppingCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_runtime_in_seconds: std::option::Option<i32>,
        pub(crate) max_wait_time_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum length of time, in seconds, that a training or compilation job can run. If
        /// the job does not complete during this time, Amazon SageMaker ends the job.</p>
        /// <p>When <code>RetryStrategy</code> is specified in the job request,
        /// <code>MaxRuntimeInSeconds</code> specifies the maximum time for all of the attempts
        /// in total, not each individual attempt.</p>
        /// <p>The default value is 1 day. The maximum value is 28 days.</p>
        pub fn max_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_in_seconds = Some(input);
            self
        }
        pub fn set_max_runtime_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_runtime_in_seconds = input;
            self
        }
        /// <p>The maximum length of time, in seconds, that a managed Spot training job has to
        /// complete. It is the amount of time spent waiting for Spot capacity plus the amount of
        /// time the job can run. It must be equal to or greater than
        /// <code>MaxRuntimeInSeconds</code>. If the job does not complete during this time,
        /// Amazon SageMaker ends the job.</p>
        /// <p>When <code>RetryStrategy</code> is specified in the job request,
        /// <code>MaxWaitTimeInSeconds</code> specifies the maximum time for all of the attempts
        /// in total, not each individual attempt.</p>
        pub fn max_wait_time_in_seconds(mut self, input: i32) -> Self {
            self.max_wait_time_in_seconds = Some(input);
            self
        }
        pub fn set_max_wait_time_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.max_wait_time_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`StoppingCondition`](crate::model::StoppingCondition)
        pub fn build(self) -> crate::model::StoppingCondition {
            crate::model::StoppingCondition {
                max_runtime_in_seconds: self.max_runtime_in_seconds.unwrap_or_default(),
                max_wait_time_in_seconds: self.max_wait_time_in_seconds,
            }
        }
    }
}
impl StoppingCondition {
    /// Creates a new builder-style object to manufacture [`StoppingCondition`](crate::model::StoppingCondition)
    pub fn builder() -> crate::model::stopping_condition::Builder {
        crate::model::stopping_condition::Builder::default()
    }
}

/// <p>Describes the resources, including ML compute instances and ML storage volumes, to
/// use for model training. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConfig {
    /// <p>The ML compute instance type. </p>
    pub instance_type: std::option::Option<crate::model::TrainingInstanceType>,
    /// <p>The number of ML compute instances to use. For distributed training, provide a
    /// value greater than 1. </p>
    pub instance_count: i32,
    /// <p>The size of the ML storage volume that you want to provision. </p>
    /// <p>ML storage volumes store model artifacts and incremental states. Training
    /// algorithms might also use the ML storage volume for scratch space. If you want to store
    /// the training data in the ML storage volume, choose <code>File</code> as the
    /// <code>TrainingInputMode</code> in the algorithm specification. </p>
    /// <p>You must specify sufficient ML storage for your scenario. </p>
    /// <note>
    /// <p> Amazon SageMaker supports only the General Purpose SSD (gp2) ML storage volume type.
    /// </p>
    /// </note>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage with a fixed total size,
    /// dependent on the instance type. When using these instances for training, Amazon SageMaker mounts
    /// the local instance storage instead of Amazon EBS gp2 storage. You can't request a
    /// <code>VolumeSizeInGB</code> greater than the total size of the local instance
    /// storage.</p>
    /// <p>For a list of instance types that support local instance storage, including the
    /// total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// </note>
    pub volume_size_in_gb: i32,
    /// <p>The Amazon Web Services KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML
    /// compute instance(s) that run the training job.</p>
    /// <note>
    /// <p>Certain Nitro-based instances include local storage, dependent on the instance
    /// type. Local storage volumes are encrypted using a hardware module on the instance.
    /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
    /// local storage.</p>
    /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
    /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
    /// Instance Store Volumes</a>.</p>
    /// </note>
    /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>// KMS Key ID</p>
    /// <p>
    /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConfig");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("instance_count", &self.instance_count);
        formatter.field("volume_size_in_gb", &self.volume_size_in_gb);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`ResourceConfig`](crate::model::ResourceConfig)
pub mod resource_config {
    /// A builder for [`ResourceConfig`](crate::model::ResourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<crate::model::TrainingInstanceType>,
        pub(crate) instance_count: std::option::Option<i32>,
        pub(crate) volume_size_in_gb: std::option::Option<i32>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ML compute instance type. </p>
        pub fn instance_type(mut self, input: crate::model::TrainingInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::TrainingInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of ML compute instances to use. For distributed training, provide a
        /// value greater than 1. </p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.instance_count = Some(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_count = input;
            self
        }
        /// <p>The size of the ML storage volume that you want to provision. </p>
        /// <p>ML storage volumes store model artifacts and incremental states. Training
        /// algorithms might also use the ML storage volume for scratch space. If you want to store
        /// the training data in the ML storage volume, choose <code>File</code> as the
        /// <code>TrainingInputMode</code> in the algorithm specification. </p>
        /// <p>You must specify sufficient ML storage for your scenario. </p>
        /// <note>
        /// <p> Amazon SageMaker supports only the General Purpose SSD (gp2) ML storage volume type.
        /// </p>
        /// </note>
        /// <note>
        /// <p>Certain Nitro-based instances include local storage with a fixed total size,
        /// dependent on the instance type. When using these instances for training, Amazon SageMaker mounts
        /// the local instance storage instead of Amazon EBS gp2 storage. You can't request a
        /// <code>VolumeSizeInGB</code> greater than the total size of the local instance
        /// storage.</p>
        /// <p>For a list of instance types that support local instance storage, including the
        /// total size per instance type, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// </note>
        pub fn volume_size_in_gb(mut self, input: i32) -> Self {
            self.volume_size_in_gb = Some(input);
            self
        }
        pub fn set_volume_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_in_gb = input;
            self
        }
        /// <p>The Amazon Web Services KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML
        /// compute instance(s) that run the training job.</p>
        /// <note>
        /// <p>Certain Nitro-based instances include local storage, dependent on the instance
        /// type. Local storage volumes are encrypted using a hardware module on the instance.
        /// You can't request a <code>VolumeKmsKeyId</code> when using an instance type with
        /// local storage.</p>
        /// <p>For a list of instance types that support local instance storage, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes">Instance Store Volumes</a>.</p>
        /// <p>For more information about local instance storage encryption, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html">SSD
        /// Instance Store Volumes</a>.</p>
        /// </note>
        /// <p>The <code>VolumeKmsKeyId</code> can be in any of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>// KMS Key ID</p>
        /// <p>
        /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConfig`](crate::model::ResourceConfig)
        pub fn build(self) -> crate::model::ResourceConfig {
            crate::model::ResourceConfig {
                instance_type: self.instance_type,
                instance_count: self.instance_count.unwrap_or_default(),
                volume_size_in_gb: self.volume_size_in_gb.unwrap_or_default(),
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl ResourceConfig {
    /// Creates a new builder-style object to manufacture [`ResourceConfig`](crate::model::ResourceConfig)
    pub fn builder() -> crate::model::resource_config::Builder {
        crate::model::resource_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingInstanceType {
    MlC42Xlarge,
    MlC44Xlarge,
    MlC48Xlarge,
    MlC4Xlarge,
    MlC518Xlarge,
    MlC52Xlarge,
    MlC54Xlarge,
    MlC59Xlarge,
    MlC5Xlarge,
    MlC5N18Xlarge,
    MlC5N2Xlarge,
    MlC5N4Xlarge,
    MlC5N9Xlarge,
    MlC5NXlarge,
    MlG4Dn12Xlarge,
    MlG4Dn16Xlarge,
    MlG4Dn2Xlarge,
    MlG4Dn4Xlarge,
    MlG4Dn8Xlarge,
    MlG4DnXlarge,
    MlM410Xlarge,
    MlM416Xlarge,
    MlM42Xlarge,
    MlM44Xlarge,
    MlM4Xlarge,
    MlM512Xlarge,
    MlM524Xlarge,
    MlM52Xlarge,
    MlM54Xlarge,
    MlM5Large,
    MlM5Xlarge,
    MlP216Xlarge,
    MlP28Xlarge,
    MlP2Xlarge,
    MlP316Xlarge,
    MlP32Xlarge,
    MlP38Xlarge,
    MlP3Dn24Xlarge,
    MlP4D24Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "ml.c4.2xlarge" => TrainingInstanceType::MlC42Xlarge,
            "ml.c4.4xlarge" => TrainingInstanceType::MlC44Xlarge,
            "ml.c4.8xlarge" => TrainingInstanceType::MlC48Xlarge,
            "ml.c4.xlarge" => TrainingInstanceType::MlC4Xlarge,
            "ml.c5.18xlarge" => TrainingInstanceType::MlC518Xlarge,
            "ml.c5.2xlarge" => TrainingInstanceType::MlC52Xlarge,
            "ml.c5.4xlarge" => TrainingInstanceType::MlC54Xlarge,
            "ml.c5.9xlarge" => TrainingInstanceType::MlC59Xlarge,
            "ml.c5.xlarge" => TrainingInstanceType::MlC5Xlarge,
            "ml.c5n.18xlarge" => TrainingInstanceType::MlC5N18Xlarge,
            "ml.c5n.2xlarge" => TrainingInstanceType::MlC5N2Xlarge,
            "ml.c5n.4xlarge" => TrainingInstanceType::MlC5N4Xlarge,
            "ml.c5n.9xlarge" => TrainingInstanceType::MlC5N9Xlarge,
            "ml.c5n.xlarge" => TrainingInstanceType::MlC5NXlarge,
            "ml.g4dn.12xlarge" => TrainingInstanceType::MlG4Dn12Xlarge,
            "ml.g4dn.16xlarge" => TrainingInstanceType::MlG4Dn16Xlarge,
            "ml.g4dn.2xlarge" => TrainingInstanceType::MlG4Dn2Xlarge,
            "ml.g4dn.4xlarge" => TrainingInstanceType::MlG4Dn4Xlarge,
            "ml.g4dn.8xlarge" => TrainingInstanceType::MlG4Dn8Xlarge,
            "ml.g4dn.xlarge" => TrainingInstanceType::MlG4DnXlarge,
            "ml.m4.10xlarge" => TrainingInstanceType::MlM410Xlarge,
            "ml.m4.16xlarge" => TrainingInstanceType::MlM416Xlarge,
            "ml.m4.2xlarge" => TrainingInstanceType::MlM42Xlarge,
            "ml.m4.4xlarge" => TrainingInstanceType::MlM44Xlarge,
            "ml.m4.xlarge" => TrainingInstanceType::MlM4Xlarge,
            "ml.m5.12xlarge" => TrainingInstanceType::MlM512Xlarge,
            "ml.m5.24xlarge" => TrainingInstanceType::MlM524Xlarge,
            "ml.m5.2xlarge" => TrainingInstanceType::MlM52Xlarge,
            "ml.m5.4xlarge" => TrainingInstanceType::MlM54Xlarge,
            "ml.m5.large" => TrainingInstanceType::MlM5Large,
            "ml.m5.xlarge" => TrainingInstanceType::MlM5Xlarge,
            "ml.p2.16xlarge" => TrainingInstanceType::MlP216Xlarge,
            "ml.p2.8xlarge" => TrainingInstanceType::MlP28Xlarge,
            "ml.p2.xlarge" => TrainingInstanceType::MlP2Xlarge,
            "ml.p3.16xlarge" => TrainingInstanceType::MlP316Xlarge,
            "ml.p3.2xlarge" => TrainingInstanceType::MlP32Xlarge,
            "ml.p3.8xlarge" => TrainingInstanceType::MlP38Xlarge,
            "ml.p3dn.24xlarge" => TrainingInstanceType::MlP3Dn24Xlarge,
            "ml.p4d.24xlarge" => TrainingInstanceType::MlP4D24Xlarge,
            other => TrainingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingInstanceType::from(s))
    }
}
impl TrainingInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            TrainingInstanceType::MlC42Xlarge => "ml.c4.2xlarge",
            TrainingInstanceType::MlC44Xlarge => "ml.c4.4xlarge",
            TrainingInstanceType::MlC48Xlarge => "ml.c4.8xlarge",
            TrainingInstanceType::MlC4Xlarge => "ml.c4.xlarge",
            TrainingInstanceType::MlC518Xlarge => "ml.c5.18xlarge",
            TrainingInstanceType::MlC52Xlarge => "ml.c5.2xlarge",
            TrainingInstanceType::MlC54Xlarge => "ml.c5.4xlarge",
            TrainingInstanceType::MlC59Xlarge => "ml.c5.9xlarge",
            TrainingInstanceType::MlC5Xlarge => "ml.c5.xlarge",
            TrainingInstanceType::MlC5N18Xlarge => "ml.c5n.18xlarge",
            TrainingInstanceType::MlC5N2Xlarge => "ml.c5n.2xlarge",
            TrainingInstanceType::MlC5N4Xlarge => "ml.c5n.4xlarge",
            TrainingInstanceType::MlC5N9Xlarge => "ml.c5n.9xlarge",
            TrainingInstanceType::MlC5NXlarge => "ml.c5n.xlarge",
            TrainingInstanceType::MlG4Dn12Xlarge => "ml.g4dn.12xlarge",
            TrainingInstanceType::MlG4Dn16Xlarge => "ml.g4dn.16xlarge",
            TrainingInstanceType::MlG4Dn2Xlarge => "ml.g4dn.2xlarge",
            TrainingInstanceType::MlG4Dn4Xlarge => "ml.g4dn.4xlarge",
            TrainingInstanceType::MlG4Dn8Xlarge => "ml.g4dn.8xlarge",
            TrainingInstanceType::MlG4DnXlarge => "ml.g4dn.xlarge",
            TrainingInstanceType::MlM410Xlarge => "ml.m4.10xlarge",
            TrainingInstanceType::MlM416Xlarge => "ml.m4.16xlarge",
            TrainingInstanceType::MlM42Xlarge => "ml.m4.2xlarge",
            TrainingInstanceType::MlM44Xlarge => "ml.m4.4xlarge",
            TrainingInstanceType::MlM4Xlarge => "ml.m4.xlarge",
            TrainingInstanceType::MlM512Xlarge => "ml.m5.12xlarge",
            TrainingInstanceType::MlM524Xlarge => "ml.m5.24xlarge",
            TrainingInstanceType::MlM52Xlarge => "ml.m5.2xlarge",
            TrainingInstanceType::MlM54Xlarge => "ml.m5.4xlarge",
            TrainingInstanceType::MlM5Large => "ml.m5.large",
            TrainingInstanceType::MlM5Xlarge => "ml.m5.xlarge",
            TrainingInstanceType::MlP216Xlarge => "ml.p2.16xlarge",
            TrainingInstanceType::MlP28Xlarge => "ml.p2.8xlarge",
            TrainingInstanceType::MlP2Xlarge => "ml.p2.xlarge",
            TrainingInstanceType::MlP316Xlarge => "ml.p3.16xlarge",
            TrainingInstanceType::MlP32Xlarge => "ml.p3.2xlarge",
            TrainingInstanceType::MlP38Xlarge => "ml.p3.8xlarge",
            TrainingInstanceType::MlP3Dn24Xlarge => "ml.p3dn.24xlarge",
            TrainingInstanceType::MlP4D24Xlarge => "ml.p4d.24xlarge",
            TrainingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.c4.2xlarge",
            "ml.c4.4xlarge",
            "ml.c4.8xlarge",
            "ml.c4.xlarge",
            "ml.c5.18xlarge",
            "ml.c5.2xlarge",
            "ml.c5.4xlarge",
            "ml.c5.9xlarge",
            "ml.c5.xlarge",
            "ml.c5n.18xlarge",
            "ml.c5n.2xlarge",
            "ml.c5n.4xlarge",
            "ml.c5n.9xlarge",
            "ml.c5n.xlarge",
            "ml.g4dn.12xlarge",
            "ml.g4dn.16xlarge",
            "ml.g4dn.2xlarge",
            "ml.g4dn.4xlarge",
            "ml.g4dn.8xlarge",
            "ml.g4dn.xlarge",
            "ml.m4.10xlarge",
            "ml.m4.16xlarge",
            "ml.m4.2xlarge",
            "ml.m4.4xlarge",
            "ml.m4.xlarge",
            "ml.m5.12xlarge",
            "ml.m5.24xlarge",
            "ml.m5.2xlarge",
            "ml.m5.4xlarge",
            "ml.m5.large",
            "ml.m5.xlarge",
            "ml.p2.16xlarge",
            "ml.p2.8xlarge",
            "ml.p2.xlarge",
            "ml.p3.16xlarge",
            "ml.p3.2xlarge",
            "ml.p3.8xlarge",
            "ml.p3dn.24xlarge",
            "ml.p4d.24xlarge",
        ]
    }
}
impl AsRef<str> for TrainingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about how to store model training results (model
/// artifacts).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputDataConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using
    /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
    /// formats: </p>
    /// <ul>
    /// <li>
    /// <p>// KMS Key ID</p>
    /// <p>
    /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// KMS Key Alias</p>
    /// <p>
    /// <code>"alias/ExampleAlias"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your master key, the Amazon SageMaker execution role must
    /// include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID,
    /// Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. Amazon SageMaker uses server-side
    /// encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket
    /// policy with an <code>s3:PutObject</code> permission that only allows objects with
    /// server-side encryption, set the condition key of
    /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption
    /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
    /// </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
    /// <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or
    /// <code>CreateHyperParameterTuningJob</code> requests. For more information, see
    /// <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using
    /// Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer
    /// Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Identifies the S3 path where you want Amazon SageMaker to store the model artifacts. For
    /// example, <code>s3://bucket-name/key-name-prefix</code>. </p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OutputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputDataConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`OutputDataConfig`](crate::model::OutputDataConfig)
pub mod output_data_config {
    /// A builder for [`OutputDataConfig`](crate::model::OutputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using
        /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
        /// formats: </p>
        /// <ul>
        /// <li>
        /// <p>// KMS Key ID</p>
        /// <p>
        /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// KMS Key Alias</p>
        /// <p>
        /// <code>"alias/ExampleAlias"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your master key, the Amazon SageMaker execution role must
        /// include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID,
        /// Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. Amazon SageMaker uses server-side
        /// encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket
        /// policy with an <code>s3:PutObject</code> permission that only allows objects with
        /// server-side encryption, set the condition key of
        /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption
        /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
        /// </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
        /// <code>CreateTrainingJob</code>, <code>CreateTransformJob</code>, or
        /// <code>CreateHyperParameterTuningJob</code> requests. For more information, see
        /// <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using
        /// Key Policies in Amazon Web Services KMS</a> in the <i>Amazon Web Services Key Management Service Developer
        /// Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>Identifies the S3 path where you want Amazon SageMaker to store the model artifacts. For
        /// example, <code>s3://bucket-name/key-name-prefix</code>. </p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputDataConfig`](crate::model::OutputDataConfig)
        pub fn build(self) -> crate::model::OutputDataConfig {
            crate::model::OutputDataConfig {
                kms_key_id: self.kms_key_id,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl OutputDataConfig {
    /// Creates a new builder-style object to manufacture [`OutputDataConfig`](crate::model::OutputDataConfig)
    pub fn builder() -> crate::model::output_data_config::Builder {
        crate::model::output_data_config::Builder::default()
    }
}

/// <p>A channel is a named input source that training algorithms can consume. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Channel {
    /// <p>The name of the channel. </p>
    pub channel_name: std::option::Option<std::string::String>,
    /// <p>The location of the channel data.</p>
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The MIME type of the data.</p>
    pub content_type: std::option::Option<std::string::String>,
    /// <p>If training data is compressed, the compression type. The default value is
    /// <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In
    /// File mode, leave this field unset or set it to None.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p></p>
    /// <p>Specify RecordIO as the value when input data is in raw format but the training
    /// algorithm requires the RecordIO format. In this case, Amazon SageMaker wraps each individual S3
    /// object in a RecordIO record. If the input data is already in RecordIO format, you don't
    /// need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create
    /// a Dataset Using RecordIO</a>. </p>
    /// <p>In File mode, leave this field unset or set it to None.</p>
    pub record_wrapper_type: std::option::Option<crate::model::RecordWrapper>,
    /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't
    /// set a value for <code>InputMode</code>, Amazon SageMaker uses the value set for
    /// <code>TrainingInputMode</code>. Use this parameter to override the
    /// <code>TrainingInputMode</code> setting in a <a>AlgorithmSpecification</a>
    /// request when you have a channel that needs a different input mode from the training
    /// job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML
    /// storage volume, and mount the directory to a Docker volume, use <code>File</code> input
    /// mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input
    /// mode.</p>
    /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
    pub input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>A configuration for a shuffle option for input data in a channel. If you use
    /// <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the
    /// S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object
    /// references in the <code>ManifestFile</code> is shuffled. If you use
    /// <code>AugmentedManifestFile</code>, the order of the JSON lines in the
    /// <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined
    /// using the <code>Seed</code> value.</p>
    /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large
    /// datasets this ensures that the order of the training data is different for each epoch,
    /// it helps reduce bias and possible overfitting. In a multi-node training job when
    /// ShuffleConfig is combined with <code>S3DataDistributionType</code> of
    /// <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content
    /// sent to a particular node on the first epoch might be sent to a different node on the
    /// second epoch.</p>
    pub shuffle_config: std::option::Option<crate::model::ShuffleConfig>,
}
impl std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Channel");
        formatter.field("channel_name", &self.channel_name);
        formatter.field("data_source", &self.data_source);
        formatter.field("content_type", &self.content_type);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("record_wrapper_type", &self.record_wrapper_type);
        formatter.field("input_mode", &self.input_mode);
        formatter.field("shuffle_config", &self.shuffle_config);
        formatter.finish()
    }
}
/// See [`Channel`](crate::model::Channel)
pub mod channel {
    /// A builder for [`Channel`](crate::model::Channel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_name: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) record_wrapper_type: std::option::Option<crate::model::RecordWrapper>,
        pub(crate) input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) shuffle_config: std::option::Option<crate::model::ShuffleConfig>,
    }
    impl Builder {
        /// <p>The name of the channel. </p>
        pub fn channel_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_name = Some(input.into());
            self
        }
        pub fn set_channel_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_name = input;
            self
        }
        /// <p>The location of the channel data.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The MIME type of the data.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>If training data is compressed, the compression type. The default value is
        /// <code>None</code>. <code>CompressionType</code> is used only in Pipe input mode. In
        /// File mode, leave this field unset or set it to None.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p></p>
        /// <p>Specify RecordIO as the value when input data is in raw format but the training
        /// algorithm requires the RecordIO format. In this case, Amazon SageMaker wraps each individual S3
        /// object in a RecordIO record. If the input data is already in RecordIO format, you don't
        /// need to set this attribute. For more information, see <a href="https://mxnet.apache.org/api/architecture/note_data_loading#data-format">Create
        /// a Dataset Using RecordIO</a>. </p>
        /// <p>In File mode, leave this field unset or set it to None.</p>
        pub fn record_wrapper_type(mut self, input: crate::model::RecordWrapper) -> Self {
            self.record_wrapper_type = Some(input);
            self
        }
        pub fn set_record_wrapper_type(
            mut self,
            input: std::option::Option<crate::model::RecordWrapper>,
        ) -> Self {
            self.record_wrapper_type = input;
            self
        }
        /// <p>(Optional) The input mode to use for the data channel in a training job. If you don't
        /// set a value for <code>InputMode</code>, Amazon SageMaker uses the value set for
        /// <code>TrainingInputMode</code>. Use this parameter to override the
        /// <code>TrainingInputMode</code> setting in a <a>AlgorithmSpecification</a>
        /// request when you have a channel that needs a different input mode from the training
        /// job's general setting. To download the data from Amazon Simple Storage Service (Amazon S3) to the provisioned ML
        /// storage volume, and mount the directory to a Docker volume, use <code>File</code> input
        /// mode. To stream data directly from Amazon S3 to the container, choose <code>Pipe</code> input
        /// mode.</p>
        /// <p>To use a model for incremental training, choose <code>File</code> input model.</p>
        pub fn input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.input_mode = Some(input);
            self
        }
        pub fn set_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.input_mode = input;
            self
        }
        /// <p>A configuration for a shuffle option for input data in a channel. If you use
        /// <code>S3Prefix</code> for <code>S3DataType</code>, this shuffles the results of the
        /// S3 key prefix matches. If you use <code>ManifestFile</code>, the order of the S3 object
        /// references in the <code>ManifestFile</code> is shuffled. If you use
        /// <code>AugmentedManifestFile</code>, the order of the JSON lines in the
        /// <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined
        /// using the <code>Seed</code> value.</p>
        /// <p>For Pipe input mode, shuffling is done at the start of every epoch. With large
        /// datasets this ensures that the order of the training data is different for each epoch,
        /// it helps reduce bias and possible overfitting. In a multi-node training job when
        /// ShuffleConfig is combined with <code>S3DataDistributionType</code> of
        /// <code>ShardedByS3Key</code>, the data is shuffled across nodes so that the content
        /// sent to a particular node on the first epoch might be sent to a different node on the
        /// second epoch.</p>
        pub fn shuffle_config(mut self, input: crate::model::ShuffleConfig) -> Self {
            self.shuffle_config = Some(input);
            self
        }
        pub fn set_shuffle_config(
            mut self,
            input: std::option::Option<crate::model::ShuffleConfig>,
        ) -> Self {
            self.shuffle_config = input;
            self
        }
        /// Consumes the builder and constructs a [`Channel`](crate::model::Channel)
        pub fn build(self) -> crate::model::Channel {
            crate::model::Channel {
                channel_name: self.channel_name,
                data_source: self.data_source,
                content_type: self.content_type,
                compression_type: self.compression_type,
                record_wrapper_type: self.record_wrapper_type,
                input_mode: self.input_mode,
                shuffle_config: self.shuffle_config,
            }
        }
    }
}
impl Channel {
    /// Creates a new builder-style object to manufacture [`Channel`](crate::model::Channel)
    pub fn builder() -> crate::model::channel::Builder {
        crate::model::channel::Builder::default()
    }
}

/// <p>A configuration for a shuffle option for input data in a channel. If you use
/// <code>S3Prefix</code> for <code>S3DataType</code>, the results of the S3 key prefix
/// matches are shuffled. If you use <code>ManifestFile</code>, the order of the S3 object
/// references in the <code>ManifestFile</code> is shuffled. If you use
/// <code>AugmentedManifestFile</code>, the order of the JSON lines in the
/// <code>AugmentedManifestFile</code> is shuffled. The shuffling order is determined
/// using the <code>Seed</code> value.</p>
/// <p>For Pipe input mode, when <code>ShuffleConfig</code> is specified shuffling is done at
/// the start of every epoch. With large datasets, this ensures that the order of the
/// training data is different for each epoch, and it helps reduce bias and possible
/// overfitting. In a multi-node training job when <code>ShuffleConfig</code> is combined
/// with <code>S3DataDistributionType</code> of <code>ShardedByS3Key</code>, the data is
/// shuffled across nodes so that the content sent to a particular node on the first epoch
/// might be sent to a different node on the second epoch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ShuffleConfig {
    /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
    pub seed: i64,
}
impl std::fmt::Debug for ShuffleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ShuffleConfig");
        formatter.field("seed", &self.seed);
        formatter.finish()
    }
}
/// See [`ShuffleConfig`](crate::model::ShuffleConfig)
pub mod shuffle_config {
    /// A builder for [`ShuffleConfig`](crate::model::ShuffleConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) seed: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Determines the shuffling order in <code>ShuffleConfig</code> value.</p>
        pub fn seed(mut self, input: i64) -> Self {
            self.seed = Some(input);
            self
        }
        pub fn set_seed(mut self, input: std::option::Option<i64>) -> Self {
            self.seed = input;
            self
        }
        /// Consumes the builder and constructs a [`ShuffleConfig`](crate::model::ShuffleConfig)
        pub fn build(self) -> crate::model::ShuffleConfig {
            crate::model::ShuffleConfig {
                seed: self.seed.unwrap_or_default(),
            }
        }
    }
}
impl ShuffleConfig {
    /// Creates a new builder-style object to manufacture [`ShuffleConfig`](crate::model::ShuffleConfig)
    pub fn builder() -> crate::model::shuffle_config::Builder {
        crate::model::shuffle_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingInputMode {
    File,
    Pipe,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingInputMode {
    fn from(s: &str) -> Self {
        match s {
            "File" => TrainingInputMode::File,
            "Pipe" => TrainingInputMode::Pipe,
            other => TrainingInputMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingInputMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingInputMode::from(s))
    }
}
impl TrainingInputMode {
    pub fn as_str(&self) -> &str {
        match self {
            TrainingInputMode::File => "File",
            TrainingInputMode::Pipe => "Pipe",
            TrainingInputMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["File", "Pipe"]
    }
}
impl AsRef<str> for TrainingInputMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordWrapper {
    None,
    Recordio,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecordWrapper {
    fn from(s: &str) -> Self {
        match s {
            "None" => RecordWrapper::None,
            "RecordIO" => RecordWrapper::Recordio,
            other => RecordWrapper::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecordWrapper {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordWrapper::from(s))
    }
}
impl RecordWrapper {
    pub fn as_str(&self) -> &str {
        match self {
            RecordWrapper::None => "None",
            RecordWrapper::Recordio => "RecordIO",
            RecordWrapper::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["None", "RecordIO"]
    }
}
impl AsRef<str> for RecordWrapper {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the location of the channel data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataSource {
    /// <p>The S3 location of the data source that is associated with a channel.</p>
    pub s3_data_source: std::option::Option<crate::model::S3DataSource>,
    /// <p>The file system that is associated with a channel.</p>
    pub file_system_data_source: std::option::Option<crate::model::FileSystemDataSource>,
}
impl std::fmt::Debug for DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.field("file_system_data_source", &self.file_system_data_source);
        formatter.finish()
    }
}
/// See [`DataSource`](crate::model::DataSource)
pub mod data_source {
    /// A builder for [`DataSource`](crate::model::DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::S3DataSource>,
        pub(crate) file_system_data_source: std::option::Option<crate::model::FileSystemDataSource>,
    }
    impl Builder {
        /// <p>The S3 location of the data source that is associated with a channel.</p>
        pub fn s3_data_source(mut self, input: crate::model::S3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::S3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// <p>The file system that is associated with a channel.</p>
        pub fn file_system_data_source(
            mut self,
            input: crate::model::FileSystemDataSource,
        ) -> Self {
            self.file_system_data_source = Some(input);
            self
        }
        pub fn set_file_system_data_source(
            mut self,
            input: std::option::Option<crate::model::FileSystemDataSource>,
        ) -> Self {
            self.file_system_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`DataSource`](crate::model::DataSource)
        pub fn build(self) -> crate::model::DataSource {
            crate::model::DataSource {
                s3_data_source: self.s3_data_source,
                file_system_data_source: self.file_system_data_source,
            }
        }
    }
}
impl DataSource {
    /// Creates a new builder-style object to manufacture [`DataSource`](crate::model::DataSource)
    pub fn builder() -> crate::model::data_source::Builder {
        crate::model::data_source::Builder::default()
    }
}

/// <p>Specifies a file system data source for a channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemDataSource {
    /// <p>The file system id.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The access mode of the mount of the directory associated with the channel. A directory
    /// can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write)
    /// mode.</p>
    pub file_system_access_mode: std::option::Option<crate::model::FileSystemAccessMode>,
    /// <p>The file system type. </p>
    pub file_system_type: std::option::Option<crate::model::FileSystemType>,
    /// <p>The full path to the directory to associate with the channel.</p>
    pub directory_path: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileSystemDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemDataSource");
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("file_system_access_mode", &self.file_system_access_mode);
        formatter.field("file_system_type", &self.file_system_type);
        formatter.field("directory_path", &self.directory_path);
        formatter.finish()
    }
}
/// See [`FileSystemDataSource`](crate::model::FileSystemDataSource)
pub mod file_system_data_source {
    /// A builder for [`FileSystemDataSource`](crate::model::FileSystemDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) file_system_access_mode: std::option::Option<crate::model::FileSystemAccessMode>,
        pub(crate) file_system_type: std::option::Option<crate::model::FileSystemType>,
        pub(crate) directory_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The file system id.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The access mode of the mount of the directory associated with the channel. A directory
        /// can be mounted either in <code>ro</code> (read-only) or <code>rw</code> (read-write)
        /// mode.</p>
        pub fn file_system_access_mode(
            mut self,
            input: crate::model::FileSystemAccessMode,
        ) -> Self {
            self.file_system_access_mode = Some(input);
            self
        }
        pub fn set_file_system_access_mode(
            mut self,
            input: std::option::Option<crate::model::FileSystemAccessMode>,
        ) -> Self {
            self.file_system_access_mode = input;
            self
        }
        /// <p>The file system type. </p>
        pub fn file_system_type(mut self, input: crate::model::FileSystemType) -> Self {
            self.file_system_type = Some(input);
            self
        }
        pub fn set_file_system_type(
            mut self,
            input: std::option::Option<crate::model::FileSystemType>,
        ) -> Self {
            self.file_system_type = input;
            self
        }
        /// <p>The full path to the directory to associate with the channel.</p>
        pub fn directory_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_path = Some(input.into());
            self
        }
        pub fn set_directory_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_path = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemDataSource`](crate::model::FileSystemDataSource)
        pub fn build(self) -> crate::model::FileSystemDataSource {
            crate::model::FileSystemDataSource {
                file_system_id: self.file_system_id,
                file_system_access_mode: self.file_system_access_mode,
                file_system_type: self.file_system_type,
                directory_path: self.directory_path,
            }
        }
    }
}
impl FileSystemDataSource {
    /// Creates a new builder-style object to manufacture [`FileSystemDataSource`](crate::model::FileSystemDataSource)
    pub fn builder() -> crate::model::file_system_data_source::Builder {
        crate::model::file_system_data_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemType {
    Efs,
    Fsxlustre,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemType {
    fn from(s: &str) -> Self {
        match s {
            "EFS" => FileSystemType::Efs,
            "FSxLustre" => FileSystemType::Fsxlustre,
            other => FileSystemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemType::from(s))
    }
}
impl FileSystemType {
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemType::Efs => "EFS",
            FileSystemType::Fsxlustre => "FSxLustre",
            FileSystemType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EFS", "FSxLustre"]
    }
}
impl AsRef<str> for FileSystemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemAccessMode {
    Ro,
    Rw,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemAccessMode {
    fn from(s: &str) -> Self {
        match s {
            "ro" => FileSystemAccessMode::Ro,
            "rw" => FileSystemAccessMode::Rw,
            other => FileSystemAccessMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemAccessMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemAccessMode::from(s))
    }
}
impl FileSystemAccessMode {
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemAccessMode::Ro => "ro",
            FileSystemAccessMode::Rw => "rw",
            FileSystemAccessMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ro", "rw"]
    }
}
impl AsRef<str> for FileSystemAccessMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3DataSource {
    /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix.
    /// Amazon SageMaker uses all objects that match the specified key name prefix for model training. </p>
    /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that
    /// is a manifest file containing a list of object keys that you want Amazon SageMaker to use for model
    /// training. </p>
    /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is
    /// an augmented manifest file in JSON lines format. This file contains the data you want to
    /// use for model training. <code>AugmentedManifestFile</code> can only be used if the
    /// Channel's input mode is <code>Pipe</code>.</p>
    pub s3_data_type: std::option::Option<crate::model::S3DataType>,
    /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either
    /// a key name prefix or a manifest. For example: </p>
    /// <ul>
    /// <li>
    /// <p> A key name prefix might look like this:
    /// <code>s3://bucketname/exampleprefix</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p> A manifest might look like this:
    /// <code>s3://bucketname/example.manifest</code>
    /// </p>
    /// <p> A manifest is an S3 object which is a JSON file consisting of an array of
    /// elements. The first element is a prefix which is followed by one or more
    /// suffixes. SageMaker appends the suffix elements to the prefix to get a full set
    /// of <code>S3Uri</code>. Note that the prefix must be a valid non-empty
    /// <code>S3Uri</code> that precludes users from specifying a manifest whose
    /// individual <code>S3Uri</code> is sourced from different S3 buckets.</p>
    /// <p> The following code example shows a valid manifest format: </p>
    /// <p>
    /// <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code>
    /// </p>
    /// <p>
    /// <code> "relative/path/to/custdata-1",</code>
    /// </p>
    /// <p>
    /// <code> "relative/path/custdata-2",</code>
    /// </p>
    /// <p>
    /// <code> ...</code>
    /// </p>
    /// <p>
    /// <code> "relative/path/custdata-N"</code>
    /// </p>
    /// <p>
    /// <code>]</code>
    /// </p>
    /// <p> This JSON is equivalent to the following <code>S3Uri</code>
    /// list:</p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code>
    /// </p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code>
    /// </p>
    /// <p>
    /// <code>...</code>
    /// </p>
    /// <p>
    /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code>
    /// </p>
    /// <p>The complete set of <code>S3Uri</code> in this manifest is the input data
    /// for the channel for this data source. The object that each <code>S3Uri</code>
    /// points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on
    /// your behalf. </p>
    /// </li>
    /// </ul>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>If you want Amazon SageMaker to replicate the entire dataset on each ML compute instance that
    /// is launched for model training, specify <code>FullyReplicated</code>. </p>
    /// <p>If you want Amazon SageMaker to replicate a subset of data on each ML compute instance that is
    /// launched for model training, specify <code>ShardedByS3Key</code>. If there are
    /// <i>n</i> ML compute instances launched for a training job, each
    /// instance gets approximately 1/<i>n</i> of the number of S3 objects. In
    /// this case, model training on each machine uses only the subset of training data. </p>
    /// <p>Don't choose more ML compute instances for training than available S3 objects. If
    /// you do, some nodes won't get any data and you will pay for nodes that aren't getting any
    /// training data. This applies in both File and Pipe modes. Keep this in mind when
    /// developing algorithms. </p>
    /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might
    /// choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to
    /// the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>),
    /// this copies 1/<i>n</i> of the number of objects. </p>
    pub s3_data_distribution_type: std::option::Option<crate::model::S3DataDistribution>,
    /// <p>A list of one or more attribute names to use that are found in a specified augmented
    /// manifest file.</p>
    pub attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for S3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("s3_data_distribution_type", &self.s3_data_distribution_type);
        formatter.field("attribute_names", &self.attribute_names);
        formatter.finish()
    }
}
/// See [`S3DataSource`](crate::model::S3DataSource)
pub mod s3_data_source {
    /// A builder for [`S3DataSource`](crate::model::S3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::S3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) s3_data_distribution_type: std::option::Option<crate::model::S3DataDistribution>,
        pub(crate) attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>If you choose <code>S3Prefix</code>, <code>S3Uri</code> identifies a key name prefix.
        /// Amazon SageMaker uses all objects that match the specified key name prefix for model training. </p>
        /// <p>If you choose <code>ManifestFile</code>, <code>S3Uri</code> identifies an object that
        /// is a manifest file containing a list of object keys that you want Amazon SageMaker to use for model
        /// training. </p>
        /// <p>If you choose <code>AugmentedManifestFile</code>, S3Uri identifies an object that is
        /// an augmented manifest file in JSON lines format. This file contains the data you want to
        /// use for model training. <code>AugmentedManifestFile</code> can only be used if the
        /// Channel's input mode is <code>Pipe</code>.</p>
        pub fn s3_data_type(mut self, input: crate::model::S3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::S3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>Depending on the value specified for the <code>S3DataType</code>, identifies either
        /// a key name prefix or a manifest. For example: </p>
        /// <ul>
        /// <li>
        /// <p> A key name prefix might look like this:
        /// <code>s3://bucketname/exampleprefix</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p> A manifest might look like this:
        /// <code>s3://bucketname/example.manifest</code>
        /// </p>
        /// <p> A manifest is an S3 object which is a JSON file consisting of an array of
        /// elements. The first element is a prefix which is followed by one or more
        /// suffixes. SageMaker appends the suffix elements to the prefix to get a full set
        /// of <code>S3Uri</code>. Note that the prefix must be a valid non-empty
        /// <code>S3Uri</code> that precludes users from specifying a manifest whose
        /// individual <code>S3Uri</code> is sourced from different S3 buckets.</p>
        /// <p> The following code example shows a valid manifest format: </p>
        /// <p>
        /// <code>[ {"prefix": "s3://customer_bucket/some/prefix/"},</code>
        /// </p>
        /// <p>
        /// <code> "relative/path/to/custdata-1",</code>
        /// </p>
        /// <p>
        /// <code> "relative/path/custdata-2",</code>
        /// </p>
        /// <p>
        /// <code> ...</code>
        /// </p>
        /// <p>
        /// <code> "relative/path/custdata-N"</code>
        /// </p>
        /// <p>
        /// <code>]</code>
        /// </p>
        /// <p> This JSON is equivalent to the following <code>S3Uri</code>
        /// list:</p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/to/custdata-1</code>
        /// </p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-2</code>
        /// </p>
        /// <p>
        /// <code>...</code>
        /// </p>
        /// <p>
        /// <code>s3://customer_bucket/some/prefix/relative/path/custdata-N</code>
        /// </p>
        /// <p>The complete set of <code>S3Uri</code> in this manifest is the input data
        /// for the channel for this data source. The object that each <code>S3Uri</code>
        /// points to must be readable by the IAM role that Amazon SageMaker uses to perform tasks on
        /// your behalf. </p>
        /// </li>
        /// </ul>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>If you want Amazon SageMaker to replicate the entire dataset on each ML compute instance that
        /// is launched for model training, specify <code>FullyReplicated</code>. </p>
        /// <p>If you want Amazon SageMaker to replicate a subset of data on each ML compute instance that is
        /// launched for model training, specify <code>ShardedByS3Key</code>. If there are
        /// <i>n</i> ML compute instances launched for a training job, each
        /// instance gets approximately 1/<i>n</i> of the number of S3 objects. In
        /// this case, model training on each machine uses only the subset of training data. </p>
        /// <p>Don't choose more ML compute instances for training than available S3 objects. If
        /// you do, some nodes won't get any data and you will pay for nodes that aren't getting any
        /// training data. This applies in both File and Pipe modes. Keep this in mind when
        /// developing algorithms. </p>
        /// <p>In distributed training, where you use multiple ML compute EC2 instances, you might
        /// choose <code>ShardedByS3Key</code>. If the algorithm requires copying training data to
        /// the ML storage volume (when <code>TrainingInputMode</code> is set to <code>File</code>),
        /// this copies 1/<i>n</i> of the number of objects. </p>
        pub fn s3_data_distribution_type(
            mut self,
            input: crate::model::S3DataDistribution,
        ) -> Self {
            self.s3_data_distribution_type = Some(input);
            self
        }
        pub fn set_s3_data_distribution_type(
            mut self,
            input: std::option::Option<crate::model::S3DataDistribution>,
        ) -> Self {
            self.s3_data_distribution_type = input;
            self
        }
        pub fn attribute_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.attribute_names.unwrap_or_default();
            v.push(input.into());
            self.attribute_names = Some(v);
            self
        }
        pub fn set_attribute_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attribute_names = input;
            self
        }
        /// Consumes the builder and constructs a [`S3DataSource`](crate::model::S3DataSource)
        pub fn build(self) -> crate::model::S3DataSource {
            crate::model::S3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
                s3_data_distribution_type: self.s3_data_distribution_type,
                attribute_names: self.attribute_names,
            }
        }
    }
}
impl S3DataSource {
    /// Creates a new builder-style object to manufacture [`S3DataSource`](crate::model::S3DataSource)
    pub fn builder() -> crate::model::s3_data_source::Builder {
        crate::model::s3_data_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3DataDistribution {
    FullyReplicated,
    ShardedByS3Key,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3DataDistribution {
    fn from(s: &str) -> Self {
        match s {
            "FullyReplicated" => S3DataDistribution::FullyReplicated,
            "ShardedByS3Key" => S3DataDistribution::ShardedByS3Key,
            other => S3DataDistribution::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3DataDistribution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(S3DataDistribution::from(s))
    }
}
impl S3DataDistribution {
    pub fn as_str(&self) -> &str {
        match self {
            S3DataDistribution::FullyReplicated => "FullyReplicated",
            S3DataDistribution::ShardedByS3Key => "ShardedByS3Key",
            S3DataDistribution::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FullyReplicated", "ShardedByS3Key"]
    }
}
impl AsRef<str> for S3DataDistribution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the training algorithm to use in a <a>CreateTrainingJob</a>
/// request.</p>
/// <p>For more information about algorithms provided by Amazon SageMaker, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. For
/// information about using your own algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
/// SageMaker</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmSpecification {
    /// <p>The registry path of the Docker image
    /// that contains the training algorithm.
    /// For information about docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms
    /// Provided by Amazon SageMaker: Common Parameters</a>. Amazon SageMaker supports both
    /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
    /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
    /// SageMaker</a>.</p>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>The name of the algorithm resource to use for the training job. This must be an
    /// algorithm resource that you created or subscribe to on Amazon Web Services Marketplace. If you specify a value for
    /// this parameter, you can't specify a value for <code>TrainingImage</code>.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>The input mode that the algorithm supports. For the input modes that Amazon SageMaker
    /// algorithms support, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. If an algorithm supports the <code>File</code> input mode, Amazon SageMaker
    /// downloads the training data from S3 to the provisioned ML storage Volume, and mounts the
    /// directory to docker volume for training container. If an algorithm supports the
    /// <code>Pipe</code> input mode, Amazon SageMaker streams data directly from S3 to the container. </p>
    /// <p> In File mode, make sure you provision ML storage volume with sufficient capacity
    /// to accommodate the data download from S3. In addition to the training data, the ML
    /// storage volume also stores the output model. The algorithm container use ML storage
    /// volume to also store intermediate information, if any. </p>
    /// <p> For distributed algorithms using File mode, training data is distributed
    /// uniformly, and your training duration is predictable if the input data objects size is
    /// approximately same. Amazon SageMaker does not split the files any further for model training. If the
    /// object sizes are skewed, training won't be optimal as the data distribution is also
    /// skewed where one host in a training cluster is overloaded, thus becoming bottleneck in
    /// training. </p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>A list of metric definition objects. Each object specifies the metric name and regular
    /// expressions used to parse algorithm logs. Amazon SageMaker publishes each metric to Amazon CloudWatch.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    /// <p>To generate and save time-series metrics during training, set to <code>true</code>.
    /// The default is <code>false</code> and time-series metrics aren't generated except in the
    /// following cases:</p>
    /// <ul>
    /// <li>
    /// <p>You use one of the Amazon SageMaker built-in algorithms</p>
    /// </li>
    /// <li>
    /// <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt Amazon SageMaker Docker Images</a>:</p>
    /// <ul>
    /// <li>
    /// <p>Tensorflow (version >= 1.15)</p>
    /// </li>
    /// <li>
    /// <p>MXNet (version >= 1.6)</p>
    /// </li>
    /// <li>
    /// <p>PyTorch (version >= 1.3)</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>You specify at least one <a>MetricDefinition</a>
    /// </p>
    /// </li>
    /// </ul>
    pub enable_sage_maker_metrics_time_series: bool,
}
impl std::fmt::Debug for AlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.field(
            "enable_sage_maker_metrics_time_series",
            &self.enable_sage_maker_metrics_time_series,
        );
        formatter.finish()
    }
}
/// See [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
pub mod algorithm_specification {
    /// A builder for [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        pub(crate) enable_sage_maker_metrics_time_series: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The registry path of the Docker image
        /// that contains the training algorithm.
        /// For information about docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms
        /// Provided by Amazon SageMaker: Common Parameters</a>. Amazon SageMaker supports both
        /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
        /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
        /// SageMaker</a>.</p>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>The name of the algorithm resource to use for the training job. This must be an
        /// algorithm resource that you created or subscribe to on Amazon Web Services Marketplace. If you specify a value for
        /// this parameter, you can't specify a value for <code>TrainingImage</code>.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// <p>The input mode that the algorithm supports. For the input modes that Amazon SageMaker
        /// algorithms support, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. If an algorithm supports the <code>File</code> input mode, Amazon SageMaker
        /// downloads the training data from S3 to the provisioned ML storage Volume, and mounts the
        /// directory to docker volume for training container. If an algorithm supports the
        /// <code>Pipe</code> input mode, Amazon SageMaker streams data directly from S3 to the container. </p>
        /// <p> In File mode, make sure you provision ML storage volume with sufficient capacity
        /// to accommodate the data download from S3. In addition to the training data, the ML
        /// storage volume also stores the output model. The algorithm container use ML storage
        /// volume to also store intermediate information, if any. </p>
        /// <p> For distributed algorithms using File mode, training data is distributed
        /// uniformly, and your training duration is predictable if the input data objects size is
        /// approximately same. Amazon SageMaker does not split the files any further for model training. If the
        /// object sizes are skewed, training won't be optimal as the data distribution is also
        /// skewed where one host in a training cluster is overloaded, thus becoming bottleneck in
        /// training. </p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        pub fn metric_definitions(
            mut self,
            input: impl Into<crate::model::MetricDefinition>,
        ) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input.into());
            self.metric_definitions = Some(v);
            self
        }
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        /// <p>To generate and save time-series metrics during training, set to <code>true</code>.
        /// The default is <code>false</code> and time-series metrics aren't generated except in the
        /// following cases:</p>
        /// <ul>
        /// <li>
        /// <p>You use one of the Amazon SageMaker built-in algorithms</p>
        /// </li>
        /// <li>
        /// <p>You use one of the following <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/pre-built-containers-frameworks-deep-learning.html">Prebuilt Amazon SageMaker Docker Images</a>:</p>
        /// <ul>
        /// <li>
        /// <p>Tensorflow (version >= 1.15)</p>
        /// </li>
        /// <li>
        /// <p>MXNet (version >= 1.6)</p>
        /// </li>
        /// <li>
        /// <p>PyTorch (version >= 1.3)</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>You specify at least one <a>MetricDefinition</a>
        /// </p>
        /// </li>
        /// </ul>
        pub fn enable_sage_maker_metrics_time_series(mut self, input: bool) -> Self {
            self.enable_sage_maker_metrics_time_series = Some(input);
            self
        }
        pub fn set_enable_sage_maker_metrics_time_series(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_sage_maker_metrics_time_series = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
        pub fn build(self) -> crate::model::AlgorithmSpecification {
            crate::model::AlgorithmSpecification {
                training_image: self.training_image,
                algorithm_name: self.algorithm_name,
                training_input_mode: self.training_input_mode,
                metric_definitions: self.metric_definitions,
                enable_sage_maker_metrics_time_series: self
                    .enable_sage_maker_metrics_time_series
                    .unwrap_or_default(),
            }
        }
    }
}
impl AlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`AlgorithmSpecification`](crate::model::AlgorithmSpecification)
    pub fn builder() -> crate::model::algorithm_specification::Builder {
        crate::model::algorithm_specification::Builder::default()
    }
}

/// <p>Specifies a metric that the training algorithm
/// writes
/// to <code>stderr</code> or <code>stdout</code>. Amazon SageMakerhyperparameter
/// tuning captures
/// all
/// defined metrics.
/// You
/// specify one metric that a hyperparameter tuning job uses as its
/// objective metric to choose the best training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDefinition {
    /// <p>The name of the metric.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A regular expression that searches the output of a training job and gets the value of
    /// the metric. For more information about using regular expressions to define metrics, see
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining
    /// Objective Metrics</a>.</p>
    pub regex: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDefinition");
        formatter.field("name", &self.name);
        formatter.field("regex", &self.regex);
        formatter.finish()
    }
}
/// See [`MetricDefinition`](crate::model::MetricDefinition)
pub mod metric_definition {
    /// A builder for [`MetricDefinition`](crate::model::MetricDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) regex: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A regular expression that searches the output of a training job and gets the value of
        /// the metric. For more information about using regular expressions to define metrics, see
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html">Defining
        /// Objective Metrics</a>.</p>
        pub fn regex(mut self, input: impl Into<std::string::String>) -> Self {
            self.regex = Some(input.into());
            self
        }
        pub fn set_regex(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.regex = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDefinition`](crate::model::MetricDefinition)
        pub fn build(self) -> crate::model::MetricDefinition {
            crate::model::MetricDefinition {
                name: self.name,
                regex: self.regex,
            }
        }
    }
}
impl MetricDefinition {
    /// Creates a new builder-style object to manufacture [`MetricDefinition`](crate::model::MetricDefinition)
    pub fn builder() -> crate::model::metric_definition::Builder {
        crate::model::metric_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => TrainingJobStatus::Completed,
            "Failed" => TrainingJobStatus::Failed,
            "InProgress" => TrainingJobStatus::InProgress,
            "Stopped" => TrainingJobStatus::Stopped,
            "Stopping" => TrainingJobStatus::Stopping,
            other => TrainingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobStatus::from(s))
    }
}
impl TrainingJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobStatus::Completed => "Completed",
            TrainingJobStatus::Failed => "Failed",
            TrainingJobStatus::InProgress => "InProgress",
            TrainingJobStatus::Stopped => "Stopped",
            TrainingJobStatus::Stopping => "Stopping",
            TrainingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for TrainingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the location that is configured for storing model
/// artifacts. </p>
/// <p>Model artifacts are the output that results from training a model, and typically
/// consist of trained parameters, a model defintion that describes how to compute
/// inferences, and other metadata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelArtifacts {
    /// <p>The path of the S3 object that contains the model artifacts. For example,
    /// <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
    pub s3_model_artifacts: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelArtifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelArtifacts");
        formatter.field("s3_model_artifacts", &self.s3_model_artifacts);
        formatter.finish()
    }
}
/// See [`ModelArtifacts`](crate::model::ModelArtifacts)
pub mod model_artifacts {
    /// A builder for [`ModelArtifacts`](crate::model::ModelArtifacts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_model_artifacts: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The path of the S3 object that contains the model artifacts. For example,
        /// <code>s3://bucket-name/keynameprefix/model.tar.gz</code>.</p>
        pub fn s3_model_artifacts(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_model_artifacts = Some(input.into());
            self
        }
        pub fn set_s3_model_artifacts(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_model_artifacts = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelArtifacts`](crate::model::ModelArtifacts)
        pub fn build(self) -> crate::model::ModelArtifacts {
            crate::model::ModelArtifacts {
                s3_model_artifacts: self.s3_model_artifacts,
            }
        }
    }
}
impl ModelArtifacts {
    /// Creates a new builder-style object to manufacture [`ModelArtifacts`](crate::model::ModelArtifacts)
    pub fn builder() -> crate::model::model_artifacts::Builder {
        crate::model::model_artifacts::Builder::default()
    }
}

/// <p>A summary of the metrics of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentMetricSummary {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>When the metric was last updated.</p>
    pub time_stamp: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum value of the metric.</p>
    pub max: std::option::Option<f64>,
    /// <p>The minimum value of the metric.</p>
    pub min: std::option::Option<f64>,
    /// <p>The most recent value of the metric.</p>
    pub last: std::option::Option<f64>,
    /// <p>The number of samples used to generate the metric.</p>
    pub count: std::option::Option<i32>,
    /// <p>The average value of the metric.</p>
    pub avg: std::option::Option<f64>,
    /// <p>The standard deviation of the metric.</p>
    pub std_dev: std::option::Option<f64>,
}
impl std::fmt::Debug for TrialComponentMetricSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentMetricSummary");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("source_arn", &self.source_arn);
        formatter.field("time_stamp", &self.time_stamp);
        formatter.field("max", &self.max);
        formatter.field("min", &self.min);
        formatter.field("last", &self.last);
        formatter.field("count", &self.count);
        formatter.field("avg", &self.avg);
        formatter.field("std_dev", &self.std_dev);
        formatter.finish()
    }
}
/// See [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
pub mod trial_component_metric_summary {
    /// A builder for [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) time_stamp: std::option::Option<smithy_types::Instant>,
        pub(crate) max: std::option::Option<f64>,
        pub(crate) min: std::option::Option<f64>,
        pub(crate) last: std::option::Option<f64>,
        pub(crate) count: std::option::Option<i32>,
        pub(crate) avg: std::option::Option<f64>,
        pub(crate) std_dev: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>When the metric was last updated.</p>
        pub fn time_stamp(mut self, input: smithy_types::Instant) -> Self {
            self.time_stamp = Some(input);
            self
        }
        pub fn set_time_stamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.time_stamp = input;
            self
        }
        /// <p>The maximum value of the metric.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// <p>The minimum value of the metric.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The most recent value of the metric.</p>
        pub fn last(mut self, input: f64) -> Self {
            self.last = Some(input);
            self
        }
        pub fn set_last(mut self, input: std::option::Option<f64>) -> Self {
            self.last = input;
            self
        }
        /// <p>The number of samples used to generate the metric.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>The average value of the metric.</p>
        pub fn avg(mut self, input: f64) -> Self {
            self.avg = Some(input);
            self
        }
        pub fn set_avg(mut self, input: std::option::Option<f64>) -> Self {
            self.avg = input;
            self
        }
        /// <p>The standard deviation of the metric.</p>
        pub fn std_dev(mut self, input: f64) -> Self {
            self.std_dev = Some(input);
            self
        }
        pub fn set_std_dev(mut self, input: std::option::Option<f64>) -> Self {
            self.std_dev = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
        pub fn build(self) -> crate::model::TrialComponentMetricSummary {
            crate::model::TrialComponentMetricSummary {
                metric_name: self.metric_name,
                source_arn: self.source_arn,
                time_stamp: self.time_stamp,
                max: self.max,
                min: self.min,
                last: self.last,
                count: self.count,
                avg: self.avg,
                std_dev: self.std_dev,
            }
        }
    }
}
impl TrialComponentMetricSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentMetricSummary`](crate::model::TrialComponentMetricSummary)
    pub fn builder() -> crate::model::trial_component_metric_summary::Builder {
        crate::model::trial_component_metric_summary::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSource {
    /// <p>The source ARN.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source job type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrialComponentSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`TrialComponentSource`](crate::model::TrialComponentSource)
pub mod trial_component_source {
    /// A builder for [`TrialComponentSource`](crate::model::TrialComponentSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The source ARN.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source job type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSource`](crate::model::TrialComponentSource)
        pub fn build(self) -> crate::model::TrialComponentSource {
            crate::model::TrialComponentSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl TrialComponentSource {
    /// Creates a new builder-style object to manufacture [`TrialComponentSource`](crate::model::TrialComponentSource)
    pub fn builder() -> crate::model::trial_component_source::Builder {
        crate::model::trial_component_source::Builder::default()
    }
}

/// <p>The properties of a trial as returned by the <a>Search</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Trial {
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub trial_arn: std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment the trial is part of.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The source of the trial.</p>
    pub source: std::option::Option<crate::model::TrialSource>,
    /// <p>When the trial was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>Who last modified the trial.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
    pub metadata_properties: std::option::Option<crate::model::MetadataProperties>,
    /// <p>The list of tags that are associated with the trial. You can use <a>Search</a>
    /// API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A list of the components associated with the trial. For each component, a summary of the
    /// component's properties is included.</p>
    pub trial_component_summaries:
        std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
}
impl std::fmt::Debug for Trial {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Trial");
        formatter.field("trial_name", &self.trial_name);
        formatter.field("trial_arn", &self.trial_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("source", &self.source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("metadata_properties", &self.metadata_properties);
        formatter.field("tags", &self.tags);
        formatter.field("trial_component_summaries", &self.trial_component_summaries);
        formatter.finish()
    }
}
/// See [`Trial`](crate::model::Trial)
pub mod trial {
    /// A builder for [`Trial`](crate::model::Trial)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) trial_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::TrialSource>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) metadata_properties: std::option::Option<crate::model::MetadataProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) trial_component_summaries:
            std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
    }
    impl Builder {
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn trial_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_arn = Some(input.into());
            self
        }
        pub fn set_trial_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_arn = input;
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>TrialName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The name of the experiment the trial is part of.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The source of the trial.</p>
        pub fn source(mut self, input: crate::model::TrialSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<crate::model::TrialSource>) -> Self {
            self.source = input;
            self
        }
        /// <p>When the trial was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>Who last modified the trial.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>Metadata properties of the tracking entity, trial, or trial component.</p>
        pub fn metadata_properties(mut self, input: crate::model::MetadataProperties) -> Self {
            self.metadata_properties = Some(input);
            self
        }
        pub fn set_metadata_properties(
            mut self,
            input: std::option::Option<crate::model::MetadataProperties>,
        ) -> Self {
            self.metadata_properties = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn trial_component_summaries(
            mut self,
            input: impl Into<crate::model::TrialComponentSimpleSummary>,
        ) -> Self {
            let mut v = self.trial_component_summaries.unwrap_or_default();
            v.push(input.into());
            self.trial_component_summaries = Some(v);
            self
        }
        pub fn set_trial_component_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrialComponentSimpleSummary>>,
        ) -> Self {
            self.trial_component_summaries = input;
            self
        }
        /// Consumes the builder and constructs a [`Trial`](crate::model::Trial)
        pub fn build(self) -> crate::model::Trial {
            crate::model::Trial {
                trial_name: self.trial_name,
                trial_arn: self.trial_arn,
                display_name: self.display_name,
                experiment_name: self.experiment_name,
                source: self.source,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                metadata_properties: self.metadata_properties,
                tags: self.tags,
                trial_component_summaries: self.trial_component_summaries,
            }
        }
    }
}
impl Trial {
    /// Creates a new builder-style object to manufacture [`Trial`](crate::model::Trial)
    pub fn builder() -> crate::model::trial::Builder {
        crate::model::trial::Builder::default()
    }
}

/// <p>A short summary of a trial component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSimpleSummary {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for TrialComponentSimpleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSimpleSummary");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("trial_component_source", &self.trial_component_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.finish()
    }
}
/// See [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
pub mod trial_component_simple_summary {
    /// A builder for [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn trial_component_source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.trial_component_source = Some(input);
            self
        }
        pub fn set_trial_component_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.trial_component_source = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
        pub fn build(self) -> crate::model::TrialComponentSimpleSummary {
            crate::model::TrialComponentSimpleSummary {
                trial_component_name: self.trial_component_name,
                trial_component_arn: self.trial_component_arn,
                trial_component_source: self.trial_component_source,
                creation_time: self.creation_time,
                created_by: self.created_by,
            }
        }
    }
}
impl TrialComponentSimpleSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentSimpleSummary`](crate::model::TrialComponentSimpleSummary)
    pub fn builder() -> crate::model::trial_component_simple_summary::Builder {
        crate::model::trial_component_simple_summary::Builder::default()
    }
}

/// <p>The source of the trial.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source job type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrialSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`TrialSource`](crate::model::TrialSource)
pub mod trial_source {
    /// A builder for [`TrialSource`](crate::model::TrialSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source job type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialSource`](crate::model::TrialSource)
        pub fn build(self) -> crate::model::TrialSource {
            crate::model::TrialSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl TrialSource {
    /// Creates a new builder-style object to manufacture [`TrialSource`](crate::model::TrialSource)
    pub fn builder() -> crate::model::trial_source::Builder {
        crate::model::trial_source::Builder::default()
    }
}

/// <p>The properties of an experiment as returned by the <a>Search</a> API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Experiment {
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub experiment_arn: std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>ExperimentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the experiment.</p>
    pub source: std::option::Option<crate::model::ExperimentSource>,
    /// <p>The description of the experiment.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>When the experiment was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the experiment was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
    /// <p>The list of tags that are associated with the experiment. You can use <a>Search</a> API to search on the tags.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Experiment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Experiment");
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("source", &self.source);
        formatter.field("description", &self.description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Experiment`](crate::model::Experiment)
pub mod experiment {
    /// A builder for [`Experiment`](crate::model::Experiment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) experiment_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ExperimentSource>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn experiment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_arn = Some(input.into());
            self
        }
        pub fn set_experiment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_arn = input;
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>ExperimentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn source(mut self, input: crate::model::ExperimentSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ExperimentSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The description of the experiment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Experiment`](crate::model::Experiment)
        pub fn build(self) -> crate::model::Experiment {
            crate::model::Experiment {
                experiment_name: self.experiment_name,
                experiment_arn: self.experiment_arn,
                display_name: self.display_name,
                source: self.source,
                description: self.description,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
                tags: self.tags,
            }
        }
    }
}
impl Experiment {
    /// Creates a new builder-style object to manufacture [`Experiment`](crate::model::Experiment)
    pub fn builder() -> crate::model::experiment::Builder {
        crate::model::experiment::Builder::default()
    }
}

/// <p>The source of the experiment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentSource {
    /// <p>The Amazon Resource Name (ARN) of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The source type.</p>
    pub source_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExperimentSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentSource");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("source_type", &self.source_type);
        formatter.finish()
    }
}
/// See [`ExperimentSource`](crate::model::ExperimentSource)
pub mod experiment_source {
    /// A builder for [`ExperimentSource`](crate::model::ExperimentSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentSource`](crate::model::ExperimentSource)
        pub fn build(self) -> crate::model::ExperimentSource {
            crate::model::ExperimentSource {
                source_arn: self.source_arn,
                source_type: self.source_type,
            }
        }
    }
}
impl ExperimentSource {
    /// Creates a new builder-style object to manufacture [`ExperimentSource`](crate::model::ExperimentSource)
    pub fn builder() -> crate::model::experiment_source::Builder {
        crate::model::experiment_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SearchSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SearchSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => SearchSortOrder::Ascending,
            "Descending" => SearchSortOrder::Descending,
            other => SearchSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SearchSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SearchSortOrder::from(s))
    }
}
impl SearchSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            SearchSortOrder::Ascending => "Ascending",
            SearchSortOrder::Descending => "Descending",
            SearchSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for SearchSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A multi-expression that searches for the specified resource or resources in a search. All resource
/// objects that satisfy the expression's condition are included in the search results. You must specify at
/// least one subexpression, filter, or nested filter. A <code>SearchExpression</code> can contain up to
/// twenty elements.</p>
/// <p>A <code>SearchExpression</code> contains the following components:</p>
/// <ul>
/// <li>
/// <p>A list of <code>Filter</code> objects. Each filter defines a simple Boolean
/// expression comprised of a resource property name, Boolean operator, and
/// value.</p>
/// </li>
/// <li>
/// <p>A list of <code>NestedFilter</code> objects. Each nested filter defines a list
/// of Boolean expressions using a list of resource properties. A nested filter is
/// satisfied if a single object in the list satisfies all Boolean
/// expressions.</p>
/// </li>
/// <li>
/// <p>A list of <code>SearchExpression</code> objects. A search expression object
/// can be nested in a list of search expression objects.</p>
/// </li>
/// <li>
/// <p>A Boolean operator: <code>And</code> or <code>Or</code>.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchExpression {
    /// <p>A list of filter objects.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>A list of nested filter objects.</p>
    pub nested_filters: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
    /// <p>A list of search expression objects.</p>
    pub sub_expressions: std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
    /// <p>A Boolean operator used to evaluate the search expression. If you want every
    /// conditional statement in all lists to be satisfied for the entire search expression to
    /// be true, specify <code>And</code>. If only a single conditional statement needs to be
    /// true for the entire search expression to be true, specify <code>Or</code>. The default
    /// value is <code>And</code>.</p>
    pub operator: std::option::Option<crate::model::BooleanOperator>,
}
impl std::fmt::Debug for SearchExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchExpression");
        formatter.field("filters", &self.filters);
        formatter.field("nested_filters", &self.nested_filters);
        formatter.field("sub_expressions", &self.sub_expressions);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`SearchExpression`](crate::model::SearchExpression)
pub mod search_expression {
    /// A builder for [`SearchExpression`](crate::model::SearchExpression)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) nested_filters: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
        pub(crate) sub_expressions:
            std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
        pub(crate) operator: std::option::Option<crate::model::BooleanOperator>,
    }
    impl Builder {
        pub fn filters(mut self, input: impl Into<crate::model::Filter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        pub fn nested_filters(mut self, input: impl Into<crate::model::NestedFilters>) -> Self {
            let mut v = self.nested_filters.unwrap_or_default();
            v.push(input.into());
            self.nested_filters = Some(v);
            self
        }
        pub fn set_nested_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NestedFilters>>,
        ) -> Self {
            self.nested_filters = input;
            self
        }
        pub fn sub_expressions(mut self, input: impl Into<crate::model::SearchExpression>) -> Self {
            let mut v = self.sub_expressions.unwrap_or_default();
            v.push(input.into());
            self.sub_expressions = Some(v);
            self
        }
        pub fn set_sub_expressions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SearchExpression>>,
        ) -> Self {
            self.sub_expressions = input;
            self
        }
        /// <p>A Boolean operator used to evaluate the search expression. If you want every
        /// conditional statement in all lists to be satisfied for the entire search expression to
        /// be true, specify <code>And</code>. If only a single conditional statement needs to be
        /// true for the entire search expression to be true, specify <code>Or</code>. The default
        /// value is <code>And</code>.</p>
        pub fn operator(mut self, input: crate::model::BooleanOperator) -> Self {
            self.operator = Some(input);
            self
        }
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::BooleanOperator>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchExpression`](crate::model::SearchExpression)
        pub fn build(self) -> crate::model::SearchExpression {
            crate::model::SearchExpression {
                filters: self.filters,
                nested_filters: self.nested_filters,
                sub_expressions: self.sub_expressions,
                operator: self.operator,
            }
        }
    }
}
impl SearchExpression {
    /// Creates a new builder-style object to manufacture [`SearchExpression`](crate::model::SearchExpression)
    pub fn builder() -> crate::model::search_expression::Builder {
        crate::model::search_expression::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BooleanOperator {
    And,
    Or,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BooleanOperator {
    fn from(s: &str) -> Self {
        match s {
            "And" => BooleanOperator::And,
            "Or" => BooleanOperator::Or,
            other => BooleanOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BooleanOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BooleanOperator::from(s))
    }
}
impl BooleanOperator {
    pub fn as_str(&self) -> &str {
        match self {
            BooleanOperator::And => "And",
            BooleanOperator::Or => "Or",
            BooleanOperator::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["And", "Or"]
    }
}
impl AsRef<str> for BooleanOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of nested <a>Filter</a> objects. A resource must satisfy the conditions
/// of all filters to be included in the results returned from the <a>Search</a> API.</p>
/// <p>For example, to filter on a training job's <code>InputDataConfig</code> property with a
/// specific channel name and <code>S3Uri</code> prefix, define the following filters:</p>
/// <ul>
/// <li>
/// <p>
/// <code>'{Name:"InputDataConfig.ChannelName", "Operator":"Equals", "Value":"train"}',</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>'{Name:"InputDataConfig.DataSource.S3DataSource.S3Uri", "Operator":"Contains",
/// "Value":"mybucket/catdata"}'</code>
/// </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NestedFilters {
    /// <p>The name of the property to use in the nested filters. The value must match a listed property name,
    /// such as <code>InputDataConfig</code>.</p>
    pub nested_property_name: std::option::Option<std::string::String>,
    /// <p>A list of filters. Each filter acts on a property. Filters must contain at least one
    /// <code>Filters</code> value. For example, a <code>NestedFilters</code> call might
    /// include a filter on the <code>PropertyName</code> parameter of the
    /// <code>InputDataConfig</code> property:
    /// <code>InputDataConfig.DataSource.S3DataSource.S3Uri</code>.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
}
impl std::fmt::Debug for NestedFilters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NestedFilters");
        formatter.field("nested_property_name", &self.nested_property_name);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}
/// See [`NestedFilters`](crate::model::NestedFilters)
pub mod nested_filters {
    /// A builder for [`NestedFilters`](crate::model::NestedFilters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) nested_property_name: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    }
    impl Builder {
        /// <p>The name of the property to use in the nested filters. The value must match a listed property name,
        /// such as <code>InputDataConfig</code>.</p>
        pub fn nested_property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.nested_property_name = Some(input.into());
            self
        }
        pub fn set_nested_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nested_property_name = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::Filter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`NestedFilters`](crate::model::NestedFilters)
        pub fn build(self) -> crate::model::NestedFilters {
            crate::model::NestedFilters {
                nested_property_name: self.nested_property_name,
                filters: self.filters,
            }
        }
    }
}
impl NestedFilters {
    /// Creates a new builder-style object to manufacture [`NestedFilters`](crate::model::NestedFilters)
    pub fn builder() -> crate::model::nested_filters::Builder {
        crate::model::nested_filters::Builder::default()
    }
}

/// <p>A conditional statement for a search expression that includes a resource property, a
/// Boolean operator, and a value. Resources that match the statement are returned in the
/// results from the <a>Search</a> API.</p>
/// <p>If you specify a <code>Value</code>, but not an <code>Operator</code>, Amazon SageMaker uses the
/// equals operator.</p>
/// <p>In search, there are several property types:</p>
/// <dl>
/// <dt>Metrics</dt>
/// <dd>
/// <p>To define a metric filter, enter a value using the form
/// <code>"Metrics.<name>"</code>, where <code><name></code> is
/// a metric name. For example, the following filter searches for training jobs
/// with an <code>"accuracy"</code> metric greater than
/// <code>"0.9"</code>:</p>
/// <p>
/// <code>{</code>
/// </p>
/// <p>
/// <code>"Name": "Metrics.accuracy",</code>
/// </p>
/// <p>
/// <code>"Operator": "GreaterThan",</code>
/// </p>
/// <p>
/// <code>"Value": "0.9"</code>
/// </p>
/// <p>
/// <code>}</code>
/// </p>
/// </dd>
/// <dt>HyperParameters</dt>
/// <dd>
/// <p>To define a hyperparameter filter, enter a value with the form
/// <code>"HyperParameters.<name>"</code>. Decimal hyperparameter
/// values are treated as a decimal in a comparison if the specified
/// <code>Value</code> is also a decimal value. If the specified
/// <code>Value</code> is an integer, the decimal hyperparameter values are
/// treated as integers. For example, the following filter is satisfied by
/// training jobs with a <code>"learning_rate"</code> hyperparameter that is
/// less than <code>"0.5"</code>:</p>
/// <p>
/// <code> {</code>
/// </p>
/// <p>
/// <code> "Name": "HyperParameters.learning_rate",</code>
/// </p>
/// <p>
/// <code> "Operator": "LessThan",</code>
/// </p>
/// <p>
/// <code> "Value": "0.5"</code>
/// </p>
/// <p>
/// <code> }</code>
/// </p>
/// </dd>
/// <dt>Tags</dt>
/// <dd>
/// <p>To define a tag filter, enter a value with the form
/// <code>Tags.<key></code>.</p>
/// </dd>
/// </dl>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>A resource property name. For example, <code>TrainingJobName</code>. For
    /// valid property names, see <a>SearchRecord</a>.
    /// You must specify a valid property for the resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field
    /// contains one of the following values:</p>
    /// <dl>
    /// <dt>Equals</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
    /// </dd>
    /// <dt>NotEquals</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
    /// </dd>
    /// <dt>Exists</dt>
    /// <dd>
    /// <p>The <code>Name</code> property exists.</p>
    /// </dd>
    /// <dt>NotExists</dt>
    /// <dd>
    /// <p>The <code>Name</code> property does not exist.</p>
    /// </dd>
    /// <dt>GreaterThan</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than <code>Value</code>.
    /// Not supported for text properties.</p>
    /// </dd>
    /// <dt>GreaterThanOrEqualTo</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>.
    /// Not supported for text properties.</p>
    /// </dd>
    /// <dt>LessThan</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than <code>Value</code>.
    /// Not supported for text properties.</p>
    /// </dd>
    /// <dt>LessThanOrEqualTo</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>.
    /// Not supported for text properties.</p>
    /// </dd>
    /// <dt>In</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> is one of the comma delimited strings in
    /// <code>Value</code>. Only supported for text properties.</p>
    /// </dd>
    /// <dt>Contains</dt>
    /// <dd>
    /// <p>The value of <code>Name</code> contains the string <code>Value</code>.
    /// Only supported for text properties.</p>
    /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator
    /// multiple times when the value of <code>Name</code> is one of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Experiment.DisplayName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Experiment.ExperimentName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Experiment.Tags</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Trial.DisplayName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Trial.TrialName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Trial.Tags</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TrialComponent.DisplayName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TrialComponent.TrialComponentName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TrialComponent.Tags</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TrialComponent.InputArtifacts</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TrialComponent.OutputArtifacts</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator
    /// for all other values of <code>Name</code>. In these cases, if you include multiple
    /// <code>Contains</code> operators in the <code>SearchExpression</code>, the result is
    /// the following error message: "<code>'CONTAINS' operator usage limit of 1
    /// exceeded.</code>"</p>
    /// </dd>
    /// </dl>
    pub operator: std::option::Option<crate::model::Operator>,
    /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which
    /// resources satisfy the filter's condition. For numerical properties, <code>Value</code>
    /// must be an integer or floating-point decimal. For timestamp properties,
    /// <code>Value</code> must be an ISO 8601 date-time string of the following format:
    /// <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("operator", &self.operator);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A resource property name. For example, <code>TrainingJobName</code>. For
        /// valid property names, see <a>SearchRecord</a>.
        /// You must specify a valid property for the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A Boolean binary operator that is used to evaluate the filter. The operator field
        /// contains one of the following values:</p>
        /// <dl>
        /// <dt>Equals</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> equals <code>Value</code>.</p>
        /// </dd>
        /// <dt>NotEquals</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> doesn't equal <code>Value</code>.</p>
        /// </dd>
        /// <dt>Exists</dt>
        /// <dd>
        /// <p>The <code>Name</code> property exists.</p>
        /// </dd>
        /// <dt>NotExists</dt>
        /// <dd>
        /// <p>The <code>Name</code> property does not exist.</p>
        /// </dd>
        /// <dt>GreaterThan</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than <code>Value</code>.
        /// Not supported for text properties.</p>
        /// </dd>
        /// <dt>GreaterThanOrEqualTo</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is greater than or equal to <code>Value</code>.
        /// Not supported for text properties.</p>
        /// </dd>
        /// <dt>LessThan</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than <code>Value</code>.
        /// Not supported for text properties.</p>
        /// </dd>
        /// <dt>LessThanOrEqualTo</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is less than or equal to <code>Value</code>.
        /// Not supported for text properties.</p>
        /// </dd>
        /// <dt>In</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> is one of the comma delimited strings in
        /// <code>Value</code>. Only supported for text properties.</p>
        /// </dd>
        /// <dt>Contains</dt>
        /// <dd>
        /// <p>The value of <code>Name</code> contains the string <code>Value</code>.
        /// Only supported for text properties.</p>
        /// <p>A <code>SearchExpression</code> can include the <code>Contains</code> operator
        /// multiple times when the value of <code>Name</code> is one of the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Experiment.DisplayName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Experiment.ExperimentName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Experiment.Tags</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Trial.DisplayName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Trial.TrialName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Trial.Tags</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TrialComponent.DisplayName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TrialComponent.TrialComponentName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TrialComponent.Tags</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TrialComponent.InputArtifacts</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TrialComponent.OutputArtifacts</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>A <code>SearchExpression</code> can include only one <code>Contains</code> operator
        /// for all other values of <code>Name</code>. In these cases, if you include multiple
        /// <code>Contains</code> operators in the <code>SearchExpression</code>, the result is
        /// the following error message: "<code>'CONTAINS' operator usage limit of 1
        /// exceeded.</code>"</p>
        /// </dd>
        /// </dl>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// <p>A value used with <code>Name</code> and <code>Operator</code> to determine which
        /// resources satisfy the filter's condition. For numerical properties, <code>Value</code>
        /// must be an integer or floating-point decimal. For timestamp properties,
        /// <code>Value</code> must be an ISO 8601 date-time string of the following format:
        /// <code>YYYY-mm-dd'T'HH:MM:SS</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                operator: self.operator,
                value: self.value,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operator {
    Contains,
    Equals,
    Exists,
    GreaterThan,
    GreaterThanOrEqualTo,
    In,
    LessThan,
    LessThanOrEqualTo,
    NotEquals,
    NotExists,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Operator {
    fn from(s: &str) -> Self {
        match s {
            "Contains" => Operator::Contains,
            "Equals" => Operator::Equals,
            "Exists" => Operator::Exists,
            "GreaterThan" => Operator::GreaterThan,
            "GreaterThanOrEqualTo" => Operator::GreaterThanOrEqualTo,
            "In" => Operator::In,
            "LessThan" => Operator::LessThan,
            "LessThanOrEqualTo" => Operator::LessThanOrEqualTo,
            "NotEquals" => Operator::NotEquals,
            "NotExists" => Operator::NotExists,
            other => Operator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Operator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operator::from(s))
    }
}
impl Operator {
    pub fn as_str(&self) -> &str {
        match self {
            Operator::Contains => "Contains",
            Operator::Equals => "Equals",
            Operator::Exists => "Exists",
            Operator::GreaterThan => "GreaterThan",
            Operator::GreaterThanOrEqualTo => "GreaterThanOrEqualTo",
            Operator::In => "In",
            Operator::LessThan => "LessThan",
            Operator::LessThanOrEqualTo => "LessThanOrEqualTo",
            Operator::NotEquals => "NotEquals",
            Operator::NotExists => "NotExists",
            Operator::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Contains",
            "Equals",
            "Exists",
            "GreaterThan",
            "GreaterThanOrEqualTo",
            "In",
            "LessThan",
            "LessThanOrEqualTo",
            "NotEquals",
            "NotExists",
        ]
    }
}
impl AsRef<str> for Operator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    Endpoint,
    Experiment,
    ExperimentTrial,
    ExperimentTrialComponent,
    FeatureGroup,
    ModelPackage,
    ModelPackageGroup,
    Pipeline,
    PipelineExecution,
    TrainingJob,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "Endpoint" => ResourceType::Endpoint,
            "Experiment" => ResourceType::Experiment,
            "ExperimentTrial" => ResourceType::ExperimentTrial,
            "ExperimentTrialComponent" => ResourceType::ExperimentTrialComponent,
            "FeatureGroup" => ResourceType::FeatureGroup,
            "ModelPackage" => ResourceType::ModelPackage,
            "ModelPackageGroup" => ResourceType::ModelPackageGroup,
            "Pipeline" => ResourceType::Pipeline,
            "PipelineExecution" => ResourceType::PipelineExecution,
            "TrainingJob" => ResourceType::TrainingJob,
            other => ResourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Endpoint => "Endpoint",
            ResourceType::Experiment => "Experiment",
            ResourceType::ExperimentTrial => "ExperimentTrial",
            ResourceType::ExperimentTrialComponent => "ExperimentTrialComponent",
            ResourceType::FeatureGroup => "FeatureGroup",
            ResourceType::ModelPackage => "ModelPackage",
            ResourceType::ModelPackageGroup => "ModelPackageGroup",
            ResourceType::Pipeline => "Pipeline",
            ResourceType::PipelineExecution => "PipelineExecution",
            ResourceType::TrainingJob => "TrainingJob",
            ResourceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Endpoint",
            "Experiment",
            "ExperimentTrial",
            "ExperimentTrialComponent",
            "FeatureGroup",
            "ModelPackage",
            "ModelPackageGroup",
            "Pipeline",
            "PipelineExecution",
            "TrainingJob",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A description of an error that occurred while rendering the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderingError {
    /// <p>A unique identifier for a specific class of errors.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A human-readable message describing the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RenderingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderingError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`RenderingError`](crate::model::RenderingError)
pub mod rendering_error {
    /// A builder for [`RenderingError`](crate::model::RenderingError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for a specific class of errors.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A human-readable message describing the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RenderingError`](crate::model::RenderingError)
        pub fn build(self) -> crate::model::RenderingError {
            crate::model::RenderingError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl RenderingError {
    /// Creates a new builder-style object to manufacture [`RenderingError`](crate::model::RenderingError)
    pub fn builder() -> crate::model::rendering_error::Builder {
        crate::model::rendering_error::Builder::default()
    }
}

/// <p>Contains input values for a task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RenderableTask {
    /// <p>A JSON object that contains values for the variables defined in the template. It is
    /// made available to the template under the substitution variable <code>task.input</code>.
    /// For example, if you define a variable <code>task.input.text</code> in your template, you
    /// can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
    pub input: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RenderableTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RenderableTask");
        formatter.field("input", &self.input);
        formatter.finish()
    }
}
/// See [`RenderableTask`](crate::model::RenderableTask)
pub mod renderable_task {
    /// A builder for [`RenderableTask`](crate::model::RenderableTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A JSON object that contains values for the variables defined in the template. It is
        /// made available to the template under the substitution variable <code>task.input</code>.
        /// For example, if you define a variable <code>task.input.text</code> in your template, you
        /// can supply the variable in the JSON object as <code>"text": "sample text"</code>.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        /// Consumes the builder and constructs a [`RenderableTask`](crate::model::RenderableTask)
        pub fn build(self) -> crate::model::RenderableTask {
            crate::model::RenderableTask { input: self.input }
        }
    }
}
impl RenderableTask {
    /// Creates a new builder-style object to manufacture [`RenderableTask`](crate::model::RenderableTask)
    pub fn builder() -> crate::model::renderable_task::Builder {
        crate::model::renderable_task::Builder::default()
    }
}

/// <p>The Liquid template for the worker user interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiTemplate {
    /// <p>The content of the Liquid template for the worker user interface.</p>
    pub content: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UiTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiTemplate");
        formatter.field("content", &self.content);
        formatter.finish()
    }
}
/// See [`UiTemplate`](crate::model::UiTemplate)
pub mod ui_template {
    /// A builder for [`UiTemplate`](crate::model::UiTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The content of the Liquid template for the worker user interface.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`UiTemplate`](crate::model::UiTemplate)
        pub fn build(self) -> crate::model::UiTemplate {
            crate::model::UiTemplate {
                content: self.content,
            }
        }
    }
}
impl UiTemplate {
    /// Creates a new builder-style object to manufacture [`UiTemplate`](crate::model::UiTemplate)
    pub fn builder() -> crate::model::ui_template::Builder {
        crate::model::ui_template::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => SortOrder::Ascending,
            "Descending" => SortOrder::Descending,
            other => SortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "Ascending",
            SortOrder::Descending => "Descending",
            SortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListWorkteamsSortByOptions {
    CreateDate,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListWorkteamsSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreateDate" => ListWorkteamsSortByOptions::CreateDate,
            "Name" => ListWorkteamsSortByOptions::Name,
            other => ListWorkteamsSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListWorkteamsSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListWorkteamsSortByOptions::from(s))
    }
}
impl ListWorkteamsSortByOptions {
    pub fn as_str(&self) -> &str {
        match self {
            ListWorkteamsSortByOptions::CreateDate => "CreateDate",
            ListWorkteamsSortByOptions::Name => "Name",
            ListWorkteamsSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreateDate", "Name"]
    }
}
impl AsRef<str> for ListWorkteamsSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListWorkforcesSortByOptions {
    CreateDate,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListWorkforcesSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreateDate" => ListWorkforcesSortByOptions::CreateDate,
            "Name" => ListWorkforcesSortByOptions::Name,
            other => ListWorkforcesSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListWorkforcesSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListWorkforcesSortByOptions::from(s))
    }
}
impl ListWorkforcesSortByOptions {
    pub fn as_str(&self) -> &str {
        match self {
            ListWorkforcesSortByOptions::CreateDate => "CreateDate",
            ListWorkforcesSortByOptions::Name => "Name",
            ListWorkforcesSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreateDate", "Name"]
    }
}
impl AsRef<str> for ListWorkforcesSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The user profile details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserProfileDetails {
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::UserProfileStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for UserProfileDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserProfileDetails");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`UserProfileDetails`](crate::model::UserProfileDetails)
pub mod user_profile_details {
    /// A builder for [`UserProfileDetails`](crate::model::UserProfileDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::UserProfileStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The user profile name.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::UserProfileStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::UserProfileStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UserProfileDetails`](crate::model::UserProfileDetails)
        pub fn build(self) -> crate::model::UserProfileDetails {
            crate::model::UserProfileDetails {
                domain_id: self.domain_id,
                user_profile_name: self.user_profile_name,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl UserProfileDetails {
    /// Creates a new builder-style object to manufacture [`UserProfileDetails`](crate::model::UserProfileDetails)
    pub fn builder() -> crate::model::user_profile_details::Builder {
        crate::model::user_profile_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserProfileStatus {
    DeleteFailed,
    Deleting,
    Failed,
    InService,
    Pending,
    UpdateFailed,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UserProfileStatus {
    fn from(s: &str) -> Self {
        match s {
            "Delete_Failed" => UserProfileStatus::DeleteFailed,
            "Deleting" => UserProfileStatus::Deleting,
            "Failed" => UserProfileStatus::Failed,
            "InService" => UserProfileStatus::InService,
            "Pending" => UserProfileStatus::Pending,
            "Update_Failed" => UserProfileStatus::UpdateFailed,
            "Updating" => UserProfileStatus::Updating,
            other => UserProfileStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UserProfileStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserProfileStatus::from(s))
    }
}
impl UserProfileStatus {
    pub fn as_str(&self) -> &str {
        match self {
            UserProfileStatus::DeleteFailed => "Delete_Failed",
            UserProfileStatus::Deleting => "Deleting",
            UserProfileStatus::Failed => "Failed",
            UserProfileStatus::InService => "InService",
            UserProfileStatus::Pending => "Pending",
            UserProfileStatus::UpdateFailed => "Update_Failed",
            UserProfileStatus::Updating => "Updating",
            UserProfileStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Delete_Failed",
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Update_Failed",
            "Updating",
        ]
    }
}
impl AsRef<str> for UserProfileStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserProfileSortKey {
    CreationTime,
    LastModifiedTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UserProfileSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => UserProfileSortKey::CreationTime,
            "LastModifiedTime" => UserProfileSortKey::LastModifiedTime,
            other => UserProfileSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UserProfileSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserProfileSortKey::from(s))
    }
}
impl UserProfileSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            UserProfileSortKey::CreationTime => "CreationTime",
            UserProfileSortKey::LastModifiedTime => "LastModifiedTime",
            UserProfileSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime"]
    }
}
impl AsRef<str> for UserProfileSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of a trial. To get the complete set of properties, call the
/// <a>DescribeTrial</a> API and provide the <code>TrialName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialSummary {
    /// <p>The Amazon Resource Name (ARN) of the trial.</p>
    pub trial_arn: std::option::Option<std::string::String>,
    /// <p>The name of the trial.</p>
    pub trial_name: std::option::Option<std::string::String>,
    /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the trial.</p>
    pub trial_source: std::option::Option<crate::model::TrialSource>,
    /// <p>When the trial was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the trial was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for TrialSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialSummary");
        formatter.field("trial_arn", &self.trial_arn);
        formatter.field("trial_name", &self.trial_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_source", &self.trial_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`TrialSummary`](crate::model::TrialSummary)
pub mod trial_summary {
    /// A builder for [`TrialSummary`](crate::model::TrialSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_arn: std::option::Option<std::string::String>,
        pub(crate) trial_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_source: std::option::Option<crate::model::TrialSource>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the trial.</p>
        pub fn trial_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_arn = Some(input.into());
            self
        }
        pub fn set_trial_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_arn = input;
            self
        }
        /// <p>The name of the trial.</p>
        pub fn trial_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_name = Some(input.into());
            self
        }
        pub fn set_trial_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trial_name = input;
            self
        }
        /// <p>The name of the trial as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>TrialName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the trial.</p>
        pub fn trial_source(mut self, input: crate::model::TrialSource) -> Self {
            self.trial_source = Some(input);
            self
        }
        pub fn set_trial_source(
            mut self,
            input: std::option::Option<crate::model::TrialSource>,
        ) -> Self {
            self.trial_source = input;
            self
        }
        /// <p>When the trial was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the trial was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialSummary`](crate::model::TrialSummary)
        pub fn build(self) -> crate::model::TrialSummary {
            crate::model::TrialSummary {
                trial_arn: self.trial_arn,
                trial_name: self.trial_name,
                display_name: self.display_name,
                trial_source: self.trial_source,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl TrialSummary {
    /// Creates a new builder-style object to manufacture [`TrialSummary`](crate::model::TrialSummary)
    pub fn builder() -> crate::model::trial_summary::Builder {
        crate::model::trial_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortTrialsBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortTrialsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortTrialsBy::CreationTime,
            "Name" => SortTrialsBy::Name,
            other => SortTrialsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortTrialsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortTrialsBy::from(s))
    }
}
impl SortTrialsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortTrialsBy::CreationTime => "CreationTime",
            SortTrialsBy::Name => "Name",
            SortTrialsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortTrialsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of a trial component. To get all the properties, call the
/// <a>DescribeTrialComponent</a> API and provide the
/// <code>TrialComponentName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrialComponentSummary {
    /// <p>The name of the trial component.</p>
    pub trial_component_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the trial component.</p>
    pub trial_component_arn: std::option::Option<std::string::String>,
    /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>TrialComponentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
    pub trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
    /// <p>The status of the component. States include:</p>
    /// <ul>
    /// <li>
    /// <p>InProgress</p>
    /// </li>
    /// <li>
    /// <p>Completed</p>
    /// </li>
    /// <li>
    /// <p>Failed</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::TrialComponentStatus>,
    /// <p>When the component started.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component ended.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the component was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who created the component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
    /// <p>When the component was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Who last modified the component.</p>
    pub last_modified_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for TrialComponentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrialComponentSummary");
        formatter.field("trial_component_name", &self.trial_component_name);
        formatter.field("trial_component_arn", &self.trial_component_arn);
        formatter.field("display_name", &self.display_name);
        formatter.field("trial_component_source", &self.trial_component_source);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.finish()
    }
}
/// See [`TrialComponentSummary`](crate::model::TrialComponentSummary)
pub mod trial_component_summary {
    /// A builder for [`TrialComponentSummary`](crate::model::TrialComponentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trial_component_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) trial_component_source: std::option::Option<crate::model::TrialComponentSource>,
        pub(crate) status: std::option::Option<crate::model::TrialComponentStatus>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The name of the trial component.</p>
        pub fn trial_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_name = Some(input.into());
            self
        }
        pub fn set_trial_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_name = input;
            self
        }
        /// <p>The ARN of the trial component.</p>
        pub fn trial_component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trial_component_arn = Some(input.into());
            self
        }
        pub fn set_trial_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trial_component_arn = input;
            self
        }
        /// <p>The name of the component as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>TrialComponentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) and job type of the source of a trial component.</p>
        pub fn trial_component_source(mut self, input: crate::model::TrialComponentSource) -> Self {
            self.trial_component_source = Some(input);
            self
        }
        pub fn set_trial_component_source(
            mut self,
            input: std::option::Option<crate::model::TrialComponentSource>,
        ) -> Self {
            self.trial_component_source = input;
            self
        }
        /// <p>The status of the component. States include:</p>
        /// <ul>
        /// <li>
        /// <p>InProgress</p>
        /// </li>
        /// <li>
        /// <p>Completed</p>
        /// </li>
        /// <li>
        /// <p>Failed</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::TrialComponentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TrialComponentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the component started.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>When the component ended.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the component was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Who created the component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// <p>When the component was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Who last modified the component.</p>
        pub fn last_modified_by(mut self, input: crate::model::UserContext) -> Self {
            self.last_modified_by = Some(input);
            self
        }
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// Consumes the builder and constructs a [`TrialComponentSummary`](crate::model::TrialComponentSummary)
        pub fn build(self) -> crate::model::TrialComponentSummary {
            crate::model::TrialComponentSummary {
                trial_component_name: self.trial_component_name,
                trial_component_arn: self.trial_component_arn,
                display_name: self.display_name,
                trial_component_source: self.trial_component_source,
                status: self.status,
                start_time: self.start_time,
                end_time: self.end_time,
                creation_time: self.creation_time,
                created_by: self.created_by,
                last_modified_time: self.last_modified_time,
                last_modified_by: self.last_modified_by,
            }
        }
    }
}
impl TrialComponentSummary {
    /// Creates a new builder-style object to manufacture [`TrialComponentSummary`](crate::model::TrialComponentSummary)
    pub fn builder() -> crate::model::trial_component_summary::Builder {
        crate::model::trial_component_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortTrialComponentsBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortTrialComponentsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortTrialComponentsBy::CreationTime,
            "Name" => SortTrialComponentsBy::Name,
            other => SortTrialComponentsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortTrialComponentsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortTrialComponentsBy::from(s))
    }
}
impl SortTrialComponentsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortTrialComponentsBy::CreationTime => "CreationTime",
            SortTrialComponentsBy::Name => "Name",
            SortTrialComponentsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortTrialComponentsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a
/// summary
/// of a transform job. Multiple <code>TransformJobSummary</code> objects are returned as a
/// list after in response to a <a>ListTransformJobs</a> call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobSummary {
    /// <p>The name of the transform job.</p>
    pub transform_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
    pub transform_job_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the transform Job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform
    /// job
    /// ends on compute instances. For successful jobs and stopped jobs, this
    /// is the exact time
    /// recorded
    /// after the results are uploaded. For failed jobs, this is when Amazon SageMaker
    /// detected that the job failed.</p>
    pub transform_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates when the transform job was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the transform job.</p>
    pub transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
    /// <p>If the transform job failed,
    /// the
    /// reason it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransformJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobSummary");
        formatter.field("transform_job_name", &self.transform_job_name);
        formatter.field("transform_job_arn", &self.transform_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("transform_end_time", &self.transform_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("transform_job_status", &self.transform_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`TransformJobSummary`](crate::model::TransformJobSummary)
pub mod transform_job_summary {
    /// A builder for [`TransformJobSummary`](crate::model::TransformJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transform_job_name: std::option::Option<std::string::String>,
        pub(crate) transform_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) transform_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) transform_job_status: std::option::Option<crate::model::TransformJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the transform job.</p>
        pub fn transform_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_name = Some(input.into());
            self
        }
        pub fn set_transform_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job.</p>
        pub fn transform_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transform_job_arn = Some(input.into());
            self
        }
        pub fn set_transform_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transform_job_arn = input;
            self
        }
        /// <p>A timestamp that shows when the transform Job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Indicates when the transform
        /// job
        /// ends on compute instances. For successful jobs and stopped jobs, this
        /// is the exact time
        /// recorded
        /// after the results are uploaded. For failed jobs, this is when Amazon SageMaker
        /// detected that the job failed.</p>
        pub fn transform_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.transform_end_time = Some(input);
            self
        }
        pub fn set_transform_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.transform_end_time = input;
            self
        }
        /// <p>Indicates when the transform job was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the transform job.</p>
        pub fn transform_job_status(mut self, input: crate::model::TransformJobStatus) -> Self {
            self.transform_job_status = Some(input);
            self
        }
        pub fn set_transform_job_status(
            mut self,
            input: std::option::Option<crate::model::TransformJobStatus>,
        ) -> Self {
            self.transform_job_status = input;
            self
        }
        /// <p>If the transform job failed,
        /// the
        /// reason it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobSummary`](crate::model::TransformJobSummary)
        pub fn build(self) -> crate::model::TransformJobSummary {
            crate::model::TransformJobSummary {
                transform_job_name: self.transform_job_name,
                transform_job_arn: self.transform_job_arn,
                creation_time: self.creation_time,
                transform_end_time: self.transform_end_time,
                last_modified_time: self.last_modified_time,
                transform_job_status: self.transform_job_status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl TransformJobSummary {
    /// Creates a new builder-style object to manufacture [`TransformJobSummary`](crate::model::TransformJobSummary)
    pub fn builder() -> crate::model::transform_job_summary::Builder {
        crate::model::transform_job_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortBy {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortBy::CreationTime,
            "Name" => SortBy::Name,
            "Status" => SortBy::Status,
            other => SortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortBy::from(s))
    }
}
impl SortBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortBy::CreationTime => "CreationTime",
            SortBy::Name => "Name",
            SortBy::Status => "Status",
            SortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for SortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies
/// summary information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTrainingJobSummary {
    /// <p>The training job definition name.</p>
    pub training_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The name of the training job.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The
    /// Amazon
    /// Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>The HyperParameter tuning job that launched the training job.</p>
    pub tuning_job_name: std::option::Option<std::string::String>,
    /// <p>The date and time that the training job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the training job started.</p>
    pub training_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies the time when the training job ends on training instances. You are billed
    /// for the time interval between the value of <code>TrainingStartTime</code> and this time.
    /// For successful jobs and stopped jobs, this is the time after model artifacts are
    /// uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.</p>
    pub training_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The
    /// status
    /// of the training job.</p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    /// <p>A
    /// list of the hyperparameters for which you specified ranges to
    /// search.</p>
    pub tuned_hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The
    /// reason that the training job failed.
    /// </p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The <a>FinalHyperParameterTuningJobObjectiveMetric</a> object that
    /// specifies the
    /// value
    /// of the
    /// objective
    /// metric of the tuning job that launched this training job.</p>
    pub final_hyper_parameter_tuning_job_objective_metric:
        std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
    /// <p>The status of the objective metric for the training job:</p>
    /// <ul>
    /// <li>
    /// <p>Succeeded: The
    /// final
    /// objective metric for the training job was evaluated by the
    /// hyperparameter tuning job and
    /// used
    /// in the hyperparameter tuning process.</p>
    /// </li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p>Pending: The training job is in progress and evaluation of its final objective
    /// metric is pending.</p>
    /// </li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p>Failed:
    /// The final objective metric for the training job was not evaluated, and was not
    /// used in the hyperparameter tuning process. This typically occurs when the
    /// training job failed or did not emit an objective
    /// metric.</p>
    /// </li>
    /// </ul>
    pub objective_status: std::option::Option<crate::model::ObjectiveStatus>,
}
impl std::fmt::Debug for HyperParameterTrainingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTrainingJobSummary");
        formatter.field(
            "training_job_definition_name",
            &self.training_job_definition_name,
        );
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("tuning_job_name", &self.tuning_job_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.field("tuned_hyper_parameters", &self.tuned_hyper_parameters);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field(
            "final_hyper_parameter_tuning_job_objective_metric",
            &self.final_hyper_parameter_tuning_job_objective_metric,
        );
        formatter.field("objective_status", &self.objective_status);
        formatter.finish()
    }
}
/// See [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
pub mod hyper_parameter_training_job_summary {
    /// A builder for [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) tuning_job_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
        pub(crate) tuned_hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) final_hyper_parameter_tuning_job_objective_metric:
            std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
        pub(crate) objective_status: std::option::Option<crate::model::ObjectiveStatus>,
    }
    impl Builder {
        /// <p>The training job definition name.</p>
        pub fn training_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.training_job_definition_name = Some(input.into());
            self
        }
        pub fn set_training_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_definition_name = input;
            self
        }
        /// <p>The name of the training job.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The
        /// Amazon
        /// Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>The HyperParameter tuning job that launched the training job.</p>
        pub fn tuning_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.tuning_job_name = Some(input.into());
            self
        }
        pub fn set_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.tuning_job_name = input;
            self
        }
        /// <p>The date and time that the training job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the training job started.</p>
        pub fn training_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.training_start_time = Some(input);
            self
        }
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>Specifies the time when the training job ends on training instances. You are billed
        /// for the time interval between the value of <code>TrainingStartTime</code> and this time.
        /// For successful jobs and stopped jobs, this is the time after model artifacts are
        /// uploaded. For failed jobs, this is the time when Amazon SageMaker detects a job failure.</p>
        pub fn training_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.training_end_time = Some(input);
            self
        }
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>The
        /// status
        /// of the training job.</p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        pub fn tuned_hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tuned_hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tuned_hyper_parameters = Some(hash_map);
            self
        }
        pub fn set_tuned_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tuned_hyper_parameters = input;
            self
        }
        /// <p>The
        /// reason that the training job failed.
        /// </p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The <a>FinalHyperParameterTuningJobObjectiveMetric</a> object that
        /// specifies the
        /// value
        /// of the
        /// objective
        /// metric of the tuning job that launched this training job.</p>
        pub fn final_hyper_parameter_tuning_job_objective_metric(
            mut self,
            input: crate::model::FinalHyperParameterTuningJobObjectiveMetric,
        ) -> Self {
            self.final_hyper_parameter_tuning_job_objective_metric = Some(input);
            self
        }
        pub fn set_final_hyper_parameter_tuning_job_objective_metric(
            mut self,
            input: std::option::Option<crate::model::FinalHyperParameterTuningJobObjectiveMetric>,
        ) -> Self {
            self.final_hyper_parameter_tuning_job_objective_metric = input;
            self
        }
        /// <p>The status of the objective metric for the training job:</p>
        /// <ul>
        /// <li>
        /// <p>Succeeded: The
        /// final
        /// objective metric for the training job was evaluated by the
        /// hyperparameter tuning job and
        /// used
        /// in the hyperparameter tuning process.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>Pending: The training job is in progress and evaluation of its final objective
        /// metric is pending.</p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>Failed:
        /// The final objective metric for the training job was not evaluated, and was not
        /// used in the hyperparameter tuning process. This typically occurs when the
        /// training job failed or did not emit an objective
        /// metric.</p>
        /// </li>
        /// </ul>
        pub fn objective_status(mut self, input: crate::model::ObjectiveStatus) -> Self {
            self.objective_status = Some(input);
            self
        }
        pub fn set_objective_status(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatus>,
        ) -> Self {
            self.objective_status = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
        pub fn build(self) -> crate::model::HyperParameterTrainingJobSummary {
            crate::model::HyperParameterTrainingJobSummary {
                training_job_definition_name: self.training_job_definition_name,
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                tuning_job_name: self.tuning_job_name,
                creation_time: self.creation_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                training_job_status: self.training_job_status,
                tuned_hyper_parameters: self.tuned_hyper_parameters,
                failure_reason: self.failure_reason,
                final_hyper_parameter_tuning_job_objective_metric: self
                    .final_hyper_parameter_tuning_job_objective_metric,
                objective_status: self.objective_status,
            }
        }
    }
}
impl HyperParameterTrainingJobSummary {
    /// Creates a new builder-style object to manufacture [`HyperParameterTrainingJobSummary`](crate::model::HyperParameterTrainingJobSummary)
    pub fn builder() -> crate::model::hyper_parameter_training_job_summary::Builder {
        crate::model::hyper_parameter_training_job_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ObjectiveStatus {
    Failed,
    Pending,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ObjectiveStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ObjectiveStatus::Failed,
            "Pending" => ObjectiveStatus::Pending,
            "Succeeded" => ObjectiveStatus::Succeeded,
            other => ObjectiveStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ObjectiveStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ObjectiveStatus::from(s))
    }
}
impl ObjectiveStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ObjectiveStatus::Failed => "Failed",
            ObjectiveStatus::Pending => "Pending",
            ObjectiveStatus::Succeeded => "Succeeded",
            ObjectiveStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Failed", "Pending", "Succeeded"]
    }
}
impl AsRef<str> for ObjectiveStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Shows the final value for the
/// objective
/// metric for a training job that was launched by a hyperparameter
/// tuning job. You define the objective metric in the
/// <code>HyperParameterTuningJobObjective</code> parameter of <a>HyperParameterTuningJobConfig</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinalHyperParameterTuningJobObjectiveMetric {
    /// <p>Whether to
    /// minimize
    /// or maximize the objective metric. Valid values are Minimize and
    /// Maximize.</p>
    pub r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
    /// <p>The name of the
    /// objective
    /// metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The value of the objective metric.</p>
    pub value: f32,
}
impl std::fmt::Debug for FinalHyperParameterTuningJobObjectiveMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinalHyperParameterTuningJobObjectiveMetric");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
pub mod final_hyper_parameter_tuning_job_objective_metric {
    /// A builder for [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>Whether to
        /// minimize
        /// or maximize the objective metric. Valid values are Minimize and
        /// Maximize.</p>
        pub fn r#type(mut self, input: crate::model::HyperParameterTuningJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the
        /// objective
        /// metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the objective metric.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
        pub fn build(self) -> crate::model::FinalHyperParameterTuningJobObjectiveMetric {
            crate::model::FinalHyperParameterTuningJobObjectiveMetric {
                r#type: self.r#type,
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl FinalHyperParameterTuningJobObjectiveMetric {
    /// Creates a new builder-style object to manufacture [`FinalHyperParameterTuningJobObjectiveMetric`](crate::model::FinalHyperParameterTuningJobObjectiveMetric)
    pub fn builder() -> crate::model::final_hyper_parameter_tuning_job_objective_metric::Builder {
        crate::model::final_hyper_parameter_tuning_job_objective_metric::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobObjectiveType {
    Maximize,
    Minimize,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobObjectiveType {
    fn from(s: &str) -> Self {
        match s {
            "Maximize" => HyperParameterTuningJobObjectiveType::Maximize,
            "Minimize" => HyperParameterTuningJobObjectiveType::Minimize,
            other => HyperParameterTuningJobObjectiveType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobObjectiveType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobObjectiveType::from(s))
    }
}
impl HyperParameterTuningJobObjectiveType {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobObjectiveType::Maximize => "Maximize",
            HyperParameterTuningJobObjectiveType::Minimize => "Minimize",
            HyperParameterTuningJobObjectiveType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Maximize", "Minimize"]
    }
}
impl AsRef<str> for HyperParameterTuningJobObjectiveType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobSortByOptions {
    CreationTime,
    FinalObjectiveMetricValue,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => TrainingJobSortByOptions::CreationTime,
            "FinalObjectiveMetricValue" => TrainingJobSortByOptions::FinalObjectiveMetricValue,
            "Name" => TrainingJobSortByOptions::Name,
            "Status" => TrainingJobSortByOptions::Status,
            other => TrainingJobSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobSortByOptions::from(s))
    }
}
impl TrainingJobSortByOptions {
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobSortByOptions::CreationTime => "CreationTime",
            TrainingJobSortByOptions::FinalObjectiveMetricValue => "FinalObjectiveMetricValue",
            TrainingJobSortByOptions::Name => "Name",
            TrainingJobSortByOptions::Status => "Status",
            TrainingJobSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "FinalObjectiveMetricValue",
            "Name",
            "Status",
        ]
    }
}
impl AsRef<str> for TrainingJobSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobSummary {
    /// <p>The name of the training job that you want a summary for.</p>
    pub training_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the training job.</p>
    pub training_job_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the training job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the training job ended. This field is set only if the
    /// training job has one of the terminal statuses (<code>Completed</code>,
    /// <code>Failed</code>, or <code>Stopped</code>). </p>
    pub training_end_time: std::option::Option<smithy_types::Instant>,
    /// <p> Timestamp when the training job was last modified. </p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the training job.</p>
    pub training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
}
impl std::fmt::Debug for TrainingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobSummary");
        formatter.field("training_job_name", &self.training_job_name);
        formatter.field("training_job_arn", &self.training_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("training_job_status", &self.training_job_status);
        formatter.finish()
    }
}
/// See [`TrainingJobSummary`](crate::model::TrainingJobSummary)
pub mod training_job_summary {
    /// A builder for [`TrainingJobSummary`](crate::model::TrainingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job_name: std::option::Option<std::string::String>,
        pub(crate) training_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_job_status: std::option::Option<crate::model::TrainingJobStatus>,
    }
    impl Builder {
        /// <p>The name of the training job that you want a summary for.</p>
        pub fn training_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_name = Some(input.into());
            self
        }
        pub fn set_training_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the training job.</p>
        pub fn training_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_job_arn = Some(input.into());
            self
        }
        pub fn set_training_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_job_arn = input;
            self
        }
        /// <p>A timestamp that shows when the training job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the training job ended. This field is set only if the
        /// training job has one of the terminal statuses (<code>Completed</code>,
        /// <code>Failed</code>, or <code>Stopped</code>). </p>
        pub fn training_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.training_end_time = Some(input);
            self
        }
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p> Timestamp when the training job was last modified. </p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the training job.</p>
        pub fn training_job_status(mut self, input: crate::model::TrainingJobStatus) -> Self {
            self.training_job_status = Some(input);
            self
        }
        pub fn set_training_job_status(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatus>,
        ) -> Self {
            self.training_job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobSummary`](crate::model::TrainingJobSummary)
        pub fn build(self) -> crate::model::TrainingJobSummary {
            crate::model::TrainingJobSummary {
                training_job_name: self.training_job_name,
                training_job_arn: self.training_job_arn,
                creation_time: self.creation_time,
                training_end_time: self.training_end_time,
                last_modified_time: self.last_modified_time,
                training_job_status: self.training_job_status,
            }
        }
    }
}
impl TrainingJobSummary {
    /// Creates a new builder-style object to manufacture [`TrainingJobSummary`](crate::model::TrainingJobSummary)
    pub fn builder() -> crate::model::training_job_summary::Builder {
        crate::model::training_job_summary::Builder::default()
    }
}

/// <p>Describes a work team of a vendor that does the a labelling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscribedWorkteam {
    /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
    pub marketplace_title: std::option::Option<std::string::String>,
    /// <p>The name of the vendor in the Amazon Marketplace.</p>
    pub seller_name: std::option::Option<std::string::String>,
    /// <p>The description of the vendor from the Amazon Marketplace.</p>
    pub marketplace_description: std::option::Option<std::string::String>,
    /// <p>Marketplace product listing ID.</p>
    pub listing_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubscribedWorkteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscribedWorkteam");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("marketplace_title", &self.marketplace_title);
        formatter.field("seller_name", &self.seller_name);
        formatter.field("marketplace_description", &self.marketplace_description);
        formatter.field("listing_id", &self.listing_id);
        formatter.finish()
    }
}
/// See [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
pub mod subscribed_workteam {
    /// A builder for [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) marketplace_title: std::option::Option<std::string::String>,
        pub(crate) seller_name: std::option::Option<std::string::String>,
        pub(crate) marketplace_description: std::option::Option<std::string::String>,
        pub(crate) listing_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the vendor that you have subscribed.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The title of the service provided by the vendor in the Amazon Marketplace.</p>
        pub fn marketplace_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.marketplace_title = Some(input.into());
            self
        }
        pub fn set_marketplace_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.marketplace_title = input;
            self
        }
        /// <p>The name of the vendor in the Amazon Marketplace.</p>
        pub fn seller_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.seller_name = Some(input.into());
            self
        }
        pub fn set_seller_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.seller_name = input;
            self
        }
        /// <p>The description of the vendor from the Amazon Marketplace.</p>
        pub fn marketplace_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.marketplace_description = Some(input.into());
            self
        }
        pub fn set_marketplace_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.marketplace_description = input;
            self
        }
        /// <p>Marketplace product listing ID.</p>
        pub fn listing_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.listing_id = Some(input.into());
            self
        }
        pub fn set_listing_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.listing_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
        pub fn build(self) -> crate::model::SubscribedWorkteam {
            crate::model::SubscribedWorkteam {
                workteam_arn: self.workteam_arn,
                marketplace_title: self.marketplace_title,
                seller_name: self.seller_name,
                marketplace_description: self.marketplace_description,
                listing_id: self.listing_id,
            }
        }
    }
}
impl SubscribedWorkteam {
    /// Creates a new builder-style object to manufacture [`SubscribedWorkteam`](crate::model::SubscribedWorkteam)
    pub fn builder() -> crate::model::subscribed_workteam::Builder {
        crate::model::subscribed_workteam::Builder::default()
    }
}

/// <p>Information about a project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectSummary {
    /// <p>The name of the project.</p>
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The description of the project.</p>
    pub project_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    pub project_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the project.</p>
    pub project_id: std::option::Option<std::string::String>,
    /// <p>The time that the project was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the project.</p>
    pub project_status: std::option::Option<crate::model::ProjectStatus>,
}
impl std::fmt::Debug for ProjectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectSummary");
        formatter.field("project_name", &self.project_name);
        formatter.field("project_description", &self.project_description);
        formatter.field("project_arn", &self.project_arn);
        formatter.field("project_id", &self.project_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("project_status", &self.project_status);
        formatter.finish()
    }
}
/// See [`ProjectSummary`](crate::model::ProjectSummary)
pub mod project_summary {
    /// A builder for [`ProjectSummary`](crate::model::ProjectSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) project_description: std::option::Option<std::string::String>,
        pub(crate) project_arn: std::option::Option<std::string::String>,
        pub(crate) project_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) project_status: std::option::Option<crate::model::ProjectStatus>,
    }
    impl Builder {
        /// <p>The name of the project.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The description of the project.</p>
        pub fn project_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_description = Some(input.into());
            self
        }
        pub fn set_project_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.project_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_arn = Some(input.into());
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_arn = input;
            self
        }
        /// <p>The ID of the project.</p>
        pub fn project_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_id = Some(input.into());
            self
        }
        pub fn set_project_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_id = input;
            self
        }
        /// <p>The time that the project was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of the project.</p>
        pub fn project_status(mut self, input: crate::model::ProjectStatus) -> Self {
            self.project_status = Some(input);
            self
        }
        pub fn set_project_status(
            mut self,
            input: std::option::Option<crate::model::ProjectStatus>,
        ) -> Self {
            self.project_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectSummary`](crate::model::ProjectSummary)
        pub fn build(self) -> crate::model::ProjectSummary {
            crate::model::ProjectSummary {
                project_name: self.project_name,
                project_description: self.project_description,
                project_arn: self.project_arn,
                project_id: self.project_id,
                creation_time: self.creation_time,
                project_status: self.project_status,
            }
        }
    }
}
impl ProjectSummary {
    /// Creates a new builder-style object to manufacture [`ProjectSummary`](crate::model::ProjectSummary)
    pub fn builder() -> crate::model::project_summary::Builder {
        crate::model::project_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectStatus {
    CreateCompleted,
    CreateFailed,
    CreateInProgress,
    DeleteCompleted,
    DeleteFailed,
    DeleteInProgress,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectStatus {
    fn from(s: &str) -> Self {
        match s {
            "CreateCompleted" => ProjectStatus::CreateCompleted,
            "CreateFailed" => ProjectStatus::CreateFailed,
            "CreateInProgress" => ProjectStatus::CreateInProgress,
            "DeleteCompleted" => ProjectStatus::DeleteCompleted,
            "DeleteFailed" => ProjectStatus::DeleteFailed,
            "DeleteInProgress" => ProjectStatus::DeleteInProgress,
            "Pending" => ProjectStatus::Pending,
            other => ProjectStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectStatus::from(s))
    }
}
impl ProjectStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ProjectStatus::CreateCompleted => "CreateCompleted",
            ProjectStatus::CreateFailed => "CreateFailed",
            ProjectStatus::CreateInProgress => "CreateInProgress",
            ProjectStatus::DeleteCompleted => "DeleteCompleted",
            ProjectStatus::DeleteFailed => "DeleteFailed",
            ProjectStatus::DeleteInProgress => "DeleteInProgress",
            ProjectStatus::Pending => "Pending",
            ProjectStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreateCompleted",
            "CreateFailed",
            "CreateInProgress",
            "DeleteCompleted",
            "DeleteFailed",
            "DeleteInProgress",
            "Pending",
        ]
    }
}
impl AsRef<str> for ProjectStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => ProjectSortOrder::Ascending,
            "Descending" => ProjectSortOrder::Descending,
            other => ProjectSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectSortOrder::from(s))
    }
}
impl ProjectSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            ProjectSortOrder::Ascending => "Ascending",
            ProjectSortOrder::Descending => "Descending",
            ProjectSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for ProjectSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectSortBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ProjectSortBy::CreationTime,
            "Name" => ProjectSortBy::Name,
            other => ProjectSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProjectSortBy::from(s))
    }
}
impl ProjectSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ProjectSortBy::CreationTime => "CreationTime",
            ProjectSortBy::Name => "Name",
            ProjectSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ProjectSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of information about a processing job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJobSummary {
    /// <p>The name of the processing job.</p>
    pub processing_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
    pub processing_job_arn: std::option::Option<std::string::String>,
    /// <p>The time at which the processing job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the processing job completed.</p>
    pub processing_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that indicates the last time the processing job was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the processing job.</p>
    pub processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
    /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if
    /// it failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>An optional string, up to one KB in size, that contains metadata from the processing
    /// container when the processing job exits.</p>
    pub exit_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJobSummary");
        formatter.field("processing_job_name", &self.processing_job_name);
        formatter.field("processing_job_arn", &self.processing_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("processing_end_time", &self.processing_end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("processing_job_status", &self.processing_job_status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("exit_message", &self.exit_message);
        formatter.finish()
    }
}
/// See [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
pub mod processing_job_summary {
    /// A builder for [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) processing_job_name: std::option::Option<std::string::String>,
        pub(crate) processing_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) processing_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) processing_job_status: std::option::Option<crate::model::ProcessingJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) exit_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the processing job.</p>
        pub fn processing_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_name = Some(input.into());
            self
        }
        pub fn set_processing_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job..</p>
        pub fn processing_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.processing_job_arn = Some(input.into());
            self
        }
        pub fn set_processing_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.processing_job_arn = input;
            self
        }
        /// <p>The time at which the processing job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the processing job completed.</p>
        pub fn processing_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.processing_end_time = Some(input);
            self
        }
        pub fn set_processing_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.processing_end_time = input;
            self
        }
        /// <p>A timestamp that indicates the last time the processing job was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the processing job.</p>
        pub fn processing_job_status(mut self, input: crate::model::ProcessingJobStatus) -> Self {
            self.processing_job_status = Some(input);
            self
        }
        pub fn set_processing_job_status(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStatus>,
        ) -> Self {
            self.processing_job_status = input;
            self
        }
        /// <p>A string, up to one KB in size, that contains the reason a processing job failed, if
        /// it failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>An optional string, up to one KB in size, that contains metadata from the processing
        /// container when the processing job exits.</p>
        pub fn exit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.exit_message = Some(input.into());
            self
        }
        pub fn set_exit_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.exit_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
        pub fn build(self) -> crate::model::ProcessingJobSummary {
            crate::model::ProcessingJobSummary {
                processing_job_name: self.processing_job_name,
                processing_job_arn: self.processing_job_arn,
                creation_time: self.creation_time,
                processing_end_time: self.processing_end_time,
                last_modified_time: self.last_modified_time,
                processing_job_status: self.processing_job_status,
                failure_reason: self.failure_reason,
                exit_message: self.exit_message,
            }
        }
    }
}
impl ProcessingJobSummary {
    /// Creates a new builder-style object to manufacture [`ProcessingJobSummary`](crate::model::ProcessingJobSummary)
    pub fn builder() -> crate::model::processing_job_summary::Builder {
        crate::model::processing_job_summary::Builder::default()
    }
}

/// <p>A summary of a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineSummary {
    /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
    pub pipeline_arn: std::option::Option<std::string::String>,
    /// <p>The name of the pipeline.</p>
    pub pipeline_name: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline.</p>
    pub pipeline_display_name: std::option::Option<std::string::String>,
    /// <p>The description of the pipeline.</p>
    pub pipeline_description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the pipeline.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the pipeline was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time that a pipeline execution began.</p>
    pub last_execution_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for PipelineSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineSummary");
        formatter.field("pipeline_arn", &self.pipeline_arn);
        formatter.field("pipeline_name", &self.pipeline_name);
        formatter.field("pipeline_display_name", &self.pipeline_display_name);
        formatter.field("pipeline_description", &self.pipeline_description);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_execution_time", &self.last_execution_time);
        formatter.finish()
    }
}
/// See [`PipelineSummary`](crate::model::PipelineSummary)
pub mod pipeline_summary {
    /// A builder for [`PipelineSummary`](crate::model::PipelineSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_arn: std::option::Option<std::string::String>,
        pub(crate) pipeline_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_display_name: std::option::Option<std::string::String>,
        pub(crate) pipeline_description: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_execution_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the pipeline.</p>
        pub fn pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_arn = Some(input.into());
            self
        }
        pub fn set_pipeline_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.pipeline_arn = input;
            self
        }
        /// <p>The name of the pipeline.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_name = Some(input.into());
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_name = input;
            self
        }
        /// <p>The display name of the pipeline.</p>
        pub fn pipeline_display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_display_name = Some(input.into());
            self
        }
        pub fn set_pipeline_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_display_name = input;
            self
        }
        /// <p>The description of the pipeline.</p>
        pub fn pipeline_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_description = Some(input.into());
            self
        }
        pub fn set_pipeline_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that the pipeline used to execute.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The creation time of the pipeline.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that the pipeline was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The last time that a pipeline execution began.</p>
        pub fn last_execution_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_execution_time = Some(input);
            self
        }
        pub fn set_last_execution_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_execution_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineSummary`](crate::model::PipelineSummary)
        pub fn build(self) -> crate::model::PipelineSummary {
            crate::model::PipelineSummary {
                pipeline_arn: self.pipeline_arn,
                pipeline_name: self.pipeline_name,
                pipeline_display_name: self.pipeline_display_name,
                pipeline_description: self.pipeline_description,
                role_arn: self.role_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                last_execution_time: self.last_execution_time,
            }
        }
    }
}
impl PipelineSummary {
    /// Creates a new builder-style object to manufacture [`PipelineSummary`](crate::model::PipelineSummary)
    pub fn builder() -> crate::model::pipeline_summary::Builder {
        crate::model::pipeline_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortPipelinesBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortPipelinesBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortPipelinesBy::CreationTime,
            "Name" => SortPipelinesBy::Name,
            other => SortPipelinesBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortPipelinesBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortPipelinesBy::from(s))
    }
}
impl SortPipelinesBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortPipelinesBy::CreationTime => "CreationTime",
            SortPipelinesBy::Name => "Name",
            SortPipelinesBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortPipelinesBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An execution of a step in a pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionStep {
    /// <p>The name of the step that is executed.</p>
    pub step_name: std::option::Option<std::string::String>,
    /// <p>The time that the step started executing.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that the step stopped executing.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the step execution.</p>
    pub step_status: std::option::Option<crate::model::StepStatus>,
    /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
    pub cache_hit_result: std::option::Option<crate::model::CacheHitResult>,
    /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Metadata for the step execution.</p>
    pub metadata: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
}
impl std::fmt::Debug for PipelineExecutionStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionStep");
        formatter.field("step_name", &self.step_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("step_status", &self.step_status);
        formatter.field("cache_hit_result", &self.cache_hit_result);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("metadata", &self.metadata);
        formatter.finish()
    }
}
/// See [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
pub mod pipeline_execution_step {
    /// A builder for [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) step_status: std::option::Option<crate::model::StepStatus>,
        pub(crate) cache_hit_result: std::option::Option<crate::model::CacheHitResult>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
    }
    impl Builder {
        /// <p>The name of the step that is executed.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// <p>The time that the step started executing.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time that the step stopped executing.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The status of the step execution.</p>
        pub fn step_status(mut self, input: crate::model::StepStatus) -> Self {
            self.step_status = Some(input);
            self
        }
        pub fn set_step_status(
            mut self,
            input: std::option::Option<crate::model::StepStatus>,
        ) -> Self {
            self.step_status = input;
            self
        }
        /// <p>If this pipeline execution step was cached, details on the cache hit.</p>
        pub fn cache_hit_result(mut self, input: crate::model::CacheHitResult) -> Self {
            self.cache_hit_result = Some(input);
            self
        }
        pub fn set_cache_hit_result(
            mut self,
            input: std::option::Option<crate::model::CacheHitResult>,
        ) -> Self {
            self.cache_hit_result = input;
            self
        }
        /// <p>The reason why the step failed execution. This is only returned if the step failed its execution.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Metadata for the step execution.</p>
        pub fn metadata(mut self, input: crate::model::PipelineExecutionStepMetadata) -> Self {
            self.metadata = Some(input);
            self
        }
        pub fn set_metadata(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStepMetadata>,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
        pub fn build(self) -> crate::model::PipelineExecutionStep {
            crate::model::PipelineExecutionStep {
                step_name: self.step_name,
                start_time: self.start_time,
                end_time: self.end_time,
                step_status: self.step_status,
                cache_hit_result: self.cache_hit_result,
                failure_reason: self.failure_reason,
                metadata: self.metadata,
            }
        }
    }
}
impl PipelineExecutionStep {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionStep`](crate::model::PipelineExecutionStep)
    pub fn builder() -> crate::model::pipeline_execution_step::Builder {
        crate::model::pipeline_execution_step::Builder::default()
    }
}

/// <p>Metadata for a step execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub training_job: std::option::Option<crate::model::TrainingJobStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
    pub processing_job: std::option::Option<crate::model::ProcessingJobStepMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub transform_job: std::option::Option<crate::model::TransformJobStepMetadata>,
    /// <p>Metadata for the Model step.</p>
    pub model: std::option::Option<crate::model::ModelStepMetadata>,
    /// <p>Metadata for the RegisterModel step.</p>
    pub register_model: std::option::Option<crate::model::RegisterModelStepMetadata>,
    /// <p>If this is a Condition step metadata object, details on the condition.</p>
    pub condition: std::option::Option<crate::model::ConditionStepMetadata>,
    /// <p>Metadata about a callback step.</p>
    pub callback: std::option::Option<crate::model::CallbackStepMetadata>,
}
impl std::fmt::Debug for PipelineExecutionStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionStepMetadata");
        formatter.field("training_job", &self.training_job);
        formatter.field("processing_job", &self.processing_job);
        formatter.field("transform_job", &self.transform_job);
        formatter.field("model", &self.model);
        formatter.field("register_model", &self.register_model);
        formatter.field("condition", &self.condition);
        formatter.field("callback", &self.callback);
        formatter.finish()
    }
}
/// See [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
pub mod pipeline_execution_step_metadata {
    /// A builder for [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_job: std::option::Option<crate::model::TrainingJobStepMetadata>,
        pub(crate) processing_job: std::option::Option<crate::model::ProcessingJobStepMetadata>,
        pub(crate) transform_job: std::option::Option<crate::model::TransformJobStepMetadata>,
        pub(crate) model: std::option::Option<crate::model::ModelStepMetadata>,
        pub(crate) register_model: std::option::Option<crate::model::RegisterModelStepMetadata>,
        pub(crate) condition: std::option::Option<crate::model::ConditionStepMetadata>,
        pub(crate) callback: std::option::Option<crate::model::CallbackStepMetadata>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn training_job(mut self, input: crate::model::TrainingJobStepMetadata) -> Self {
            self.training_job = Some(input);
            self
        }
        pub fn set_training_job(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStepMetadata>,
        ) -> Self {
            self.training_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the processing job that was run by this step execution.</p>
        pub fn processing_job(mut self, input: crate::model::ProcessingJobStepMetadata) -> Self {
            self.processing_job = Some(input);
            self
        }
        pub fn set_processing_job(
            mut self,
            input: std::option::Option<crate::model::ProcessingJobStepMetadata>,
        ) -> Self {
            self.processing_job = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn transform_job(mut self, input: crate::model::TransformJobStepMetadata) -> Self {
            self.transform_job = Some(input);
            self
        }
        pub fn set_transform_job(
            mut self,
            input: std::option::Option<crate::model::TransformJobStepMetadata>,
        ) -> Self {
            self.transform_job = input;
            self
        }
        /// <p>Metadata for the Model step.</p>
        pub fn model(mut self, input: crate::model::ModelStepMetadata) -> Self {
            self.model = Some(input);
            self
        }
        pub fn set_model(
            mut self,
            input: std::option::Option<crate::model::ModelStepMetadata>,
        ) -> Self {
            self.model = input;
            self
        }
        /// <p>Metadata for the RegisterModel step.</p>
        pub fn register_model(mut self, input: crate::model::RegisterModelStepMetadata) -> Self {
            self.register_model = Some(input);
            self
        }
        pub fn set_register_model(
            mut self,
            input: std::option::Option<crate::model::RegisterModelStepMetadata>,
        ) -> Self {
            self.register_model = input;
            self
        }
        /// <p>If this is a Condition step metadata object, details on the condition.</p>
        pub fn condition(mut self, input: crate::model::ConditionStepMetadata) -> Self {
            self.condition = Some(input);
            self
        }
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::ConditionStepMetadata>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>Metadata about a callback step.</p>
        pub fn callback(mut self, input: crate::model::CallbackStepMetadata) -> Self {
            self.callback = Some(input);
            self
        }
        pub fn set_callback(
            mut self,
            input: std::option::Option<crate::model::CallbackStepMetadata>,
        ) -> Self {
            self.callback = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
        pub fn build(self) -> crate::model::PipelineExecutionStepMetadata {
            crate::model::PipelineExecutionStepMetadata {
                training_job: self.training_job,
                processing_job: self.processing_job,
                transform_job: self.transform_job,
                model: self.model,
                register_model: self.register_model,
                condition: self.condition,
                callback: self.callback,
            }
        }
    }
}
impl PipelineExecutionStepMetadata {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionStepMetadata`](crate::model::PipelineExecutionStepMetadata)
    pub fn builder() -> crate::model::pipeline_execution_step_metadata::Builder {
        crate::model::pipeline_execution_step_metadata::Builder::default()
    }
}

/// <p>Metadata about a callback step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CallbackStepMetadata {
    /// <p>The pipeline generated token from the Amazon SQS queue.</p>
    pub callback_token: std::option::Option<std::string::String>,
    /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
    pub sqs_queue_url: std::option::Option<std::string::String>,
    /// <p>A list of the output parameters of the callback step.</p>
    pub output_parameters: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
}
impl std::fmt::Debug for CallbackStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CallbackStepMetadata");
        formatter.field("callback_token", &self.callback_token);
        formatter.field("sqs_queue_url", &self.sqs_queue_url);
        formatter.field("output_parameters", &self.output_parameters);
        formatter.finish()
    }
}
/// See [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
pub mod callback_step_metadata {
    /// A builder for [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) callback_token: std::option::Option<std::string::String>,
        pub(crate) sqs_queue_url: std::option::Option<std::string::String>,
        pub(crate) output_parameters:
            std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
    }
    impl Builder {
        /// <p>The pipeline generated token from the Amazon SQS queue.</p>
        pub fn callback_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.callback_token = Some(input.into());
            self
        }
        pub fn set_callback_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.callback_token = input;
            self
        }
        /// <p>The URL of the Amazon Simple Queue Service (Amazon SQS) queue used by the callback step.</p>
        pub fn sqs_queue_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.sqs_queue_url = Some(input.into());
            self
        }
        pub fn set_sqs_queue_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sqs_queue_url = input;
            self
        }
        pub fn output_parameters(
            mut self,
            input: impl Into<crate::model::OutputParameter>,
        ) -> Self {
            let mut v = self.output_parameters.unwrap_or_default();
            v.push(input.into());
            self.output_parameters = Some(v);
            self
        }
        pub fn set_output_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OutputParameter>>,
        ) -> Self {
            self.output_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
        pub fn build(self) -> crate::model::CallbackStepMetadata {
            crate::model::CallbackStepMetadata {
                callback_token: self.callback_token,
                sqs_queue_url: self.sqs_queue_url,
                output_parameters: self.output_parameters,
            }
        }
    }
}
impl CallbackStepMetadata {
    /// Creates a new builder-style object to manufacture [`CallbackStepMetadata`](crate::model::CallbackStepMetadata)
    pub fn builder() -> crate::model::callback_step_metadata::Builder {
        crate::model::callback_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a Condition step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionStepMetadata {
    /// <p>The outcome of the Condition step evaluation.</p>
    pub outcome: std::option::Option<crate::model::ConditionOutcome>,
}
impl std::fmt::Debug for ConditionStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionStepMetadata");
        formatter.field("outcome", &self.outcome);
        formatter.finish()
    }
}
/// See [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
pub mod condition_step_metadata {
    /// A builder for [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) outcome: std::option::Option<crate::model::ConditionOutcome>,
    }
    impl Builder {
        /// <p>The outcome of the Condition step evaluation.</p>
        pub fn outcome(mut self, input: crate::model::ConditionOutcome) -> Self {
            self.outcome = Some(input);
            self
        }
        pub fn set_outcome(
            mut self,
            input: std::option::Option<crate::model::ConditionOutcome>,
        ) -> Self {
            self.outcome = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
        pub fn build(self) -> crate::model::ConditionStepMetadata {
            crate::model::ConditionStepMetadata {
                outcome: self.outcome,
            }
        }
    }
}
impl ConditionStepMetadata {
    /// Creates a new builder-style object to manufacture [`ConditionStepMetadata`](crate::model::ConditionStepMetadata)
    pub fn builder() -> crate::model::condition_step_metadata::Builder {
        crate::model::condition_step_metadata::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionOutcome {
    False,
    True,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConditionOutcome {
    fn from(s: &str) -> Self {
        match s {
            "False" => ConditionOutcome::False,
            "True" => ConditionOutcome::True,
            other => ConditionOutcome::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConditionOutcome {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConditionOutcome::from(s))
    }
}
impl ConditionOutcome {
    pub fn as_str(&self) -> &str {
        match self {
            ConditionOutcome::False => "False",
            ConditionOutcome::True => "True",
            ConditionOutcome::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["False", "True"]
    }
}
impl AsRef<str> for ConditionOutcome {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metadata for a register model job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterModelStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterModelStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
pub mod register_model_step_metadata {
    /// A builder for [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
        pub fn build(self) -> crate::model::RegisterModelStepMetadata {
            crate::model::RegisterModelStepMetadata { arn: self.arn }
        }
    }
}
impl RegisterModelStepMetadata {
    /// Creates a new builder-style object to manufacture [`RegisterModelStepMetadata`](crate::model::RegisterModelStepMetadata)
    pub fn builder() -> crate::model::register_model_step_metadata::Builder {
        crate::model::register_model_step_metadata::Builder::default()
    }
}

/// <p>Metadata for Model steps.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the created model.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`ModelStepMetadata`](crate::model::ModelStepMetadata)
pub mod model_step_metadata {
    /// A builder for [`ModelStepMetadata`](crate::model::ModelStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the created model.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelStepMetadata`](crate::model::ModelStepMetadata)
        pub fn build(self) -> crate::model::ModelStepMetadata {
            crate::model::ModelStepMetadata { arn: self.arn }
        }
    }
}
impl ModelStepMetadata {
    /// Creates a new builder-style object to manufacture [`ModelStepMetadata`](crate::model::ModelStepMetadata)
    pub fn builder() -> crate::model::model_step_metadata::Builder {
        crate::model::model_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a transform job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransformJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransformJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransformJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
pub mod transform_job_step_metadata {
    /// A builder for [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the transform job that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
        pub fn build(self) -> crate::model::TransformJobStepMetadata {
            crate::model::TransformJobStepMetadata { arn: self.arn }
        }
    }
}
impl TransformJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`TransformJobStepMetadata`](crate::model::TransformJobStepMetadata)
    pub fn builder() -> crate::model::transform_job_step_metadata::Builder {
        crate::model::transform_job_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a processing job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessingJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessingJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
pub mod processing_job_step_metadata {
    /// A builder for [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the processing job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
        pub fn build(self) -> crate::model::ProcessingJobStepMetadata {
            crate::model::ProcessingJobStepMetadata { arn: self.arn }
        }
    }
}
impl ProcessingJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`ProcessingJobStepMetadata`](crate::model::ProcessingJobStepMetadata)
    pub fn builder() -> crate::model::processing_job_step_metadata::Builder {
        crate::model::processing_job_step_metadata::Builder::default()
    }
}

/// <p>Metadata for a training job step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobStepMetadata {
    /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TrainingJobStepMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobStepMetadata");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
/// See [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
pub mod training_job_step_metadata {
    /// A builder for [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the training job that was run by this step execution.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
        pub fn build(self) -> crate::model::TrainingJobStepMetadata {
            crate::model::TrainingJobStepMetadata { arn: self.arn }
        }
    }
}
impl TrainingJobStepMetadata {
    /// Creates a new builder-style object to manufacture [`TrainingJobStepMetadata`](crate::model::TrainingJobStepMetadata)
    pub fn builder() -> crate::model::training_job_step_metadata::Builder {
        crate::model::training_job_step_metadata::Builder::default()
    }
}

/// <p>Details on the cache hit of a pipeline execution step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheHitResult {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub source_pipeline_execution_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheHitResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheHitResult");
        formatter.field(
            "source_pipeline_execution_arn",
            &self.source_pipeline_execution_arn,
        );
        formatter.finish()
    }
}
/// See [`CacheHitResult`](crate::model::CacheHitResult)
pub mod cache_hit_result {
    /// A builder for [`CacheHitResult`](crate::model::CacheHitResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_pipeline_execution_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn source_pipeline_execution_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.source_pipeline_execution_arn = Some(input.into());
            self
        }
        pub fn set_source_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_pipeline_execution_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheHitResult`](crate::model::CacheHitResult)
        pub fn build(self) -> crate::model::CacheHitResult {
            crate::model::CacheHitResult {
                source_pipeline_execution_arn: self.source_pipeline_execution_arn,
            }
        }
    }
}
impl CacheHitResult {
    /// Creates a new builder-style object to manufacture [`CacheHitResult`](crate::model::CacheHitResult)
    pub fn builder() -> crate::model::cache_hit_result::Builder {
        crate::model::cache_hit_result::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StepStatus {
    Executing,
    Failed,
    Starting,
    Stopped,
    Stopping,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StepStatus {
    fn from(s: &str) -> Self {
        match s {
            "Executing" => StepStatus::Executing,
            "Failed" => StepStatus::Failed,
            "Starting" => StepStatus::Starting,
            "Stopped" => StepStatus::Stopped,
            "Stopping" => StepStatus::Stopping,
            "Succeeded" => StepStatus::Succeeded,
            other => StepStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StepStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StepStatus::from(s))
    }
}
impl StepStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StepStatus::Executing => "Executing",
            StepStatus::Failed => "Failed",
            StepStatus::Starting => "Starting",
            StepStatus::Stopped => "Stopped",
            StepStatus::Stopping => "Stopping",
            StepStatus::Succeeded => "Succeeded",
            StepStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Executing",
            "Failed",
            "Starting",
            "Stopped",
            "Stopping",
            "Succeeded",
        ]
    }
}
impl AsRef<str> for StepStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A pipeline execution summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PipelineExecutionSummary {
    /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
    pub pipeline_execution_arn: std::option::Option<std::string::String>,
    /// <p>The start time of the pipeline execution.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the pipeline execution.</p>
    pub pipeline_execution_status: std::option::Option<crate::model::PipelineExecutionStatus>,
    /// <p>The description of the pipeline execution.</p>
    pub pipeline_execution_description: std::option::Option<std::string::String>,
    /// <p>The display name of the pipeline execution.</p>
    pub pipeline_execution_display_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PipelineExecutionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PipelineExecutionSummary");
        formatter.field("pipeline_execution_arn", &self.pipeline_execution_arn);
        formatter.field("start_time", &self.start_time);
        formatter.field("pipeline_execution_status", &self.pipeline_execution_status);
        formatter.field(
            "pipeline_execution_description",
            &self.pipeline_execution_description,
        );
        formatter.field(
            "pipeline_execution_display_name",
            &self.pipeline_execution_display_name,
        );
        formatter.finish()
    }
}
/// See [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
pub mod pipeline_execution_summary {
    /// A builder for [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_execution_arn: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) pipeline_execution_status:
            std::option::Option<crate::model::PipelineExecutionStatus>,
        pub(crate) pipeline_execution_description: std::option::Option<std::string::String>,
        pub(crate) pipeline_execution_display_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the pipeline execution.</p>
        pub fn pipeline_execution_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pipeline_execution_arn = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_arn = input;
            self
        }
        /// <p>The start time of the pipeline execution.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The status of the pipeline execution.</p>
        pub fn pipeline_execution_status(
            mut self,
            input: crate::model::PipelineExecutionStatus,
        ) -> Self {
            self.pipeline_execution_status = Some(input);
            self
        }
        pub fn set_pipeline_execution_status(
            mut self,
            input: std::option::Option<crate::model::PipelineExecutionStatus>,
        ) -> Self {
            self.pipeline_execution_status = input;
            self
        }
        /// <p>The description of the pipeline execution.</p>
        pub fn pipeline_execution_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_description = input;
            self
        }
        /// <p>The display name of the pipeline execution.</p>
        pub fn pipeline_execution_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = Some(input.into());
            self
        }
        pub fn set_pipeline_execution_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pipeline_execution_display_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
        pub fn build(self) -> crate::model::PipelineExecutionSummary {
            crate::model::PipelineExecutionSummary {
                pipeline_execution_arn: self.pipeline_execution_arn,
                start_time: self.start_time,
                pipeline_execution_status: self.pipeline_execution_status,
                pipeline_execution_description: self.pipeline_execution_description,
                pipeline_execution_display_name: self.pipeline_execution_display_name,
            }
        }
    }
}
impl PipelineExecutionSummary {
    /// Creates a new builder-style object to manufacture [`PipelineExecutionSummary`](crate::model::PipelineExecutionSummary)
    pub fn builder() -> crate::model::pipeline_execution_summary::Builder {
        crate::model::pipeline_execution_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortPipelineExecutionsBy {
    CreationTime,
    PipelineExecutionArn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortPipelineExecutionsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortPipelineExecutionsBy::CreationTime,
            "PipelineExecutionArn" => SortPipelineExecutionsBy::PipelineExecutionArn,
            other => SortPipelineExecutionsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortPipelineExecutionsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortPipelineExecutionsBy::from(s))
    }
}
impl SortPipelineExecutionsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortPipelineExecutionsBy::CreationTime => "CreationTime",
            SortPipelineExecutionsBy::PipelineExecutionArn => "PipelineExecutionArn",
            SortPipelineExecutionsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "PipelineExecutionArn"]
    }
}
impl AsRef<str> for SortPipelineExecutionsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an Amazon SageMaker notebook instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceSummary {
    /// <p>The name of the notebook instance that you want a summary for.</p>
    pub notebook_instance_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
    pub notebook_instance_arn: std::option::Option<std::string::String>,
    /// <p>The status of the notebook instance.</p>
    pub notebook_instance_status: std::option::Option<crate::model::NotebookInstanceStatus>,
    /// <p>The
    /// URL that you use to connect to the Jupyter instance running in your notebook instance.
    /// </p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The type of ML compute instance that the notebook instance is running on.</p>
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>A timestamp that shows when the notebook instance was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the notebook instance was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The name of a notebook instance lifecycle configuration associated with this notebook
    /// instance.</p>
    /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step
    /// 2.1: (Optional) Customize a Notebook Instance</a>.</p>
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The Git repository associated with the notebook instance as its default code
    /// repository. This can be either the name of a Git repository stored as a resource in your
    /// account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any
    /// other Git repository. When you open a notebook instance, it opens in the directory that
    /// contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with Amazon SageMaker
    /// Notebook Instances</a>.</p>
    pub default_code_repository: std::option::Option<std::string::String>,
    /// <p>An array of up to three Git repositories associated with the notebook instance. These
    /// can be either the names of Git repositories stored as resources in your account, or the
    /// URL of Git repositories in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any
    /// other Git repository. These repositories are cloned at the same level as the default
    /// repository of your notebook instance. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git
    /// Repositories with Amazon SageMaker Notebook Instances</a>.</p>
    pub additional_code_repositories: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for NotebookInstanceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceSummary");
        formatter.field("notebook_instance_name", &self.notebook_instance_name);
        formatter.field("notebook_instance_arn", &self.notebook_instance_arn);
        formatter.field("notebook_instance_status", &self.notebook_instance_status);
        formatter.field("url", &self.url);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field("default_code_repository", &self.default_code_repository);
        formatter.field(
            "additional_code_repositories",
            &self.additional_code_repositories,
        );
        formatter.finish()
    }
}
/// See [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
pub mod notebook_instance_summary {
    /// A builder for [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_instance_name: std::option::Option<std::string::String>,
        pub(crate) notebook_instance_arn: std::option::Option<std::string::String>,
        pub(crate) notebook_instance_status:
            std::option::Option<crate::model::NotebookInstanceStatus>,
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) notebook_instance_lifecycle_config_name:
            std::option::Option<std::string::String>,
        pub(crate) default_code_repository: std::option::Option<std::string::String>,
        pub(crate) additional_code_repositories:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the notebook instance that you want a summary for.</p>
        pub fn notebook_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_instance_name = Some(input.into());
            self
        }
        pub fn set_notebook_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
        pub fn notebook_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notebook_instance_arn = Some(input.into());
            self
        }
        pub fn set_notebook_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_arn = input;
            self
        }
        /// <p>The status of the notebook instance.</p>
        pub fn notebook_instance_status(
            mut self,
            input: crate::model::NotebookInstanceStatus,
        ) -> Self {
            self.notebook_instance_status = Some(input);
            self
        }
        pub fn set_notebook_instance_status(
            mut self,
            input: std::option::Option<crate::model::NotebookInstanceStatus>,
        ) -> Self {
            self.notebook_instance_status = input;
            self
        }
        /// <p>The
        /// URL that you use to connect to the Jupyter instance running in your notebook instance.
        /// </p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The type of ML compute instance that the notebook instance is running on.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>A timestamp that shows when the notebook instance was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the notebook instance was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The name of a notebook instance lifecycle configuration associated with this notebook
        /// instance.</p>
        /// <p>For information about notebook instance lifestyle configurations, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html">Step
        /// 2.1: (Optional) Customize a Notebook Instance</a>.</p>
        pub fn notebook_instance_lifecycle_config_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = Some(input.into());
            self
        }
        pub fn set_notebook_instance_lifecycle_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = input;
            self
        }
        /// <p>The Git repository associated with the notebook instance as its default code
        /// repository. This can be either the name of a Git repository stored as a resource in your
        /// account, or the URL of a Git repository in <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">Amazon Web Services CodeCommit</a> or in any
        /// other Git repository. When you open a notebook instance, it opens in the directory that
        /// contains this repository. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating Git Repositories with Amazon SageMaker
        /// Notebook Instances</a>.</p>
        pub fn default_code_repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_code_repository = Some(input.into());
            self
        }
        pub fn set_default_code_repository(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_code_repository = input;
            self
        }
        pub fn additional_code_repositories(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.additional_code_repositories.unwrap_or_default();
            v.push(input.into());
            self.additional_code_repositories = Some(v);
            self
        }
        pub fn set_additional_code_repositories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.additional_code_repositories = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
        pub fn build(self) -> crate::model::NotebookInstanceSummary {
            crate::model::NotebookInstanceSummary {
                notebook_instance_name: self.notebook_instance_name,
                notebook_instance_arn: self.notebook_instance_arn,
                notebook_instance_status: self.notebook_instance_status,
                url: self.url,
                instance_type: self.instance_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                notebook_instance_lifecycle_config_name: self
                    .notebook_instance_lifecycle_config_name,
                default_code_repository: self.default_code_repository,
                additional_code_repositories: self.additional_code_repositories,
            }
        }
    }
}
impl NotebookInstanceSummary {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceSummary`](crate::model::NotebookInstanceSummary)
    pub fn builder() -> crate::model::notebook_instance_summary::Builder {
        crate::model::notebook_instance_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceStatus {
    Deleting,
    Failed,
    InService,
    Pending,
    Stopped,
    Stopping,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "Deleting" => NotebookInstanceStatus::Deleting,
            "Failed" => NotebookInstanceStatus::Failed,
            "InService" => NotebookInstanceStatus::InService,
            "Pending" => NotebookInstanceStatus::Pending,
            "Stopped" => NotebookInstanceStatus::Stopped,
            "Stopping" => NotebookInstanceStatus::Stopping,
            "Updating" => NotebookInstanceStatus::Updating,
            other => NotebookInstanceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceStatus::from(s))
    }
}
impl NotebookInstanceStatus {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceStatus::Deleting => "Deleting",
            NotebookInstanceStatus::Failed => "Failed",
            NotebookInstanceStatus::InService => "InService",
            NotebookInstanceStatus::Pending => "Pending",
            NotebookInstanceStatus::Stopped => "Stopped",
            NotebookInstanceStatus::Stopping => "Stopping",
            NotebookInstanceStatus::Updating => "Updating",
            NotebookInstanceStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Stopped",
            "Stopping",
            "Updating",
        ]
    }
}
impl AsRef<str> for NotebookInstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => NotebookInstanceSortOrder::Ascending,
            "Descending" => NotebookInstanceSortOrder::Descending,
            other => NotebookInstanceSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceSortOrder::from(s))
    }
}
impl NotebookInstanceSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceSortOrder::Ascending => "Ascending",
            NotebookInstanceSortOrder::Descending => "Descending",
            NotebookInstanceSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for NotebookInstanceSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceSortKey {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => NotebookInstanceSortKey::CreationTime,
            "Name" => NotebookInstanceSortKey::Name,
            "Status" => NotebookInstanceSortKey::Status,
            other => NotebookInstanceSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceSortKey::from(s))
    }
}
impl NotebookInstanceSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceSortKey::CreationTime => "CreationTime",
            NotebookInstanceSortKey::Name => "Name",
            NotebookInstanceSortKey::Status => "Status",
            NotebookInstanceSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for NotebookInstanceSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary of a notebook instance lifecycle configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotebookInstanceLifecycleConfigSummary {
    /// <p>The name of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
    pub notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for NotebookInstanceLifecycleConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotebookInstanceLifecycleConfigSummary");
        formatter.field(
            "notebook_instance_lifecycle_config_name",
            &self.notebook_instance_lifecycle_config_name,
        );
        formatter.field(
            "notebook_instance_lifecycle_config_arn",
            &self.notebook_instance_lifecycle_config_arn,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
pub mod notebook_instance_lifecycle_config_summary {
    /// A builder for [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notebook_instance_lifecycle_config_name:
            std::option::Option<std::string::String>,
        pub(crate) notebook_instance_lifecycle_config_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the lifecycle configuration.</p>
        pub fn notebook_instance_lifecycle_config_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = Some(input.into());
            self
        }
        pub fn set_notebook_instance_lifecycle_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the lifecycle configuration.</p>
        pub fn notebook_instance_lifecycle_config_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_arn = Some(input.into());
            self
        }
        pub fn set_notebook_instance_lifecycle_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notebook_instance_lifecycle_config_arn = input;
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that tells when the lifecycle configuration was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
        pub fn build(self) -> crate::model::NotebookInstanceLifecycleConfigSummary {
            crate::model::NotebookInstanceLifecycleConfigSummary {
                notebook_instance_lifecycle_config_name: self
                    .notebook_instance_lifecycle_config_name,
                notebook_instance_lifecycle_config_arn: self.notebook_instance_lifecycle_config_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl NotebookInstanceLifecycleConfigSummary {
    /// Creates a new builder-style object to manufacture [`NotebookInstanceLifecycleConfigSummary`](crate::model::NotebookInstanceLifecycleConfigSummary)
    pub fn builder() -> crate::model::notebook_instance_lifecycle_config_summary::Builder {
        crate::model::notebook_instance_lifecycle_config_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceLifecycleConfigSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceLifecycleConfigSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => NotebookInstanceLifecycleConfigSortOrder::Ascending,
            "Descending" => NotebookInstanceLifecycleConfigSortOrder::Descending,
            other => NotebookInstanceLifecycleConfigSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceLifecycleConfigSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceLifecycleConfigSortOrder::from(s))
    }
}
impl NotebookInstanceLifecycleConfigSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceLifecycleConfigSortOrder::Ascending => "Ascending",
            NotebookInstanceLifecycleConfigSortOrder::Descending => "Descending",
            NotebookInstanceLifecycleConfigSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for NotebookInstanceLifecycleConfigSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotebookInstanceLifecycleConfigSortKey {
    CreationTime,
    LastModifiedTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotebookInstanceLifecycleConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => NotebookInstanceLifecycleConfigSortKey::CreationTime,
            "LastModifiedTime" => NotebookInstanceLifecycleConfigSortKey::LastModifiedTime,
            "Name" => NotebookInstanceLifecycleConfigSortKey::Name,
            other => NotebookInstanceLifecycleConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotebookInstanceLifecycleConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotebookInstanceLifecycleConfigSortKey::from(s))
    }
}
impl NotebookInstanceLifecycleConfigSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            NotebookInstanceLifecycleConfigSortKey::CreationTime => "CreationTime",
            NotebookInstanceLifecycleConfigSortKey::LastModifiedTime => "LastModifiedTime",
            NotebookInstanceLifecycleConfigSortKey::Name => "Name",
            NotebookInstanceLifecycleConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for NotebookInstanceLifecycleConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summarizes the monitoring schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringScheduleSummary {
    /// <p>The name of the monitoring schedule.</p>
    pub monitoring_schedule_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
    pub monitoring_schedule_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the monitoring schedule.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last time the monitoring schedule was modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the monitoring schedule.</p>
    pub monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
    /// <p>The name of the endpoint using the monitoring schedule.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The name of the monitoring job definition that the schedule is for.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The type of the monitoring job definition that the schedule is for.</p>
    pub monitoring_type: std::option::Option<crate::model::MonitoringType>,
}
impl std::fmt::Debug for MonitoringScheduleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringScheduleSummary");
        formatter.field("monitoring_schedule_name", &self.monitoring_schedule_name);
        formatter.field("monitoring_schedule_arn", &self.monitoring_schedule_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "monitoring_schedule_status",
            &self.monitoring_schedule_status,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field("monitoring_type", &self.monitoring_type);
        formatter.finish()
    }
}
/// See [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
pub mod monitoring_schedule_summary {
    /// A builder for [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_schedule_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_schedule_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) monitoring_schedule_status: std::option::Option<crate::model::ScheduleStatus>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_type: std::option::Option<crate::model::MonitoringType>,
    }
    impl Builder {
        /// <p>The name of the monitoring schedule.</p>
        pub fn monitoring_schedule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_name = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring schedule.</p>
        pub fn monitoring_schedule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitoring_schedule_arn = Some(input.into());
            self
        }
        pub fn set_monitoring_schedule_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_schedule_arn = input;
            self
        }
        /// <p>The creation time of the monitoring schedule.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the monitoring schedule was modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the monitoring schedule.</p>
        pub fn monitoring_schedule_status(mut self, input: crate::model::ScheduleStatus) -> Self {
            self.monitoring_schedule_status = Some(input);
            self
        }
        pub fn set_monitoring_schedule_status(
            mut self,
            input: std::option::Option<crate::model::ScheduleStatus>,
        ) -> Self {
            self.monitoring_schedule_status = input;
            self
        }
        /// <p>The name of the endpoint using the monitoring schedule.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The name of the monitoring job definition that the schedule is for.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The type of the monitoring job definition that the schedule is for.</p>
        pub fn monitoring_type(mut self, input: crate::model::MonitoringType) -> Self {
            self.monitoring_type = Some(input);
            self
        }
        pub fn set_monitoring_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringType>,
        ) -> Self {
            self.monitoring_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
        pub fn build(self) -> crate::model::MonitoringScheduleSummary {
            crate::model::MonitoringScheduleSummary {
                monitoring_schedule_name: self.monitoring_schedule_name,
                monitoring_schedule_arn: self.monitoring_schedule_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                monitoring_schedule_status: self.monitoring_schedule_status,
                endpoint_name: self.endpoint_name,
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_type: self.monitoring_type,
            }
        }
    }
}
impl MonitoringScheduleSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringScheduleSummary`](crate::model::MonitoringScheduleSummary)
    pub fn builder() -> crate::model::monitoring_schedule_summary::Builder {
        crate::model::monitoring_schedule_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringScheduleSortKey {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringScheduleSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringScheduleSortKey::CreationTime,
            "Name" => MonitoringScheduleSortKey::Name,
            "Status" => MonitoringScheduleSortKey::Status,
            other => MonitoringScheduleSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringScheduleSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringScheduleSortKey::from(s))
    }
}
impl MonitoringScheduleSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringScheduleSortKey::CreationTime => "CreationTime",
            MonitoringScheduleSortKey::Name => "Name",
            MonitoringScheduleSortKey::Status => "Status",
            MonitoringScheduleSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for MonitoringScheduleSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringExecutionSortKey {
    CreationTime,
    ScheduledTime,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringExecutionSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringExecutionSortKey::CreationTime,
            "ScheduledTime" => MonitoringExecutionSortKey::ScheduledTime,
            "Status" => MonitoringExecutionSortKey::Status,
            other => MonitoringExecutionSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringExecutionSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringExecutionSortKey::from(s))
    }
}
impl MonitoringExecutionSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringExecutionSortKey::CreationTime => "CreationTime",
            MonitoringExecutionSortKey::ScheduledTime => "ScheduledTime",
            MonitoringExecutionSortKey::Status => "Status",
            MonitoringExecutionSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "ScheduledTime", "Status"]
    }
}
impl AsRef<str> for MonitoringExecutionSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelSummary {
    /// <p>The name of the model that you want a summary for.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that indicates when the model was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ModelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelSummary");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_arn", &self.model_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`ModelSummary`](crate::model::ModelSummary)
pub mod model_summary {
    /// A builder for [`ModelSummary`](crate::model::ModelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the model that you want a summary for.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>A timestamp that indicates when the model was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelSummary`](crate::model::ModelSummary)
        pub fn build(self) -> crate::model::ModelSummary {
            crate::model::ModelSummary {
                model_name: self.model_name,
                model_arn: self.model_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl ModelSummary {
    /// Creates a new builder-style object to manufacture [`ModelSummary`](crate::model::ModelSummary)
    pub fn builder() -> crate::model::model_summary::Builder {
        crate::model::model_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderKey {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OrderKey {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => OrderKey::Ascending,
            "Descending" => OrderKey::Descending,
            other => OrderKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OrderKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderKey::from(s))
    }
}
impl OrderKey {
    pub fn as_str(&self) -> &str {
        match self {
            OrderKey::Ascending => "Ascending",
            OrderKey::Descending => "Descending",
            OrderKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for OrderKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelSortKey {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelSortKey::CreationTime,
            "Name" => ModelSortKey::Name,
            other => ModelSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelSortKey::from(s))
    }
}
impl ModelSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            ModelSortKey::CreationTime => "CreationTime",
            ModelSortKey::Name => "Name",
            ModelSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringJobDefinitionSummary {
    /// <p>The name of the monitoring job.</p>
    pub monitoring_job_definition_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
    pub monitoring_job_definition_arn: std::option::Option<std::string::String>,
    /// <p>The time that the monitoring job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The name of the endpoint that the job monitors.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringJobDefinitionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringJobDefinitionSummary");
        formatter.field(
            "monitoring_job_definition_name",
            &self.monitoring_job_definition_name,
        );
        formatter.field(
            "monitoring_job_definition_arn",
            &self.monitoring_job_definition_arn,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
pub mod monitoring_job_definition_summary {
    /// A builder for [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitoring_job_definition_name: std::option::Option<std::string::String>,
        pub(crate) monitoring_job_definition_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the monitoring job.</p>
        pub fn monitoring_job_definition_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = Some(input.into());
            self
        }
        pub fn set_monitoring_job_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the monitoring job.</p>
        pub fn monitoring_job_definition_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_arn = Some(input.into());
            self
        }
        pub fn set_monitoring_job_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitoring_job_definition_arn = input;
            self
        }
        /// <p>The time that the monitoring job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The name of the endpoint that the job monitors.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
        pub fn build(self) -> crate::model::MonitoringJobDefinitionSummary {
            crate::model::MonitoringJobDefinitionSummary {
                monitoring_job_definition_name: self.monitoring_job_definition_name,
                monitoring_job_definition_arn: self.monitoring_job_definition_arn,
                creation_time: self.creation_time,
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl MonitoringJobDefinitionSummary {
    /// Creates a new builder-style object to manufacture [`MonitoringJobDefinitionSummary`](crate::model::MonitoringJobDefinitionSummary)
    pub fn builder() -> crate::model::monitoring_job_definition_summary::Builder {
        crate::model::monitoring_job_definition_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringJobDefinitionSortKey {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringJobDefinitionSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => MonitoringJobDefinitionSortKey::CreationTime,
            "Name" => MonitoringJobDefinitionSortKey::Name,
            other => MonitoringJobDefinitionSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringJobDefinitionSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringJobDefinitionSortKey::from(s))
    }
}
impl MonitoringJobDefinitionSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringJobDefinitionSortKey::CreationTime => "CreationTime",
            MonitoringJobDefinitionSortKey::Name => "Name",
            MonitoringJobDefinitionSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for MonitoringJobDefinitionSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a model package.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageSummary {
    /// <p>The name of the model package.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>If the model package is a versioned model, the model group that the versioned model
    /// belongs to.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>If the model package is a versioned model, the version of the model.</p>
    pub model_package_version: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the model package.</p>
    pub model_package_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the model package.</p>
    pub model_package_description: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the model package was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The overall status of the model package.</p>
    pub model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
    /// <p>The approval status of the model. This can be one of the following values.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>APPROVED</code> - The model is approved</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>REJECTED</code> - The model is rejected.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual
    /// approval.</p>
    /// </li>
    /// </ul>
    pub model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
}
impl std::fmt::Debug for ModelPackageSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageSummary");
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_version", &self.model_package_version);
        formatter.field("model_package_arn", &self.model_package_arn);
        formatter.field("model_package_description", &self.model_package_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("model_package_status", &self.model_package_status);
        formatter.field("model_approval_status", &self.model_approval_status);
        formatter.finish()
    }
}
/// See [`ModelPackageSummary`](crate::model::ModelPackageSummary)
pub mod model_package_summary {
    /// A builder for [`ModelPackageSummary`](crate::model::ModelPackageSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_version: std::option::Option<i32>,
        pub(crate) model_package_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) model_package_status: std::option::Option<crate::model::ModelPackageStatus>,
        pub(crate) model_approval_status: std::option::Option<crate::model::ModelApprovalStatus>,
    }
    impl Builder {
        /// <p>The name of the model package.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>If the model package is a versioned model, the model group that the versioned model
        /// belongs to.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>If the model package is a versioned model, the version of the model.</p>
        pub fn model_package_version(mut self, input: i32) -> Self {
            self.model_package_version = Some(input);
            self
        }
        pub fn set_model_package_version(mut self, input: std::option::Option<i32>) -> Self {
            self.model_package_version = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model package.</p>
        pub fn model_package_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_arn = Some(input.into());
            self
        }
        pub fn set_model_package_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_arn = input;
            self
        }
        /// <p>A brief description of the model package.</p>
        pub fn model_package_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_description = Some(input.into());
            self
        }
        pub fn set_model_package_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_description = input;
            self
        }
        /// <p>A timestamp that shows when the model package was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The overall status of the model package.</p>
        pub fn model_package_status(mut self, input: crate::model::ModelPackageStatus) -> Self {
            self.model_package_status = Some(input);
            self
        }
        pub fn set_model_package_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageStatus>,
        ) -> Self {
            self.model_package_status = input;
            self
        }
        /// <p>The approval status of the model. This can be one of the following values.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>APPROVED</code> - The model is approved</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REJECTED</code> - The model is rejected.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING_MANUAL_APPROVAL</code> - The model is waiting for manual
        /// approval.</p>
        /// </li>
        /// </ul>
        pub fn model_approval_status(mut self, input: crate::model::ModelApprovalStatus) -> Self {
            self.model_approval_status = Some(input);
            self
        }
        pub fn set_model_approval_status(
            mut self,
            input: std::option::Option<crate::model::ModelApprovalStatus>,
        ) -> Self {
            self.model_approval_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageSummary`](crate::model::ModelPackageSummary)
        pub fn build(self) -> crate::model::ModelPackageSummary {
            crate::model::ModelPackageSummary {
                model_package_name: self.model_package_name,
                model_package_group_name: self.model_package_group_name,
                model_package_version: self.model_package_version,
                model_package_arn: self.model_package_arn,
                model_package_description: self.model_package_description,
                creation_time: self.creation_time,
                model_package_status: self.model_package_status,
                model_approval_status: self.model_approval_status,
            }
        }
    }
}
impl ModelPackageSummary {
    /// Creates a new builder-style object to manufacture [`ModelPackageSummary`](crate::model::ModelPackageSummary)
    pub fn builder() -> crate::model::model_package_summary::Builder {
        crate::model::model_package_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageSortBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelPackageSortBy::CreationTime,
            "Name" => ModelPackageSortBy::Name,
            other => ModelPackageSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageSortBy::from(s))
    }
}
impl ModelPackageSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageSortBy::CreationTime => "CreationTime",
            ModelPackageSortBy::Name => "Name",
            ModelPackageSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelPackageSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageType {
    Both,
    Unversioned,
    Versioned,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageType {
    fn from(s: &str) -> Self {
        match s {
            "Both" => ModelPackageType::Both,
            "Unversioned" => ModelPackageType::Unversioned,
            "Versioned" => ModelPackageType::Versioned,
            other => ModelPackageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageType::from(s))
    }
}
impl ModelPackageType {
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageType::Both => "Both",
            ModelPackageType::Unversioned => "Unversioned",
            ModelPackageType::Versioned => "Versioned",
            ModelPackageType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Both", "Unversioned", "Versioned"]
    }
}
impl AsRef<str> for ModelPackageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a model group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelPackageGroupSummary {
    /// <p>The name of the model group.</p>
    pub model_package_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model group.</p>
    pub model_package_group_arn: std::option::Option<std::string::String>,
    /// <p>A description of the model group.</p>
    pub model_package_group_description: std::option::Option<std::string::String>,
    /// <p>The time that the model group was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the model group.</p>
    pub model_package_group_status: std::option::Option<crate::model::ModelPackageGroupStatus>,
}
impl std::fmt::Debug for ModelPackageGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelPackageGroupSummary");
        formatter.field("model_package_group_name", &self.model_package_group_name);
        formatter.field("model_package_group_arn", &self.model_package_group_arn);
        formatter.field(
            "model_package_group_description",
            &self.model_package_group_description,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "model_package_group_status",
            &self.model_package_group_status,
        );
        formatter.finish()
    }
}
/// See [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
pub mod model_package_group_summary {
    /// A builder for [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_package_group_name: std::option::Option<std::string::String>,
        pub(crate) model_package_group_arn: std::option::Option<std::string::String>,
        pub(crate) model_package_group_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) model_package_group_status:
            std::option::Option<crate::model::ModelPackageGroupStatus>,
    }
    impl Builder {
        /// <p>The name of the model group.</p>
        pub fn model_package_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_name = Some(input.into());
            self
        }
        pub fn set_model_package_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model group.</p>
        pub fn model_package_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_group_arn = Some(input.into());
            self
        }
        pub fn set_model_package_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_arn = input;
            self
        }
        /// <p>A description of the model group.</p>
        pub fn model_package_group_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.model_package_group_description = Some(input.into());
            self
        }
        pub fn set_model_package_group_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_group_description = input;
            self
        }
        /// <p>The time that the model group was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of the model group.</p>
        pub fn model_package_group_status(
            mut self,
            input: crate::model::ModelPackageGroupStatus,
        ) -> Self {
            self.model_package_group_status = Some(input);
            self
        }
        pub fn set_model_package_group_status(
            mut self,
            input: std::option::Option<crate::model::ModelPackageGroupStatus>,
        ) -> Self {
            self.model_package_group_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
        pub fn build(self) -> crate::model::ModelPackageGroupSummary {
            crate::model::ModelPackageGroupSummary {
                model_package_group_name: self.model_package_group_name,
                model_package_group_arn: self.model_package_group_arn,
                model_package_group_description: self.model_package_group_description,
                creation_time: self.creation_time,
                model_package_group_status: self.model_package_group_status,
            }
        }
    }
}
impl ModelPackageGroupSummary {
    /// Creates a new builder-style object to manufacture [`ModelPackageGroupSummary`](crate::model::ModelPackageGroupSummary)
    pub fn builder() -> crate::model::model_package_group_summary::Builder {
        crate::model::model_package_group_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelPackageGroupSortBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelPackageGroupSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ModelPackageGroupSortBy::CreationTime,
            "Name" => ModelPackageGroupSortBy::Name,
            other => ModelPackageGroupSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelPackageGroupSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelPackageGroupSortBy::from(s))
    }
}
impl ModelPackageGroupSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ModelPackageGroupSortBy::CreationTime => "CreationTime",
            ModelPackageGroupSortBy::Name => "Name",
            ModelPackageGroupSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for ModelPackageGroupSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for a work team.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobForWorkteamSummary {
    /// <p>The name of the labeling job that the work team is assigned to.</p>
    pub labeling_job_name: std::option::Option<std::string::String>,
    /// <p>A unique identifier for a labeling job. You can use this to refer to a specific
    /// labeling job.</p>
    pub job_reference_code: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
    pub work_requester_account_id: std::option::Option<std::string::String>,
    /// <p>The date and time that the labeling job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Provides information about the progress of a labeling job.</p>
    pub label_counters: std::option::Option<crate::model::LabelCountersForWorkteam>,
    /// <p>The configured number of workers per data object.</p>
    pub number_of_human_workers_per_data_object: std::option::Option<i32>,
}
impl std::fmt::Debug for LabelingJobForWorkteamSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobForWorkteamSummary");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("job_reference_code", &self.job_reference_code);
        formatter.field("work_requester_account_id", &self.work_requester_account_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("label_counters", &self.label_counters);
        formatter.field(
            "number_of_human_workers_per_data_object",
            &self.number_of_human_workers_per_data_object,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
pub mod labeling_job_for_workteam_summary {
    /// A builder for [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_name: std::option::Option<std::string::String>,
        pub(crate) job_reference_code: std::option::Option<std::string::String>,
        pub(crate) work_requester_account_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) label_counters: std::option::Option<crate::model::LabelCountersForWorkteam>,
        pub(crate) number_of_human_workers_per_data_object: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the labeling job that the work team is assigned to.</p>
        pub fn labeling_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_name = Some(input.into());
            self
        }
        pub fn set_labeling_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_name = input;
            self
        }
        /// <p>A unique identifier for a labeling job. You can use this to refer to a specific
        /// labeling job.</p>
        pub fn job_reference_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_reference_code = Some(input.into());
            self
        }
        pub fn set_job_reference_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.job_reference_code = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the account used to start the labeling job.</p>
        pub fn work_requester_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.work_requester_account_id = Some(input.into());
            self
        }
        pub fn set_work_requester_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.work_requester_account_id = input;
            self
        }
        /// <p>The date and time that the labeling job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Provides information about the progress of a labeling job.</p>
        pub fn label_counters(mut self, input: crate::model::LabelCountersForWorkteam) -> Self {
            self.label_counters = Some(input);
            self
        }
        pub fn set_label_counters(
            mut self,
            input: std::option::Option<crate::model::LabelCountersForWorkteam>,
        ) -> Self {
            self.label_counters = input;
            self
        }
        /// <p>The configured number of workers per data object.</p>
        pub fn number_of_human_workers_per_data_object(mut self, input: i32) -> Self {
            self.number_of_human_workers_per_data_object = Some(input);
            self
        }
        pub fn set_number_of_human_workers_per_data_object(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_human_workers_per_data_object = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
        pub fn build(self) -> crate::model::LabelingJobForWorkteamSummary {
            crate::model::LabelingJobForWorkteamSummary {
                labeling_job_name: self.labeling_job_name,
                job_reference_code: self.job_reference_code,
                work_requester_account_id: self.work_requester_account_id,
                creation_time: self.creation_time,
                label_counters: self.label_counters,
                number_of_human_workers_per_data_object: self
                    .number_of_human_workers_per_data_object,
            }
        }
    }
}
impl LabelingJobForWorkteamSummary {
    /// Creates a new builder-style object to manufacture [`LabelingJobForWorkteamSummary`](crate::model::LabelingJobForWorkteamSummary)
    pub fn builder() -> crate::model::labeling_job_for_workteam_summary::Builder {
        crate::model::labeling_job_for_workteam_summary::Builder::default()
    }
}

/// <p>Provides counts for human-labeled tasks in the labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelCountersForWorkteam {
    /// <p>The total number of data objects labeled by a human worker.</p>
    pub human_labeled: i32,
    /// <p>The total number of data objects that need to be labeled by a human worker.</p>
    pub pending_human: i32,
    /// <p>The total number of tasks in the labeling job.</p>
    pub total: i32,
}
impl std::fmt::Debug for LabelCountersForWorkteam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelCountersForWorkteam");
        formatter.field("human_labeled", &self.human_labeled);
        formatter.field("pending_human", &self.pending_human);
        formatter.field("total", &self.total);
        formatter.finish()
    }
}
/// See [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
pub mod label_counters_for_workteam {
    /// A builder for [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_labeled: std::option::Option<i32>,
        pub(crate) pending_human: std::option::Option<i32>,
        pub(crate) total: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of data objects labeled by a human worker.</p>
        pub fn human_labeled(mut self, input: i32) -> Self {
            self.human_labeled = Some(input);
            self
        }
        pub fn set_human_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.human_labeled = input;
            self
        }
        /// <p>The total number of data objects that need to be labeled by a human worker.</p>
        pub fn pending_human(mut self, input: i32) -> Self {
            self.pending_human = Some(input);
            self
        }
        pub fn set_pending_human(mut self, input: std::option::Option<i32>) -> Self {
            self.pending_human = input;
            self
        }
        /// <p>The total number of tasks in the labeling job.</p>
        pub fn total(mut self, input: i32) -> Self {
            self.total = Some(input);
            self
        }
        pub fn set_total(mut self, input: std::option::Option<i32>) -> Self {
            self.total = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
        pub fn build(self) -> crate::model::LabelCountersForWorkteam {
            crate::model::LabelCountersForWorkteam {
                human_labeled: self.human_labeled.unwrap_or_default(),
                pending_human: self.pending_human.unwrap_or_default(),
                total: self.total.unwrap_or_default(),
            }
        }
    }
}
impl LabelCountersForWorkteam {
    /// Creates a new builder-style object to manufacture [`LabelCountersForWorkteam`](crate::model::LabelCountersForWorkteam)
    pub fn builder() -> crate::model::label_counters_for_workteam::Builder {
        crate::model::label_counters_for_workteam::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListLabelingJobsForWorkteamSortByOptions {
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListLabelingJobsForWorkteamSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ListLabelingJobsForWorkteamSortByOptions::CreationTime,
            other => ListLabelingJobsForWorkteamSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListLabelingJobsForWorkteamSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListLabelingJobsForWorkteamSortByOptions::from(s))
    }
}
impl ListLabelingJobsForWorkteamSortByOptions {
    pub fn as_str(&self) -> &str {
        match self {
            ListLabelingJobsForWorkteamSortByOptions::CreationTime => "CreationTime",
            ListLabelingJobsForWorkteamSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for ListLabelingJobsForWorkteamSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobSummary {
    /// <p>The name of the labeling job.</p>
    pub labeling_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was
    /// created.</p>
    pub labeling_job_arn: std::option::Option<std::string::String>,
    /// <p>The date and time that the job was created (timestamp).</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the job was last modified (timestamp).</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current status of the labeling job. </p>
    pub labeling_job_status: std::option::Option<crate::model::LabelingJobStatus>,
    /// <p>Counts showing the progress of the labeling job.</p>
    pub label_counters: std::option::Option<crate::model::LabelCounters>,
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each
    /// data object is sent to a worker.</p>
    pub pre_human_task_lambda_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the
    /// annotations from individual workers into a label for a data object. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation
    /// Consolidation</a>.</p>
    pub annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
    /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field
    /// contains a description of the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The location of the output produced by the labeling job.</p>
    pub labeling_job_output: std::option::Option<crate::model::LabelingJobOutput>,
    /// <p>Input configuration for the labeling job.</p>
    pub input_config: std::option::Option<crate::model::LabelingJobInputConfig>,
}
impl std::fmt::Debug for LabelingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobSummary");
        formatter.field("labeling_job_name", &self.labeling_job_name);
        formatter.field("labeling_job_arn", &self.labeling_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("labeling_job_status", &self.labeling_job_status);
        formatter.field("label_counters", &self.label_counters);
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("pre_human_task_lambda_arn", &self.pre_human_task_lambda_arn);
        formatter.field(
            "annotation_consolidation_lambda_arn",
            &self.annotation_consolidation_lambda_arn,
        );
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("labeling_job_output", &self.labeling_job_output);
        formatter.field("input_config", &self.input_config);
        formatter.finish()
    }
}
/// See [`LabelingJobSummary`](crate::model::LabelingJobSummary)
pub mod labeling_job_summary {
    /// A builder for [`LabelingJobSummary`](crate::model::LabelingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_name: std::option::Option<std::string::String>,
        pub(crate) labeling_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) labeling_job_status: std::option::Option<crate::model::LabelingJobStatus>,
        pub(crate) label_counters: std::option::Option<crate::model::LabelCounters>,
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) pre_human_task_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) labeling_job_output: std::option::Option<crate::model::LabelingJobOutput>,
        pub(crate) input_config: std::option::Option<crate::model::LabelingJobInputConfig>,
    }
    impl Builder {
        /// <p>The name of the labeling job.</p>
        pub fn labeling_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_name = Some(input.into());
            self
        }
        pub fn set_labeling_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) assigned to the labeling job when it was
        /// created.</p>
        pub fn labeling_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.labeling_job_arn = Some(input.into());
            self
        }
        pub fn set_labeling_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_arn = input;
            self
        }
        /// <p>The date and time that the job was created (timestamp).</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the job was last modified (timestamp).</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The current status of the labeling job. </p>
        pub fn labeling_job_status(mut self, input: crate::model::LabelingJobStatus) -> Self {
            self.labeling_job_status = Some(input);
            self
        }
        pub fn set_labeling_job_status(
            mut self,
            input: std::option::Option<crate::model::LabelingJobStatus>,
        ) -> Self {
            self.labeling_job_status = input;
            self
        }
        /// <p>Counts showing the progress of the labeling job.</p>
        pub fn label_counters(mut self, input: crate::model::LabelCounters) -> Self {
            self.label_counters = Some(input);
            self
        }
        pub fn set_label_counters(
            mut self,
            input: std::option::Option<crate::model::LabelCounters>,
        ) -> Self {
            self.label_counters = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to the job.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function. The function is run before each
        /// data object is sent to a worker.</p>
        pub fn pre_human_task_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_human_task_lambda_arn = Some(input.into());
            self
        }
        pub fn set_pre_human_task_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_human_task_lambda_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda function used to consolidate the
        /// annotations from individual workers into a label for a data object. For more
        /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">Annotation
        /// Consolidation</a>.</p>
        pub fn annotation_consolidation_lambda_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = Some(input.into());
            self
        }
        pub fn set_annotation_consolidation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = input;
            self
        }
        /// <p>If the <code>LabelingJobStatus</code> field is <code>Failed</code>, this field
        /// contains a description of the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The location of the output produced by the labeling job.</p>
        pub fn labeling_job_output(mut self, input: crate::model::LabelingJobOutput) -> Self {
            self.labeling_job_output = Some(input);
            self
        }
        pub fn set_labeling_job_output(
            mut self,
            input: std::option::Option<crate::model::LabelingJobOutput>,
        ) -> Self {
            self.labeling_job_output = input;
            self
        }
        /// <p>Input configuration for the labeling job.</p>
        pub fn input_config(mut self, input: crate::model::LabelingJobInputConfig) -> Self {
            self.input_config = Some(input);
            self
        }
        pub fn set_input_config(
            mut self,
            input: std::option::Option<crate::model::LabelingJobInputConfig>,
        ) -> Self {
            self.input_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobSummary`](crate::model::LabelingJobSummary)
        pub fn build(self) -> crate::model::LabelingJobSummary {
            crate::model::LabelingJobSummary {
                labeling_job_name: self.labeling_job_name,
                labeling_job_arn: self.labeling_job_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                labeling_job_status: self.labeling_job_status,
                label_counters: self.label_counters,
                workteam_arn: self.workteam_arn,
                pre_human_task_lambda_arn: self.pre_human_task_lambda_arn,
                annotation_consolidation_lambda_arn: self.annotation_consolidation_lambda_arn,
                failure_reason: self.failure_reason,
                labeling_job_output: self.labeling_job_output,
                input_config: self.input_config,
            }
        }
    }
}
impl LabelingJobSummary {
    /// Creates a new builder-style object to manufacture [`LabelingJobSummary`](crate::model::LabelingJobSummary)
    pub fn builder() -> crate::model::labeling_job_summary::Builder {
        crate::model::labeling_job_summary::Builder::default()
    }
}

/// <p>Input configuration information for a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobInputConfig {
    /// <p>The location of the input data.</p>
    pub data_source: std::option::Option<crate::model::LabelingJobDataSource>,
    /// <p>Attributes of the data specified by the customer.</p>
    pub data_attributes: std::option::Option<crate::model::LabelingJobDataAttributes>,
}
impl std::fmt::Debug for LabelingJobInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobInputConfig");
        formatter.field("data_source", &self.data_source);
        formatter.field("data_attributes", &self.data_attributes);
        formatter.finish()
    }
}
/// See [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
pub mod labeling_job_input_config {
    /// A builder for [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::LabelingJobDataSource>,
        pub(crate) data_attributes: std::option::Option<crate::model::LabelingJobDataAttributes>,
    }
    impl Builder {
        /// <p>The location of the input data.</p>
        pub fn data_source(mut self, input: crate::model::LabelingJobDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>Attributes of the data specified by the customer.</p>
        pub fn data_attributes(mut self, input: crate::model::LabelingJobDataAttributes) -> Self {
            self.data_attributes = Some(input);
            self
        }
        pub fn set_data_attributes(
            mut self,
            input: std::option::Option<crate::model::LabelingJobDataAttributes>,
        ) -> Self {
            self.data_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
        pub fn build(self) -> crate::model::LabelingJobInputConfig {
            crate::model::LabelingJobInputConfig {
                data_source: self.data_source,
                data_attributes: self.data_attributes,
            }
        }
    }
}
impl LabelingJobInputConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobInputConfig`](crate::model::LabelingJobInputConfig)
    pub fn builder() -> crate::model::labeling_job_input_config::Builder {
        crate::model::labeling_job_input_config::Builder::default()
    }
}

/// <p>Attributes of the data specified by the customer. Use these to describe the data to be
/// labeled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobDataAttributes {
    /// <p>Declares that your content is free of personally identifiable information or adult
    /// content. Amazon SageMaker may restrict the Amazon Mechanical Turk workers that can view your task
    /// based on this information.</p>
    pub content_classifiers: std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
}
impl std::fmt::Debug for LabelingJobDataAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobDataAttributes");
        formatter.field("content_classifiers", &self.content_classifiers);
        formatter.finish()
    }
}
/// See [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
pub mod labeling_job_data_attributes {
    /// A builder for [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_classifiers:
            std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
    }
    impl Builder {
        pub fn content_classifiers(
            mut self,
            input: impl Into<crate::model::ContentClassifier>,
        ) -> Self {
            let mut v = self.content_classifiers.unwrap_or_default();
            v.push(input.into());
            self.content_classifiers = Some(v);
            self
        }
        pub fn set_content_classifiers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContentClassifier>>,
        ) -> Self {
            self.content_classifiers = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
        pub fn build(self) -> crate::model::LabelingJobDataAttributes {
            crate::model::LabelingJobDataAttributes {
                content_classifiers: self.content_classifiers,
            }
        }
    }
}
impl LabelingJobDataAttributes {
    /// Creates a new builder-style object to manufacture [`LabelingJobDataAttributes`](crate::model::LabelingJobDataAttributes)
    pub fn builder() -> crate::model::labeling_job_data_attributes::Builder {
        crate::model::labeling_job_data_attributes::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContentClassifier {
    FreeOfAdultContent,
    FreeOfPersonallyIdentifiableInformation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContentClassifier {
    fn from(s: &str) -> Self {
        match s {
            "FreeOfAdultContent" => ContentClassifier::FreeOfAdultContent,
            "FreeOfPersonallyIdentifiableInformation" => {
                ContentClassifier::FreeOfPersonallyIdentifiableInformation
            }
            other => ContentClassifier::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContentClassifier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContentClassifier::from(s))
    }
}
impl ContentClassifier {
    pub fn as_str(&self) -> &str {
        match self {
            ContentClassifier::FreeOfAdultContent => "FreeOfAdultContent",
            ContentClassifier::FreeOfPersonallyIdentifiableInformation => {
                "FreeOfPersonallyIdentifiableInformation"
            }
            ContentClassifier::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "FreeOfAdultContent",
            "FreeOfPersonallyIdentifiableInformation",
        ]
    }
}
impl AsRef<str> for ContentClassifier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the location of input data.</p>
/// <p>You must specify at least one of the following: <code>S3DataSource</code> or <code>SnsDataSource</code>.</p>
/// <p>Use <code>SnsDataSource</code> to specify an SNS input topic
/// for a streaming labeling job. If you do not specify
/// and SNS input topic ARN, Ground Truth will create a one-time labeling job.</p>
/// <p>Use <code>S3DataSource</code> to specify an input
/// manifest file for both streaming and one-time labeling jobs.
/// Adding an <code>S3DataSource</code> is optional if you use <code>SnsDataSource</code> to create a streaming labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobDataSource {
    /// <p>The Amazon S3 location of the input data objects.</p>
    pub s3_data_source: std::option::Option<crate::model::LabelingJobS3DataSource>,
    /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
    pub sns_data_source: std::option::Option<crate::model::LabelingJobSnsDataSource>,
}
impl std::fmt::Debug for LabelingJobDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.field("sns_data_source", &self.sns_data_source);
        formatter.finish()
    }
}
/// See [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
pub mod labeling_job_data_source {
    /// A builder for [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::LabelingJobS3DataSource>,
        pub(crate) sns_data_source: std::option::Option<crate::model::LabelingJobSnsDataSource>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the input data objects.</p>
        pub fn s3_data_source(mut self, input: crate::model::LabelingJobS3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobS3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// <p>An Amazon SNS data source used for streaming labeling jobs. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-send-data">Send Data to a Streaming Labeling Job</a>. </p>
        pub fn sns_data_source(mut self, input: crate::model::LabelingJobSnsDataSource) -> Self {
            self.sns_data_source = Some(input);
            self
        }
        pub fn set_sns_data_source(
            mut self,
            input: std::option::Option<crate::model::LabelingJobSnsDataSource>,
        ) -> Self {
            self.sns_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
        pub fn build(self) -> crate::model::LabelingJobDataSource {
            crate::model::LabelingJobDataSource {
                s3_data_source: self.s3_data_source,
                sns_data_source: self.sns_data_source,
            }
        }
    }
}
impl LabelingJobDataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobDataSource`](crate::model::LabelingJobDataSource)
    pub fn builder() -> crate::model::labeling_job_data_source::Builder {
        crate::model::labeling_job_data_source::Builder::default()
    }
}

/// <p>An Amazon SNS data source used for streaming labeling jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobSnsDataSource {
    /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic
    /// you will use to send new data objects to a streaming labeling job.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LabelingJobSnsDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobSnsDataSource");
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.finish()
    }
}
/// See [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
pub mod labeling_job_sns_data_source {
    /// A builder for [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon SNS input topic Amazon Resource Name (ARN). Specify the ARN of the input topic
        /// you will use to send new data objects to a streaming labeling job.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
        pub fn build(self) -> crate::model::LabelingJobSnsDataSource {
            crate::model::LabelingJobSnsDataSource {
                sns_topic_arn: self.sns_topic_arn,
            }
        }
    }
}
impl LabelingJobSnsDataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobSnsDataSource`](crate::model::LabelingJobSnsDataSource)
    pub fn builder() -> crate::model::labeling_job_sns_data_source::Builder {
        crate::model::labeling_job_sns_data_source::Builder::default()
    }
}

/// <p>The Amazon S3 location of the input data objects.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobS3DataSource {
    /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
    /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of
    /// the following keys: <code>source-ref</code> or <code>source</code>. The value of the
    /// keys are interpreted as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>source-ref</code>: The source of the object is the Amazon S3 object
    /// specified in the value. Use this value when the object is a binary object, such
    /// as an image.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>source</code>: The source of the object is the value. Use this
    /// value when the object is a text value.</p>
    /// </li>
    /// </ul>
    /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to
    /// create an input manifest file.</p>
    pub manifest_s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LabelingJobS3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobS3DataSource");
        formatter.field("manifest_s3_uri", &self.manifest_s3_uri);
        formatter.finish()
    }
}
/// See [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
pub mod labeling_job_s3_data_source {
    /// A builder for [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) manifest_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the manifest file that describes the input data objects. </p>
        /// <p>The input manifest file referenced in <code>ManifestS3Uri</code> must contain one of
        /// the following keys: <code>source-ref</code> or <code>source</code>. The value of the
        /// keys are interpreted as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>source-ref</code>: The source of the object is the Amazon S3 object
        /// specified in the value. Use this value when the object is a binary object, such
        /// as an image.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>source</code>: The source of the object is the value. Use this
        /// value when the object is a text value.</p>
        /// </li>
        /// </ul>
        /// <p>If you are a new user of Ground Truth, it is recommended you review <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-input-data-input-manifest.html">Use an Input Manifest File </a> in the Amazon SageMaker Developer Guide to learn how to
        /// create an input manifest file.</p>
        pub fn manifest_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.manifest_s3_uri = Some(input.into());
            self
        }
        pub fn set_manifest_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.manifest_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
        pub fn build(self) -> crate::model::LabelingJobS3DataSource {
            crate::model::LabelingJobS3DataSource {
                manifest_s3_uri: self.manifest_s3_uri,
            }
        }
    }
}
impl LabelingJobS3DataSource {
    /// Creates a new builder-style object to manufacture [`LabelingJobS3DataSource`](crate::model::LabelingJobS3DataSource)
    pub fn builder() -> crate::model::labeling_job_s3_data_source::Builder {
        crate::model::labeling_job_s3_data_source::Builder::default()
    }
}

/// <p>Specifies the location of the output produced by the labeling job. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobOutput {
    /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
    pub output_dataset_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the most recent Amazon SageMaker model trained as part of
    /// automated data labeling. </p>
    pub final_active_learning_model_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LabelingJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobOutput");
        formatter.field("output_dataset_s3_uri", &self.output_dataset_s3_uri);
        formatter.field(
            "final_active_learning_model_arn",
            &self.final_active_learning_model_arn,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobOutput`](crate::model::LabelingJobOutput)
pub mod labeling_job_output {
    /// A builder for [`LabelingJobOutput`](crate::model::LabelingJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_dataset_s3_uri: std::option::Option<std::string::String>,
        pub(crate) final_active_learning_model_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket location of the manifest file for labeled data. </p>
        pub fn output_dataset_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_dataset_s3_uri = Some(input.into());
            self
        }
        pub fn set_output_dataset_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_dataset_s3_uri = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the most recent Amazon SageMaker model trained as part of
        /// automated data labeling. </p>
        pub fn final_active_learning_model_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.final_active_learning_model_arn = Some(input.into());
            self
        }
        pub fn set_final_active_learning_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.final_active_learning_model_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobOutput`](crate::model::LabelingJobOutput)
        pub fn build(self) -> crate::model::LabelingJobOutput {
            crate::model::LabelingJobOutput {
                output_dataset_s3_uri: self.output_dataset_s3_uri,
                final_active_learning_model_arn: self.final_active_learning_model_arn,
            }
        }
    }
}
impl LabelingJobOutput {
    /// Creates a new builder-style object to manufacture [`LabelingJobOutput`](crate::model::LabelingJobOutput)
    pub fn builder() -> crate::model::labeling_job_output::Builder {
        crate::model::labeling_job_output::Builder::default()
    }
}

/// <p>Provides a breakdown of the number of objects labeled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelCounters {
    /// <p>The total number of objects labeled.</p>
    pub total_labeled: i32,
    /// <p>The total number of objects labeled by a human worker.</p>
    pub human_labeled: i32,
    /// <p>The total number of objects labeled by automated data labeling.</p>
    pub machine_labeled: i32,
    /// <p>The total number of objects that could not be labeled due to an error.</p>
    pub failed_non_retryable_error: i32,
    /// <p>The total number of objects not yet labeled.</p>
    pub unlabeled: i32,
}
impl std::fmt::Debug for LabelCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelCounters");
        formatter.field("total_labeled", &self.total_labeled);
        formatter.field("human_labeled", &self.human_labeled);
        formatter.field("machine_labeled", &self.machine_labeled);
        formatter.field(
            "failed_non_retryable_error",
            &self.failed_non_retryable_error,
        );
        formatter.field("unlabeled", &self.unlabeled);
        formatter.finish()
    }
}
/// See [`LabelCounters`](crate::model::LabelCounters)
pub mod label_counters {
    /// A builder for [`LabelCounters`](crate::model::LabelCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_labeled: std::option::Option<i32>,
        pub(crate) human_labeled: std::option::Option<i32>,
        pub(crate) machine_labeled: std::option::Option<i32>,
        pub(crate) failed_non_retryable_error: std::option::Option<i32>,
        pub(crate) unlabeled: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of objects labeled.</p>
        pub fn total_labeled(mut self, input: i32) -> Self {
            self.total_labeled = Some(input);
            self
        }
        pub fn set_total_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.total_labeled = input;
            self
        }
        /// <p>The total number of objects labeled by a human worker.</p>
        pub fn human_labeled(mut self, input: i32) -> Self {
            self.human_labeled = Some(input);
            self
        }
        pub fn set_human_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.human_labeled = input;
            self
        }
        /// <p>The total number of objects labeled by automated data labeling.</p>
        pub fn machine_labeled(mut self, input: i32) -> Self {
            self.machine_labeled = Some(input);
            self
        }
        pub fn set_machine_labeled(mut self, input: std::option::Option<i32>) -> Self {
            self.machine_labeled = input;
            self
        }
        /// <p>The total number of objects that could not be labeled due to an error.</p>
        pub fn failed_non_retryable_error(mut self, input: i32) -> Self {
            self.failed_non_retryable_error = Some(input);
            self
        }
        pub fn set_failed_non_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_non_retryable_error = input;
            self
        }
        /// <p>The total number of objects not yet labeled.</p>
        pub fn unlabeled(mut self, input: i32) -> Self {
            self.unlabeled = Some(input);
            self
        }
        pub fn set_unlabeled(mut self, input: std::option::Option<i32>) -> Self {
            self.unlabeled = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelCounters`](crate::model::LabelCounters)
        pub fn build(self) -> crate::model::LabelCounters {
            crate::model::LabelCounters {
                total_labeled: self.total_labeled.unwrap_or_default(),
                human_labeled: self.human_labeled.unwrap_or_default(),
                machine_labeled: self.machine_labeled.unwrap_or_default(),
                failed_non_retryable_error: self.failed_non_retryable_error.unwrap_or_default(),
                unlabeled: self.unlabeled.unwrap_or_default(),
            }
        }
    }
}
impl LabelCounters {
    /// Creates a new builder-style object to manufacture [`LabelCounters`](crate::model::LabelCounters)
    pub fn builder() -> crate::model::label_counters::Builder {
        crate::model::label_counters::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LabelingJobStatus {
    Completed,
    Failed,
    InProgress,
    Initializing,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LabelingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => LabelingJobStatus::Completed,
            "Failed" => LabelingJobStatus::Failed,
            "InProgress" => LabelingJobStatus::InProgress,
            "Initializing" => LabelingJobStatus::Initializing,
            "Stopped" => LabelingJobStatus::Stopped,
            "Stopping" => LabelingJobStatus::Stopping,
            other => LabelingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LabelingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LabelingJobStatus::from(s))
    }
}
impl LabelingJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            LabelingJobStatus::Completed => "Completed",
            LabelingJobStatus::Failed => "Failed",
            LabelingJobStatus::InProgress => "InProgress",
            LabelingJobStatus::Initializing => "Initializing",
            LabelingJobStatus::Stopped => "Stopped",
            LabelingJobStatus::Stopping => "Stopping",
            LabelingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Completed",
            "Failed",
            "InProgress",
            "Initializing",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for LabelingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A version of a SageMaker <code>Image</code>. A version represents an existing container
/// image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageVersion {
    /// <p>When the version was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When a create or delete operation fails, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the version.</p>
    pub image_version_arn: std::option::Option<std::string::String>,
    /// <p>The status of the version.</p>
    pub image_version_status: std::option::Option<crate::model::ImageVersionStatus>,
    /// <p>When the version was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The version number.</p>
    pub version: std::option::Option<i32>,
}
impl std::fmt::Debug for ImageVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageVersion");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_version_arn", &self.image_version_arn);
        formatter.field("image_version_status", &self.image_version_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ImageVersion`](crate::model::ImageVersion)
pub mod image_version {
    /// A builder for [`ImageVersion`](crate::model::ImageVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) image_arn: std::option::Option<std::string::String>,
        pub(crate) image_version_arn: std::option::Option<std::string::String>,
        pub(crate) image_version_status: std::option::Option<crate::model::ImageVersionStatus>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When the version was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When a create or delete operation fails, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image the version is based on.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_arn = Some(input.into());
            self
        }
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_arn = input;
            self
        }
        /// <p>The ARN of the version.</p>
        pub fn image_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_version_arn = Some(input.into());
            self
        }
        pub fn set_image_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_version_arn = input;
            self
        }
        /// <p>The status of the version.</p>
        pub fn image_version_status(mut self, input: crate::model::ImageVersionStatus) -> Self {
            self.image_version_status = Some(input);
            self
        }
        pub fn set_image_version_status(
            mut self,
            input: std::option::Option<crate::model::ImageVersionStatus>,
        ) -> Self {
            self.image_version_status = input;
            self
        }
        /// <p>When the version was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The version number.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageVersion`](crate::model::ImageVersion)
        pub fn build(self) -> crate::model::ImageVersion {
            crate::model::ImageVersion {
                creation_time: self.creation_time,
                failure_reason: self.failure_reason,
                image_arn: self.image_arn,
                image_version_arn: self.image_version_arn,
                image_version_status: self.image_version_status,
                last_modified_time: self.last_modified_time,
                version: self.version,
            }
        }
    }
}
impl ImageVersion {
    /// Creates a new builder-style object to manufacture [`ImageVersion`](crate::model::ImageVersion)
    pub fn builder() -> crate::model::image_version::Builder {
        crate::model::image_version::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionStatus {
    Created,
    CreateFailed,
    Creating,
    DeleteFailed,
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ImageVersionStatus::Created,
            "CREATE_FAILED" => ImageVersionStatus::CreateFailed,
            "CREATING" => ImageVersionStatus::Creating,
            "DELETE_FAILED" => ImageVersionStatus::DeleteFailed,
            "DELETING" => ImageVersionStatus::Deleting,
            other => ImageVersionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionStatus::from(s))
    }
}
impl ImageVersionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionStatus::Created => "CREATED",
            ImageVersionStatus::CreateFailed => "CREATE_FAILED",
            ImageVersionStatus::Creating => "CREATING",
            ImageVersionStatus::DeleteFailed => "DELETE_FAILED",
            ImageVersionStatus::Deleting => "DELETING",
            ImageVersionStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
        ]
    }
}
impl AsRef<str> for ImageVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => ImageVersionSortOrder::Ascending,
            "DESCENDING" => ImageVersionSortOrder::Descending,
            other => ImageVersionSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionSortOrder::from(s))
    }
}
impl ImageVersionSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionSortOrder::Ascending => "ASCENDING",
            ImageVersionSortOrder::Descending => "DESCENDING",
            ImageVersionSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for ImageVersionSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageVersionSortBy {
    CreationTime,
    LastModifiedTime,
    Version,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageVersionSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ImageVersionSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ImageVersionSortBy::LastModifiedTime,
            "VERSION" => ImageVersionSortBy::Version,
            other => ImageVersionSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageVersionSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageVersionSortBy::from(s))
    }
}
impl ImageVersionSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ImageVersionSortBy::CreationTime => "CREATION_TIME",
            ImageVersionSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ImageVersionSortBy::Version => "VERSION",
            ImageVersionSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "LAST_MODIFIED_TIME", "VERSION"]
    }
}
impl AsRef<str> for ImageVersionSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A SageMaker image. A SageMaker image represents a set of container images that are derived from
/// a common base container image. Each of these container images is represented by a SageMaker
/// <code>ImageVersion</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Image {
    /// <p>When the image was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The description of the image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the image as displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    pub image_arn: std::option::Option<std::string::String>,
    /// <p>The name of the image.</p>
    pub image_name: std::option::Option<std::string::String>,
    /// <p>The status of the image.</p>
    pub image_status: std::option::Option<crate::model::ImageStatus>,
    /// <p>When the image was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Image");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("display_name", &self.display_name);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("image_arn", &self.image_arn);
        formatter.field("image_name", &self.image_name);
        formatter.field("image_status", &self.image_status);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`Image`](crate::model::Image)
pub mod image {
    /// A builder for [`Image`](crate::model::Image)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) image_arn: std::option::Option<std::string::String>,
        pub(crate) image_name: std::option::Option<std::string::String>,
        pub(crate) image_status: std::option::Option<crate::model::ImageStatus>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>When the image was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the image as displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>When a create, update, or delete operation fails, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_arn = Some(input.into());
            self
        }
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_arn = input;
            self
        }
        /// <p>The name of the image.</p>
        pub fn image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_name = Some(input.into());
            self
        }
        pub fn set_image_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_name = input;
            self
        }
        /// <p>The status of the image.</p>
        pub fn image_status(mut self, input: crate::model::ImageStatus) -> Self {
            self.image_status = Some(input);
            self
        }
        pub fn set_image_status(
            mut self,
            input: std::option::Option<crate::model::ImageStatus>,
        ) -> Self {
            self.image_status = input;
            self
        }
        /// <p>When the image was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Image`](crate::model::Image)
        pub fn build(self) -> crate::model::Image {
            crate::model::Image {
                creation_time: self.creation_time,
                description: self.description,
                display_name: self.display_name,
                failure_reason: self.failure_reason,
                image_arn: self.image_arn,
                image_name: self.image_name,
                image_status: self.image_status,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::model::Image)
    pub fn builder() -> crate::model::image::Builder {
        crate::model::image::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageStatus {
    Created,
    CreateFailed,
    Creating,
    DeleteFailed,
    Deleting,
    UpdateFailed,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ImageStatus::Created,
            "CREATE_FAILED" => ImageStatus::CreateFailed,
            "CREATING" => ImageStatus::Creating,
            "DELETE_FAILED" => ImageStatus::DeleteFailed,
            "DELETING" => ImageStatus::Deleting,
            "UPDATE_FAILED" => ImageStatus::UpdateFailed,
            "UPDATING" => ImageStatus::Updating,
            other => ImageStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageStatus::from(s))
    }
}
impl ImageStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ImageStatus::Created => "CREATED",
            ImageStatus::CreateFailed => "CREATE_FAILED",
            ImageStatus::Creating => "CREATING",
            ImageStatus::DeleteFailed => "DELETE_FAILED",
            ImageStatus::Deleting => "DELETING",
            ImageStatus::UpdateFailed => "UPDATE_FAILED",
            ImageStatus::Updating => "UPDATING",
            ImageStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
            "UPDATE_FAILED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ImageStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => ImageSortOrder::Ascending,
            "DESCENDING" => ImageSortOrder::Descending,
            other => ImageSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageSortOrder::from(s))
    }
}
impl ImageSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            ImageSortOrder::Ascending => "ASCENDING",
            ImageSortOrder::Descending => "DESCENDING",
            ImageSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for ImageSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageSortBy {
    CreationTime,
    ImageName,
    LastModifiedTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ImageSortBy::CreationTime,
            "IMAGE_NAME" => ImageSortBy::ImageName,
            "LAST_MODIFIED_TIME" => ImageSortBy::LastModifiedTime,
            other => ImageSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageSortBy::from(s))
    }
}
impl ImageSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ImageSortBy::CreationTime => "CREATION_TIME",
            ImageSortBy::ImageName => "IMAGE_NAME",
            ImageSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ImageSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "IMAGE_NAME", "LAST_MODIFIED_TIME"]
    }
}
impl AsRef<str> for ImageSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobSummary {
    /// <p>The name of the tuning job.</p>
    pub hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
    /// <p>The
    /// Amazon
    /// Resource Name (ARN) of the tuning job.</p>
    pub hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the
    /// tuning
    /// job.</p>
    pub hyper_parameter_tuning_job_status:
        std::option::Option<crate::model::HyperParameterTuningJobStatus>,
    /// <p>Specifies the search strategy hyperparameter tuning uses to choose which
    /// hyperparameters to
    /// use
    /// for each iteration. Currently, the only valid value is
    /// Bayesian.</p>
    pub strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
    /// <p>The date and time that the tuning job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the tuning job ended.</p>
    pub hyper_parameter_tuning_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the tuning job was
    /// modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The <a>TrainingJobStatusCounters</a> object that specifies the numbers of
    /// training jobs, categorized by status, that this tuning job launched.</p>
    pub training_job_status_counters: std::option::Option<crate::model::TrainingJobStatusCounters>,
    /// <p>The <a>ObjectiveStatusCounters</a> object that specifies the numbers of
    /// training jobs, categorized by objective metric status, that this tuning job
    /// launched.</p>
    pub objective_status_counters: std::option::Option<crate::model::ObjectiveStatusCounters>,
    /// <p>The <a>ResourceLimits</a> object that specifies the maximum number of
    /// training jobs and parallel training jobs allowed for this tuning job.</p>
    pub resource_limits: std::option::Option<crate::model::ResourceLimits>,
}
impl std::fmt::Debug for HyperParameterTuningJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobSummary");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.field(
            "hyper_parameter_tuning_job_arn",
            &self.hyper_parameter_tuning_job_arn,
        );
        formatter.field(
            "hyper_parameter_tuning_job_status",
            &self.hyper_parameter_tuning_job_status,
        );
        formatter.field("strategy", &self.strategy);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "hyper_parameter_tuning_end_time",
            &self.hyper_parameter_tuning_end_time,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "training_job_status_counters",
            &self.training_job_status_counters,
        );
        formatter.field("objective_status_counters", &self.objective_status_counters);
        formatter.field("resource_limits", &self.resource_limits);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
pub mod hyper_parameter_tuning_job_summary {
    /// A builder for [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
        pub(crate) hyper_parameter_tuning_job_arn: std::option::Option<std::string::String>,
        pub(crate) hyper_parameter_tuning_job_status:
            std::option::Option<crate::model::HyperParameterTuningJobStatus>,
        pub(crate) strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) hyper_parameter_tuning_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) training_job_status_counters:
            std::option::Option<crate::model::TrainingJobStatusCounters>,
        pub(crate) objective_status_counters:
            std::option::Option<crate::model::ObjectiveStatusCounters>,
        pub(crate) resource_limits: std::option::Option<crate::model::ResourceLimits>,
    }
    impl Builder {
        /// <p>The name of the tuning job.</p>
        pub fn hyper_parameter_tuning_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = Some(input.into());
            self
        }
        pub fn set_hyper_parameter_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = input;
            self
        }
        /// <p>The
        /// Amazon
        /// Resource Name (ARN) of the tuning job.</p>
        pub fn hyper_parameter_tuning_job_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_arn = Some(input.into());
            self
        }
        pub fn set_hyper_parameter_tuning_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_arn = input;
            self
        }
        /// <p>The status of the
        /// tuning
        /// job.</p>
        pub fn hyper_parameter_tuning_job_status(
            mut self,
            input: crate::model::HyperParameterTuningJobStatus,
        ) -> Self {
            self.hyper_parameter_tuning_job_status = Some(input);
            self
        }
        pub fn set_hyper_parameter_tuning_job_status(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStatus>,
        ) -> Self {
            self.hyper_parameter_tuning_job_status = input;
            self
        }
        /// <p>Specifies the search strategy hyperparameter tuning uses to choose which
        /// hyperparameters to
        /// use
        /// for each iteration. Currently, the only valid value is
        /// Bayesian.</p>
        pub fn strategy(
            mut self,
            input: crate::model::HyperParameterTuningJobStrategyType,
        ) -> Self {
            self.strategy = Some(input);
            self
        }
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        ) -> Self {
            self.strategy = input;
            self
        }
        /// <p>The date and time that the tuning job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the tuning job ended.</p>
        pub fn hyper_parameter_tuning_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.hyper_parameter_tuning_end_time = Some(input);
            self
        }
        pub fn set_hyper_parameter_tuning_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.hyper_parameter_tuning_end_time = input;
            self
        }
        /// <p>The date and time that the tuning job was
        /// modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The <a>TrainingJobStatusCounters</a> object that specifies the numbers of
        /// training jobs, categorized by status, that this tuning job launched.</p>
        pub fn training_job_status_counters(
            mut self,
            input: crate::model::TrainingJobStatusCounters,
        ) -> Self {
            self.training_job_status_counters = Some(input);
            self
        }
        pub fn set_training_job_status_counters(
            mut self,
            input: std::option::Option<crate::model::TrainingJobStatusCounters>,
        ) -> Self {
            self.training_job_status_counters = input;
            self
        }
        /// <p>The <a>ObjectiveStatusCounters</a> object that specifies the numbers of
        /// training jobs, categorized by objective metric status, that this tuning job
        /// launched.</p>
        pub fn objective_status_counters(
            mut self,
            input: crate::model::ObjectiveStatusCounters,
        ) -> Self {
            self.objective_status_counters = Some(input);
            self
        }
        pub fn set_objective_status_counters(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatusCounters>,
        ) -> Self {
            self.objective_status_counters = input;
            self
        }
        /// <p>The <a>ResourceLimits</a> object that specifies the maximum number of
        /// training jobs and parallel training jobs allowed for this tuning job.</p>
        pub fn resource_limits(mut self, input: crate::model::ResourceLimits) -> Self {
            self.resource_limits = Some(input);
            self
        }
        pub fn set_resource_limits(
            mut self,
            input: std::option::Option<crate::model::ResourceLimits>,
        ) -> Self {
            self.resource_limits = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
        pub fn build(self) -> crate::model::HyperParameterTuningJobSummary {
            crate::model::HyperParameterTuningJobSummary {
                hyper_parameter_tuning_job_name: self.hyper_parameter_tuning_job_name,
                hyper_parameter_tuning_job_arn: self.hyper_parameter_tuning_job_arn,
                hyper_parameter_tuning_job_status: self.hyper_parameter_tuning_job_status,
                strategy: self.strategy,
                creation_time: self.creation_time,
                hyper_parameter_tuning_end_time: self.hyper_parameter_tuning_end_time,
                last_modified_time: self.last_modified_time,
                training_job_status_counters: self.training_job_status_counters,
                objective_status_counters: self.objective_status_counters,
                resource_limits: self.resource_limits,
            }
        }
    }
}
impl HyperParameterTuningJobSummary {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobSummary`](crate::model::HyperParameterTuningJobSummary)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_summary::Builder {
        crate::model::hyper_parameter_tuning_job_summary::Builder::default()
    }
}

/// <p>Specifies the maximum number of
/// training
/// jobs and parallel training jobs that a hyperparameter tuning job can
/// launch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimits {
    /// <p>The
    /// maximum
    /// number of training jobs that a hyperparameter tuning job can
    /// launch.</p>
    pub max_number_of_training_jobs: i32,
    /// <p>The
    /// maximum
    /// number of concurrent training jobs that a hyperparameter tuning job can
    /// launch.</p>
    pub max_parallel_training_jobs: i32,
}
impl std::fmt::Debug for ResourceLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimits");
        formatter.field(
            "max_number_of_training_jobs",
            &self.max_number_of_training_jobs,
        );
        formatter.field(
            "max_parallel_training_jobs",
            &self.max_parallel_training_jobs,
        );
        formatter.finish()
    }
}
/// See [`ResourceLimits`](crate::model::ResourceLimits)
pub mod resource_limits {
    /// A builder for [`ResourceLimits`](crate::model::ResourceLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_number_of_training_jobs: std::option::Option<i32>,
        pub(crate) max_parallel_training_jobs: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The
        /// maximum
        /// number of training jobs that a hyperparameter tuning job can
        /// launch.</p>
        pub fn max_number_of_training_jobs(mut self, input: i32) -> Self {
            self.max_number_of_training_jobs = Some(input);
            self
        }
        pub fn set_max_number_of_training_jobs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_number_of_training_jobs = input;
            self
        }
        /// <p>The
        /// maximum
        /// number of concurrent training jobs that a hyperparameter tuning job can
        /// launch.</p>
        pub fn max_parallel_training_jobs(mut self, input: i32) -> Self {
            self.max_parallel_training_jobs = Some(input);
            self
        }
        pub fn set_max_parallel_training_jobs(mut self, input: std::option::Option<i32>) -> Self {
            self.max_parallel_training_jobs = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimits`](crate::model::ResourceLimits)
        pub fn build(self) -> crate::model::ResourceLimits {
            crate::model::ResourceLimits {
                max_number_of_training_jobs: self.max_number_of_training_jobs.unwrap_or_default(),
                max_parallel_training_jobs: self.max_parallel_training_jobs.unwrap_or_default(),
            }
        }
    }
}
impl ResourceLimits {
    /// Creates a new builder-style object to manufacture [`ResourceLimits`](crate::model::ResourceLimits)
    pub fn builder() -> crate::model::resource_limits::Builder {
        crate::model::resource_limits::Builder::default()
    }
}

/// <p>Specifies the number of training jobs that this hyperparameter tuning job launched,
/// categorized by the status of their objective metric. The objective metric status shows
/// whether the
/// final
/// objective metric for the training job has been evaluated by the
/// tuning job and used in the hyperparameter tuning process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ObjectiveStatusCounters {
    /// <p>The number of training jobs whose final objective metric was evaluated by the
    /// hyperparameter tuning job and used in the hyperparameter tuning process.</p>
    pub succeeded: i32,
    /// <p>The number of training jobs that are in progress and pending evaluation of their final
    /// objective metric.</p>
    pub pending: i32,
    /// <p>The number of training jobs whose final objective metric was not evaluated and used in
    /// the hyperparameter tuning process. This typically occurs when the training job failed or
    /// did not emit an objective metric.</p>
    pub failed: i32,
}
impl std::fmt::Debug for ObjectiveStatusCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ObjectiveStatusCounters");
        formatter.field("succeeded", &self.succeeded);
        formatter.field("pending", &self.pending);
        formatter.field("failed", &self.failed);
        formatter.finish()
    }
}
/// See [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
pub mod objective_status_counters {
    /// A builder for [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) succeeded: std::option::Option<i32>,
        pub(crate) pending: std::option::Option<i32>,
        pub(crate) failed: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of training jobs whose final objective metric was evaluated by the
        /// hyperparameter tuning job and used in the hyperparameter tuning process.</p>
        pub fn succeeded(mut self, input: i32) -> Self {
            self.succeeded = Some(input);
            self
        }
        pub fn set_succeeded(mut self, input: std::option::Option<i32>) -> Self {
            self.succeeded = input;
            self
        }
        /// <p>The number of training jobs that are in progress and pending evaluation of their final
        /// objective metric.</p>
        pub fn pending(mut self, input: i32) -> Self {
            self.pending = Some(input);
            self
        }
        pub fn set_pending(mut self, input: std::option::Option<i32>) -> Self {
            self.pending = input;
            self
        }
        /// <p>The number of training jobs whose final objective metric was not evaluated and used in
        /// the hyperparameter tuning process. This typically occurs when the training job failed or
        /// did not emit an objective metric.</p>
        pub fn failed(mut self, input: i32) -> Self {
            self.failed = Some(input);
            self
        }
        pub fn set_failed(mut self, input: std::option::Option<i32>) -> Self {
            self.failed = input;
            self
        }
        /// Consumes the builder and constructs a [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
        pub fn build(self) -> crate::model::ObjectiveStatusCounters {
            crate::model::ObjectiveStatusCounters {
                succeeded: self.succeeded.unwrap_or_default(),
                pending: self.pending.unwrap_or_default(),
                failed: self.failed.unwrap_or_default(),
            }
        }
    }
}
impl ObjectiveStatusCounters {
    /// Creates a new builder-style object to manufacture [`ObjectiveStatusCounters`](crate::model::ObjectiveStatusCounters)
    pub fn builder() -> crate::model::objective_status_counters::Builder {
        crate::model::objective_status_counters::Builder::default()
    }
}

/// <p>The numbers of training jobs launched by a hyperparameter tuning job, categorized by
/// status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobStatusCounters {
    /// <p>The number of completed training jobs launched by the hyperparameter tuning
    /// job.</p>
    pub completed: i32,
    /// <p>The number of in-progress training jobs launched by a hyperparameter tuning
    /// job.</p>
    pub in_progress: i32,
    /// <p>The number of training jobs that failed, but can be retried. A failed training job can
    /// be retried only if it failed because an internal service error occurred.</p>
    pub retryable_error: i32,
    /// <p>The number of training jobs that failed and can't be retried. A failed training job
    /// can't be retried if it failed because a client error occurred.</p>
    pub non_retryable_error: i32,
    /// <p>The number of training jobs launched by a hyperparameter tuning job that were
    /// manually
    /// stopped.</p>
    pub stopped: i32,
}
impl std::fmt::Debug for TrainingJobStatusCounters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobStatusCounters");
        formatter.field("completed", &self.completed);
        formatter.field("in_progress", &self.in_progress);
        formatter.field("retryable_error", &self.retryable_error);
        formatter.field("non_retryable_error", &self.non_retryable_error);
        formatter.field("stopped", &self.stopped);
        formatter.finish()
    }
}
/// See [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
pub mod training_job_status_counters {
    /// A builder for [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) completed: std::option::Option<i32>,
        pub(crate) in_progress: std::option::Option<i32>,
        pub(crate) retryable_error: std::option::Option<i32>,
        pub(crate) non_retryable_error: std::option::Option<i32>,
        pub(crate) stopped: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of completed training jobs launched by the hyperparameter tuning
        /// job.</p>
        pub fn completed(mut self, input: i32) -> Self {
            self.completed = Some(input);
            self
        }
        pub fn set_completed(mut self, input: std::option::Option<i32>) -> Self {
            self.completed = input;
            self
        }
        /// <p>The number of in-progress training jobs launched by a hyperparameter tuning
        /// job.</p>
        pub fn in_progress(mut self, input: i32) -> Self {
            self.in_progress = Some(input);
            self
        }
        pub fn set_in_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.in_progress = input;
            self
        }
        /// <p>The number of training jobs that failed, but can be retried. A failed training job can
        /// be retried only if it failed because an internal service error occurred.</p>
        pub fn retryable_error(mut self, input: i32) -> Self {
            self.retryable_error = Some(input);
            self
        }
        pub fn set_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.retryable_error = input;
            self
        }
        /// <p>The number of training jobs that failed and can't be retried. A failed training job
        /// can't be retried if it failed because a client error occurred.</p>
        pub fn non_retryable_error(mut self, input: i32) -> Self {
            self.non_retryable_error = Some(input);
            self
        }
        pub fn set_non_retryable_error(mut self, input: std::option::Option<i32>) -> Self {
            self.non_retryable_error = input;
            self
        }
        /// <p>The number of training jobs launched by a hyperparameter tuning job that were
        /// manually
        /// stopped.</p>
        pub fn stopped(mut self, input: i32) -> Self {
            self.stopped = Some(input);
            self
        }
        pub fn set_stopped(mut self, input: std::option::Option<i32>) -> Self {
            self.stopped = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
        pub fn build(self) -> crate::model::TrainingJobStatusCounters {
            crate::model::TrainingJobStatusCounters {
                completed: self.completed.unwrap_or_default(),
                in_progress: self.in_progress.unwrap_or_default(),
                retryable_error: self.retryable_error.unwrap_or_default(),
                non_retryable_error: self.non_retryable_error.unwrap_or_default(),
                stopped: self.stopped.unwrap_or_default(),
            }
        }
    }
}
impl TrainingJobStatusCounters {
    /// Creates a new builder-style object to manufacture [`TrainingJobStatusCounters`](crate::model::TrainingJobStatusCounters)
    pub fn builder() -> crate::model::training_job_status_counters::Builder {
        crate::model::training_job_status_counters::Builder::default()
    }
}

/// <p>The strategy hyperparameter tuning uses to
/// find
/// the best combination of hyperparameters for your model. Currently,
/// the only
/// supported
/// value is <code>Bayesian</code>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobStrategyType {
    Bayesian,
    Random,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobStrategyType {
    fn from(s: &str) -> Self {
        match s {
            "Bayesian" => HyperParameterTuningJobStrategyType::Bayesian,
            "Random" => HyperParameterTuningJobStrategyType::Random,
            other => HyperParameterTuningJobStrategyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobStrategyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobStrategyType::from(s))
    }
}
impl HyperParameterTuningJobStrategyType {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobStrategyType::Bayesian => "Bayesian",
            HyperParameterTuningJobStrategyType::Random => "Random",
            HyperParameterTuningJobStrategyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Bayesian", "Random"]
    }
}
impl AsRef<str> for HyperParameterTuningJobStrategyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => HyperParameterTuningJobStatus::Completed,
            "Failed" => HyperParameterTuningJobStatus::Failed,
            "InProgress" => HyperParameterTuningJobStatus::InProgress,
            "Stopped" => HyperParameterTuningJobStatus::Stopped,
            "Stopping" => HyperParameterTuningJobStatus::Stopping,
            other => HyperParameterTuningJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobStatus::from(s))
    }
}
impl HyperParameterTuningJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobStatus::Completed => "Completed",
            HyperParameterTuningJobStatus::Failed => "Failed",
            HyperParameterTuningJobStatus::InProgress => "InProgress",
            HyperParameterTuningJobStatus::Stopped => "Stopped",
            HyperParameterTuningJobStatus::Stopping => "Stopping",
            HyperParameterTuningJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for HyperParameterTuningJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobSortByOptions {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobSortByOptions {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => HyperParameterTuningJobSortByOptions::CreationTime,
            "Name" => HyperParameterTuningJobSortByOptions::Name,
            "Status" => HyperParameterTuningJobSortByOptions::Status,
            other => HyperParameterTuningJobSortByOptions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobSortByOptions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobSortByOptions::from(s))
    }
}
impl HyperParameterTuningJobSortByOptions {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobSortByOptions::CreationTime => "CreationTime",
            HyperParameterTuningJobSortByOptions::Name => "Name",
            HyperParameterTuningJobSortByOptions::Status => "Status",
            HyperParameterTuningJobSortByOptions::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for HyperParameterTuningJobSortByOptions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for human task user interface information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanTaskUiSummary {
    /// <p>The name of the human task user interface.</p>
    pub human_task_ui_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp when SageMaker created the human task user interface.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for HumanTaskUiSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanTaskUiSummary");
        formatter.field("human_task_ui_name", &self.human_task_ui_name);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
pub mod human_task_ui_summary {
    /// A builder for [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_task_ui_name: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the human task user interface.</p>
        pub fn human_task_ui_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_name = Some(input.into());
            self
        }
        pub fn set_human_task_ui_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// <p>A timestamp when SageMaker created the human task user interface.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
        pub fn build(self) -> crate::model::HumanTaskUiSummary {
            crate::model::HumanTaskUiSummary {
                human_task_ui_name: self.human_task_ui_name,
                human_task_ui_arn: self.human_task_ui_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl HumanTaskUiSummary {
    /// Creates a new builder-style object to manufacture [`HumanTaskUiSummary`](crate::model::HumanTaskUiSummary)
    pub fn builder() -> crate::model::human_task_ui_summary::Builder {
        crate::model::human_task_ui_summary::Builder::default()
    }
}

/// <p>Contains summary information about the flow definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlowDefinitionSummary {
    /// <p>The name of the flow definition.</p>
    pub flow_definition_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
    pub flow_definition_arn: std::option::Option<std::string::String>,
    /// <p>The status of the flow definition. Valid values:</p>
    pub flow_definition_status: std::option::Option<crate::model::FlowDefinitionStatus>,
    /// <p>The timestamp when SageMaker created the flow definition.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FlowDefinitionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlowDefinitionSummary");
        formatter.field("flow_definition_name", &self.flow_definition_name);
        formatter.field("flow_definition_arn", &self.flow_definition_arn);
        formatter.field("flow_definition_status", &self.flow_definition_status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
pub mod flow_definition_summary {
    /// A builder for [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flow_definition_name: std::option::Option<std::string::String>,
        pub(crate) flow_definition_arn: std::option::Option<std::string::String>,
        pub(crate) flow_definition_status: std::option::Option<crate::model::FlowDefinitionStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the flow definition.</p>
        pub fn flow_definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_definition_name = Some(input.into());
            self
        }
        pub fn set_flow_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.flow_definition_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the flow definition.</p>
        pub fn flow_definition_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.flow_definition_arn = Some(input.into());
            self
        }
        pub fn set_flow_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.flow_definition_arn = input;
            self
        }
        /// <p>The status of the flow definition. Valid values:</p>
        pub fn flow_definition_status(mut self, input: crate::model::FlowDefinitionStatus) -> Self {
            self.flow_definition_status = Some(input);
            self
        }
        pub fn set_flow_definition_status(
            mut self,
            input: std::option::Option<crate::model::FlowDefinitionStatus>,
        ) -> Self {
            self.flow_definition_status = input;
            self
        }
        /// <p>The timestamp when SageMaker created the flow definition.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The reason why the flow definition creation failed. A failure reason is returned only when the flow definition status is <code>Failed</code>.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
        pub fn build(self) -> crate::model::FlowDefinitionSummary {
            crate::model::FlowDefinitionSummary {
                flow_definition_name: self.flow_definition_name,
                flow_definition_arn: self.flow_definition_arn,
                flow_definition_status: self.flow_definition_status,
                creation_time: self.creation_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl FlowDefinitionSummary {
    /// Creates a new builder-style object to manufacture [`FlowDefinitionSummary`](crate::model::FlowDefinitionSummary)
    pub fn builder() -> crate::model::flow_definition_summary::Builder {
        crate::model::flow_definition_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FlowDefinitionStatus {
    Active,
    Deleting,
    Failed,
    Initializing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FlowDefinitionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => FlowDefinitionStatus::Active,
            "Deleting" => FlowDefinitionStatus::Deleting,
            "Failed" => FlowDefinitionStatus::Failed,
            "Initializing" => FlowDefinitionStatus::Initializing,
            other => FlowDefinitionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FlowDefinitionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FlowDefinitionStatus::from(s))
    }
}
impl FlowDefinitionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            FlowDefinitionStatus::Active => "Active",
            FlowDefinitionStatus::Deleting => "Deleting",
            FlowDefinitionStatus::Failed => "Failed",
            FlowDefinitionStatus::Initializing => "Initializing",
            FlowDefinitionStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Active", "Deleting", "Failed", "Initializing"]
    }
}
impl AsRef<str> for FlowDefinitionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The name, Arn, <code>CreationTime</code>, <code>FeatureGroup</code> values,
/// <code>LastUpdatedTime</code> and <code>EnableOnlineStorage</code> status of a
/// <code>FeatureGroup</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FeatureGroupSummary {
    /// <p>The name of <code>FeatureGroup</code>.</p>
    pub feature_group_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
    pub feature_group_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of a FeatureGroup. The status can be any of the following:
    /// <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>,
    /// <code>Deleting</code> or <code>DetailFail</code>. </p>
    pub feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
    /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns
    /// either: <code>Active</code> or <code>Blocked</code>.</p>
    pub offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
}
impl std::fmt::Debug for FeatureGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FeatureGroupSummary");
        formatter.field("feature_group_name", &self.feature_group_name);
        formatter.field("feature_group_arn", &self.feature_group_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("feature_group_status", &self.feature_group_status);
        formatter.field("offline_store_status", &self.offline_store_status);
        formatter.finish()
    }
}
/// See [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
pub mod feature_group_summary {
    /// A builder for [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) feature_group_name: std::option::Option<std::string::String>,
        pub(crate) feature_group_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) feature_group_status: std::option::Option<crate::model::FeatureGroupStatus>,
        pub(crate) offline_store_status: std::option::Option<crate::model::OfflineStoreStatus>,
    }
    impl Builder {
        /// <p>The name of <code>FeatureGroup</code>.</p>
        pub fn feature_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_name = Some(input.into());
            self
        }
        pub fn set_feature_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_name = input;
            self
        }
        /// <p>Unique identifier for the <code>FeatureGroup</code>.</p>
        pub fn feature_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.feature_group_arn = Some(input.into());
            self
        }
        pub fn set_feature_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feature_group_arn = input;
            self
        }
        /// <p>A timestamp indicating the time of creation time of the <code>FeatureGroup</code>.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of a FeatureGroup. The status can be any of the following:
        /// <code>Creating</code>, <code>Created</code>, <code>CreateFail</code>,
        /// <code>Deleting</code> or <code>DetailFail</code>. </p>
        pub fn feature_group_status(mut self, input: crate::model::FeatureGroupStatus) -> Self {
            self.feature_group_status = Some(input);
            self
        }
        pub fn set_feature_group_status(
            mut self,
            input: std::option::Option<crate::model::FeatureGroupStatus>,
        ) -> Self {
            self.feature_group_status = input;
            self
        }
        /// <p>Notifies you if replicating data into the <code>OfflineStore</code> has failed. Returns
        /// either: <code>Active</code> or <code>Blocked</code>.</p>
        pub fn offline_store_status(mut self, input: crate::model::OfflineStoreStatus) -> Self {
            self.offline_store_status = Some(input);
            self
        }
        pub fn set_offline_store_status(
            mut self,
            input: std::option::Option<crate::model::OfflineStoreStatus>,
        ) -> Self {
            self.offline_store_status = input;
            self
        }
        /// Consumes the builder and constructs a [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
        pub fn build(self) -> crate::model::FeatureGroupSummary {
            crate::model::FeatureGroupSummary {
                feature_group_name: self.feature_group_name,
                feature_group_arn: self.feature_group_arn,
                creation_time: self.creation_time,
                feature_group_status: self.feature_group_status,
                offline_store_status: self.offline_store_status,
            }
        }
    }
}
impl FeatureGroupSummary {
    /// Creates a new builder-style object to manufacture [`FeatureGroupSummary`](crate::model::FeatureGroupSummary)
    pub fn builder() -> crate::model::feature_group_summary::Builder {
        crate::model::feature_group_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupSortBy {
    CreationTime,
    FeatureGroupStatus,
    Name,
    OfflineStoreStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => FeatureGroupSortBy::CreationTime,
            "FeatureGroupStatus" => FeatureGroupSortBy::FeatureGroupStatus,
            "Name" => FeatureGroupSortBy::Name,
            "OfflineStoreStatus" => FeatureGroupSortBy::OfflineStoreStatus,
            other => FeatureGroupSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupSortBy::from(s))
    }
}
impl FeatureGroupSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupSortBy::CreationTime => "CreationTime",
            FeatureGroupSortBy::FeatureGroupStatus => "FeatureGroupStatus",
            FeatureGroupSortBy::Name => "Name",
            FeatureGroupSortBy::OfflineStoreStatus => "OfflineStoreStatus",
            FeatureGroupSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "FeatureGroupStatus",
            "Name",
            "OfflineStoreStatus",
        ]
    }
}
impl AsRef<str> for FeatureGroupSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FeatureGroupSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FeatureGroupSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => FeatureGroupSortOrder::Ascending,
            "Descending" => FeatureGroupSortOrder::Descending,
            other => FeatureGroupSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FeatureGroupSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FeatureGroupSortOrder::from(s))
    }
}
impl FeatureGroupSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            FeatureGroupSortOrder::Ascending => "Ascending",
            FeatureGroupSortOrder::Descending => "Descending",
            FeatureGroupSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for FeatureGroupSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of the properties of an experiment. To get the complete set of properties, call
/// the <a>DescribeExperiment</a> API and provide the
/// <code>ExperimentName</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExperimentSummary {
    /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
    pub experiment_arn: std::option::Option<std::string::String>,
    /// <p>The name of the experiment.</p>
    pub experiment_name: std::option::Option<std::string::String>,
    /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified,
    /// <code>ExperimentName</code> is displayed.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The source of the experiment.</p>
    pub experiment_source: std::option::Option<crate::model::ExperimentSource>,
    /// <p>When the experiment was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the experiment was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ExperimentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExperimentSummary");
        formatter.field("experiment_arn", &self.experiment_arn);
        formatter.field("experiment_name", &self.experiment_name);
        formatter.field("display_name", &self.display_name);
        formatter.field("experiment_source", &self.experiment_source);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ExperimentSummary`](crate::model::ExperimentSummary)
pub mod experiment_summary {
    /// A builder for [`ExperimentSummary`](crate::model::ExperimentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) experiment_arn: std::option::Option<std::string::String>,
        pub(crate) experiment_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) experiment_source: std::option::Option<crate::model::ExperimentSource>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the experiment.</p>
        pub fn experiment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_arn = Some(input.into());
            self
        }
        pub fn set_experiment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_arn = input;
            self
        }
        /// <p>The name of the experiment.</p>
        pub fn experiment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.experiment_name = Some(input.into());
            self
        }
        pub fn set_experiment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.experiment_name = input;
            self
        }
        /// <p>The name of the experiment as displayed. If <code>DisplayName</code> isn't specified,
        /// <code>ExperimentName</code> is displayed.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The source of the experiment.</p>
        pub fn experiment_source(mut self, input: crate::model::ExperimentSource) -> Self {
            self.experiment_source = Some(input);
            self
        }
        pub fn set_experiment_source(
            mut self,
            input: std::option::Option<crate::model::ExperimentSource>,
        ) -> Self {
            self.experiment_source = input;
            self
        }
        /// <p>When the experiment was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the experiment was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExperimentSummary`](crate::model::ExperimentSummary)
        pub fn build(self) -> crate::model::ExperimentSummary {
            crate::model::ExperimentSummary {
                experiment_arn: self.experiment_arn,
                experiment_name: self.experiment_name,
                display_name: self.display_name,
                experiment_source: self.experiment_source,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ExperimentSummary {
    /// Creates a new builder-style object to manufacture [`ExperimentSummary`](crate::model::ExperimentSummary)
    pub fn builder() -> crate::model::experiment_summary::Builder {
        crate::model::experiment_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortExperimentsBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortExperimentsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortExperimentsBy::CreationTime,
            "Name" => SortExperimentsBy::Name,
            other => SortExperimentsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortExperimentsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortExperimentsBy::from(s))
    }
}
impl SortExperimentsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortExperimentsBy::CreationTime => "CreationTime",
            SortExperimentsBy::Name => "Name",
            SortExperimentsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortExperimentsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointSummary {
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp that shows when the endpoint was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the endpoint.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>OutOfService</code>: Endpoint is not available to take incoming
    /// requests.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Creating</code>: <a>CreateEndpoint</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Updating</code>: <a>UpdateEndpoint</a> or <a>UpdateEndpointWeightsAndCapacities</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be
    /// updated or deleted or re-scaled until it has completed. This maintenance
    /// operation does not change any customer-specified values such as VPC config, KMS
    /// encryption, model, instance type, or instance count.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RollingBack</code>: Endpoint fails to scale up or down or change its
    /// variant weight and is in the process of rolling back to its previous
    /// configuration. Once the rollback completes, endpoint returns to an
    /// <code>InService</code> status. This transitional status only applies to an
    /// endpoint that has autoscaling enabled and is undergoing variant weight or
    /// capacity changes as part of an <a>UpdateEndpointWeightsAndCapacities</a> call or when the <a>UpdateEndpointWeightsAndCapacities</a> operation is called
    /// explicitly.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InService</code>: Endpoint is available to process incoming
    /// requests.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Deleting</code>: <a>DeleteEndpoint</a> is executing.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use
    /// <a>DescribeEndpointOutput$FailureReason</a> for information about
    /// the failure. <a>DeleteEndpoint</a> is the only operation that can be
    /// performed on a failed endpoint.</p>
    /// </li>
    /// </ul>
    /// <p>To get a list of endpoints with a specified status, use the <a>ListEndpointsInput$StatusEquals</a> filter.</p>
    pub endpoint_status: std::option::Option<crate::model::EndpointStatus>,
}
impl std::fmt::Debug for EndpointSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointSummary");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.finish()
    }
}
/// See [`EndpointSummary`](crate::model::EndpointSummary)
pub mod endpoint_summary {
    /// A builder for [`EndpointSummary`](crate::model::EndpointSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) endpoint_status: std::option::Option<crate::model::EndpointStatus>,
    }
    impl Builder {
        /// <p>The name of the endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the endpoint.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>OutOfService</code>: Endpoint is not available to take incoming
        /// requests.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Creating</code>: <a>CreateEndpoint</a> is executing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Updating</code>: <a>UpdateEndpoint</a> or <a>UpdateEndpointWeightsAndCapacities</a> is executing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SystemUpdating</code>: Endpoint is undergoing maintenance and cannot be
        /// updated or deleted or re-scaled until it has completed. This maintenance
        /// operation does not change any customer-specified values such as VPC config, KMS
        /// encryption, model, instance type, or instance count.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RollingBack</code>: Endpoint fails to scale up or down or change its
        /// variant weight and is in the process of rolling back to its previous
        /// configuration. Once the rollback completes, endpoint returns to an
        /// <code>InService</code> status. This transitional status only applies to an
        /// endpoint that has autoscaling enabled and is undergoing variant weight or
        /// capacity changes as part of an <a>UpdateEndpointWeightsAndCapacities</a> call or when the <a>UpdateEndpointWeightsAndCapacities</a> operation is called
        /// explicitly.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InService</code>: Endpoint is available to process incoming
        /// requests.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Deleting</code>: <a>DeleteEndpoint</a> is executing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code>: Endpoint could not be created, updated, or re-scaled. Use
        /// <a>DescribeEndpointOutput$FailureReason</a> for information about
        /// the failure. <a>DeleteEndpoint</a> is the only operation that can be
        /// performed on a failed endpoint.</p>
        /// </li>
        /// </ul>
        /// <p>To get a list of endpoints with a specified status, use the <a>ListEndpointsInput$StatusEquals</a> filter.</p>
        pub fn endpoint_status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.endpoint_status = Some(input);
            self
        }
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointSummary`](crate::model::EndpointSummary)
        pub fn build(self) -> crate::model::EndpointSummary {
            crate::model::EndpointSummary {
                endpoint_name: self.endpoint_name,
                endpoint_arn: self.endpoint_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                endpoint_status: self.endpoint_status,
            }
        }
    }
}
impl EndpointSummary {
    /// Creates a new builder-style object to manufacture [`EndpointSummary`](crate::model::EndpointSummary)
    pub fn builder() -> crate::model::endpoint_summary::Builder {
        crate::model::endpoint_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointSortKey {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => EndpointSortKey::CreationTime,
            "Name" => EndpointSortKey::Name,
            "Status" => EndpointSortKey::Status,
            other => EndpointSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointSortKey::from(s))
    }
}
impl EndpointSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            EndpointSortKey::CreationTime => "CreationTime",
            EndpointSortKey::Name => "Name",
            EndpointSortKey::Status => "Status",
            EndpointSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for EndpointSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information for an endpoint configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointConfigSummary {
    /// <p>The name of the endpoint configuration.</p>
    pub endpoint_config_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
    pub endpoint_config_arn: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the endpoint configuration was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for EndpointConfigSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointConfigSummary");
        formatter.field("endpoint_config_name", &self.endpoint_config_name);
        formatter.field("endpoint_config_arn", &self.endpoint_config_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
pub mod endpoint_config_summary {
    /// A builder for [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_config_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_config_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the endpoint configuration.</p>
        pub fn endpoint_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_name = Some(input.into());
            self
        }
        pub fn set_endpoint_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the endpoint configuration.</p>
        pub fn endpoint_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_config_arn = Some(input.into());
            self
        }
        pub fn set_endpoint_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_config_arn = input;
            self
        }
        /// <p>A timestamp that shows when the endpoint configuration was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
        pub fn build(self) -> crate::model::EndpointConfigSummary {
            crate::model::EndpointConfigSummary {
                endpoint_config_name: self.endpoint_config_name,
                endpoint_config_arn: self.endpoint_config_arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl EndpointConfigSummary {
    /// Creates a new builder-style object to manufacture [`EndpointConfigSummary`](crate::model::EndpointConfigSummary)
    pub fn builder() -> crate::model::endpoint_config_summary::Builder {
        crate::model::endpoint_config_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointConfigSortKey {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => EndpointConfigSortKey::CreationTime,
            "Name" => EndpointConfigSortKey::Name,
            other => EndpointConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointConfigSortKey::from(s))
    }
}
impl EndpointConfigSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            EndpointConfigSortKey::CreationTime => "CreationTime",
            EndpointConfigSortKey::Name => "Name",
            EndpointConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for EndpointConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of edge packaging job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgePackagingJobSummary {
    /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
    pub edge_packaging_job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the edge packaging job.</p>
    pub edge_packaging_job_name: std::option::Option<std::string::String>,
    /// <p>The status of the edge packaging job.</p>
    pub edge_packaging_job_status: std::option::Option<crate::model::EdgePackagingJobStatus>,
    /// <p>The name of the SageMaker Neo compilation job.</p>
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The version of the model.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp of when the edge packaging job was last updated.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for EdgePackagingJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgePackagingJobSummary");
        formatter.field("edge_packaging_job_arn", &self.edge_packaging_job_arn);
        formatter.field("edge_packaging_job_name", &self.edge_packaging_job_name);
        formatter.field("edge_packaging_job_status", &self.edge_packaging_job_status);
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
pub mod edge_packaging_job_summary {
    /// A builder for [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) edge_packaging_job_arn: std::option::Option<std::string::String>,
        pub(crate) edge_packaging_job_name: std::option::Option<std::string::String>,
        pub(crate) edge_packaging_job_status:
            std::option::Option<crate::model::EdgePackagingJobStatus>,
        pub(crate) compilation_job_name: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the edge packaging job.</p>
        pub fn edge_packaging_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_packaging_job_arn = Some(input.into());
            self
        }
        pub fn set_edge_packaging_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_packaging_job_arn = input;
            self
        }
        /// <p>The name of the edge packaging job.</p>
        pub fn edge_packaging_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_packaging_job_name = Some(input.into());
            self
        }
        pub fn set_edge_packaging_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_packaging_job_name = input;
            self
        }
        /// <p>The status of the edge packaging job.</p>
        pub fn edge_packaging_job_status(
            mut self,
            input: crate::model::EdgePackagingJobStatus,
        ) -> Self {
            self.edge_packaging_job_status = Some(input);
            self
        }
        pub fn set_edge_packaging_job_status(
            mut self,
            input: std::option::Option<crate::model::EdgePackagingJobStatus>,
        ) -> Self {
            self.edge_packaging_job_status = input;
            self
        }
        /// <p>The name of the SageMaker Neo compilation job.</p>
        pub fn compilation_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_name = Some(input.into());
            self
        }
        pub fn set_compilation_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_name = input;
            self
        }
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The version of the model.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The timestamp of when the job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The timestamp of when the edge packaging job was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
        pub fn build(self) -> crate::model::EdgePackagingJobSummary {
            crate::model::EdgePackagingJobSummary {
                edge_packaging_job_arn: self.edge_packaging_job_arn,
                edge_packaging_job_name: self.edge_packaging_job_name,
                edge_packaging_job_status: self.edge_packaging_job_status,
                compilation_job_name: self.compilation_job_name,
                model_name: self.model_name,
                model_version: self.model_version,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl EdgePackagingJobSummary {
    /// Creates a new builder-style object to manufacture [`EdgePackagingJobSummary`](crate::model::EdgePackagingJobSummary)
    pub fn builder() -> crate::model::edge_packaging_job_summary::Builder {
        crate::model::edge_packaging_job_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePackagingJobStatus {
    Completed,
    Failed,
    InProgress,
    Starting,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePackagingJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => EdgePackagingJobStatus::Completed,
            "FAILED" => EdgePackagingJobStatus::Failed,
            "INPROGRESS" => EdgePackagingJobStatus::InProgress,
            "STARTING" => EdgePackagingJobStatus::Starting,
            "STOPPED" => EdgePackagingJobStatus::Stopped,
            "STOPPING" => EdgePackagingJobStatus::Stopping,
            other => EdgePackagingJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePackagingJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePackagingJobStatus::from(s))
    }
}
impl EdgePackagingJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            EdgePackagingJobStatus::Completed => "COMPLETED",
            EdgePackagingJobStatus::Failed => "FAILED",
            EdgePackagingJobStatus::InProgress => "INPROGRESS",
            EdgePackagingJobStatus::Starting => "STARTING",
            EdgePackagingJobStatus::Stopped => "STOPPED",
            EdgePackagingJobStatus::Stopping => "STOPPING",
            EdgePackagingJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "INPROGRESS",
            "STARTING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for EdgePackagingJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListEdgePackagingJobsSortBy {
    CreationTime,
    LastModifiedTime,
    ModelName,
    Name,
    EdgePackagingJobStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListEdgePackagingJobsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ListEdgePackagingJobsSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ListEdgePackagingJobsSortBy::LastModifiedTime,
            "MODEL_NAME" => ListEdgePackagingJobsSortBy::ModelName,
            "NAME" => ListEdgePackagingJobsSortBy::Name,
            "STATUS" => ListEdgePackagingJobsSortBy::EdgePackagingJobStatus,
            other => ListEdgePackagingJobsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListEdgePackagingJobsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListEdgePackagingJobsSortBy::from(s))
    }
}
impl ListEdgePackagingJobsSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ListEdgePackagingJobsSortBy::CreationTime => "CREATION_TIME",
            ListEdgePackagingJobsSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ListEdgePackagingJobsSortBy::ModelName => "MODEL_NAME",
            ListEdgePackagingJobsSortBy::Name => "NAME",
            ListEdgePackagingJobsSortBy::EdgePackagingJobStatus => "STATUS",
            ListEdgePackagingJobsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATION_TIME",
            "LAST_MODIFIED_TIME",
            "MODEL_NAME",
            "NAME",
            "STATUS",
        ]
    }
}
impl AsRef<str> for ListEdgePackagingJobsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The domain's details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainDetails {
    /// <p>The domain's Amazon Resource Name (ARN).</p>
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The domain name.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::DomainStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The domain's URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainDetails");
        formatter.field("domain_arn", &self.domain_arn);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`DomainDetails`](crate::model::DomainDetails)
pub mod domain_details {
    /// A builder for [`DomainDetails`](crate::model::DomainDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_arn: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DomainStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The domain's Amazon Resource Name (ARN).</p>
        pub fn domain_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_arn = Some(input.into());
            self
        }
        pub fn set_domain_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_arn = input;
            self
        }
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The domain name.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::DomainStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DomainStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The domain's URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainDetails`](crate::model::DomainDetails)
        pub fn build(self) -> crate::model::DomainDetails {
            crate::model::DomainDetails {
                domain_arn: self.domain_arn,
                domain_id: self.domain_id,
                domain_name: self.domain_name,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                url: self.url,
            }
        }
    }
}
impl DomainDetails {
    /// Creates a new builder-style object to manufacture [`DomainDetails`](crate::model::DomainDetails)
    pub fn builder() -> crate::model::domain_details::Builder {
        crate::model::domain_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainStatus {
    DeleteFailed,
    Deleting,
    Failed,
    InService,
    Pending,
    UpdateFailed,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "Delete_Failed" => DomainStatus::DeleteFailed,
            "Deleting" => DomainStatus::Deleting,
            "Failed" => DomainStatus::Failed,
            "InService" => DomainStatus::InService,
            "Pending" => DomainStatus::Pending,
            "Update_Failed" => DomainStatus::UpdateFailed,
            "Updating" => DomainStatus::Updating,
            other => DomainStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainStatus::from(s))
    }
}
impl DomainStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DomainStatus::DeleteFailed => "Delete_Failed",
            DomainStatus::Deleting => "Deleting",
            DomainStatus::Failed => "Failed",
            DomainStatus::InService => "InService",
            DomainStatus::Pending => "Pending",
            DomainStatus::UpdateFailed => "Update_Failed",
            DomainStatus::Updating => "Updating",
            DomainStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Delete_Failed",
            "Deleting",
            "Failed",
            "InService",
            "Pending",
            "Update_Failed",
            "Updating",
        ]
    }
}
impl AsRef<str> for DomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary of the device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceSummary {
    /// <p>The unique identifier of the device.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Name (ARN) of the device.</p>
    pub device_arn: std::option::Option<std::string::String>,
    /// <p>A description of the device.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the fleet the device belongs to.</p>
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
    pub iot_thing_name: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last registration or de-reregistration.</p>
    pub registration_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last heartbeat received from the device.</p>
    pub latest_heartbeat: std::option::Option<smithy_types::Instant>,
    /// <p>Models on the device.</p>
    pub models: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
}
impl std::fmt::Debug for DeviceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceSummary");
        formatter.field("device_name", &self.device_name);
        formatter.field("device_arn", &self.device_arn);
        formatter.field("description", &self.description);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("iot_thing_name", &self.iot_thing_name);
        formatter.field("registration_time", &self.registration_time);
        formatter.field("latest_heartbeat", &self.latest_heartbeat);
        formatter.field("models", &self.models);
        formatter.finish()
    }
}
/// See [`DeviceSummary`](crate::model::DeviceSummary)
pub mod device_summary {
    /// A builder for [`DeviceSummary`](crate::model::DeviceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) device_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) device_fleet_name: std::option::Option<std::string::String>,
        pub(crate) iot_thing_name: std::option::Option<std::string::String>,
        pub(crate) registration_time: std::option::Option<smithy_types::Instant>,
        pub(crate) latest_heartbeat: std::option::Option<smithy_types::Instant>,
        pub(crate) models: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
    }
    impl Builder {
        /// <p>The unique identifier of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Amazon Resource Name (ARN) of the device.</p>
        pub fn device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_arn = Some(input.into());
            self
        }
        pub fn set_device_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_arn = input;
            self
        }
        /// <p>A description of the device.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the fleet the device belongs to.</p>
        pub fn device_fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_name = Some(input.into());
            self
        }
        pub fn set_device_fleet_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_name = input;
            self
        }
        /// <p>The Amazon Web Services Internet of Things (IoT) object thing name associated with the device..</p>
        pub fn iot_thing_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.iot_thing_name = Some(input.into());
            self
        }
        pub fn set_iot_thing_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iot_thing_name = input;
            self
        }
        /// <p>The timestamp of the last registration or de-reregistration.</p>
        pub fn registration_time(mut self, input: smithy_types::Instant) -> Self {
            self.registration_time = Some(input);
            self
        }
        pub fn set_registration_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.registration_time = input;
            self
        }
        /// <p>The last heartbeat received from the device.</p>
        pub fn latest_heartbeat(mut self, input: smithy_types::Instant) -> Self {
            self.latest_heartbeat = Some(input);
            self
        }
        pub fn set_latest_heartbeat(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_heartbeat = input;
            self
        }
        pub fn models(mut self, input: impl Into<crate::model::EdgeModelSummary>) -> Self {
            let mut v = self.models.unwrap_or_default();
            v.push(input.into());
            self.models = Some(v);
            self
        }
        pub fn set_models(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EdgeModelSummary>>,
        ) -> Self {
            self.models = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceSummary`](crate::model::DeviceSummary)
        pub fn build(self) -> crate::model::DeviceSummary {
            crate::model::DeviceSummary {
                device_name: self.device_name,
                device_arn: self.device_arn,
                description: self.description,
                device_fleet_name: self.device_fleet_name,
                iot_thing_name: self.iot_thing_name,
                registration_time: self.registration_time,
                latest_heartbeat: self.latest_heartbeat,
                models: self.models,
            }
        }
    }
}
impl DeviceSummary {
    /// Creates a new builder-style object to manufacture [`DeviceSummary`](crate::model::DeviceSummary)
    pub fn builder() -> crate::model::device_summary::Builder {
        crate::model::device_summary::Builder::default()
    }
}

/// <p>Summary of model on edge device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModelSummary {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The version model.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EdgeModelSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModelSummary");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`EdgeModelSummary`](crate::model::EdgeModelSummary)
pub mod edge_model_summary {
    /// A builder for [`EdgeModelSummary`](crate::model::EdgeModelSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The version model.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModelSummary`](crate::model::EdgeModelSummary)
        pub fn build(self) -> crate::model::EdgeModelSummary {
            crate::model::EdgeModelSummary {
                model_name: self.model_name,
                model_version: self.model_version,
            }
        }
    }
}
impl EdgeModelSummary {
    /// Creates a new builder-style object to manufacture [`EdgeModelSummary`](crate::model::EdgeModelSummary)
    pub fn builder() -> crate::model::edge_model_summary::Builder {
        crate::model::edge_model_summary::Builder::default()
    }
}

/// <p>Summary of the device fleet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceFleetSummary {
    /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
    pub device_fleet_arn: std::option::Option<std::string::String>,
    /// <p>Name of the device fleet.</p>
    pub device_fleet_name: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the device fleet was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Timestamp of when the device fleet was last updated.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DeviceFleetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceFleetSummary");
        formatter.field("device_fleet_arn", &self.device_fleet_arn);
        formatter.field("device_fleet_name", &self.device_fleet_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
pub mod device_fleet_summary {
    /// A builder for [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_fleet_arn: std::option::Option<std::string::String>,
        pub(crate) device_fleet_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of the device fleet.</p>
        pub fn device_fleet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_arn = Some(input.into());
            self
        }
        pub fn set_device_fleet_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_arn = input;
            self
        }
        /// <p>Name of the device fleet.</p>
        pub fn device_fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_fleet_name = Some(input.into());
            self
        }
        pub fn set_device_fleet_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_fleet_name = input;
            self
        }
        /// <p>Timestamp of when the device fleet was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Timestamp of when the device fleet was last updated.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
        pub fn build(self) -> crate::model::DeviceFleetSummary {
            crate::model::DeviceFleetSummary {
                device_fleet_arn: self.device_fleet_arn,
                device_fleet_name: self.device_fleet_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl DeviceFleetSummary {
    /// Creates a new builder-style object to manufacture [`DeviceFleetSummary`](crate::model::DeviceFleetSummary)
    pub fn builder() -> crate::model::device_fleet_summary::Builder {
        crate::model::device_fleet_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListDeviceFleetsSortBy {
    CreationTime,
    LastModifiedTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListDeviceFleetsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATION_TIME" => ListDeviceFleetsSortBy::CreationTime,
            "LAST_MODIFIED_TIME" => ListDeviceFleetsSortBy::LastModifiedTime,
            "NAME" => ListDeviceFleetsSortBy::Name,
            other => ListDeviceFleetsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListDeviceFleetsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListDeviceFleetsSortBy::from(s))
    }
}
impl ListDeviceFleetsSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ListDeviceFleetsSortBy::CreationTime => "CREATION_TIME",
            ListDeviceFleetsSortBy::LastModifiedTime => "LAST_MODIFIED_TIME",
            ListDeviceFleetsSortBy::Name => "NAME",
            ListDeviceFleetsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CREATION_TIME", "LAST_MODIFIED_TIME", "NAME"]
    }
}
impl AsRef<str> for ListDeviceFleetsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of a context. A context provides a logical grouping
/// of other entities.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContextSummary {
    /// <p>The Amazon Resource Name (ARN) of the context.</p>
    pub context_arn: std::option::Option<std::string::String>,
    /// <p>The name of the context.</p>
    pub context_name: std::option::Option<std::string::String>,
    /// <p>The source of the context.</p>
    pub source: std::option::Option<crate::model::ContextSource>,
    /// <p>The type of the context.</p>
    pub context_type: std::option::Option<std::string::String>,
    /// <p>When the context was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the context was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ContextSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContextSummary");
        formatter.field("context_arn", &self.context_arn);
        formatter.field("context_name", &self.context_name);
        formatter.field("source", &self.source);
        formatter.field("context_type", &self.context_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ContextSummary`](crate::model::ContextSummary)
pub mod context_summary {
    /// A builder for [`ContextSummary`](crate::model::ContextSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) context_arn: std::option::Option<std::string::String>,
        pub(crate) context_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ContextSource>,
        pub(crate) context_type: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the context.</p>
        pub fn context_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_arn = Some(input.into());
            self
        }
        pub fn set_context_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_arn = input;
            self
        }
        /// <p>The name of the context.</p>
        pub fn context_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_name = Some(input.into());
            self
        }
        pub fn set_context_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_name = input;
            self
        }
        /// <p>The source of the context.</p>
        pub fn source(mut self, input: crate::model::ContextSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ContextSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the context.</p>
        pub fn context_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.context_type = Some(input.into());
            self
        }
        pub fn set_context_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context_type = input;
            self
        }
        /// <p>When the context was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the context was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ContextSummary`](crate::model::ContextSummary)
        pub fn build(self) -> crate::model::ContextSummary {
            crate::model::ContextSummary {
                context_arn: self.context_arn,
                context_name: self.context_name,
                source: self.source,
                context_type: self.context_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ContextSummary {
    /// Creates a new builder-style object to manufacture [`ContextSummary`](crate::model::ContextSummary)
    pub fn builder() -> crate::model::context_summary::Builder {
        crate::model::context_summary::Builder::default()
    }
}

/// <p>A structure describing the source of a context.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContextSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>The type of the source.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The ID of the source.</p>
    pub source_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContextSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContextSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_type", &self.source_type);
        formatter.field("source_id", &self.source_id);
        formatter.finish()
    }
}
/// See [`ContextSource`](crate::model::ContextSource)
pub mod context_source {
    /// A builder for [`ContextSource`](crate::model::ContextSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        /// <p>The type of the source.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The ID of the source.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ContextSource`](crate::model::ContextSource)
        pub fn build(self) -> crate::model::ContextSource {
            crate::model::ContextSource {
                source_uri: self.source_uri,
                source_type: self.source_type,
                source_id: self.source_id,
            }
        }
    }
}
impl ContextSource {
    /// Creates a new builder-style object to manufacture [`ContextSource`](crate::model::ContextSource)
    pub fn builder() -> crate::model::context_source::Builder {
        crate::model::context_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortContextsBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortContextsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortContextsBy::CreationTime,
            "Name" => SortContextsBy::Name,
            other => SortContextsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortContextsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortContextsBy::from(s))
    }
}
impl SortContextsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortContextsBy::CreationTime => "CreationTime",
            SortContextsBy::Name => "Name",
            SortContextsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortContextsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of a model compilation job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompilationJobSummary {
    /// <p>The name of the model compilation job that you want a summary for.</p>
    pub compilation_job_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
    pub compilation_job_arn: std::option::Option<std::string::String>,
    /// <p>The time when the model compilation job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the model compilation job started.</p>
    pub compilation_start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the model compilation job completed.</p>
    pub compilation_end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The type of device that the model will run on after the compilation job has
    /// completed.</p>
    pub compilation_target_device: std::option::Option<crate::model::TargetDevice>,
    /// <p>The type of OS that the model will run on after the compilation job has
    /// completed.</p>
    pub compilation_target_platform_os: std::option::Option<crate::model::TargetPlatformOs>,
    /// <p>The type of architecture that the model will run on after the compilation job has
    /// completed.</p>
    pub compilation_target_platform_arch: std::option::Option<crate::model::TargetPlatformArch>,
    /// <p>The type of accelerator that the model will run on after the compilation job has
    /// completed.</p>
    pub compilation_target_platform_accelerator:
        std::option::Option<crate::model::TargetPlatformAccelerator>,
    /// <p>The time when the model compilation job was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The status of the model compilation job.</p>
    pub compilation_job_status: std::option::Option<crate::model::CompilationJobStatus>,
}
impl std::fmt::Debug for CompilationJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompilationJobSummary");
        formatter.field("compilation_job_name", &self.compilation_job_name);
        formatter.field("compilation_job_arn", &self.compilation_job_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("compilation_start_time", &self.compilation_start_time);
        formatter.field("compilation_end_time", &self.compilation_end_time);
        formatter.field("compilation_target_device", &self.compilation_target_device);
        formatter.field(
            "compilation_target_platform_os",
            &self.compilation_target_platform_os,
        );
        formatter.field(
            "compilation_target_platform_arch",
            &self.compilation_target_platform_arch,
        );
        formatter.field(
            "compilation_target_platform_accelerator",
            &self.compilation_target_platform_accelerator,
        );
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("compilation_job_status", &self.compilation_job_status);
        formatter.finish()
    }
}
/// See [`CompilationJobSummary`](crate::model::CompilationJobSummary)
pub mod compilation_job_summary {
    /// A builder for [`CompilationJobSummary`](crate::model::CompilationJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) compilation_job_name: std::option::Option<std::string::String>,
        pub(crate) compilation_job_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) compilation_start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) compilation_end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) compilation_target_device: std::option::Option<crate::model::TargetDevice>,
        pub(crate) compilation_target_platform_os:
            std::option::Option<crate::model::TargetPlatformOs>,
        pub(crate) compilation_target_platform_arch:
            std::option::Option<crate::model::TargetPlatformArch>,
        pub(crate) compilation_target_platform_accelerator:
            std::option::Option<crate::model::TargetPlatformAccelerator>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) compilation_job_status: std::option::Option<crate::model::CompilationJobStatus>,
    }
    impl Builder {
        /// <p>The name of the model compilation job that you want a summary for.</p>
        pub fn compilation_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_name = Some(input.into());
            self
        }
        pub fn set_compilation_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the model compilation job.</p>
        pub fn compilation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.compilation_job_arn = Some(input.into());
            self
        }
        pub fn set_compilation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compilation_job_arn = input;
            self
        }
        /// <p>The time when the model compilation job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time when the model compilation job started.</p>
        pub fn compilation_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.compilation_start_time = Some(input);
            self
        }
        pub fn set_compilation_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.compilation_start_time = input;
            self
        }
        /// <p>The time when the model compilation job completed.</p>
        pub fn compilation_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.compilation_end_time = Some(input);
            self
        }
        pub fn set_compilation_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.compilation_end_time = input;
            self
        }
        /// <p>The type of device that the model will run on after the compilation job has
        /// completed.</p>
        pub fn compilation_target_device(mut self, input: crate::model::TargetDevice) -> Self {
            self.compilation_target_device = Some(input);
            self
        }
        pub fn set_compilation_target_device(
            mut self,
            input: std::option::Option<crate::model::TargetDevice>,
        ) -> Self {
            self.compilation_target_device = input;
            self
        }
        /// <p>The type of OS that the model will run on after the compilation job has
        /// completed.</p>
        pub fn compilation_target_platform_os(
            mut self,
            input: crate::model::TargetPlatformOs,
        ) -> Self {
            self.compilation_target_platform_os = Some(input);
            self
        }
        pub fn set_compilation_target_platform_os(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformOs>,
        ) -> Self {
            self.compilation_target_platform_os = input;
            self
        }
        /// <p>The type of architecture that the model will run on after the compilation job has
        /// completed.</p>
        pub fn compilation_target_platform_arch(
            mut self,
            input: crate::model::TargetPlatformArch,
        ) -> Self {
            self.compilation_target_platform_arch = Some(input);
            self
        }
        pub fn set_compilation_target_platform_arch(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformArch>,
        ) -> Self {
            self.compilation_target_platform_arch = input;
            self
        }
        /// <p>The type of accelerator that the model will run on after the compilation job has
        /// completed.</p>
        pub fn compilation_target_platform_accelerator(
            mut self,
            input: crate::model::TargetPlatformAccelerator,
        ) -> Self {
            self.compilation_target_platform_accelerator = Some(input);
            self
        }
        pub fn set_compilation_target_platform_accelerator(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformAccelerator>,
        ) -> Self {
            self.compilation_target_platform_accelerator = input;
            self
        }
        /// <p>The time when the model compilation job was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The status of the model compilation job.</p>
        pub fn compilation_job_status(mut self, input: crate::model::CompilationJobStatus) -> Self {
            self.compilation_job_status = Some(input);
            self
        }
        pub fn set_compilation_job_status(
            mut self,
            input: std::option::Option<crate::model::CompilationJobStatus>,
        ) -> Self {
            self.compilation_job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`CompilationJobSummary`](crate::model::CompilationJobSummary)
        pub fn build(self) -> crate::model::CompilationJobSummary {
            crate::model::CompilationJobSummary {
                compilation_job_name: self.compilation_job_name,
                compilation_job_arn: self.compilation_job_arn,
                creation_time: self.creation_time,
                compilation_start_time: self.compilation_start_time,
                compilation_end_time: self.compilation_end_time,
                compilation_target_device: self.compilation_target_device,
                compilation_target_platform_os: self.compilation_target_platform_os,
                compilation_target_platform_arch: self.compilation_target_platform_arch,
                compilation_target_platform_accelerator: self
                    .compilation_target_platform_accelerator,
                last_modified_time: self.last_modified_time,
                compilation_job_status: self.compilation_job_status,
            }
        }
    }
}
impl CompilationJobSummary {
    /// Creates a new builder-style object to manufacture [`CompilationJobSummary`](crate::model::CompilationJobSummary)
    pub fn builder() -> crate::model::compilation_job_summary::Builder {
        crate::model::compilation_job_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CompilationJobStatus {
    Completed,
    Failed,
    Inprogress,
    Starting,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CompilationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => CompilationJobStatus::Completed,
            "FAILED" => CompilationJobStatus::Failed,
            "INPROGRESS" => CompilationJobStatus::Inprogress,
            "STARTING" => CompilationJobStatus::Starting,
            "STOPPED" => CompilationJobStatus::Stopped,
            "STOPPING" => CompilationJobStatus::Stopping,
            other => CompilationJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CompilationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CompilationJobStatus::from(s))
    }
}
impl CompilationJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CompilationJobStatus::Completed => "COMPLETED",
            CompilationJobStatus::Failed => "FAILED",
            CompilationJobStatus::Inprogress => "INPROGRESS",
            CompilationJobStatus::Starting => "STARTING",
            CompilationJobStatus::Stopped => "STOPPED",
            CompilationJobStatus::Stopping => "STOPPING",
            CompilationJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "INPROGRESS",
            "STARTING",
            "STOPPED",
            "STOPPING",
        ]
    }
}
impl AsRef<str> for CompilationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformAccelerator {
    IntelGraphics,
    Mali,
    Nvidia,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformAccelerator {
    fn from(s: &str) -> Self {
        match s {
            "INTEL_GRAPHICS" => TargetPlatformAccelerator::IntelGraphics,
            "MALI" => TargetPlatformAccelerator::Mali,
            "NVIDIA" => TargetPlatformAccelerator::Nvidia,
            other => TargetPlatformAccelerator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformAccelerator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformAccelerator::from(s))
    }
}
impl TargetPlatformAccelerator {
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformAccelerator::IntelGraphics => "INTEL_GRAPHICS",
            TargetPlatformAccelerator::Mali => "MALI",
            TargetPlatformAccelerator::Nvidia => "NVIDIA",
            TargetPlatformAccelerator::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["INTEL_GRAPHICS", "MALI", "NVIDIA"]
    }
}
impl AsRef<str> for TargetPlatformAccelerator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformArch {
    Arm64,
    ArmEabi,
    ArmEabihf,
    X86,
    X8664,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformArch {
    fn from(s: &str) -> Self {
        match s {
            "ARM64" => TargetPlatformArch::Arm64,
            "ARM_EABI" => TargetPlatformArch::ArmEabi,
            "ARM_EABIHF" => TargetPlatformArch::ArmEabihf,
            "X86" => TargetPlatformArch::X86,
            "X86_64" => TargetPlatformArch::X8664,
            other => TargetPlatformArch::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformArch {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformArch::from(s))
    }
}
impl TargetPlatformArch {
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformArch::Arm64 => "ARM64",
            TargetPlatformArch::ArmEabi => "ARM_EABI",
            TargetPlatformArch::ArmEabihf => "ARM_EABIHF",
            TargetPlatformArch::X86 => "X86",
            TargetPlatformArch::X8664 => "X86_64",
            TargetPlatformArch::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ARM64", "ARM_EABI", "ARM_EABIHF", "X86", "X86_64"]
    }
}
impl AsRef<str> for TargetPlatformArch {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetPlatformOs {
    Android,
    Linux,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetPlatformOs {
    fn from(s: &str) -> Self {
        match s {
            "ANDROID" => TargetPlatformOs::Android,
            "LINUX" => TargetPlatformOs::Linux,
            other => TargetPlatformOs::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetPlatformOs {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetPlatformOs::from(s))
    }
}
impl TargetPlatformOs {
    pub fn as_str(&self) -> &str {
        match self {
            TargetPlatformOs::Android => "ANDROID",
            TargetPlatformOs::Linux => "LINUX",
            TargetPlatformOs::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ANDROID", "LINUX"]
    }
}
impl AsRef<str> for TargetPlatformOs {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetDevice {
    Aisage,
    AmbaCv22,
    AmbaCv25,
    Coreml,
    Deeplens,
    Imx8Qm,
    JacintoTda4Vm,
    JetsonNano,
    JetsonTx1,
    JetsonTx2,
    JetsonXavier,
    Lambda,
    MlC4,
    MlC5,
    MlEia2,
    MlG4Dn,
    MlInf1,
    MlM4,
    MlM5,
    MlP2,
    MlP3,
    Qcs603,
    Qcs605,
    Rasp3B,
    Rk3288,
    Rk3399,
    SbeC,
    SitaraAm57X,
    X86Win32,
    X86Win64,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TargetDevice {
    fn from(s: &str) -> Self {
        match s {
            "aisage" => TargetDevice::Aisage,
            "amba_cv22" => TargetDevice::AmbaCv22,
            "amba_cv25" => TargetDevice::AmbaCv25,
            "coreml" => TargetDevice::Coreml,
            "deeplens" => TargetDevice::Deeplens,
            "imx8qm" => TargetDevice::Imx8Qm,
            "jacinto_tda4vm" => TargetDevice::JacintoTda4Vm,
            "jetson_nano" => TargetDevice::JetsonNano,
            "jetson_tx1" => TargetDevice::JetsonTx1,
            "jetson_tx2" => TargetDevice::JetsonTx2,
            "jetson_xavier" => TargetDevice::JetsonXavier,
            "lambda" => TargetDevice::Lambda,
            "ml_c4" => TargetDevice::MlC4,
            "ml_c5" => TargetDevice::MlC5,
            "ml_eia2" => TargetDevice::MlEia2,
            "ml_g4dn" => TargetDevice::MlG4Dn,
            "ml_inf1" => TargetDevice::MlInf1,
            "ml_m4" => TargetDevice::MlM4,
            "ml_m5" => TargetDevice::MlM5,
            "ml_p2" => TargetDevice::MlP2,
            "ml_p3" => TargetDevice::MlP3,
            "qcs603" => TargetDevice::Qcs603,
            "qcs605" => TargetDevice::Qcs605,
            "rasp3b" => TargetDevice::Rasp3B,
            "rk3288" => TargetDevice::Rk3288,
            "rk3399" => TargetDevice::Rk3399,
            "sbe_c" => TargetDevice::SbeC,
            "sitara_am57x" => TargetDevice::SitaraAm57X,
            "x86_win32" => TargetDevice::X86Win32,
            "x86_win64" => TargetDevice::X86Win64,
            other => TargetDevice::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TargetDevice {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetDevice::from(s))
    }
}
impl TargetDevice {
    pub fn as_str(&self) -> &str {
        match self {
            TargetDevice::Aisage => "aisage",
            TargetDevice::AmbaCv22 => "amba_cv22",
            TargetDevice::AmbaCv25 => "amba_cv25",
            TargetDevice::Coreml => "coreml",
            TargetDevice::Deeplens => "deeplens",
            TargetDevice::Imx8Qm => "imx8qm",
            TargetDevice::JacintoTda4Vm => "jacinto_tda4vm",
            TargetDevice::JetsonNano => "jetson_nano",
            TargetDevice::JetsonTx1 => "jetson_tx1",
            TargetDevice::JetsonTx2 => "jetson_tx2",
            TargetDevice::JetsonXavier => "jetson_xavier",
            TargetDevice::Lambda => "lambda",
            TargetDevice::MlC4 => "ml_c4",
            TargetDevice::MlC5 => "ml_c5",
            TargetDevice::MlEia2 => "ml_eia2",
            TargetDevice::MlG4Dn => "ml_g4dn",
            TargetDevice::MlInf1 => "ml_inf1",
            TargetDevice::MlM4 => "ml_m4",
            TargetDevice::MlM5 => "ml_m5",
            TargetDevice::MlP2 => "ml_p2",
            TargetDevice::MlP3 => "ml_p3",
            TargetDevice::Qcs603 => "qcs603",
            TargetDevice::Qcs605 => "qcs605",
            TargetDevice::Rasp3B => "rasp3b",
            TargetDevice::Rk3288 => "rk3288",
            TargetDevice::Rk3399 => "rk3399",
            TargetDevice::SbeC => "sbe_c",
            TargetDevice::SitaraAm57X => "sitara_am57x",
            TargetDevice::X86Win32 => "x86_win32",
            TargetDevice::X86Win64 => "x86_win64",
            TargetDevice::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "aisage",
            "amba_cv22",
            "amba_cv25",
            "coreml",
            "deeplens",
            "imx8qm",
            "jacinto_tda4vm",
            "jetson_nano",
            "jetson_tx1",
            "jetson_tx2",
            "jetson_xavier",
            "lambda",
            "ml_c4",
            "ml_c5",
            "ml_eia2",
            "ml_g4dn",
            "ml_inf1",
            "ml_m4",
            "ml_m5",
            "ml_p2",
            "ml_p3",
            "qcs603",
            "qcs605",
            "rasp3b",
            "rk3288",
            "rk3399",
            "sbe_c",
            "sitara_am57x",
            "x86_win32",
            "x86_win64",
        ]
    }
}
impl AsRef<str> for TargetDevice {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ListCompilationJobsSortBy {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ListCompilationJobsSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => ListCompilationJobsSortBy::CreationTime,
            "Name" => ListCompilationJobsSortBy::Name,
            "Status" => ListCompilationJobsSortBy::Status,
            other => ListCompilationJobsSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ListCompilationJobsSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ListCompilationJobsSortBy::from(s))
    }
}
impl ListCompilationJobsSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            ListCompilationJobsSortBy::CreationTime => "CreationTime",
            ListCompilationJobsSortBy::Name => "Name",
            ListCompilationJobsSortBy::Status => "Status",
            ListCompilationJobsSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for ListCompilationJobsSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies summary information about a Git repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeRepositorySummary {
    /// <p>The name of the Git repository.</p>
    pub code_repository_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
    pub code_repository_arn: std::option::Option<std::string::String>,
    /// <p>The date and time that the Git repository was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time that the Git repository was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>Configuration details for the Git repository, including the URL where it is located
    /// and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to
    /// access the repository.</p>
    pub git_config: std::option::Option<crate::model::GitConfig>,
}
impl std::fmt::Debug for CodeRepositorySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeRepositorySummary");
        formatter.field("code_repository_name", &self.code_repository_name);
        formatter.field("code_repository_arn", &self.code_repository_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("git_config", &self.git_config);
        formatter.finish()
    }
}
/// See [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
pub mod code_repository_summary {
    /// A builder for [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_repository_name: std::option::Option<std::string::String>,
        pub(crate) code_repository_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) git_config: std::option::Option<crate::model::GitConfig>,
    }
    impl Builder {
        /// <p>The name of the Git repository.</p>
        pub fn code_repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_repository_name = Some(input.into());
            self
        }
        pub fn set_code_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_repository_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Git repository.</p>
        pub fn code_repository_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.code_repository_arn = Some(input.into());
            self
        }
        pub fn set_code_repository_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.code_repository_arn = input;
            self
        }
        /// <p>The date and time that the Git repository was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the Git repository was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Configuration details for the Git repository, including the URL where it is located
        /// and the ARN of the Amazon Web Services Secrets Manager secret that contains the credentials used to
        /// access the repository.</p>
        pub fn git_config(mut self, input: crate::model::GitConfig) -> Self {
            self.git_config = Some(input);
            self
        }
        pub fn set_git_config(
            mut self,
            input: std::option::Option<crate::model::GitConfig>,
        ) -> Self {
            self.git_config = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
        pub fn build(self) -> crate::model::CodeRepositorySummary {
            crate::model::CodeRepositorySummary {
                code_repository_name: self.code_repository_name,
                code_repository_arn: self.code_repository_arn,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                git_config: self.git_config,
            }
        }
    }
}
impl CodeRepositorySummary {
    /// Creates a new builder-style object to manufacture [`CodeRepositorySummary`](crate::model::CodeRepositorySummary)
    pub fn builder() -> crate::model::code_repository_summary::Builder {
        crate::model::code_repository_summary::Builder::default()
    }
}

/// <p>Specifies configuration details for a Git repository in your Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GitConfig {
    /// <p>The URL where the Git repository is located.</p>
    pub repository_url: std::option::Option<std::string::String>,
    /// <p>The default branch for the Git repository.</p>
    pub branch: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the
    /// credentials used to access the git repository. The secret must have a staging label of
    /// <code>AWSCURRENT</code> and must be in the following format:</p>
    /// <p>
    /// <code>{"username": <i>UserName</i>, "password":
    /// <i>Password</i>}</code>
    /// </p>
    pub secret_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GitConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GitConfig");
        formatter.field("repository_url", &self.repository_url);
        formatter.field("branch", &self.branch);
        formatter.field("secret_arn", &self.secret_arn);
        formatter.finish()
    }
}
/// See [`GitConfig`](crate::model::GitConfig)
pub mod git_config {
    /// A builder for [`GitConfig`](crate::model::GitConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_url: std::option::Option<std::string::String>,
        pub(crate) branch: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL where the Git repository is located.</p>
        pub fn repository_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_url = Some(input.into());
            self
        }
        pub fn set_repository_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_url = input;
            self
        }
        /// <p>The default branch for the Git repository.</p>
        pub fn branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch = Some(input.into());
            self
        }
        pub fn set_branch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.branch = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Secrets Manager secret that contains the
        /// credentials used to access the git repository. The secret must have a staging label of
        /// <code>AWSCURRENT</code> and must be in the following format:</p>
        /// <p>
        /// <code>{"username": <i>UserName</i>, "password":
        /// <i>Password</i>}</code>
        /// </p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GitConfig`](crate::model::GitConfig)
        pub fn build(self) -> crate::model::GitConfig {
            crate::model::GitConfig {
                repository_url: self.repository_url,
                branch: self.branch,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl GitConfig {
    /// Creates a new builder-style object to manufacture [`GitConfig`](crate::model::GitConfig)
    pub fn builder() -> crate::model::git_config::Builder {
        crate::model::git_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeRepositorySortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CodeRepositorySortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => CodeRepositorySortOrder::Ascending,
            "Descending" => CodeRepositorySortOrder::Descending,
            other => CodeRepositorySortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CodeRepositorySortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeRepositorySortOrder::from(s))
    }
}
impl CodeRepositorySortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            CodeRepositorySortOrder::Ascending => "Ascending",
            CodeRepositorySortOrder::Descending => "Descending",
            CodeRepositorySortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for CodeRepositorySortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CodeRepositorySortBy {
    CreationTime,
    LastModifiedTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CodeRepositorySortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => CodeRepositorySortBy::CreationTime,
            "LastModifiedTime" => CodeRepositorySortBy::LastModifiedTime,
            "Name" => CodeRepositorySortBy::Name,
            other => CodeRepositorySortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CodeRepositorySortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CodeRepositorySortBy::from(s))
    }
}
impl CodeRepositorySortBy {
    pub fn as_str(&self) -> &str {
        match self {
            CodeRepositorySortBy::CreationTime => "CreationTime",
            CodeRepositorySortBy::LastModifiedTime => "LastModifiedTime",
            CodeRepositorySortBy::Name => "Name",
            CodeRepositorySortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for CodeRepositorySortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An Autopilot job returns recommendations, or candidates. Each candidate has futher details
/// about the steps involved and the status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlCandidate {
    /// <p>The name of the candidate.</p>
    pub candidate_name: std::option::Option<std::string::String>,
    /// <p>The best candidate result from an AutoML training job.</p>
    pub final_auto_ml_job_objective_metric:
        std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
    /// <p>The objective's status.</p>
    pub objective_status: std::option::Option<crate::model::ObjectiveStatus>,
    /// <p>Information about the candidate's steps.</p>
    pub candidate_steps: std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
    /// <p>The candidate's status.</p>
    pub candidate_status: std::option::Option<crate::model::CandidateStatus>,
    /// <p>Information about the inference container definitions.</p>
    pub inference_containers:
        std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The end time.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The last modified time.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The failure reason.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The AutoML candidate's properties.</p>
    pub candidate_properties: std::option::Option<crate::model::CandidateProperties>,
}
impl std::fmt::Debug for AutoMlCandidate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlCandidate");
        formatter.field("candidate_name", &self.candidate_name);
        formatter.field(
            "final_auto_ml_job_objective_metric",
            &self.final_auto_ml_job_objective_metric,
        );
        formatter.field("objective_status", &self.objective_status);
        formatter.field("candidate_steps", &self.candidate_steps);
        formatter.field("candidate_status", &self.candidate_status);
        formatter.field("inference_containers", &self.inference_containers);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("candidate_properties", &self.candidate_properties);
        formatter.finish()
    }
}
/// See [`AutoMlCandidate`](crate::model::AutoMlCandidate)
pub mod auto_ml_candidate {
    /// A builder for [`AutoMlCandidate`](crate::model::AutoMlCandidate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_name: std::option::Option<std::string::String>,
        pub(crate) final_auto_ml_job_objective_metric:
            std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
        pub(crate) objective_status: std::option::Option<crate::model::ObjectiveStatus>,
        pub(crate) candidate_steps:
            std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
        pub(crate) candidate_status: std::option::Option<crate::model::CandidateStatus>,
        pub(crate) inference_containers:
            std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) candidate_properties: std::option::Option<crate::model::CandidateProperties>,
    }
    impl Builder {
        /// <p>The name of the candidate.</p>
        pub fn candidate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_name = Some(input.into());
            self
        }
        pub fn set_candidate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_name = input;
            self
        }
        /// <p>The best candidate result from an AutoML training job.</p>
        pub fn final_auto_ml_job_objective_metric(
            mut self,
            input: crate::model::FinalAutoMlJobObjectiveMetric,
        ) -> Self {
            self.final_auto_ml_job_objective_metric = Some(input);
            self
        }
        pub fn set_final_auto_ml_job_objective_metric(
            mut self,
            input: std::option::Option<crate::model::FinalAutoMlJobObjectiveMetric>,
        ) -> Self {
            self.final_auto_ml_job_objective_metric = input;
            self
        }
        /// <p>The objective's status.</p>
        pub fn objective_status(mut self, input: crate::model::ObjectiveStatus) -> Self {
            self.objective_status = Some(input);
            self
        }
        pub fn set_objective_status(
            mut self,
            input: std::option::Option<crate::model::ObjectiveStatus>,
        ) -> Self {
            self.objective_status = input;
            self
        }
        pub fn candidate_steps(
            mut self,
            input: impl Into<crate::model::AutoMlCandidateStep>,
        ) -> Self {
            let mut v = self.candidate_steps.unwrap_or_default();
            v.push(input.into());
            self.candidate_steps = Some(v);
            self
        }
        pub fn set_candidate_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlCandidateStep>>,
        ) -> Self {
            self.candidate_steps = input;
            self
        }
        /// <p>The candidate's status.</p>
        pub fn candidate_status(mut self, input: crate::model::CandidateStatus) -> Self {
            self.candidate_status = Some(input);
            self
        }
        pub fn set_candidate_status(
            mut self,
            input: std::option::Option<crate::model::CandidateStatus>,
        ) -> Self {
            self.candidate_status = input;
            self
        }
        pub fn inference_containers(
            mut self,
            input: impl Into<crate::model::AutoMlContainerDefinition>,
        ) -> Self {
            let mut v = self.inference_containers.unwrap_or_default();
            v.push(input.into());
            self.inference_containers = Some(v);
            self
        }
        pub fn set_inference_containers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlContainerDefinition>>,
        ) -> Self {
            self.inference_containers = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The end time.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The last modified time.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The failure reason.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The AutoML candidate's properties.</p>
        pub fn candidate_properties(mut self, input: crate::model::CandidateProperties) -> Self {
            self.candidate_properties = Some(input);
            self
        }
        pub fn set_candidate_properties(
            mut self,
            input: std::option::Option<crate::model::CandidateProperties>,
        ) -> Self {
            self.candidate_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlCandidate`](crate::model::AutoMlCandidate)
        pub fn build(self) -> crate::model::AutoMlCandidate {
            crate::model::AutoMlCandidate {
                candidate_name: self.candidate_name,
                final_auto_ml_job_objective_metric: self.final_auto_ml_job_objective_metric,
                objective_status: self.objective_status,
                candidate_steps: self.candidate_steps,
                candidate_status: self.candidate_status,
                inference_containers: self.inference_containers,
                creation_time: self.creation_time,
                end_time: self.end_time,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                candidate_properties: self.candidate_properties,
            }
        }
    }
}
impl AutoMlCandidate {
    /// Creates a new builder-style object to manufacture [`AutoMlCandidate`](crate::model::AutoMlCandidate)
    pub fn builder() -> crate::model::auto_ml_candidate::Builder {
        crate::model::auto_ml_candidate::Builder::default()
    }
}

/// <p>The properties of an AutoML candidate job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CandidateProperties {
    /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
    pub candidate_artifact_locations: std::option::Option<crate::model::CandidateArtifactLocations>,
}
impl std::fmt::Debug for CandidateProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CandidateProperties");
        formatter.field(
            "candidate_artifact_locations",
            &self.candidate_artifact_locations,
        );
        formatter.finish()
    }
}
/// See [`CandidateProperties`](crate::model::CandidateProperties)
pub mod candidate_properties {
    /// A builder for [`CandidateProperties`](crate::model::CandidateProperties)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_artifact_locations:
            std::option::Option<crate::model::CandidateArtifactLocations>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix to the artifacts generated for an AutoML candidate.</p>
        pub fn candidate_artifact_locations(
            mut self,
            input: crate::model::CandidateArtifactLocations,
        ) -> Self {
            self.candidate_artifact_locations = Some(input);
            self
        }
        pub fn set_candidate_artifact_locations(
            mut self,
            input: std::option::Option<crate::model::CandidateArtifactLocations>,
        ) -> Self {
            self.candidate_artifact_locations = input;
            self
        }
        /// Consumes the builder and constructs a [`CandidateProperties`](crate::model::CandidateProperties)
        pub fn build(self) -> crate::model::CandidateProperties {
            crate::model::CandidateProperties {
                candidate_artifact_locations: self.candidate_artifact_locations,
            }
        }
    }
}
impl CandidateProperties {
    /// Creates a new builder-style object to manufacture [`CandidateProperties`](crate::model::CandidateProperties)
    pub fn builder() -> crate::model::candidate_properties::Builder {
        crate::model::candidate_properties::Builder::default()
    }
}

/// <p>The location of artifacts for an AutoML candidate job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CandidateArtifactLocations {
    /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML
    /// candidate.</p>
    pub explainability: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CandidateArtifactLocations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CandidateArtifactLocations");
        formatter.field("explainability", &self.explainability);
        formatter.finish()
    }
}
/// See [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
pub mod candidate_artifact_locations {
    /// A builder for [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) explainability: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 prefix to the explainability artifacts generated for the AutoML
        /// candidate.</p>
        pub fn explainability(mut self, input: impl Into<std::string::String>) -> Self {
            self.explainability = Some(input.into());
            self
        }
        pub fn set_explainability(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.explainability = input;
            self
        }
        /// Consumes the builder and constructs a [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
        pub fn build(self) -> crate::model::CandidateArtifactLocations {
            crate::model::CandidateArtifactLocations {
                explainability: self.explainability,
            }
        }
    }
}
impl CandidateArtifactLocations {
    /// Creates a new builder-style object to manufacture [`CandidateArtifactLocations`](crate::model::CandidateArtifactLocations)
    pub fn builder() -> crate::model::candidate_artifact_locations::Builder {
        crate::model::candidate_artifact_locations::Builder::default()
    }
}

/// <p>A list of container definitions that describe the different containers that make up an
/// AutoML candidate. For more information, see .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlContainerDefinition {
    /// <p>The ECR path of the container. For more information, see .</p>
    pub image: std::option::Option<std::string::String>,
    /// <p>The location of the model artifacts. For more information, see .</p>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the container. For more information, see .</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for AutoMlContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlContainerDefinition");
        formatter.field("image", &self.image);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
pub mod auto_ml_container_definition {
    /// A builder for [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ECR path of the container. For more information, see .</p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>The location of the model artifacts. For more information, see .</p>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
        pub fn build(self) -> crate::model::AutoMlContainerDefinition {
            crate::model::AutoMlContainerDefinition {
                image: self.image,
                model_data_url: self.model_data_url,
                environment: self.environment,
            }
        }
    }
}
impl AutoMlContainerDefinition {
    /// Creates a new builder-style object to manufacture [`AutoMlContainerDefinition`](crate::model::AutoMlContainerDefinition)
    pub fn builder() -> crate::model::auto_ml_container_definition::Builder {
        crate::model::auto_ml_container_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => CandidateStatus::Completed,
            "Failed" => CandidateStatus::Failed,
            "InProgress" => CandidateStatus::InProgress,
            "Stopped" => CandidateStatus::Stopped,
            "Stopping" => CandidateStatus::Stopping,
            other => CandidateStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateStatus::from(s))
    }
}
impl CandidateStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CandidateStatus::Completed => "Completed",
            CandidateStatus::Failed => "Failed",
            CandidateStatus::InProgress => "InProgress",
            CandidateStatus::Stopped => "Stopped",
            CandidateStatus::Stopping => "Stopping",
            CandidateStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for CandidateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the steps for a candidate and what step it is working on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlCandidateStep {
    /// <p>Whether the candidate is at the transform, training, or processing step.</p>
    pub candidate_step_type: std::option::Option<crate::model::CandidateStepType>,
    /// <p>The ARN for the candidate's step.</p>
    pub candidate_step_arn: std::option::Option<std::string::String>,
    /// <p>The name for the candidate's step.</p>
    pub candidate_step_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMlCandidateStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlCandidateStep");
        formatter.field("candidate_step_type", &self.candidate_step_type);
        formatter.field("candidate_step_arn", &self.candidate_step_arn);
        formatter.field("candidate_step_name", &self.candidate_step_name);
        formatter.finish()
    }
}
/// See [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
pub mod auto_ml_candidate_step {
    /// A builder for [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_step_type: std::option::Option<crate::model::CandidateStepType>,
        pub(crate) candidate_step_arn: std::option::Option<std::string::String>,
        pub(crate) candidate_step_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the candidate is at the transform, training, or processing step.</p>
        pub fn candidate_step_type(mut self, input: crate::model::CandidateStepType) -> Self {
            self.candidate_step_type = Some(input);
            self
        }
        pub fn set_candidate_step_type(
            mut self,
            input: std::option::Option<crate::model::CandidateStepType>,
        ) -> Self {
            self.candidate_step_type = input;
            self
        }
        /// <p>The ARN for the candidate's step.</p>
        pub fn candidate_step_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_step_arn = Some(input.into());
            self
        }
        pub fn set_candidate_step_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_step_arn = input;
            self
        }
        /// <p>The name for the candidate's step.</p>
        pub fn candidate_step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.candidate_step_name = Some(input.into());
            self
        }
        pub fn set_candidate_step_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_step_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
        pub fn build(self) -> crate::model::AutoMlCandidateStep {
            crate::model::AutoMlCandidateStep {
                candidate_step_type: self.candidate_step_type,
                candidate_step_arn: self.candidate_step_arn,
                candidate_step_name: self.candidate_step_name,
            }
        }
    }
}
impl AutoMlCandidateStep {
    /// Creates a new builder-style object to manufacture [`AutoMlCandidateStep`](crate::model::AutoMlCandidateStep)
    pub fn builder() -> crate::model::auto_ml_candidate_step::Builder {
        crate::model::auto_ml_candidate_step::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateStepType {
    Processing,
    Training,
    Transform,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateStepType {
    fn from(s: &str) -> Self {
        match s {
            "AWS::SageMaker::ProcessingJob" => CandidateStepType::Processing,
            "AWS::SageMaker::TrainingJob" => CandidateStepType::Training,
            "AWS::SageMaker::TransformJob" => CandidateStepType::Transform,
            other => CandidateStepType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateStepType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateStepType::from(s))
    }
}
impl CandidateStepType {
    pub fn as_str(&self) -> &str {
        match self {
            CandidateStepType::Processing => "AWS::SageMaker::ProcessingJob",
            CandidateStepType::Training => "AWS::SageMaker::TrainingJob",
            CandidateStepType::Transform => "AWS::SageMaker::TransformJob",
            CandidateStepType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS::SageMaker::ProcessingJob",
            "AWS::SageMaker::TrainingJob",
            "AWS::SageMaker::TransformJob",
        ]
    }
}
impl AsRef<str> for CandidateStepType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The best candidate result from an AutoML training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinalAutoMlJobObjectiveMetric {
    /// <p>The type of metric with the best result.</p>
    pub r#type: std::option::Option<crate::model::AutoMlJobObjectiveType>,
    /// <p>The name of the metric with the best result. For a description of the possible objective
    /// metrics, see <a>AutoMLJobObjective$MetricName</a>.</p>
    pub metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
    /// <p>The value of the metric with the best result.</p>
    pub value: f32,
}
impl std::fmt::Debug for FinalAutoMlJobObjectiveMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinalAutoMlJobObjectiveMetric");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
pub mod final_auto_ml_job_objective_metric {
    /// A builder for [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::AutoMlJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
        pub(crate) value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The type of metric with the best result.</p>
        pub fn r#type(mut self, input: crate::model::AutoMlJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the metric with the best result. For a description of the possible objective
        /// metrics, see <a>AutoMLJobObjective$MetricName</a>.</p>
        pub fn metric_name(mut self, input: crate::model::AutoMlMetricEnum) -> Self {
            self.metric_name = Some(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricEnum>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The value of the metric with the best result.</p>
        pub fn value(mut self, input: f32) -> Self {
            self.value = Some(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<f32>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
        pub fn build(self) -> crate::model::FinalAutoMlJobObjectiveMetric {
            crate::model::FinalAutoMlJobObjectiveMetric {
                r#type: self.r#type,
                metric_name: self.metric_name,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl FinalAutoMlJobObjectiveMetric {
    /// Creates a new builder-style object to manufacture [`FinalAutoMlJobObjectiveMetric`](crate::model::FinalAutoMlJobObjectiveMetric)
    pub fn builder() -> crate::model::final_auto_ml_job_objective_metric::Builder {
        crate::model::final_auto_ml_job_objective_metric::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlMetricEnum {
    Auc,
    Accuracy,
    F1,
    F1Macro,
    Mse,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlMetricEnum {
    fn from(s: &str) -> Self {
        match s {
            "AUC" => AutoMlMetricEnum::Auc,
            "Accuracy" => AutoMlMetricEnum::Accuracy,
            "F1" => AutoMlMetricEnum::F1,
            "F1macro" => AutoMlMetricEnum::F1Macro,
            "MSE" => AutoMlMetricEnum::Mse,
            other => AutoMlMetricEnum::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlMetricEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlMetricEnum::from(s))
    }
}
impl AutoMlMetricEnum {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlMetricEnum::Auc => "AUC",
            AutoMlMetricEnum::Accuracy => "Accuracy",
            AutoMlMetricEnum::F1 => "F1",
            AutoMlMetricEnum::F1Macro => "F1macro",
            AutoMlMetricEnum::Mse => "MSE",
            AutoMlMetricEnum::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AUC", "Accuracy", "F1", "F1macro", "MSE"]
    }
}
impl AsRef<str> for AutoMlMetricEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobObjectiveType {
    Maximize,
    Minimize,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobObjectiveType {
    fn from(s: &str) -> Self {
        match s {
            "Maximize" => AutoMlJobObjectiveType::Maximize,
            "Minimize" => AutoMlJobObjectiveType::Minimize,
            other => AutoMlJobObjectiveType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobObjectiveType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobObjectiveType::from(s))
    }
}
impl AutoMlJobObjectiveType {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobObjectiveType::Maximize => "Maximize",
            AutoMlJobObjectiveType::Minimize => "Minimize",
            AutoMlJobObjectiveType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Maximize", "Minimize"]
    }
}
impl AsRef<str> for AutoMlJobObjectiveType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CandidateSortBy {
    CreationTime,
    FinalObjectiveMetricValue,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CandidateSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => CandidateSortBy::CreationTime,
            "FinalObjectiveMetricValue" => CandidateSortBy::FinalObjectiveMetricValue,
            "Status" => CandidateSortBy::Status,
            other => CandidateSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CandidateSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CandidateSortBy::from(s))
    }
}
impl CandidateSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            CandidateSortBy::CreationTime => "CreationTime",
            CandidateSortBy::FinalObjectiveMetricValue => "FinalObjectiveMetricValue",
            CandidateSortBy::Status => "Status",
            CandidateSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "FinalObjectiveMetricValue", "Status"]
    }
}
impl AsRef<str> for CandidateSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlSortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlSortOrder {
    fn from(s: &str) -> Self {
        match s {
            "Ascending" => AutoMlSortOrder::Ascending,
            "Descending" => AutoMlSortOrder::Descending,
            other => AutoMlSortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlSortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlSortOrder::from(s))
    }
}
impl AutoMlSortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlSortOrder::Ascending => "Ascending",
            AutoMlSortOrder::Descending => "Descending",
            AutoMlSortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Ascending", "Descending"]
    }
}
impl AsRef<str> for AutoMlSortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides a summary about an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobSummary {
    /// <p>The name of the AutoML you are requesting.</p>
    pub auto_ml_job_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the AutoML job.</p>
    pub auto_ml_job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the AutoML job.</p>
    pub auto_ml_job_status: std::option::Option<crate::model::AutoMlJobStatus>,
    /// <p>The secondary status of the AutoML job.</p>
    pub auto_ml_job_secondary_status: std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
    /// <p>When the AutoML job was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The end time of an AutoML job.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the AutoML job was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The failure reason of an AutoML job.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The list of reasons for partial failures within an AutoML job.</p>
    pub partial_failure_reasons:
        std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
}
impl std::fmt::Debug for AutoMlJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobSummary");
        formatter.field("auto_ml_job_name", &self.auto_ml_job_name);
        formatter.field("auto_ml_job_arn", &self.auto_ml_job_arn);
        formatter.field("auto_ml_job_status", &self.auto_ml_job_status);
        formatter.field(
            "auto_ml_job_secondary_status",
            &self.auto_ml_job_secondary_status,
        );
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("partial_failure_reasons", &self.partial_failure_reasons);
        formatter.finish()
    }
}
/// See [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
pub mod auto_ml_job_summary {
    /// A builder for [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_ml_job_name: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_arn: std::option::Option<std::string::String>,
        pub(crate) auto_ml_job_status: std::option::Option<crate::model::AutoMlJobStatus>,
        pub(crate) auto_ml_job_secondary_status:
            std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) partial_failure_reasons:
            std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
    }
    impl Builder {
        /// <p>The name of the AutoML you are requesting.</p>
        pub fn auto_ml_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_name = Some(input.into());
            self
        }
        pub fn set_auto_ml_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_name = input;
            self
        }
        /// <p>The ARN of the AutoML job.</p>
        pub fn auto_ml_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_ml_job_arn = Some(input.into());
            self
        }
        pub fn set_auto_ml_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_ml_job_arn = input;
            self
        }
        /// <p>The status of the AutoML job.</p>
        pub fn auto_ml_job_status(mut self, input: crate::model::AutoMlJobStatus) -> Self {
            self.auto_ml_job_status = Some(input);
            self
        }
        pub fn set_auto_ml_job_status(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobStatus>,
        ) -> Self {
            self.auto_ml_job_status = input;
            self
        }
        /// <p>The secondary status of the AutoML job.</p>
        pub fn auto_ml_job_secondary_status(
            mut self,
            input: crate::model::AutoMlJobSecondaryStatus,
        ) -> Self {
            self.auto_ml_job_secondary_status = Some(input);
            self
        }
        pub fn set_auto_ml_job_secondary_status(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobSecondaryStatus>,
        ) -> Self {
            self.auto_ml_job_secondary_status = input;
            self
        }
        /// <p>When the AutoML job was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The end time of an AutoML job.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>When the AutoML job was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The failure reason of an AutoML job.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        pub fn partial_failure_reasons(
            mut self,
            input: impl Into<crate::model::AutoMlPartialFailureReason>,
        ) -> Self {
            let mut v = self.partial_failure_reasons.unwrap_or_default();
            v.push(input.into());
            self.partial_failure_reasons = Some(v);
            self
        }
        pub fn set_partial_failure_reasons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutoMlPartialFailureReason>>,
        ) -> Self {
            self.partial_failure_reasons = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
        pub fn build(self) -> crate::model::AutoMlJobSummary {
            crate::model::AutoMlJobSummary {
                auto_ml_job_name: self.auto_ml_job_name,
                auto_ml_job_arn: self.auto_ml_job_arn,
                auto_ml_job_status: self.auto_ml_job_status,
                auto_ml_job_secondary_status: self.auto_ml_job_secondary_status,
                creation_time: self.creation_time,
                end_time: self.end_time,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                partial_failure_reasons: self.partial_failure_reasons,
            }
        }
    }
}
impl AutoMlJobSummary {
    /// Creates a new builder-style object to manufacture [`AutoMlJobSummary`](crate::model::AutoMlJobSummary)
    pub fn builder() -> crate::model::auto_ml_job_summary::Builder {
        crate::model::auto_ml_job_summary::Builder::default()
    }
}

/// <p>The reason for a partial failure of an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlPartialFailureReason {
    /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
    pub partial_failure_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMlPartialFailureReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlPartialFailureReason");
        formatter.field("partial_failure_message", &self.partial_failure_message);
        formatter.finish()
    }
}
/// See [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
pub mod auto_ml_partial_failure_reason {
    /// A builder for [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partial_failure_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message containing the reason for a partial failure of an AutoML job.</p>
        pub fn partial_failure_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.partial_failure_message = Some(input.into());
            self
        }
        pub fn set_partial_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partial_failure_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
        pub fn build(self) -> crate::model::AutoMlPartialFailureReason {
            crate::model::AutoMlPartialFailureReason {
                partial_failure_message: self.partial_failure_message,
            }
        }
    }
}
impl AutoMlPartialFailureReason {
    /// Creates a new builder-style object to manufacture [`AutoMlPartialFailureReason`](crate::model::AutoMlPartialFailureReason)
    pub fn builder() -> crate::model::auto_ml_partial_failure_reason::Builder {
        crate::model::auto_ml_partial_failure_reason::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobSecondaryStatus {
    AnalyzingData,
    CandidateDefinitionsGenerated,
    Completed,
    DeployingModel,
    ExplainabilityError,
    Failed,
    FeatureEngineering,
    GeneratingExplainabilityReport,
    MaxAutoMlJobRuntimeReached,
    MaxCandidatesReached,
    ModelDeploymentError,
    ModelTuning,
    Starting,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobSecondaryStatus {
    fn from(s: &str) -> Self {
        match s {
            "AnalyzingData" => AutoMlJobSecondaryStatus::AnalyzingData,
            "CandidateDefinitionsGenerated" => {
                AutoMlJobSecondaryStatus::CandidateDefinitionsGenerated
            }
            "Completed" => AutoMlJobSecondaryStatus::Completed,
            "DeployingModel" => AutoMlJobSecondaryStatus::DeployingModel,
            "ExplainabilityError" => AutoMlJobSecondaryStatus::ExplainabilityError,
            "Failed" => AutoMlJobSecondaryStatus::Failed,
            "FeatureEngineering" => AutoMlJobSecondaryStatus::FeatureEngineering,
            "GeneratingExplainabilityReport" => {
                AutoMlJobSecondaryStatus::GeneratingExplainabilityReport
            }
            "MaxAutoMLJobRuntimeReached" => AutoMlJobSecondaryStatus::MaxAutoMlJobRuntimeReached,
            "MaxCandidatesReached" => AutoMlJobSecondaryStatus::MaxCandidatesReached,
            "ModelDeploymentError" => AutoMlJobSecondaryStatus::ModelDeploymentError,
            "ModelTuning" => AutoMlJobSecondaryStatus::ModelTuning,
            "Starting" => AutoMlJobSecondaryStatus::Starting,
            "Stopped" => AutoMlJobSecondaryStatus::Stopped,
            "Stopping" => AutoMlJobSecondaryStatus::Stopping,
            other => AutoMlJobSecondaryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobSecondaryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobSecondaryStatus::from(s))
    }
}
impl AutoMlJobSecondaryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobSecondaryStatus::AnalyzingData => "AnalyzingData",
            AutoMlJobSecondaryStatus::CandidateDefinitionsGenerated => {
                "CandidateDefinitionsGenerated"
            }
            AutoMlJobSecondaryStatus::Completed => "Completed",
            AutoMlJobSecondaryStatus::DeployingModel => "DeployingModel",
            AutoMlJobSecondaryStatus::ExplainabilityError => "ExplainabilityError",
            AutoMlJobSecondaryStatus::Failed => "Failed",
            AutoMlJobSecondaryStatus::FeatureEngineering => "FeatureEngineering",
            AutoMlJobSecondaryStatus::GeneratingExplainabilityReport => {
                "GeneratingExplainabilityReport"
            }
            AutoMlJobSecondaryStatus::MaxAutoMlJobRuntimeReached => "MaxAutoMLJobRuntimeReached",
            AutoMlJobSecondaryStatus::MaxCandidatesReached => "MaxCandidatesReached",
            AutoMlJobSecondaryStatus::ModelDeploymentError => "ModelDeploymentError",
            AutoMlJobSecondaryStatus::ModelTuning => "ModelTuning",
            AutoMlJobSecondaryStatus::Starting => "Starting",
            AutoMlJobSecondaryStatus::Stopped => "Stopped",
            AutoMlJobSecondaryStatus::Stopping => "Stopping",
            AutoMlJobSecondaryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AnalyzingData",
            "CandidateDefinitionsGenerated",
            "Completed",
            "DeployingModel",
            "ExplainabilityError",
            "Failed",
            "FeatureEngineering",
            "GeneratingExplainabilityReport",
            "MaxAutoMLJobRuntimeReached",
            "MaxCandidatesReached",
            "ModelDeploymentError",
            "ModelTuning",
            "Starting",
            "Stopped",
            "Stopping",
        ]
    }
}
impl AsRef<str> for AutoMlJobSecondaryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlJobStatus {
    Completed,
    Failed,
    InProgress,
    Stopped,
    Stopping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => AutoMlJobStatus::Completed,
            "Failed" => AutoMlJobStatus::Failed,
            "InProgress" => AutoMlJobStatus::InProgress,
            "Stopped" => AutoMlJobStatus::Stopped,
            "Stopping" => AutoMlJobStatus::Stopping,
            other => AutoMlJobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlJobStatus::from(s))
    }
}
impl AutoMlJobStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlJobStatus::Completed => "Completed",
            AutoMlJobStatus::Failed => "Failed",
            AutoMlJobStatus::InProgress => "InProgress",
            AutoMlJobStatus::Stopped => "Stopped",
            AutoMlJobStatus::Stopping => "Stopping",
            AutoMlJobStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "Stopped", "Stopping"]
    }
}
impl AsRef<str> for AutoMlJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMlSortBy {
    CreationTime,
    Name,
    Status,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMlSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AutoMlSortBy::CreationTime,
            "Name" => AutoMlSortBy::Name,
            "Status" => AutoMlSortBy::Status,
            other => AutoMlSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMlSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMlSortBy::from(s))
    }
}
impl AutoMlSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMlSortBy::CreationTime => "CreationTime",
            AutoMlSortBy::Name => "Name",
            AutoMlSortBy::Status => "Status",
            AutoMlSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name", "Status"]
    }
}
impl AsRef<str> for AutoMlSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of an association. An association is an entity that
/// links other lineage or experiment entities. An example would be an association between a
/// training job and a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociationSummary {
    /// <p>The ARN of the source.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p>The source type.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The destination type.</p>
    pub destination_type: std::option::Option<std::string::String>,
    /// <p>The type of the association.</p>
    pub association_type: std::option::Option<crate::model::AssociationEdgeType>,
    /// <p>The name of the source.</p>
    pub source_name: std::option::Option<std::string::String>,
    /// <p>The name of the destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>When the association was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Information about the user who created or modified an experiment, trial, or trial
    /// component.</p>
    pub created_by: std::option::Option<crate::model::UserContext>,
}
impl std::fmt::Debug for AssociationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociationSummary");
        formatter.field("source_arn", &self.source_arn);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("source_type", &self.source_type);
        formatter.field("destination_type", &self.destination_type);
        formatter.field("association_type", &self.association_type);
        formatter.field("source_name", &self.source_name);
        formatter.field("destination_name", &self.destination_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("created_by", &self.created_by);
        formatter.finish()
    }
}
/// See [`AssociationSummary`](crate::model::AssociationSummary)
pub mod association_summary {
    /// A builder for [`AssociationSummary`](crate::model::AssociationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) destination_type: std::option::Option<std::string::String>,
        pub(crate) association_type: std::option::Option<crate::model::AssociationEdgeType>,
        pub(crate) source_name: std::option::Option<std::string::String>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<crate::model::UserContext>,
    }
    impl Builder {
        /// <p>The ARN of the source.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p>The source type.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The destination type.</p>
        pub fn destination_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_type = Some(input.into());
            self
        }
        pub fn set_destination_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_type = input;
            self
        }
        /// <p>The type of the association.</p>
        pub fn association_type(mut self, input: crate::model::AssociationEdgeType) -> Self {
            self.association_type = Some(input);
            self
        }
        pub fn set_association_type(
            mut self,
            input: std::option::Option<crate::model::AssociationEdgeType>,
        ) -> Self {
            self.association_type = input;
            self
        }
        /// <p>The name of the source.</p>
        pub fn source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_name = Some(input.into());
            self
        }
        pub fn set_source_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_name = input;
            self
        }
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>When the association was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the user who created or modified an experiment, trial, or trial
        /// component.</p>
        pub fn created_by(mut self, input: crate::model::UserContext) -> Self {
            self.created_by = Some(input);
            self
        }
        pub fn set_created_by(
            mut self,
            input: std::option::Option<crate::model::UserContext>,
        ) -> Self {
            self.created_by = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociationSummary`](crate::model::AssociationSummary)
        pub fn build(self) -> crate::model::AssociationSummary {
            crate::model::AssociationSummary {
                source_arn: self.source_arn,
                destination_arn: self.destination_arn,
                source_type: self.source_type,
                destination_type: self.destination_type,
                association_type: self.association_type,
                source_name: self.source_name,
                destination_name: self.destination_name,
                creation_time: self.creation_time,
                created_by: self.created_by,
            }
        }
    }
}
impl AssociationSummary {
    /// Creates a new builder-style object to manufacture [`AssociationSummary`](crate::model::AssociationSummary)
    pub fn builder() -> crate::model::association_summary::Builder {
        crate::model::association_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationEdgeType {
    AssociatedWith,
    ContributedTo,
    DerivedFrom,
    Produced,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssociationEdgeType {
    fn from(s: &str) -> Self {
        match s {
            "AssociatedWith" => AssociationEdgeType::AssociatedWith,
            "ContributedTo" => AssociationEdgeType::ContributedTo,
            "DerivedFrom" => AssociationEdgeType::DerivedFrom,
            "Produced" => AssociationEdgeType::Produced,
            other => AssociationEdgeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssociationEdgeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociationEdgeType::from(s))
    }
}
impl AssociationEdgeType {
    pub fn as_str(&self) -> &str {
        match self {
            AssociationEdgeType::AssociatedWith => "AssociatedWith",
            AssociationEdgeType::ContributedTo => "ContributedTo",
            AssociationEdgeType::DerivedFrom => "DerivedFrom",
            AssociationEdgeType::Produced => "Produced",
            AssociationEdgeType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AssociatedWith", "ContributedTo", "DerivedFrom", "Produced"]
    }
}
impl AsRef<str> for AssociationEdgeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortAssociationsBy {
    CreationTime,
    DestinationArn,
    DestinationType,
    SourceArn,
    SourceType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortAssociationsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortAssociationsBy::CreationTime,
            "DestinationArn" => SortAssociationsBy::DestinationArn,
            "DestinationType" => SortAssociationsBy::DestinationType,
            "SourceArn" => SortAssociationsBy::SourceArn,
            "SourceType" => SortAssociationsBy::SourceType,
            other => SortAssociationsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortAssociationsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortAssociationsBy::from(s))
    }
}
impl SortAssociationsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortAssociationsBy::CreationTime => "CreationTime",
            SortAssociationsBy::DestinationArn => "DestinationArn",
            SortAssociationsBy::DestinationType => "DestinationType",
            SortAssociationsBy::SourceArn => "SourceArn",
            SortAssociationsBy::SourceType => "SourceType",
            SortAssociationsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CreationTime",
            "DestinationArn",
            "DestinationType",
            "SourceArn",
            "SourceType",
        ]
    }
}
impl AsRef<str> for SortAssociationsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists a summary of the properties of an artifact. An artifact represents a URI
/// addressable object or data. Some examples are a dataset and a model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSummary {
    /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
    pub artifact_arn: std::option::Option<std::string::String>,
    /// <p>The name of the artifact.</p>
    pub artifact_name: std::option::Option<std::string::String>,
    /// <p>The source of the artifact.</p>
    pub source: std::option::Option<crate::model::ArtifactSource>,
    /// <p>The type of the artifact.</p>
    pub artifact_type: std::option::Option<std::string::String>,
    /// <p>When the artifact was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the artifact was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ArtifactSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSummary");
        formatter.field("artifact_arn", &self.artifact_arn);
        formatter.field("artifact_name", &self.artifact_name);
        formatter.field("source", &self.source);
        formatter.field("artifact_type", &self.artifact_type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ArtifactSummary`](crate::model::ArtifactSummary)
pub mod artifact_summary {
    /// A builder for [`ArtifactSummary`](crate::model::ArtifactSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_arn: std::option::Option<std::string::String>,
        pub(crate) artifact_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ArtifactSource>,
        pub(crate) artifact_type: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the artifact.</p>
        pub fn artifact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_arn = Some(input.into());
            self
        }
        pub fn set_artifact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.artifact_arn = input;
            self
        }
        /// <p>The name of the artifact.</p>
        pub fn artifact_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_name = Some(input.into());
            self
        }
        pub fn set_artifact_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_name = input;
            self
        }
        /// <p>The source of the artifact.</p>
        pub fn source(mut self, input: crate::model::ArtifactSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ArtifactSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the artifact.</p>
        pub fn artifact_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_type = Some(input.into());
            self
        }
        pub fn set_artifact_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_type = input;
            self
        }
        /// <p>When the artifact was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the artifact was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSummary`](crate::model::ArtifactSummary)
        pub fn build(self) -> crate::model::ArtifactSummary {
            crate::model::ArtifactSummary {
                artifact_arn: self.artifact_arn,
                artifact_name: self.artifact_name,
                source: self.source,
                artifact_type: self.artifact_type,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ArtifactSummary {
    /// Creates a new builder-style object to manufacture [`ArtifactSummary`](crate::model::ArtifactSummary)
    pub fn builder() -> crate::model::artifact_summary::Builder {
        crate::model::artifact_summary::Builder::default()
    }
}

/// <p>A structure describing the source of an artifact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>A list of source types.</p>
    pub source_types: std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
}
impl std::fmt::Debug for ArtifactSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_types", &self.source_types);
        formatter.finish()
    }
}
/// See [`ArtifactSource`](crate::model::ArtifactSource)
pub mod artifact_source {
    /// A builder for [`ArtifactSource`](crate::model::ArtifactSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_types:
            std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        pub fn source_types(mut self, input: impl Into<crate::model::ArtifactSourceType>) -> Self {
            let mut v = self.source_types.unwrap_or_default();
            v.push(input.into());
            self.source_types = Some(v);
            self
        }
        pub fn set_source_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ArtifactSourceType>>,
        ) -> Self {
            self.source_types = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSource`](crate::model::ArtifactSource)
        pub fn build(self) -> crate::model::ArtifactSource {
            crate::model::ArtifactSource {
                source_uri: self.source_uri,
                source_types: self.source_types,
            }
        }
    }
}
impl ArtifactSource {
    /// Creates a new builder-style object to manufacture [`ArtifactSource`](crate::model::ArtifactSource)
    pub fn builder() -> crate::model::artifact_source::Builder {
        crate::model::artifact_source::Builder::default()
    }
}

/// <p>The ID and ID type of an artifact source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArtifactSourceType {
    /// <p>The type of ID.</p>
    pub source_id_type: std::option::Option<crate::model::ArtifactSourceIdType>,
    /// <p>The ID.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ArtifactSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArtifactSourceType");
        formatter.field("source_id_type", &self.source_id_type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ArtifactSourceType`](crate::model::ArtifactSourceType)
pub mod artifact_source_type {
    /// A builder for [`ArtifactSourceType`](crate::model::ArtifactSourceType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_id_type: std::option::Option<crate::model::ArtifactSourceIdType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of ID.</p>
        pub fn source_id_type(mut self, input: crate::model::ArtifactSourceIdType) -> Self {
            self.source_id_type = Some(input);
            self
        }
        pub fn set_source_id_type(
            mut self,
            input: std::option::Option<crate::model::ArtifactSourceIdType>,
        ) -> Self {
            self.source_id_type = input;
            self
        }
        /// <p>The ID.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ArtifactSourceType`](crate::model::ArtifactSourceType)
        pub fn build(self) -> crate::model::ArtifactSourceType {
            crate::model::ArtifactSourceType {
                source_id_type: self.source_id_type,
                value: self.value,
            }
        }
    }
}
impl ArtifactSourceType {
    /// Creates a new builder-style object to manufacture [`ArtifactSourceType`](crate::model::ArtifactSourceType)
    pub fn builder() -> crate::model::artifact_source_type::Builder {
        crate::model::artifact_source_type::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArtifactSourceIdType {
    Custom,
    Md5Hash,
    S3Etag,
    S3Version,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ArtifactSourceIdType {
    fn from(s: &str) -> Self {
        match s {
            "Custom" => ArtifactSourceIdType::Custom,
            "MD5Hash" => ArtifactSourceIdType::Md5Hash,
            "S3ETag" => ArtifactSourceIdType::S3Etag,
            "S3Version" => ArtifactSourceIdType::S3Version,
            other => ArtifactSourceIdType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ArtifactSourceIdType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArtifactSourceIdType::from(s))
    }
}
impl ArtifactSourceIdType {
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactSourceIdType::Custom => "Custom",
            ArtifactSourceIdType::Md5Hash => "MD5Hash",
            ArtifactSourceIdType::S3Etag => "S3ETag",
            ArtifactSourceIdType::S3Version => "S3Version",
            ArtifactSourceIdType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Custom", "MD5Hash", "S3ETag", "S3Version"]
    }
}
impl AsRef<str> for ArtifactSourceIdType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortArtifactsBy {
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortArtifactsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortArtifactsBy::CreationTime,
            other => SortArtifactsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortArtifactsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortArtifactsBy::from(s))
    }
}
impl SortArtifactsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortArtifactsBy::CreationTime => "CreationTime",
            SortArtifactsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for SortArtifactsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details about an Amazon SageMaker app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppDetails {
    /// <p>The domain ID.</p>
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The user profile name.</p>
    pub user_profile_name: std::option::Option<std::string::String>,
    /// <p>The type of app.</p>
    pub app_type: std::option::Option<crate::model::AppType>,
    /// <p>The name of the app.</p>
    pub app_name: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    pub status: std::option::Option<crate::model::AppStatus>,
    /// <p>The creation time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for AppDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppDetails");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("user_profile_name", &self.user_profile_name);
        formatter.field("app_type", &self.app_type);
        formatter.field("app_name", &self.app_name);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`AppDetails`](crate::model::AppDetails)
pub mod app_details {
    /// A builder for [`AppDetails`](crate::model::AppDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) user_profile_name: std::option::Option<std::string::String>,
        pub(crate) app_type: std::option::Option<crate::model::AppType>,
        pub(crate) app_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AppStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The domain ID.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The user profile name.</p>
        pub fn user_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_profile_name = Some(input.into());
            self
        }
        pub fn set_user_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_profile_name = input;
            self
        }
        /// <p>The type of app.</p>
        pub fn app_type(mut self, input: crate::model::AppType) -> Self {
            self.app_type = Some(input);
            self
        }
        pub fn set_app_type(mut self, input: std::option::Option<crate::model::AppType>) -> Self {
            self.app_type = input;
            self
        }
        /// <p>The name of the app.</p>
        pub fn app_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_name = Some(input.into());
            self
        }
        pub fn set_app_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_name = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::AppStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::AppStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`AppDetails`](crate::model::AppDetails)
        pub fn build(self) -> crate::model::AppDetails {
            crate::model::AppDetails {
                domain_id: self.domain_id,
                user_profile_name: self.user_profile_name,
                app_type: self.app_type,
                app_name: self.app_name,
                status: self.status,
                creation_time: self.creation_time,
            }
        }
    }
}
impl AppDetails {
    /// Creates a new builder-style object to manufacture [`AppDetails`](crate::model::AppDetails)
    pub fn builder() -> crate::model::app_details::Builder {
        crate::model::app_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppStatus {
    Deleted,
    Deleting,
    Failed,
    InService,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppStatus {
    fn from(s: &str) -> Self {
        match s {
            "Deleted" => AppStatus::Deleted,
            "Deleting" => AppStatus::Deleting,
            "Failed" => AppStatus::Failed,
            "InService" => AppStatus::InService,
            "Pending" => AppStatus::Pending,
            other => AppStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppStatus::from(s))
    }
}
impl AppStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AppStatus::Deleted => "Deleted",
            AppStatus::Deleting => "Deleting",
            AppStatus::Failed => "Failed",
            AppStatus::InService => "InService",
            AppStatus::Pending => "Pending",
            AppStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Deleted", "Deleting", "Failed", "InService", "Pending"]
    }
}
impl AsRef<str> for AppStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppType {
    JupyterServer,
    KernelGateway,
    TensorBoard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppType {
    fn from(s: &str) -> Self {
        match s {
            "JupyterServer" => AppType::JupyterServer,
            "KernelGateway" => AppType::KernelGateway,
            "TensorBoard" => AppType::TensorBoard,
            other => AppType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppType::from(s))
    }
}
impl AppType {
    pub fn as_str(&self) -> &str {
        match self {
            AppType::JupyterServer => "JupyterServer",
            AppType::KernelGateway => "KernelGateway",
            AppType::TensorBoard => "TensorBoard",
            AppType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["JupyterServer", "KernelGateway", "TensorBoard"]
    }
}
impl AsRef<str> for AppType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppSortKey {
    CreationTime,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AppSortKey::CreationTime,
            other => AppSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppSortKey::from(s))
    }
}
impl AppSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            AppSortKey::CreationTime => "CreationTime",
            AppSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime"]
    }
}
impl AsRef<str> for AppSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for running a SageMaker image as a KernelGateway app.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppImageConfigDetails {
    /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
    pub app_image_config_arn: std::option::Option<std::string::String>,
    /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
    pub app_image_config_name: std::option::Option<std::string::String>,
    /// <p>When the AppImageConfig was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the AppImageConfig was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
    /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
    pub kernel_gateway_image_config: std::option::Option<crate::model::KernelGatewayImageConfig>,
}
impl std::fmt::Debug for AppImageConfigDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppImageConfigDetails");
        formatter.field("app_image_config_arn", &self.app_image_config_arn);
        formatter.field("app_image_config_name", &self.app_image_config_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field(
            "kernel_gateway_image_config",
            &self.kernel_gateway_image_config,
        );
        formatter.finish()
    }
}
/// See [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
pub mod app_image_config_details {
    /// A builder for [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_image_config_arn: std::option::Option<std::string::String>,
        pub(crate) app_image_config_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
        pub(crate) kernel_gateway_image_config:
            std::option::Option<crate::model::KernelGatewayImageConfig>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the AppImageConfig.</p>
        pub fn app_image_config_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_arn = Some(input.into());
            self
        }
        pub fn set_app_image_config_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_arn = input;
            self
        }
        /// <p>The name of the AppImageConfig. Must be unique to your account.</p>
        pub fn app_image_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_image_config_name = Some(input.into());
            self
        }
        pub fn set_app_image_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_image_config_name = input;
            self
        }
        /// <p>When the AppImageConfig was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the AppImageConfig was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The configuration for the file system and kernels in the SageMaker image.</p>
        pub fn kernel_gateway_image_config(
            mut self,
            input: crate::model::KernelGatewayImageConfig,
        ) -> Self {
            self.kernel_gateway_image_config = Some(input);
            self
        }
        pub fn set_kernel_gateway_image_config(
            mut self,
            input: std::option::Option<crate::model::KernelGatewayImageConfig>,
        ) -> Self {
            self.kernel_gateway_image_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
        pub fn build(self) -> crate::model::AppImageConfigDetails {
            crate::model::AppImageConfigDetails {
                app_image_config_arn: self.app_image_config_arn,
                app_image_config_name: self.app_image_config_name,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                kernel_gateway_image_config: self.kernel_gateway_image_config,
            }
        }
    }
}
impl AppImageConfigDetails {
    /// Creates a new builder-style object to manufacture [`AppImageConfigDetails`](crate::model::AppImageConfigDetails)
    pub fn builder() -> crate::model::app_image_config_details::Builder {
        crate::model::app_image_config_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppImageConfigSortKey {
    CreationTime,
    LastModifiedTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppImageConfigSortKey {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AppImageConfigSortKey::CreationTime,
            "LastModifiedTime" => AppImageConfigSortKey::LastModifiedTime,
            "Name" => AppImageConfigSortKey::Name,
            other => AppImageConfigSortKey::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppImageConfigSortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppImageConfigSortKey::from(s))
    }
}
impl AppImageConfigSortKey {
    pub fn as_str(&self) -> &str {
        match self {
            AppImageConfigSortKey::CreationTime => "CreationTime",
            AppImageConfigSortKey::LastModifiedTime => "LastModifiedTime",
            AppImageConfigSortKey::Name => "Name",
            AppImageConfigSortKey::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "LastModifiedTime", "Name"]
    }
}
impl AsRef<str> for AppImageConfigSortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides summary information about an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmSummary {
    /// <p>The name of the algorithm that is described by the summary.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
    pub algorithm_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the algorithm.</p>
    pub algorithm_description: std::option::Option<std::string::String>,
    /// <p>A timestamp that shows when the algorithm was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The overall status of the algorithm.</p>
    pub algorithm_status: std::option::Option<crate::model::AlgorithmStatus>,
}
impl std::fmt::Debug for AlgorithmSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmSummary");
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("algorithm_arn", &self.algorithm_arn);
        formatter.field("algorithm_description", &self.algorithm_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("algorithm_status", &self.algorithm_status);
        formatter.finish()
    }
}
/// See [`AlgorithmSummary`](crate::model::AlgorithmSummary)
pub mod algorithm_summary {
    /// A builder for [`AlgorithmSummary`](crate::model::AlgorithmSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) algorithm_arn: std::option::Option<std::string::String>,
        pub(crate) algorithm_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) algorithm_status: std::option::Option<crate::model::AlgorithmStatus>,
    }
    impl Builder {
        /// <p>The name of the algorithm that is described by the summary.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the algorithm.</p>
        pub fn algorithm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_arn = Some(input.into());
            self
        }
        pub fn set_algorithm_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_arn = input;
            self
        }
        /// <p>A brief description of the algorithm.</p>
        pub fn algorithm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_description = Some(input.into());
            self
        }
        pub fn set_algorithm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_description = input;
            self
        }
        /// <p>A timestamp that shows when the algorithm was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The overall status of the algorithm.</p>
        pub fn algorithm_status(mut self, input: crate::model::AlgorithmStatus) -> Self {
            self.algorithm_status = Some(input);
            self
        }
        pub fn set_algorithm_status(
            mut self,
            input: std::option::Option<crate::model::AlgorithmStatus>,
        ) -> Self {
            self.algorithm_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmSummary`](crate::model::AlgorithmSummary)
        pub fn build(self) -> crate::model::AlgorithmSummary {
            crate::model::AlgorithmSummary {
                algorithm_name: self.algorithm_name,
                algorithm_arn: self.algorithm_arn,
                algorithm_description: self.algorithm_description,
                creation_time: self.creation_time,
                algorithm_status: self.algorithm_status,
            }
        }
    }
}
impl AlgorithmSummary {
    /// Creates a new builder-style object to manufacture [`AlgorithmSummary`](crate::model::AlgorithmSummary)
    pub fn builder() -> crate::model::algorithm_summary::Builder {
        crate::model::algorithm_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmStatus {
    Completed,
    Deleting,
    Failed,
    InProgress,
    Pending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AlgorithmStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => AlgorithmStatus::Completed,
            "Deleting" => AlgorithmStatus::Deleting,
            "Failed" => AlgorithmStatus::Failed,
            "InProgress" => AlgorithmStatus::InProgress,
            "Pending" => AlgorithmStatus::Pending,
            other => AlgorithmStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AlgorithmStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmStatus::from(s))
    }
}
impl AlgorithmStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmStatus::Completed => "Completed",
            AlgorithmStatus::Deleting => "Deleting",
            AlgorithmStatus::Failed => "Failed",
            AlgorithmStatus::InProgress => "InProgress",
            AlgorithmStatus::Pending => "Pending",
            AlgorithmStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Deleting", "Failed", "InProgress", "Pending"]
    }
}
impl AsRef<str> for AlgorithmStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlgorithmSortBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AlgorithmSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => AlgorithmSortBy::CreationTime,
            "Name" => AlgorithmSortBy::Name,
            other => AlgorithmSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AlgorithmSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlgorithmSortBy::from(s))
    }
}
impl AlgorithmSortBy {
    pub fn as_str(&self) -> &str {
        match self {
            AlgorithmSortBy::CreationTime => "CreationTime",
            AlgorithmSortBy::Name => "Name",
            AlgorithmSortBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for AlgorithmSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists the properties of an <i>action</i>. An action represents an action
/// or activity. Some examples are a workflow step and a model deployment. Generally, an
/// action involves at least one input artifact or output artifact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionSummary {
    /// <p>The Amazon Resource Name (ARN) of the action.</p>
    pub action_arn: std::option::Option<std::string::String>,
    /// <p>The name of the action.</p>
    pub action_name: std::option::Option<std::string::String>,
    /// <p>The source of the action.</p>
    pub source: std::option::Option<crate::model::ActionSource>,
    /// <p>The type of the action.</p>
    pub action_type: std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    pub status: std::option::Option<crate::model::ActionStatus>,
    /// <p>When the action was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>When the action was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ActionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionSummary");
        formatter.field("action_arn", &self.action_arn);
        formatter.field("action_name", &self.action_name);
        formatter.field("source", &self.source);
        formatter.field("action_type", &self.action_type);
        formatter.field("status", &self.status);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ActionSummary`](crate::model::ActionSummary)
pub mod action_summary {
    /// A builder for [`ActionSummary`](crate::model::ActionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_arn: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::ActionSource>,
        pub(crate) action_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ActionStatus>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the action.</p>
        pub fn action_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_arn = Some(input.into());
            self
        }
        pub fn set_action_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_arn = input;
            self
        }
        /// <p>The name of the action.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p>The source of the action.</p>
        pub fn source(mut self, input: crate::model::ActionSource) -> Self {
            self.source = Some(input);
            self
        }
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::ActionSource>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The type of the action.</p>
        pub fn action_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_type = Some(input.into());
            self
        }
        pub fn set_action_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_type = input;
            self
        }
        /// <p>The status of the action.</p>
        pub fn status(mut self, input: crate::model::ActionStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ActionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>When the action was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>When the action was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionSummary`](crate::model::ActionSummary)
        pub fn build(self) -> crate::model::ActionSummary {
            crate::model::ActionSummary {
                action_arn: self.action_arn,
                action_name: self.action_name,
                source: self.source,
                action_type: self.action_type,
                status: self.status,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ActionSummary {
    /// Creates a new builder-style object to manufacture [`ActionSummary`](crate::model::ActionSummary)
    pub fn builder() -> crate::model::action_summary::Builder {
        crate::model::action_summary::Builder::default()
    }
}

/// <p>A structure describing the source of an action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActionSource {
    /// <p>The URI of the source.</p>
    pub source_uri: std::option::Option<std::string::String>,
    /// <p>The type of the source.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The ID of the source.</p>
    pub source_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActionSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActionSource");
        formatter.field("source_uri", &self.source_uri);
        formatter.field("source_type", &self.source_type);
        formatter.field("source_id", &self.source_id);
        formatter.finish()
    }
}
/// See [`ActionSource`](crate::model::ActionSource)
pub mod action_source {
    /// A builder for [`ActionSource`](crate::model::ActionSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_uri: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) source_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URI of the source.</p>
        pub fn source_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_uri = Some(input.into());
            self
        }
        pub fn set_source_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_uri = input;
            self
        }
        /// <p>The type of the source.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The ID of the source.</p>
        pub fn source_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_id = Some(input.into());
            self
        }
        pub fn set_source_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ActionSource`](crate::model::ActionSource)
        pub fn build(self) -> crate::model::ActionSource {
            crate::model::ActionSource {
                source_uri: self.source_uri,
                source_type: self.source_type,
                source_id: self.source_id,
            }
        }
    }
}
impl ActionSource {
    /// Creates a new builder-style object to manufacture [`ActionSource`](crate::model::ActionSource)
    pub fn builder() -> crate::model::action_source::Builder {
        crate::model::action_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortActionsBy {
    CreationTime,
    Name,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortActionsBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationTime" => SortActionsBy::CreationTime,
            "Name" => SortActionsBy::Name,
            other => SortActionsBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortActionsBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortActionsBy::from(s))
    }
}
impl SortActionsBy {
    pub fn as_str(&self) -> &str {
        match self {
            SortActionsBy::CreationTime => "CreationTime",
            SortActionsBy::Name => "Name",
            SortActionsBy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CreationTime", "Name"]
    }
}
impl AsRef<str> for SortActionsBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A property name returned from a <code>GetSearchSuggestions</code> call that specifies
/// a value in the <code>PropertyNameQuery</code> field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyNameSuggestion {
    /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker
    /// console.</p>
    pub property_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PropertyNameSuggestion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyNameSuggestion");
        formatter.field("property_name", &self.property_name);
        formatter.finish()
    }
}
/// See [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
pub mod property_name_suggestion {
    /// A builder for [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A suggested property name based on what you entered in the search textbox in the Amazon SageMaker
        /// console.</p>
        pub fn property_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name = Some(input.into());
            self
        }
        pub fn set_property_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
        pub fn build(self) -> crate::model::PropertyNameSuggestion {
            crate::model::PropertyNameSuggestion {
                property_name: self.property_name,
            }
        }
    }
}
impl PropertyNameSuggestion {
    /// Creates a new builder-style object to manufacture [`PropertyNameSuggestion`](crate::model::PropertyNameSuggestion)
    pub fn builder() -> crate::model::property_name_suggestion::Builder {
        crate::model::property_name_suggestion::Builder::default()
    }
}

/// <p>Specified in the <a>GetSearchSuggestions</a> request.
/// Limits the property names that are included in the response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SuggestionQuery {
    /// <p>Defines a property name hint. Only property
    /// names that begin with the specified hint are included in the response.</p>
    pub property_name_query: std::option::Option<crate::model::PropertyNameQuery>,
}
impl std::fmt::Debug for SuggestionQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SuggestionQuery");
        formatter.field("property_name_query", &self.property_name_query);
        formatter.finish()
    }
}
/// See [`SuggestionQuery`](crate::model::SuggestionQuery)
pub mod suggestion_query {
    /// A builder for [`SuggestionQuery`](crate::model::SuggestionQuery)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name_query: std::option::Option<crate::model::PropertyNameQuery>,
    }
    impl Builder {
        /// <p>Defines a property name hint. Only property
        /// names that begin with the specified hint are included in the response.</p>
        pub fn property_name_query(mut self, input: crate::model::PropertyNameQuery) -> Self {
            self.property_name_query = Some(input);
            self
        }
        pub fn set_property_name_query(
            mut self,
            input: std::option::Option<crate::model::PropertyNameQuery>,
        ) -> Self {
            self.property_name_query = input;
            self
        }
        /// Consumes the builder and constructs a [`SuggestionQuery`](crate::model::SuggestionQuery)
        pub fn build(self) -> crate::model::SuggestionQuery {
            crate::model::SuggestionQuery {
                property_name_query: self.property_name_query,
            }
        }
    }
}
impl SuggestionQuery {
    /// Creates a new builder-style object to manufacture [`SuggestionQuery`](crate::model::SuggestionQuery)
    pub fn builder() -> crate::model::suggestion_query::Builder {
        crate::model::suggestion_query::Builder::default()
    }
}

/// <p>Part of the <code>SuggestionQuery</code> type. Specifies a hint for retrieving property
/// names that begin with the specified text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyNameQuery {
    /// <p>Text that begins a property's name.</p>
    pub property_name_hint: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PropertyNameQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyNameQuery");
        formatter.field("property_name_hint", &self.property_name_hint);
        formatter.finish()
    }
}
/// See [`PropertyNameQuery`](crate::model::PropertyNameQuery)
pub mod property_name_query {
    /// A builder for [`PropertyNameQuery`](crate::model::PropertyNameQuery)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_name_hint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Text that begins a property's name.</p>
        pub fn property_name_hint(mut self, input: impl Into<std::string::String>) -> Self {
            self.property_name_hint = Some(input.into());
            self
        }
        pub fn set_property_name_hint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.property_name_hint = input;
            self
        }
        /// Consumes the builder and constructs a [`PropertyNameQuery`](crate::model::PropertyNameQuery)
        pub fn build(self) -> crate::model::PropertyNameQuery {
            crate::model::PropertyNameQuery {
                property_name_hint: self.property_name_hint,
            }
        }
    }
}
impl PropertyNameQuery {
    /// Creates a new builder-style object to manufacture [`PropertyNameQuery`](crate::model::PropertyNameQuery)
    pub fn builder() -> crate::model::property_name_query::Builder {
        crate::model::property_name_query::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SagemakerServicecatalogStatus {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SagemakerServicecatalogStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => SagemakerServicecatalogStatus::Disabled,
            "Enabled" => SagemakerServicecatalogStatus::Enabled,
            other => SagemakerServicecatalogStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SagemakerServicecatalogStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SagemakerServicecatalogStatus::from(s))
    }
}
impl SagemakerServicecatalogStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SagemakerServicecatalogStatus::Disabled => "Disabled",
            SagemakerServicecatalogStatus::Enabled => "Enabled",
            SagemakerServicecatalogStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for SagemakerServicecatalogStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Status of edge devices with this model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModelStat {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The model version.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The number of devices that have this model version and do not have a heart beat.</p>
    pub offline_device_count: i64,
    /// <p>The number of devices that have this model version and have a heart beat. </p>
    pub connected_device_count: i64,
    /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
    pub active_device_count: i64,
    /// <p>The number of devices with this model version and are producing sample data.</p>
    pub sampling_device_count: i64,
}
impl std::fmt::Debug for EdgeModelStat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModelStat");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("offline_device_count", &self.offline_device_count);
        formatter.field("connected_device_count", &self.connected_device_count);
        formatter.field("active_device_count", &self.active_device_count);
        formatter.field("sampling_device_count", &self.sampling_device_count);
        formatter.finish()
    }
}
/// See [`EdgeModelStat`](crate::model::EdgeModelStat)
pub mod edge_model_stat {
    /// A builder for [`EdgeModelStat`](crate::model::EdgeModelStat)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) offline_device_count: std::option::Option<i64>,
        pub(crate) connected_device_count: std::option::Option<i64>,
        pub(crate) active_device_count: std::option::Option<i64>,
        pub(crate) sampling_device_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The model version.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The number of devices that have this model version and do not have a heart beat.</p>
        pub fn offline_device_count(mut self, input: i64) -> Self {
            self.offline_device_count = Some(input);
            self
        }
        pub fn set_offline_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.offline_device_count = input;
            self
        }
        /// <p>The number of devices that have this model version and have a heart beat. </p>
        pub fn connected_device_count(mut self, input: i64) -> Self {
            self.connected_device_count = Some(input);
            self
        }
        pub fn set_connected_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.connected_device_count = input;
            self
        }
        /// <p>The number of devices that have this model version, a heart beat, and are currently running.</p>
        pub fn active_device_count(mut self, input: i64) -> Self {
            self.active_device_count = Some(input);
            self
        }
        pub fn set_active_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.active_device_count = input;
            self
        }
        /// <p>The number of devices with this model version and are producing sample data.</p>
        pub fn sampling_device_count(mut self, input: i64) -> Self {
            self.sampling_device_count = Some(input);
            self
        }
        pub fn set_sampling_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.sampling_device_count = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModelStat`](crate::model::EdgeModelStat)
        pub fn build(self) -> crate::model::EdgeModelStat {
            crate::model::EdgeModelStat {
                model_name: self.model_name,
                model_version: self.model_version,
                offline_device_count: self.offline_device_count.unwrap_or_default(),
                connected_device_count: self.connected_device_count.unwrap_or_default(),
                active_device_count: self.active_device_count.unwrap_or_default(),
                sampling_device_count: self.sampling_device_count.unwrap_or_default(),
            }
        }
    }
}
impl EdgeModelStat {
    /// Creates a new builder-style object to manufacture [`EdgeModelStat`](crate::model::EdgeModelStat)
    pub fn builder() -> crate::model::edge_model_stat::Builder {
        crate::model::edge_model_stat::Builder::default()
    }
}

/// <p>Edge Manager agent version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AgentVersion {
    /// <p>Version of the agent.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The number of Edge Manager agents.</p>
    pub agent_count: i64,
}
impl std::fmt::Debug for AgentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AgentVersion");
        formatter.field("version", &self.version);
        formatter.field("agent_count", &self.agent_count);
        formatter.finish()
    }
}
/// See [`AgentVersion`](crate::model::AgentVersion)
pub mod agent_version {
    /// A builder for [`AgentVersion`](crate::model::AgentVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) agent_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Version of the agent.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The number of Edge Manager agents.</p>
        pub fn agent_count(mut self, input: i64) -> Self {
            self.agent_count = Some(input);
            self
        }
        pub fn set_agent_count(mut self, input: std::option::Option<i64>) -> Self {
            self.agent_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AgentVersion`](crate::model::AgentVersion)
        pub fn build(self) -> crate::model::AgentVersion {
            crate::model::AgentVersion {
                version: self.version,
                agent_count: self.agent_count.unwrap_or_default(),
            }
        }
    }
}
impl AgentVersion {
    /// Creates a new builder-style object to manufacture [`AgentVersion`](crate::model::AgentVersion)
    pub fn builder() -> crate::model::agent_version::Builder {
        crate::model::agent_version::Builder::default()
    }
}

/// <p>Status of devices.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeviceStats {
    /// <p>The number of devices connected with a heartbeat.</p>
    pub connected_device_count: i64,
    /// <p>The number of registered devices.</p>
    pub registered_device_count: i64,
}
impl std::fmt::Debug for DeviceStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceStats");
        formatter.field("connected_device_count", &self.connected_device_count);
        formatter.field("registered_device_count", &self.registered_device_count);
        formatter.finish()
    }
}
/// See [`DeviceStats`](crate::model::DeviceStats)
pub mod device_stats {
    /// A builder for [`DeviceStats`](crate::model::DeviceStats)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connected_device_count: std::option::Option<i64>,
        pub(crate) registered_device_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The number of devices connected with a heartbeat.</p>
        pub fn connected_device_count(mut self, input: i64) -> Self {
            self.connected_device_count = Some(input);
            self
        }
        pub fn set_connected_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.connected_device_count = input;
            self
        }
        /// <p>The number of registered devices.</p>
        pub fn registered_device_count(mut self, input: i64) -> Self {
            self.registered_device_count = Some(input);
            self
        }
        pub fn set_registered_device_count(mut self, input: std::option::Option<i64>) -> Self {
            self.registered_device_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceStats`](crate::model::DeviceStats)
        pub fn build(self) -> crate::model::DeviceStats {
            crate::model::DeviceStats {
                connected_device_count: self.connected_device_count.unwrap_or_default(),
                registered_device_count: self.registered_device_count.unwrap_or_default(),
            }
        }
    }
}
impl DeviceStats {
    /// Creates a new builder-style object to manufacture [`DeviceStats`](crate::model::DeviceStats)
    pub fn builder() -> crate::model::device_stats::Builder {
        crate::model::device_stats::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProfilingStatus {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProfilingStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ProfilingStatus::Disabled,
            "Enabled" => ProfilingStatus::Enabled,
            other => ProfilingStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProfilingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProfilingStatus::from(s))
    }
}
impl ProfilingStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ProfilingStatus::Disabled => "Disabled",
            ProfilingStatus::Enabled => "Enabled",
            ProfilingStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ProfilingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the status of the rule evaluation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerRuleEvaluationStatus {
    /// <p>The name of the rule configuration.</p>
    pub rule_configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
    pub rule_evaluation_job_arn: std::option::Option<std::string::String>,
    /// <p>Status of the rule evaluation.</p>
    pub rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
    /// <p>Details from the rule evaluation.</p>
    pub status_details: std::option::Option<std::string::String>,
    /// <p>Timestamp when the rule evaluation status was last modified.</p>
    pub last_modified_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ProfilerRuleEvaluationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerRuleEvaluationStatus");
        formatter.field("rule_configuration_name", &self.rule_configuration_name);
        formatter.field("rule_evaluation_job_arn", &self.rule_evaluation_job_arn);
        formatter.field("rule_evaluation_status", &self.rule_evaluation_status);
        formatter.field("status_details", &self.status_details);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
pub mod profiler_rule_evaluation_status {
    /// A builder for [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_configuration_name: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_job_arn: std::option::Option<std::string::String>,
        pub(crate) rule_evaluation_status: std::option::Option<crate::model::RuleEvaluationStatus>,
        pub(crate) status_details: std::option::Option<std::string::String>,
        pub(crate) last_modified_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the rule configuration.</p>
        pub fn rule_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_configuration_name = Some(input.into());
            self
        }
        pub fn set_rule_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_configuration_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the rule evaluation job.</p>
        pub fn rule_evaluation_job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_evaluation_job_arn = Some(input.into());
            self
        }
        pub fn set_rule_evaluation_job_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_evaluation_job_arn = input;
            self
        }
        /// <p>Status of the rule evaluation.</p>
        pub fn rule_evaluation_status(mut self, input: crate::model::RuleEvaluationStatus) -> Self {
            self.rule_evaluation_status = Some(input);
            self
        }
        pub fn set_rule_evaluation_status(
            mut self,
            input: std::option::Option<crate::model::RuleEvaluationStatus>,
        ) -> Self {
            self.rule_evaluation_status = input;
            self
        }
        /// <p>Details from the rule evaluation.</p>
        pub fn status_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_details = Some(input.into());
            self
        }
        pub fn set_status_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_details = input;
            self
        }
        /// <p>Timestamp when the rule evaluation status was last modified.</p>
        pub fn last_modified_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
        pub fn build(self) -> crate::model::ProfilerRuleEvaluationStatus {
            crate::model::ProfilerRuleEvaluationStatus {
                rule_configuration_name: self.rule_configuration_name,
                rule_evaluation_job_arn: self.rule_evaluation_job_arn,
                rule_evaluation_status: self.rule_evaluation_status,
                status_details: self.status_details,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl ProfilerRuleEvaluationStatus {
    /// Creates a new builder-style object to manufacture [`ProfilerRuleEvaluationStatus`](crate::model::ProfilerRuleEvaluationStatus)
    pub fn builder() -> crate::model::profiler_rule_evaluation_status::Builder {
        crate::model::profiler_rule_evaluation_status::Builder::default()
    }
}

/// <p>Configuration information for Debugger system monitoring, framework profiling, and
/// storage paths.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProfilerConfig {
    /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>A time interval for capturing system metrics in milliseconds. Available values are
    /// 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
    pub profiling_interval_in_milliseconds: std::option::Option<i64>,
    /// <p>Configuration information for capturing framework metrics. Available key strings for different profiling options are
    /// <code>DetailedProfilingConfig</code>, <code>PythonProfilingConfig</code>, and <code>DataLoaderProfilingConfig</code>.
    /// The following codes are configuration structures for the <code>ProfilingParameters</code> parameter. To learn more about
    /// how to configure the <code>ProfilingParameters</code> parameter,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-createtrainingjob-api.html">Use the SageMaker and Debugger Configuration API Operations to Create, Update, and Debug Your Training Job</a>.
    /// </p>
    pub profiling_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ProfilerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProfilerConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field(
            "profiling_interval_in_milliseconds",
            &self.profiling_interval_in_milliseconds,
        );
        formatter.field("profiling_parameters", &self.profiling_parameters);
        formatter.finish()
    }
}
/// See [`ProfilerConfig`](crate::model::ProfilerConfig)
pub mod profiler_config {
    /// A builder for [`ProfilerConfig`](crate::model::ProfilerConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) profiling_interval_in_milliseconds: std::option::Option<i64>,
        pub(crate) profiling_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Path to Amazon S3 storage location for system and framework metrics.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>A time interval for capturing system metrics in milliseconds. Available values are
        /// 100, 200, 500, 1000 (1 second), 5000 (5 seconds), and 60000 (1 minute) milliseconds. The default value is 500 milliseconds.</p>
        pub fn profiling_interval_in_milliseconds(mut self, input: i64) -> Self {
            self.profiling_interval_in_milliseconds = Some(input);
            self
        }
        pub fn set_profiling_interval_in_milliseconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.profiling_interval_in_milliseconds = input;
            self
        }
        pub fn profiling_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.profiling_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.profiling_parameters = Some(hash_map);
            self
        }
        pub fn set_profiling_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.profiling_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ProfilerConfig`](crate::model::ProfilerConfig)
        pub fn build(self) -> crate::model::ProfilerConfig {
            crate::model::ProfilerConfig {
                s3_output_path: self.s3_output_path,
                profiling_interval_in_milliseconds: self.profiling_interval_in_milliseconds,
                profiling_parameters: self.profiling_parameters,
            }
        }
    }
}
impl ProfilerConfig {
    /// Creates a new builder-style object to manufacture [`ProfilerConfig`](crate::model::ProfilerConfig)
    pub fn builder() -> crate::model::profiler_config::Builder {
        crate::model::profiler_config::Builder::default()
    }
}

/// <p>Details of a provisioned service catalog product. For information about service catalog,
/// see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service
/// Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceCatalogProvisionedProductDetails {
    /// <p>The ID of the provisioned product.</p>
    pub provisioned_product_id: std::option::Option<std::string::String>,
    /// <p>The current status of the product.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p>
    /// </li>
    /// </ul>
    pub provisioned_product_status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceCatalogProvisionedProductDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceCatalogProvisionedProductDetails");
        formatter.field("provisioned_product_id", &self.provisioned_product_id);
        formatter.field(
            "provisioned_product_status_message",
            &self.provisioned_product_status_message,
        );
        formatter.finish()
    }
}
/// See [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
pub mod service_catalog_provisioned_product_details {
    /// A builder for [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provisioned_product_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_product_status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the provisioned product.</p>
        pub fn provisioned_product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned_product_id = Some(input.into());
            self
        }
        pub fn set_provisioned_product_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_id = input;
            self
        }
        /// <p>The current status of the product.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.</p>
        /// </li>
        /// </ul>
        pub fn provisioned_product_status_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.provisioned_product_status_message = Some(input.into());
            self
        }
        pub fn set_provisioned_product_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
        pub fn build(self) -> crate::model::ServiceCatalogProvisionedProductDetails {
            crate::model::ServiceCatalogProvisionedProductDetails {
                provisioned_product_id: self.provisioned_product_id,
                provisioned_product_status_message: self.provisioned_product_status_message,
            }
        }
    }
}
impl ServiceCatalogProvisionedProductDetails {
    /// Creates a new builder-style object to manufacture [`ServiceCatalogProvisionedProductDetails`](crate::model::ServiceCatalogProvisionedProductDetails)
    pub fn builder() -> crate::model::service_catalog_provisioned_product_details::Builder {
        crate::model::service_catalog_provisioned_product_details::Builder::default()
    }
}

/// <p>Details that you specify to provision a service catalog product. For information about
/// service catalog, see .<a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service
/// Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceCatalogProvisioningDetails {
    /// <p>The ID of the product to provision.</p>
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The ID of the provisioning artifact.</p>
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
    pub path_id: std::option::Option<std::string::String>,
    /// <p>A list of key value pairs that you specify when you provision a product.</p>
    pub provisioning_parameters:
        std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
}
impl std::fmt::Debug for ServiceCatalogProvisioningDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceCatalogProvisioningDetails");
        formatter.field("product_id", &self.product_id);
        formatter.field("provisioning_artifact_id", &self.provisioning_artifact_id);
        formatter.field("path_id", &self.path_id);
        formatter.field("provisioning_parameters", &self.provisioning_parameters);
        formatter.finish()
    }
}
/// See [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
pub mod service_catalog_provisioning_details {
    /// A builder for [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) path_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_parameters:
            std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
    }
    impl Builder {
        /// <p>The ID of the product to provision.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The ID of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. </p>
        pub fn path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.path_id = Some(input.into());
            self
        }
        pub fn set_path_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path_id = input;
            self
        }
        pub fn provisioning_parameters(
            mut self,
            input: impl Into<crate::model::ProvisioningParameter>,
        ) -> Self {
            let mut v = self.provisioning_parameters.unwrap_or_default();
            v.push(input.into());
            self.provisioning_parameters = Some(v);
            self
        }
        pub fn set_provisioning_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProvisioningParameter>>,
        ) -> Self {
            self.provisioning_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
        pub fn build(self) -> crate::model::ServiceCatalogProvisioningDetails {
            crate::model::ServiceCatalogProvisioningDetails {
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
                path_id: self.path_id,
                provisioning_parameters: self.provisioning_parameters,
            }
        }
    }
}
impl ServiceCatalogProvisioningDetails {
    /// Creates a new builder-style object to manufacture [`ServiceCatalogProvisioningDetails`](crate::model::ServiceCatalogProvisioningDetails)
    pub fn builder() -> crate::model::service_catalog_provisioning_details::Builder {
        crate::model::service_catalog_provisioning_details::Builder::default()
    }
}

/// <p>A key value pair used when you provision a project as a service catalog product. For
/// information, see <a href="https://docs.aws.amazon.com/servicecatalog/latest/adminguide/introduction.html">What is Amazon Web Services Service
/// Catalog</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisioningParameter {
    /// <p>The key that identifies a provisioning parameter.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the provisioning parameter.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisioningParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisioningParameter");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ProvisioningParameter`](crate::model::ProvisioningParameter)
pub mod provisioning_parameter {
    /// A builder for [`ProvisioningParameter`](crate::model::ProvisioningParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key that identifies a provisioning parameter.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the provisioning parameter.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningParameter`](crate::model::ProvisioningParameter)
        pub fn build(self) -> crate::model::ProvisioningParameter {
            crate::model::ProvisioningParameter {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ProvisioningParameter {
    /// Creates a new builder-style object to manufacture [`ProvisioningParameter`](crate::model::ProvisioningParameter)
    pub fn builder() -> crate::model::provisioning_parameter::Builder {
        crate::model::provisioning_parameter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DirectInternetAccess {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DirectInternetAccess {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => DirectInternetAccess::Disabled,
            "Enabled" => DirectInternetAccess::Enabled,
            other => DirectInternetAccess::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DirectInternetAccess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DirectInternetAccess::from(s))
    }
}
impl DirectInternetAccess {
    pub fn as_str(&self) -> &str {
        match self {
            DirectInternetAccess::Disabled => "Disabled",
            DirectInternetAccess::Enabled => "Enabled",
            DirectInternetAccess::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for DirectInternetAccess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The networking configuration for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringNetworkConfig {
    /// <p>Whether to encrypt all communications between the instances used for the monitoring
    /// jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater
    /// security for distributed jobs, but the processing might take longer.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>Whether to allow inbound and outbound network calls to and from the containers used for
    /// the monitoring job.</p>
    pub enable_network_isolation: bool,
    /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control
    /// access to and from your training and model containers by configuring the VPC. For more
    /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
    /// by Using an Amazon Virtual Private Cloud</a>. </p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl std::fmt::Debug for MonitoringNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringNetworkConfig");
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
pub mod monitoring_network_config {
    /// A builder for [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>Whether to encrypt all communications between the instances used for the monitoring
        /// jobs. Choose <code>True</code> to encrypt communications. Encryption provides greater
        /// security for distributed jobs, but the processing might take longer.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>Whether to allow inbound and outbound network calls to and from the containers used for
        /// the monitoring job.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>Specifies a VPC that your training jobs and hosted models have access to. Control
        /// access to and from your training and model containers by configuring the VPC. For more
        /// information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html">Protect Endpoints by Using an Amazon Virtual Private Cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
        /// by Using an Amazon Virtual Private Cloud</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
        pub fn build(self) -> crate::model::MonitoringNetworkConfig {
            crate::model::MonitoringNetworkConfig {
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl MonitoringNetworkConfig {
    /// Creates a new builder-style object to manufacture [`MonitoringNetworkConfig`](crate::model::MonitoringNetworkConfig)
    pub fn builder() -> crate::model::monitoring_network_config::Builder {
        crate::model::monitoring_network_config::Builder::default()
    }
}

/// <p>The input for the model quality monitoring job. Currently endponts are supported for
/// input for model quality monitoring jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
    /// <p>The ground truth label provided for the model.</p>
    pub ground_truth_s3_input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
}
impl std::fmt::Debug for ModelQualityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.field("ground_truth_s3_input", &self.ground_truth_s3_input);
        formatter.finish()
    }
}
/// See [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
pub mod model_quality_job_input {
    /// A builder for [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
        pub(crate) ground_truth_s3_input:
            std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// <p>The ground truth label provided for the model.</p>
        pub fn ground_truth_s3_input(
            mut self,
            input: crate::model::MonitoringGroundTruthS3Input,
        ) -> Self {
            self.ground_truth_s3_input = Some(input);
            self
        }
        pub fn set_ground_truth_s3_input(
            mut self,
            input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
        ) -> Self {
            self.ground_truth_s3_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
        pub fn build(self) -> crate::model::ModelQualityJobInput {
            crate::model::ModelQualityJobInput {
                endpoint_input: self.endpoint_input,
                ground_truth_s3_input: self.ground_truth_s3_input,
            }
        }
    }
}
impl ModelQualityJobInput {
    /// Creates a new builder-style object to manufacture [`ModelQualityJobInput`](crate::model::ModelQualityJobInput)
    pub fn builder() -> crate::model::model_quality_job_input::Builder {
        crate::model::model_quality_job_input::Builder::default()
    }
}

/// <p>The ground truth labels for the dataset used for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringGroundTruthS3Input {
    /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MonitoringGroundTruthS3Input {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringGroundTruthS3Input");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
pub mod monitoring_ground_truth_s3_input {
    /// A builder for [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The address of the Amazon S3 location of the ground truth labels.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
        pub fn build(self) -> crate::model::MonitoringGroundTruthS3Input {
            crate::model::MonitoringGroundTruthS3Input {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl MonitoringGroundTruthS3Input {
    /// Creates a new builder-style object to manufacture [`MonitoringGroundTruthS3Input`](crate::model::MonitoringGroundTruthS3Input)
    pub fn builder() -> crate::model::monitoring_ground_truth_s3_input::Builder {
        crate::model::monitoring_ground_truth_s3_input::Builder::default()
    }
}

/// <p>Container image configuration object for the monitoring job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityAppSpecification {
    /// <p>The address of the container image that the monitoring job runs.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the entrypoint for a container that the monitoring job runs.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of arguments for the container used to run the monitoring job.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
    /// base64 decode the payload and convert it into a flatted json so that the built-in container
    /// can use the converted data. Applicable only for the built-in (first party)
    /// containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
    /// Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
    pub problem_type: std::option::Option<crate::model::MonitoringProblemType>,
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ModelQualityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.field("problem_type", &self.problem_type);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
pub mod model_quality_app_specification {
    /// A builder for [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
        pub(crate) problem_type: std::option::Option<crate::model::MonitoringProblemType>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The address of the container image that the monitoring job runs.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
        /// base64 decode the payload and convert it into a flatted json so that the built-in container
        /// can use the converted data. Applicable only for the built-in (first party)
        /// containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
        /// Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        /// <p>The machine learning problem type of the model that the monitoring job monitors.</p>
        pub fn problem_type(mut self, input: crate::model::MonitoringProblemType) -> Self {
            self.problem_type = Some(input);
            self
        }
        pub fn set_problem_type(
            mut self,
            input: std::option::Option<crate::model::MonitoringProblemType>,
        ) -> Self {
            self.problem_type = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
        pub fn build(self) -> crate::model::ModelQualityAppSpecification {
            crate::model::ModelQualityAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
                problem_type: self.problem_type,
                environment: self.environment,
            }
        }
    }
}
impl ModelQualityAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelQualityAppSpecification`](crate::model::ModelQualityAppSpecification)
    pub fn builder() -> crate::model::model_quality_app_specification::Builder {
        crate::model::model_quality_app_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitoringProblemType {
    BinaryClassification,
    MulticlassClassification,
    Regression,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitoringProblemType {
    fn from(s: &str) -> Self {
        match s {
            "BinaryClassification" => MonitoringProblemType::BinaryClassification,
            "MulticlassClassification" => MonitoringProblemType::MulticlassClassification,
            "Regression" => MonitoringProblemType::Regression,
            other => MonitoringProblemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitoringProblemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitoringProblemType::from(s))
    }
}
impl MonitoringProblemType {
    pub fn as_str(&self) -> &str {
        match self {
            MonitoringProblemType::BinaryClassification => "BinaryClassification",
            MonitoringProblemType::MulticlassClassification => "MulticlassClassification",
            MonitoringProblemType::Regression => "Regression",
            MonitoringProblemType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "BinaryClassification",
            "MulticlassClassification",
            "Regression",
        ]
    }
}
impl AsRef<str> for MonitoringProblemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline
/// resources are compared against the results of the current job from the series of jobs
/// scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl std::fmt::Debug for ModelQualityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelQualityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
pub mod model_quality_baseline_config {
    /// A builder for [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
        pub fn build(self) -> crate::model::ModelQualityBaselineConfig {
            crate::model::ModelQualityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelQualityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelQualityBaselineConfig`](crate::model::ModelQualityBaselineConfig)
    pub fn builder() -> crate::model::model_quality_baseline_config::Builder {
        crate::model::model_quality_baseline_config::Builder::default()
    }
}

/// <p>Inputs for the model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl std::fmt::Debug for ModelExplainabilityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
pub mod model_explainability_job_input {
    /// A builder for [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
        pub fn build(self) -> crate::model::ModelExplainabilityJobInput {
            crate::model::ModelExplainabilityJobInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl ModelExplainabilityJobInput {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityJobInput`](crate::model::ModelExplainabilityJobInput)
    pub fn builder() -> crate::model::model_explainability_job_input::Builder {
        crate::model::model_explainability_job_input::Builder::default()
    }
}

/// <p>Docker container image configuration object for the model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityAppSpecification {
    /// <p>The container image to be run by the model explainability job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>JSON formatted S3 file that defines explainability parameters. For more information on
    /// this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model
    /// explainability parameters</a>.</p>
    pub config_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ModelExplainabilityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("config_uri", &self.config_uri);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
pub mod model_explainability_app_specification {
    /// A builder for [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) config_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image to be run by the model explainability job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>JSON formatted S3 file that defines explainability parameters. For more information on
        /// this JSON configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-model-explainability-parameter-config.html">Configure model
        /// explainability parameters</a>.</p>
        pub fn config_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_uri = Some(input.into());
            self
        }
        pub fn set_config_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_uri = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
        pub fn build(self) -> crate::model::ModelExplainabilityAppSpecification {
            crate::model::ModelExplainabilityAppSpecification {
                image_uri: self.image_uri,
                config_uri: self.config_uri,
                environment: self.environment,
            }
        }
    }
}
impl ModelExplainabilityAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityAppSpecification`](crate::model::ModelExplainabilityAppSpecification)
    pub fn builder() -> crate::model::model_explainability_app_specification::Builder {
        crate::model::model_explainability_app_specification::Builder::default()
    }
}

/// <p>The configuration for a baseline model explainability job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelExplainabilityBaselineConfig {
    /// <p>The name of the baseline model explainability job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl std::fmt::Debug for ModelExplainabilityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelExplainabilityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
pub mod model_explainability_baseline_config {
    /// A builder for [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the baseline model explainability job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
        pub fn build(self) -> crate::model::ModelExplainabilityBaselineConfig {
            crate::model::ModelExplainabilityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelExplainabilityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelExplainabilityBaselineConfig`](crate::model::ModelExplainabilityBaselineConfig)
    pub fn builder() -> crate::model::model_explainability_baseline_config::Builder {
        crate::model::model_explainability_baseline_config::Builder::default()
    }
}

/// <p>Inputs for the model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
    /// <p>Location of ground truth labels to use in model bias job.</p>
    pub ground_truth_s3_input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
}
impl std::fmt::Debug for ModelBiasJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.field("ground_truth_s3_input", &self.ground_truth_s3_input);
        formatter.finish()
    }
}
/// See [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
pub mod model_bias_job_input {
    /// A builder for [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
        pub(crate) ground_truth_s3_input:
            std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// <p>Location of ground truth labels to use in model bias job.</p>
        pub fn ground_truth_s3_input(
            mut self,
            input: crate::model::MonitoringGroundTruthS3Input,
        ) -> Self {
            self.ground_truth_s3_input = Some(input);
            self
        }
        pub fn set_ground_truth_s3_input(
            mut self,
            input: std::option::Option<crate::model::MonitoringGroundTruthS3Input>,
        ) -> Self {
            self.ground_truth_s3_input = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
        pub fn build(self) -> crate::model::ModelBiasJobInput {
            crate::model::ModelBiasJobInput {
                endpoint_input: self.endpoint_input,
                ground_truth_s3_input: self.ground_truth_s3_input,
            }
        }
    }
}
impl ModelBiasJobInput {
    /// Creates a new builder-style object to manufacture [`ModelBiasJobInput`](crate::model::ModelBiasJobInput)
    pub fn builder() -> crate::model::model_bias_job_input::Builder {
        crate::model::model_bias_job_input::Builder::default()
    }
}

/// <p>Docker container image configuration object for the model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasAppSpecification {
    /// <p>The container image to be run by the model bias job.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON
    /// configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias
    /// parameters</a>.</p>
    pub config_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the Docker container.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ModelBiasAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("config_uri", &self.config_uri);
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
pub mod model_bias_app_specification {
    /// A builder for [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) config_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image to be run by the model bias job.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>JSON formatted S3 file that defines bias parameters. For more information on this JSON
        /// configuration file, see <a href="https://docs.aws.amazon.com/sagemaker/latest/json-bias-parameter-config.html">Configure bias
        /// parameters</a>.</p>
        pub fn config_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.config_uri = Some(input.into());
            self
        }
        pub fn set_config_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.config_uri = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
        pub fn build(self) -> crate::model::ModelBiasAppSpecification {
            crate::model::ModelBiasAppSpecification {
                image_uri: self.image_uri,
                config_uri: self.config_uri,
                environment: self.environment,
            }
        }
    }
}
impl ModelBiasAppSpecification {
    /// Creates a new builder-style object to manufacture [`ModelBiasAppSpecification`](crate::model::ModelBiasAppSpecification)
    pub fn builder() -> crate::model::model_bias_app_specification::Builder {
        crate::model::model_bias_app_specification::Builder::default()
    }
}

/// <p>The configuration for a baseline model bias job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelBiasBaselineConfig {
    /// <p>The name of the baseline model bias job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
}
impl std::fmt::Debug for ModelBiasBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelBiasBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.finish()
    }
}
/// See [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
pub mod model_bias_baseline_config {
    /// A builder for [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
    }
    impl Builder {
        /// <p>The name of the baseline model bias job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
        pub fn build(self) -> crate::model::ModelBiasBaselineConfig {
            crate::model::ModelBiasBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
            }
        }
    }
}
impl ModelBiasBaselineConfig {
    /// Creates a new builder-style object to manufacture [`ModelBiasBaselineConfig`](crate::model::ModelBiasBaselineConfig)
    pub fn builder() -> crate::model::model_bias_baseline_config::Builder {
        crate::model::model_bias_baseline_config::Builder::default()
    }
}

/// <p>Specifies details about how containers in a multi-container endpoint are run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferenceExecutionConfig {
    /// <p>How containers in a multi-container are run. The following values are valid.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SERIAL</code> - Containers run as a serial pipeline.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DIRECT</code> - Only the individual container that you specify is
    /// run.</p>
    /// </li>
    /// </ul>
    pub mode: std::option::Option<crate::model::InferenceExecutionMode>,
}
impl std::fmt::Debug for InferenceExecutionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferenceExecutionConfig");
        formatter.field("mode", &self.mode);
        formatter.finish()
    }
}
/// See [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
pub mod inference_execution_config {
    /// A builder for [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::InferenceExecutionMode>,
    }
    impl Builder {
        /// <p>How containers in a multi-container are run. The following values are valid.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SERIAL</code> - Containers run as a serial pipeline.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DIRECT</code> - Only the individual container that you specify is
        /// run.</p>
        /// </li>
        /// </ul>
        pub fn mode(mut self, input: crate::model::InferenceExecutionMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::InferenceExecutionMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
        pub fn build(self) -> crate::model::InferenceExecutionConfig {
            crate::model::InferenceExecutionConfig { mode: self.mode }
        }
    }
}
impl InferenceExecutionConfig {
    /// Creates a new builder-style object to manufacture [`InferenceExecutionConfig`](crate::model::InferenceExecutionConfig)
    pub fn builder() -> crate::model::inference_execution_config::Builder {
        crate::model::inference_execution_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InferenceExecutionMode {
    Direct,
    Serial,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InferenceExecutionMode {
    fn from(s: &str) -> Self {
        match s {
            "Direct" => InferenceExecutionMode::Direct,
            "Serial" => InferenceExecutionMode::Serial,
            other => InferenceExecutionMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InferenceExecutionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InferenceExecutionMode::from(s))
    }
}
impl InferenceExecutionMode {
    pub fn as_str(&self) -> &str {
        match self {
            InferenceExecutionMode::Direct => "Direct",
            InferenceExecutionMode::Serial => "Serial",
            InferenceExecutionMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Direct", "Serial"]
    }
}
impl AsRef<str> for InferenceExecutionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the container, as part of model definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainerDefinition {
    /// <p>This parameter is ignored for models that contain only a
    /// <code>PrimaryContainer</code>.</p>
    /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of
    /// the parameter uniquely identifies the container for the purposes of logging and metrics.
    /// For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics
    /// to Monitor an Inference Pipeline</a>. If you don't specify a value for this
    /// parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline,
    /// a unique name is automatically assigned based on the position of the
    /// <code>ContainerDefinition</code> in the pipeline. If you specify a value for the
    /// <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part
    /// of an inference pipeline, you must specify a value for the
    /// <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code>
    /// in that pipeline.</p>
    pub container_hostname: std::option::Option<std::string::String>,
    /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a
    /// Docker registry that is accessible from the same VPC that you configure for your
    /// endpoint. If you are using your own custom algorithm instead of an algorithm provided by
    /// Amazon SageMaker, the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both
    /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
    /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
    /// SageMaker</a>
    /// </p>
    pub image: std::option::Option<std::string::String>,
    /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry
    /// accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a
    /// private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a
    /// Private Docker Registry for Real-Time Inference Containers</a>
    /// </p>
    pub image_config: std::option::Option<crate::model::ImageConfig>,
    /// <p>Whether the container hosts a single model or multiple models.</p>
    pub mode: std::option::Option<crate::model::ContainerMode>,
    /// <p>The S3 path where the model artifacts, which result from model training, are stored.
    /// This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3
    /// path is required for Amazon SageMaker built-in algorithms, but not if you use your own algorithms.
    /// For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common
    /// Parameters</a>. </p>
    /// <note>
    /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
    /// model or endpoint you are creating.</p>
    /// </note>
    /// <p>If you provide a value for this parameter, Amazon SageMaker uses Amazon Web Services Security Token Service to
    /// download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your
    /// IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you
    /// need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    /// Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User
    /// Guide</i>.</p>
    /// <important>
    /// <p>If you use a built-in algorithm to create a model, Amazon SageMaker requires that you provide
    /// a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
    /// </important>
    pub model_data_url: std::option::Option<std::string::String>,
    /// <p>The environment variables to set in the Docker container. Each key and value in the
    /// <code>Environment</code> string to string map can have length of up to 1024. We
    /// support up to 16 entries in the map. </p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the
    /// model.</p>
    pub model_package_name: std::option::Option<std::string::String>,
    /// <p>Specifies additional configuration for multi-model endpoints.</p>
    pub multi_model_config: std::option::Option<crate::model::MultiModelConfig>,
}
impl std::fmt::Debug for ContainerDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainerDefinition");
        formatter.field("container_hostname", &self.container_hostname);
        formatter.field("image", &self.image);
        formatter.field("image_config", &self.image_config);
        formatter.field("mode", &self.mode);
        formatter.field("model_data_url", &self.model_data_url);
        formatter.field("environment", &self.environment);
        formatter.field("model_package_name", &self.model_package_name);
        formatter.field("multi_model_config", &self.multi_model_config);
        formatter.finish()
    }
}
/// See [`ContainerDefinition`](crate::model::ContainerDefinition)
pub mod container_definition {
    /// A builder for [`ContainerDefinition`](crate::model::ContainerDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_hostname: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
        pub(crate) image_config: std::option::Option<crate::model::ImageConfig>,
        pub(crate) mode: std::option::Option<crate::model::ContainerMode>,
        pub(crate) model_data_url: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) model_package_name: std::option::Option<std::string::String>,
        pub(crate) multi_model_config: std::option::Option<crate::model::MultiModelConfig>,
    }
    impl Builder {
        /// <p>This parameter is ignored for models that contain only a
        /// <code>PrimaryContainer</code>.</p>
        /// <p>When a <code>ContainerDefinition</code> is part of an inference pipeline, the value of
        /// the parameter uniquely identifies the container for the purposes of logging and metrics.
        /// For information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/inference-pipeline-logs-metrics.html">Use Logs and Metrics
        /// to Monitor an Inference Pipeline</a>. If you don't specify a value for this
        /// parameter for a <code>ContainerDefinition</code> that is part of an inference pipeline,
        /// a unique name is automatically assigned based on the position of the
        /// <code>ContainerDefinition</code> in the pipeline. If you specify a value for the
        /// <code>ContainerHostName</code> for any <code>ContainerDefinition</code> that is part
        /// of an inference pipeline, you must specify a value for the
        /// <code>ContainerHostName</code> parameter of every <code>ContainerDefinition</code>
        /// in that pipeline.</p>
        pub fn container_hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_hostname = Some(input.into());
            self
        }
        pub fn set_container_hostname(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_hostname = input;
            self
        }
        /// <p>The path where inference code is stored. This can be either in Amazon EC2 Container Registry or in a
        /// Docker registry that is accessible from the same VPC that you configure for your
        /// endpoint. If you are using your own custom algorithm instead of an algorithm provided by
        /// Amazon SageMaker, the inference code must meet Amazon SageMaker requirements. Amazon SageMaker supports both
        /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
        /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
        /// SageMaker</a>
        /// </p>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry
        /// accessible from your Amazon Virtual Private Cloud (VPC). For information about storing containers in a
        /// private Docker registry, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-containers-inference-private.html">Use a
        /// Private Docker Registry for Real-Time Inference Containers</a>
        /// </p>
        pub fn image_config(mut self, input: crate::model::ImageConfig) -> Self {
            self.image_config = Some(input);
            self
        }
        pub fn set_image_config(
            mut self,
            input: std::option::Option<crate::model::ImageConfig>,
        ) -> Self {
            self.image_config = input;
            self
        }
        /// <p>Whether the container hosts a single model or multiple models.</p>
        pub fn mode(mut self, input: crate::model::ContainerMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ContainerMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The S3 path where the model artifacts, which result from model training, are stored.
        /// This path must point to a single gzip compressed tar archive (.tar.gz suffix). The S3
        /// path is required for Amazon SageMaker built-in algorithms, but not if you use your own algorithms.
        /// For more information on built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Common
        /// Parameters</a>. </p>
        /// <note>
        /// <p>The model artifacts must be in an S3 bucket that is in the same region as the
        /// model or endpoint you are creating.</p>
        /// </note>
        /// <p>If you provide a value for this parameter, Amazon SageMaker uses Amazon Web Services Security Token Service to
        /// download model artifacts from the S3 path you provide. Amazon Web Services STS is activated in your
        /// IAM user account by default. If you previously deactivated Amazon Web Services STS for a region, you
        /// need to reactivate Amazon Web Services STS for that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
        /// Deactivating Amazon Web Services STS in an Amazon Web Services Region</a> in the <i>Amazon Web Services Identity and Access Management User
        /// Guide</i>.</p>
        /// <important>
        /// <p>If you use a built-in algorithm to create a model, Amazon SageMaker requires that you provide
        /// a S3 path to the model artifacts in <code>ModelDataUrl</code>.</p>
        /// </important>
        pub fn model_data_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_data_url = Some(input.into());
            self
        }
        pub fn set_model_data_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_data_url = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the model package to use to create the
        /// model.</p>
        pub fn model_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_package_name = Some(input.into());
            self
        }
        pub fn set_model_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_package_name = input;
            self
        }
        /// <p>Specifies additional configuration for multi-model endpoints.</p>
        pub fn multi_model_config(mut self, input: crate::model::MultiModelConfig) -> Self {
            self.multi_model_config = Some(input);
            self
        }
        pub fn set_multi_model_config(
            mut self,
            input: std::option::Option<crate::model::MultiModelConfig>,
        ) -> Self {
            self.multi_model_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainerDefinition`](crate::model::ContainerDefinition)
        pub fn build(self) -> crate::model::ContainerDefinition {
            crate::model::ContainerDefinition {
                container_hostname: self.container_hostname,
                image: self.image,
                image_config: self.image_config,
                mode: self.mode,
                model_data_url: self.model_data_url,
                environment: self.environment,
                model_package_name: self.model_package_name,
                multi_model_config: self.multi_model_config,
            }
        }
    }
}
impl ContainerDefinition {
    /// Creates a new builder-style object to manufacture [`ContainerDefinition`](crate::model::ContainerDefinition)
    pub fn builder() -> crate::model::container_definition::Builder {
        crate::model::container_definition::Builder::default()
    }
}

/// <p>Specifies additional configuration for hosting multi-model endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultiModelConfig {
    /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints
    /// cache models so that a model does not have to be loaded into memory each time it is
    /// invoked. Some use cases do not benefit from model caching. For example, if an endpoint
    /// hosts a large number of models that are each invoked infrequently, the endpoint might
    /// perform better if you disable model caching. To disable model caching, set the value of
    /// this parameter to <code>Disabled</code>.</p>
    pub model_cache_setting: std::option::Option<crate::model::ModelCacheSetting>,
}
impl std::fmt::Debug for MultiModelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultiModelConfig");
        formatter.field("model_cache_setting", &self.model_cache_setting);
        formatter.finish()
    }
}
/// See [`MultiModelConfig`](crate::model::MultiModelConfig)
pub mod multi_model_config {
    /// A builder for [`MultiModelConfig`](crate::model::MultiModelConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_cache_setting: std::option::Option<crate::model::ModelCacheSetting>,
    }
    impl Builder {
        /// <p>Whether to cache models for a multi-model endpoint. By default, multi-model endpoints
        /// cache models so that a model does not have to be loaded into memory each time it is
        /// invoked. Some use cases do not benefit from model caching. For example, if an endpoint
        /// hosts a large number of models that are each invoked infrequently, the endpoint might
        /// perform better if you disable model caching. To disable model caching, set the value of
        /// this parameter to <code>Disabled</code>.</p>
        pub fn model_cache_setting(mut self, input: crate::model::ModelCacheSetting) -> Self {
            self.model_cache_setting = Some(input);
            self
        }
        pub fn set_model_cache_setting(
            mut self,
            input: std::option::Option<crate::model::ModelCacheSetting>,
        ) -> Self {
            self.model_cache_setting = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiModelConfig`](crate::model::MultiModelConfig)
        pub fn build(self) -> crate::model::MultiModelConfig {
            crate::model::MultiModelConfig {
                model_cache_setting: self.model_cache_setting,
            }
        }
    }
}
impl MultiModelConfig {
    /// Creates a new builder-style object to manufacture [`MultiModelConfig`](crate::model::MultiModelConfig)
    pub fn builder() -> crate::model::multi_model_config::Builder {
        crate::model::multi_model_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelCacheSetting {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ModelCacheSetting {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => ModelCacheSetting::Disabled,
            "Enabled" => ModelCacheSetting::Enabled,
            other => ModelCacheSetting::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ModelCacheSetting {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelCacheSetting::from(s))
    }
}
impl ModelCacheSetting {
    pub fn as_str(&self) -> &str {
        match self {
            ModelCacheSetting::Disabled => "Disabled",
            ModelCacheSetting::Enabled => "Enabled",
            ModelCacheSetting::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for ModelCacheSetting {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContainerMode {
    MultiModel,
    SingleModel,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContainerMode {
    fn from(s: &str) -> Self {
        match s {
            "MultiModel" => ContainerMode::MultiModel,
            "SingleModel" => ContainerMode::SingleModel,
            other => ContainerMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContainerMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ContainerMode::from(s))
    }
}
impl ContainerMode {
    pub fn as_str(&self) -> &str {
        match self {
            ContainerMode::MultiModel => "MultiModel",
            ContainerMode::SingleModel => "SingleModel",
            ContainerMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["MultiModel", "SingleModel"]
    }
}
impl AsRef<str> for ContainerMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies whether the model container is in Amazon ECR or a private Docker registry
/// accessible from your Amazon Virtual Private Cloud (VPC).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageConfig {
    /// <p>Set this to one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Platform</code> - The model image is hosted in Amazon ECR.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Vpc</code> - The model image is hosted in a private Docker registry in
    /// your VPC.</p>
    /// </li>
    /// </ul>
    pub repository_access_mode: std::option::Option<crate::model::RepositoryAccessMode>,
    /// <p>(Optional) Specifies an authentication configuration for the private docker registry
    /// where your model image is hosted. Specify a value for this property only if you
    /// specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field,
    /// and the private Docker registry where the model image is hosted requires
    /// authentication.</p>
    pub repository_auth_config: std::option::Option<crate::model::RepositoryAuthConfig>,
}
impl std::fmt::Debug for ImageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageConfig");
        formatter.field("repository_access_mode", &self.repository_access_mode);
        formatter.field("repository_auth_config", &self.repository_auth_config);
        formatter.finish()
    }
}
/// See [`ImageConfig`](crate::model::ImageConfig)
pub mod image_config {
    /// A builder for [`ImageConfig`](crate::model::ImageConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_access_mode: std::option::Option<crate::model::RepositoryAccessMode>,
        pub(crate) repository_auth_config: std::option::Option<crate::model::RepositoryAuthConfig>,
    }
    impl Builder {
        /// <p>Set this to one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Platform</code> - The model image is hosted in Amazon ECR.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Vpc</code> - The model image is hosted in a private Docker registry in
        /// your VPC.</p>
        /// </li>
        /// </ul>
        pub fn repository_access_mode(mut self, input: crate::model::RepositoryAccessMode) -> Self {
            self.repository_access_mode = Some(input);
            self
        }
        pub fn set_repository_access_mode(
            mut self,
            input: std::option::Option<crate::model::RepositoryAccessMode>,
        ) -> Self {
            self.repository_access_mode = input;
            self
        }
        /// <p>(Optional) Specifies an authentication configuration for the private docker registry
        /// where your model image is hosted. Specify a value for this property only if you
        /// specified <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field,
        /// and the private Docker registry where the model image is hosted requires
        /// authentication.</p>
        pub fn repository_auth_config(mut self, input: crate::model::RepositoryAuthConfig) -> Self {
            self.repository_auth_config = Some(input);
            self
        }
        pub fn set_repository_auth_config(
            mut self,
            input: std::option::Option<crate::model::RepositoryAuthConfig>,
        ) -> Self {
            self.repository_auth_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfig`](crate::model::ImageConfig)
        pub fn build(self) -> crate::model::ImageConfig {
            crate::model::ImageConfig {
                repository_access_mode: self.repository_access_mode,
                repository_auth_config: self.repository_auth_config,
            }
        }
    }
}
impl ImageConfig {
    /// Creates a new builder-style object to manufacture [`ImageConfig`](crate::model::ImageConfig)
    pub fn builder() -> crate::model::image_config::Builder {
        crate::model::image_config::Builder::default()
    }
}

/// <p>Specifies an authentication configuration for the private docker registry where your
/// model image is hosted. Specify a value for this property only if you specified
/// <code>Vpc</code> as the value for the <code>RepositoryAccessMode</code> field of the
/// <code>ImageConfig</code> object that you passed to a call to <a>CreateModel</a> and the private Docker registry where the model image is
/// hosted requires authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryAuthConfig {
    /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to
    /// authenticate to the private Docker registry where your model image is hosted. For
    /// information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function
    /// with the console</a> in the <i>Amazon Web Services Lambda Developer
    /// Guide</i>.</p>
    pub repository_credentials_provider_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryAuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryAuthConfig");
        formatter.field(
            "repository_credentials_provider_arn",
            &self.repository_credentials_provider_arn,
        );
        formatter.finish()
    }
}
/// See [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
pub mod repository_auth_config {
    /// A builder for [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_credentials_provider_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of an Amazon Web Services Lambda function that provides credentials to
        /// authenticate to the private Docker registry where your model image is hosted. For
        /// information about how to create an Amazon Web Services Lambda function, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function
        /// with the console</a> in the <i>Amazon Web Services Lambda Developer
        /// Guide</i>.</p>
        pub fn repository_credentials_provider_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.repository_credentials_provider_arn = Some(input.into());
            self
        }
        pub fn set_repository_credentials_provider_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_credentials_provider_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
        pub fn build(self) -> crate::model::RepositoryAuthConfig {
            crate::model::RepositoryAuthConfig {
                repository_credentials_provider_arn: self.repository_credentials_provider_arn,
            }
        }
    }
}
impl RepositoryAuthConfig {
    /// Creates a new builder-style object to manufacture [`RepositoryAuthConfig`](crate::model::RepositoryAuthConfig)
    pub fn builder() -> crate::model::repository_auth_config::Builder {
        crate::model::repository_auth_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RepositoryAccessMode {
    Platform,
    Vpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RepositoryAccessMode {
    fn from(s: &str) -> Self {
        match s {
            "Platform" => RepositoryAccessMode::Platform,
            "Vpc" => RepositoryAccessMode::Vpc,
            other => RepositoryAccessMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RepositoryAccessMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RepositoryAccessMode::from(s))
    }
}
impl RepositoryAccessMode {
    pub fn as_str(&self) -> &str {
        match self {
            RepositoryAccessMode::Platform => "Platform",
            RepositoryAccessMode::Vpc => "Vpc",
            RepositoryAccessMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Platform", "Vpc"]
    }
}
impl AsRef<str> for RepositoryAccessMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information required for human workers to complete a labeling task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanTaskConfig {
    /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>Information about the user interface that workers use to complete the labeling
    /// task.</p>
    pub ui_config: std::option::Option<crate::model::UiConfig>,
    /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object
    /// is sent to a human worker. Use this function to provide input to a custom labeling
    /// job.</p>
    /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in
    /// task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for
    /// <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
    /// <p>
    /// <b>Bounding box</b> - Finds the most similar boxes from
    /// different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Image classification</b> - Uses a variant of the Expectation
    /// Maximization approach to estimate the true class of an image based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Multi-label image classification</b> - Uses a variant of the Expectation
    /// Maximization approach to estimate the true classes of an image based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Semantic segmentation</b> - Treats each pixel in an image as
    /// a multi-class classification and treats pixel annotations from workers as
    /// "votes" for the correct label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Text classification</b> - Uses a variant of the Expectation
    /// Maximization approach to estimate the true class of text based on annotations
    /// from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Multi-label text classification</b> - Uses a variant of the
    /// Expectation Maximization approach to estimate the true classes of text based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Named entity recognition</b> - Groups similar selections and
    /// calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Classification</b> - Use this task type when you need workers to classify videos using
    /// predefined labels that you specify. Workers are shown videos and are asked to choose one
    /// label for each video.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Detection</b> - Use this task type to
    /// have workers identify and locate objects in a sequence of video frames (images extracted
    /// from a video) using bounding boxes. For example, you can use this task to ask workers to
    /// identify and localize various objects in a series of video frames, such as cars, bikes,
    /// and pedestrians.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Tracking</b> - Use this task type to
    /// have workers track the movement of objects in a sequence of video frames (images
    /// extracted from a video) using bounding boxes. For example, you can use this task to ask
    /// workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Modalities</b>
    /// </p>
    /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks.
    /// See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types
    /// </a> to learn more. </p>
    /// <p>
    /// <b>3D Point Cloud Object Detection</b> -
    /// Use this task type when you want workers to classify objects in a 3D point cloud by
    /// drawing 3D cuboids around objects. For example, you can use this task type to ask workers
    /// to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Object Tracking</b> -
    /// Use this task type when you want workers to draw 3D cuboids around objects
    /// that appear in a sequence of 3D point cloud frames.
    /// For example, you can use this task type to ask workers to track
    /// the movement of vehicles across multiple point cloud frames.
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Semantic Segmentation</b> -
    /// Use this task type when you want workers to create a point-level semantic segmentation masks by
    /// painting objects in a 3D point cloud using different colors where each color is assigned to one of
    /// the classes you specify.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Use the following ARNs for Label Verification and Adjustment Jobs</b>
    /// </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p>
    /// <b>Bounding box verification</b> - Uses a variant of the
    /// Expectation Maximization approach to estimate the true class of verification
    /// judgement for bounding box labels based on annotations from individual
    /// workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Bounding box adjustment</b> - Finds the most similar boxes
    /// from different workers based on the Jaccard index of the adjusted
    /// annotations.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Semantic segmentation verification</b> - Uses a variant of
    /// the Expectation Maximization approach to estimate the true class of verification
    /// judgment for semantic segmentation labels based on annotations from individual
    /// workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Semantic segmentation adjustment</b> - Treats each pixel in
    /// an image as a multi-class classification and treats pixel adjusted annotations
    /// from workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Detection Adjustment</b> -
    /// Use this task type when you want workers to adjust bounding boxes that workers have added
    /// to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Tracking Adjustment</b> -
    /// Use this task type when you want workers to adjust bounding boxes that workers have added
    /// to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D point cloud object detection adjustment</b> - Adjust
    /// 3D cuboids in a point cloud frame. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D point cloud object tracking adjustment</b> - Adjust 3D
    /// cuboids across a sequence of point cloud frames. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D point cloud semantic segmentation adjustment</b> -
    /// Adjust semantic segmentation masks in a 3D point cloud. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    pub pre_human_task_lambda_arn: std::option::Option<std::string::String>,
    /// <p>Keywords used to describe the task so that workers on Amazon Mechanical Turk can
    /// discover the task.</p>
    pub task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A title for the task for your human workers.</p>
    pub task_title: std::option::Option<std::string::String>,
    /// <p>A description of the task for your human workers.</p>
    pub task_description: std::option::Option<std::string::String>,
    /// <p>The number of human workers that will label an object. </p>
    pub number_of_human_workers_per_data_object: std::option::Option<i32>,
    /// <p>The amount of time that a worker has to complete a task. </p>
    /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours
    /// (28,800 seconds).</p>
    /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum
    /// for this parameter depends on the task type you use:</p>
    /// <ul>
    /// <li>
    /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs,
    /// the maximum is 8 hours (28,800 seconds).</p>
    /// </li>
    /// <li>
    /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs,
    /// the maximum is 7 days (604,800 seconds). If you want to change these limits,
    /// contact Amazon Web Services Support.</p>
    /// </li>
    /// </ul>
    pub task_time_limit_in_seconds: std::option::Option<i32>,
    /// <p>The length of time that a task remains available for labeling by human workers. The
    /// default and maximum values for this parameter depend on the type of workforce you
    /// use.</p>
    /// <ul>
    /// <li>
    /// <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds).
    /// The default is 6 hours (21,600 seconds).</p>
    /// </li>
    /// <li>
    /// <p>If you choose a private or vendor workforce, the default value is 10 days
    /// (864,000 seconds). For most users, the maximum is also 10 days. If you want to
    /// change this limit, contact Amazon Web Services Support.</p>
    /// </li>
    /// </ul>
    pub task_availability_lifetime_in_seconds: std::option::Option<i32>,
    /// <p>Defines the maximum number of data objects that can be labeled by human workers at the
    /// same time. Also referred to as batch size. Each object may have more than one worker at one time.
    /// The default value is 1000 objects.</p>
    pub max_concurrent_task_count: std::option::Option<i32>,
    /// <p>Configures how labels are consolidated across human workers.</p>
    pub annotation_consolidation_config:
        std::option::Option<crate::model::AnnotationConsolidationConfig>,
    /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
    pub public_workforce_task_price: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
}
impl std::fmt::Debug for HumanTaskConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanTaskConfig");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("ui_config", &self.ui_config);
        formatter.field("pre_human_task_lambda_arn", &self.pre_human_task_lambda_arn);
        formatter.field("task_keywords", &self.task_keywords);
        formatter.field("task_title", &self.task_title);
        formatter.field("task_description", &self.task_description);
        formatter.field(
            "number_of_human_workers_per_data_object",
            &self.number_of_human_workers_per_data_object,
        );
        formatter.field(
            "task_time_limit_in_seconds",
            &self.task_time_limit_in_seconds,
        );
        formatter.field(
            "task_availability_lifetime_in_seconds",
            &self.task_availability_lifetime_in_seconds,
        );
        formatter.field("max_concurrent_task_count", &self.max_concurrent_task_count);
        formatter.field(
            "annotation_consolidation_config",
            &self.annotation_consolidation_config,
        );
        formatter.field(
            "public_workforce_task_price",
            &self.public_workforce_task_price,
        );
        formatter.finish()
    }
}
/// See [`HumanTaskConfig`](crate::model::HumanTaskConfig)
pub mod human_task_config {
    /// A builder for [`HumanTaskConfig`](crate::model::HumanTaskConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) ui_config: std::option::Option<crate::model::UiConfig>,
        pub(crate) pre_human_task_lambda_arn: std::option::Option<std::string::String>,
        pub(crate) task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) task_title: std::option::Option<std::string::String>,
        pub(crate) task_description: std::option::Option<std::string::String>,
        pub(crate) number_of_human_workers_per_data_object: std::option::Option<i32>,
        pub(crate) task_time_limit_in_seconds: std::option::Option<i32>,
        pub(crate) task_availability_lifetime_in_seconds: std::option::Option<i32>,
        pub(crate) max_concurrent_task_count: std::option::Option<i32>,
        pub(crate) annotation_consolidation_config:
            std::option::Option<crate::model::AnnotationConsolidationConfig>,
        pub(crate) public_workforce_task_price:
            std::option::Option<crate::model::PublicWorkforceTaskPrice>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the work team assigned to complete the tasks.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>Information about the user interface that workers use to complete the labeling
        /// task.</p>
        pub fn ui_config(mut self, input: crate::model::UiConfig) -> Self {
            self.ui_config = Some(input);
            self
        }
        pub fn set_ui_config(mut self, input: std::option::Option<crate::model::UiConfig>) -> Self {
            self.ui_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a Lambda function that is run before a data object
        /// is sent to a human worker. Use this function to provide input to a custom labeling
        /// job.</p>
        /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in
        /// task types</a>, use one of the following Amazon SageMaker Ground Truth Lambda function ARNs for
        /// <code>PreHumanTaskLambdaArn</code>. For custom labeling workflows, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-prelambda">Pre-annotation Lambda</a>. </p>
        /// <p>
        /// <b>Bounding box</b> - Finds the most similar boxes from
        /// different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-BoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Image classification</b> - Uses a variant of the Expectation
        /// Maximization approach to estimate the true class of an image based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Multi-label image classification</b> - Uses a variant of the Expectation
        /// Maximization approach to estimate the true classes of an image based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Semantic segmentation</b> - Treats each pixel in an image as
        /// a multi-class classification and treats pixel annotations from workers as
        /// "votes" for the correct label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Text classification</b> - Uses a variant of the Expectation
        /// Maximization approach to estimate the true class of text based on annotations
        /// from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Multi-label text classification</b> - Uses a variant of the
        /// Expectation Maximization approach to estimate the true classes of text based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Named entity recognition</b> - Groups similar selections and
        /// calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Classification</b> - Use this task type when you need workers to classify videos using
        /// predefined labels that you specify. Workers are shown videos and are asked to choose one
        /// label for each video.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Detection</b> - Use this task type to
        /// have workers identify and locate objects in a sequence of video frames (images extracted
        /// from a video) using bounding boxes. For example, you can use this task to ask workers to
        /// identify and localize various objects in a series of video frames, such as cars, bikes,
        /// and pedestrians.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Tracking</b> - Use this task type to
        /// have workers track the movement of objects in a sequence of video frames (images
        /// extracted from a video) using bounding boxes. For example, you can use this task to ask
        /// workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Modalities</b>
        /// </p>
        /// <p>Use the following pre-annotation lambdas for 3D point cloud labeling modality tasks.
        /// See <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud-task-types.html">3D Point Cloud Task types
        /// </a> to learn more. </p>
        /// <p>
        /// <b>3D Point Cloud Object Detection</b> -
        /// Use this task type when you want workers to classify objects in a 3D point cloud by
        /// drawing 3D cuboids around objects. For example, you can use this task type to ask workers
        /// to identify different types of objects in a point cloud, such as cars, bikes, and pedestrians.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Object Tracking</b> -
        /// Use this task type when you want workers to draw 3D cuboids around objects
        /// that appear in a sequence of 3D point cloud frames.
        /// For example, you can use this task type to ask workers to track
        /// the movement of vehicles across multiple point cloud frames.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Semantic Segmentation</b> -
        /// Use this task type when you want workers to create a point-level semantic segmentation masks by
        /// painting objects in a 3D point cloud using different colors where each color is assigned to one of
        /// the classes you specify.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Use the following ARNs for Label Verification and Adjustment Jobs</b>
        /// </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more,
        /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p>
        /// <b>Bounding box verification</b> - Uses a variant of the
        /// Expectation Maximization approach to estimate the true class of verification
        /// judgement for bounding box labels based on annotations from individual
        /// workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Bounding box adjustment</b> - Finds the most similar boxes
        /// from different workers based on the Jaccard index of the adjusted
        /// annotations.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Semantic segmentation verification</b> - Uses a variant of
        /// the Expectation Maximization approach to estimate the true class of verification
        /// judgment for semantic segmentation labels based on annotations from individual
        /// workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Semantic segmentation adjustment</b> - Treats each pixel in
        /// an image as a multi-class classification and treats pixel adjusted annotations
        /// from workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Detection Adjustment</b> -
        /// Use this task type when you want workers to adjust bounding boxes that workers have added
        /// to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Tracking Adjustment</b> -
        /// Use this task type when you want workers to adjust bounding boxes that workers have added
        /// to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D point cloud object detection adjustment</b> - Adjust
        /// 3D cuboids in a point cloud frame. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D point cloud object tracking adjustment</b> - Adjust 3D
        /// cuboids across a sequence of point cloud frames. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D point cloud semantic segmentation adjustment</b> -
        /// Adjust semantic segmentation masks in a 3D point cloud. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:PRE-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn pre_human_task_lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.pre_human_task_lambda_arn = Some(input.into());
            self
        }
        pub fn set_pre_human_task_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pre_human_task_lambda_arn = input;
            self
        }
        pub fn task_keywords(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.task_keywords.unwrap_or_default();
            v.push(input.into());
            self.task_keywords = Some(v);
            self
        }
        pub fn set_task_keywords(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.task_keywords = input;
            self
        }
        /// <p>A title for the task for your human workers.</p>
        pub fn task_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_title = Some(input.into());
            self
        }
        pub fn set_task_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_title = input;
            self
        }
        /// <p>A description of the task for your human workers.</p>
        pub fn task_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_description = Some(input.into());
            self
        }
        pub fn set_task_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_description = input;
            self
        }
        /// <p>The number of human workers that will label an object. </p>
        pub fn number_of_human_workers_per_data_object(mut self, input: i32) -> Self {
            self.number_of_human_workers_per_data_object = Some(input);
            self
        }
        pub fn set_number_of_human_workers_per_data_object(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_human_workers_per_data_object = input;
            self
        }
        /// <p>The amount of time that a worker has to complete a task. </p>
        /// <p>If you create a custom labeling job, the maximum value for this parameter is 8 hours
        /// (28,800 seconds).</p>
        /// <p>If you create a labeling job using a <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task type</a> the maximum
        /// for this parameter depends on the task type you use:</p>
        /// <ul>
        /// <li>
        /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-images.html">image</a> and
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-label-text.html">text</a> labeling jobs,
        /// the maximum is 8 hours (28,800 seconds).</p>
        /// </li>
        /// <li>
        /// <p>For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-point-cloud.html">3D point cloud</a> and <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-video.html">video frame</a> labeling jobs,
        /// the maximum is 7 days (604,800 seconds). If you want to change these limits,
        /// contact Amazon Web Services Support.</p>
        /// </li>
        /// </ul>
        pub fn task_time_limit_in_seconds(mut self, input: i32) -> Self {
            self.task_time_limit_in_seconds = Some(input);
            self
        }
        pub fn set_task_time_limit_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.task_time_limit_in_seconds = input;
            self
        }
        /// <p>The length of time that a task remains available for labeling by human workers. The
        /// default and maximum values for this parameter depend on the type of workforce you
        /// use.</p>
        /// <ul>
        /// <li>
        /// <p>If you choose the Amazon Mechanical Turk workforce, the maximum is 12 hours (43,200 seconds).
        /// The default is 6 hours (21,600 seconds).</p>
        /// </li>
        /// <li>
        /// <p>If you choose a private or vendor workforce, the default value is 10 days
        /// (864,000 seconds). For most users, the maximum is also 10 days. If you want to
        /// change this limit, contact Amazon Web Services Support.</p>
        /// </li>
        /// </ul>
        pub fn task_availability_lifetime_in_seconds(mut self, input: i32) -> Self {
            self.task_availability_lifetime_in_seconds = Some(input);
            self
        }
        pub fn set_task_availability_lifetime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.task_availability_lifetime_in_seconds = input;
            self
        }
        /// <p>Defines the maximum number of data objects that can be labeled by human workers at the
        /// same time. Also referred to as batch size. Each object may have more than one worker at one time.
        /// The default value is 1000 objects.</p>
        pub fn max_concurrent_task_count(mut self, input: i32) -> Self {
            self.max_concurrent_task_count = Some(input);
            self
        }
        pub fn set_max_concurrent_task_count(mut self, input: std::option::Option<i32>) -> Self {
            self.max_concurrent_task_count = input;
            self
        }
        /// <p>Configures how labels are consolidated across human workers.</p>
        pub fn annotation_consolidation_config(
            mut self,
            input: crate::model::AnnotationConsolidationConfig,
        ) -> Self {
            self.annotation_consolidation_config = Some(input);
            self
        }
        pub fn set_annotation_consolidation_config(
            mut self,
            input: std::option::Option<crate::model::AnnotationConsolidationConfig>,
        ) -> Self {
            self.annotation_consolidation_config = input;
            self
        }
        /// <p>The price that you pay for each task performed by an Amazon Mechanical Turk worker.</p>
        pub fn public_workforce_task_price(
            mut self,
            input: crate::model::PublicWorkforceTaskPrice,
        ) -> Self {
            self.public_workforce_task_price = Some(input);
            self
        }
        pub fn set_public_workforce_task_price(
            mut self,
            input: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
        ) -> Self {
            self.public_workforce_task_price = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanTaskConfig`](crate::model::HumanTaskConfig)
        pub fn build(self) -> crate::model::HumanTaskConfig {
            crate::model::HumanTaskConfig {
                workteam_arn: self.workteam_arn,
                ui_config: self.ui_config,
                pre_human_task_lambda_arn: self.pre_human_task_lambda_arn,
                task_keywords: self.task_keywords,
                task_title: self.task_title,
                task_description: self.task_description,
                number_of_human_workers_per_data_object: self
                    .number_of_human_workers_per_data_object,
                task_time_limit_in_seconds: self.task_time_limit_in_seconds,
                task_availability_lifetime_in_seconds: self.task_availability_lifetime_in_seconds,
                max_concurrent_task_count: self.max_concurrent_task_count,
                annotation_consolidation_config: self.annotation_consolidation_config,
                public_workforce_task_price: self.public_workforce_task_price,
            }
        }
    }
}
impl HumanTaskConfig {
    /// Creates a new builder-style object to manufacture [`HumanTaskConfig`](crate::model::HumanTaskConfig)
    pub fn builder() -> crate::model::human_task_config::Builder {
        crate::model::human_task_config::Builder::default()
    }
}

/// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
/// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and
/// should be based on the complexity of the task; the longer it takes in your initial
/// testing, the more you should offer.</p>
/// <ul>
/// <li>
/// <p>0.036</p>
/// </li>
/// <li>
/// <p>0.048</p>
/// </li>
/// <li>
/// <p>0.060</p>
/// </li>
/// <li>
/// <p>0.072</p>
/// </li>
/// <li>
/// <p>0.120</p>
/// </li>
/// <li>
/// <p>0.240</p>
/// </li>
/// <li>
/// <p>0.360</p>
/// </li>
/// <li>
/// <p>0.480</p>
/// </li>
/// <li>
/// <p>0.600</p>
/// </li>
/// <li>
/// <p>0.720</p>
/// </li>
/// <li>
/// <p>0.840</p>
/// </li>
/// <li>
/// <p>0.960</p>
/// </li>
/// <li>
/// <p>1.080</p>
/// </li>
/// <li>
/// <p>1.200</p>
/// </li>
/// </ul>
/// <p>Use one of the following prices for image classification, text classification, and
/// custom tasks. Prices are in US dollars.</p>
/// <ul>
/// <li>
/// <p>0.012</p>
/// </li>
/// <li>
/// <p>0.024</p>
/// </li>
/// <li>
/// <p>0.036</p>
/// </li>
/// <li>
/// <p>0.048</p>
/// </li>
/// <li>
/// <p>0.060</p>
/// </li>
/// <li>
/// <p>0.072</p>
/// </li>
/// <li>
/// <p>0.120</p>
/// </li>
/// <li>
/// <p>0.240</p>
/// </li>
/// <li>
/// <p>0.360</p>
/// </li>
/// <li>
/// <p>0.480</p>
/// </li>
/// <li>
/// <p>0.600</p>
/// </li>
/// <li>
/// <p>0.720</p>
/// </li>
/// <li>
/// <p>0.840</p>
/// </li>
/// <li>
/// <p>0.960</p>
/// </li>
/// <li>
/// <p>1.080</p>
/// </li>
/// <li>
/// <p>1.200</p>
/// </li>
/// </ul>
/// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US
/// dollars.</p>
/// <ul>
/// <li>
/// <p>0.840</p>
/// </li>
/// <li>
/// <p>0.960</p>
/// </li>
/// <li>
/// <p>1.080</p>
/// </li>
/// <li>
/// <p>1.200</p>
/// </li>
/// </ul>
/// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon
/// Augmented AI review tasks. Prices are in US dollars.</p>
/// <ul>
/// <li>
/// <p>2.400 </p>
/// </li>
/// <li>
/// <p>2.280 </p>
/// </li>
/// <li>
/// <p>2.160 </p>
/// </li>
/// <li>
/// <p>2.040 </p>
/// </li>
/// <li>
/// <p>1.920 </p>
/// </li>
/// <li>
/// <p>1.800 </p>
/// </li>
/// <li>
/// <p>1.680 </p>
/// </li>
/// <li>
/// <p>1.560 </p>
/// </li>
/// <li>
/// <p>1.440 </p>
/// </li>
/// <li>
/// <p>1.320 </p>
/// </li>
/// <li>
/// <p>1.200 </p>
/// </li>
/// <li>
/// <p>1.080 </p>
/// </li>
/// <li>
/// <p>0.960 </p>
/// </li>
/// <li>
/// <p>0.840 </p>
/// </li>
/// <li>
/// <p>0.720 </p>
/// </li>
/// <li>
/// <p>0.600 </p>
/// </li>
/// <li>
/// <p>0.480 </p>
/// </li>
/// <li>
/// <p>0.360 </p>
/// </li>
/// <li>
/// <p>0.240 </p>
/// </li>
/// <li>
/// <p>0.120 </p>
/// </li>
/// <li>
/// <p>0.072 </p>
/// </li>
/// <li>
/// <p>0.060 </p>
/// </li>
/// <li>
/// <p>0.048 </p>
/// </li>
/// <li>
/// <p>0.036 </p>
/// </li>
/// <li>
/// <p>0.024 </p>
/// </li>
/// <li>
/// <p>0.012 </p>
/// </li>
/// </ul>
/// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon
/// Augmented AI review tasks. Prices are in US dollars.</p>
/// <ul>
/// <li>
/// <p>1.200 </p>
/// </li>
/// <li>
/// <p>1.080 </p>
/// </li>
/// <li>
/// <p>0.960 </p>
/// </li>
/// <li>
/// <p>0.840 </p>
/// </li>
/// <li>
/// <p>0.720 </p>
/// </li>
/// <li>
/// <p>0.600 </p>
/// </li>
/// <li>
/// <p>0.480 </p>
/// </li>
/// <li>
/// <p>0.360 </p>
/// </li>
/// <li>
/// <p>0.240 </p>
/// </li>
/// <li>
/// <p>0.120 </p>
/// </li>
/// <li>
/// <p>0.072 </p>
/// </li>
/// <li>
/// <p>0.060 </p>
/// </li>
/// <li>
/// <p>0.048 </p>
/// </li>
/// <li>
/// <p>0.036 </p>
/// </li>
/// <li>
/// <p>0.024 </p>
/// </li>
/// <li>
/// <p>0.012 </p>
/// </li>
/// </ul>
/// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks.
/// Prices are in US dollars.</p>
/// <ul>
/// <li>
/// <p>1.200 </p>
/// </li>
/// <li>
/// <p>1.080 </p>
/// </li>
/// <li>
/// <p>0.960 </p>
/// </li>
/// <li>
/// <p>0.840 </p>
/// </li>
/// <li>
/// <p>0.720 </p>
/// </li>
/// <li>
/// <p>0.600 </p>
/// </li>
/// <li>
/// <p>0.480 </p>
/// </li>
/// <li>
/// <p>0.360 </p>
/// </li>
/// <li>
/// <p>0.240 </p>
/// </li>
/// <li>
/// <p>0.120 </p>
/// </li>
/// <li>
/// <p>0.072 </p>
/// </li>
/// <li>
/// <p>0.060 </p>
/// </li>
/// <li>
/// <p>0.048 </p>
/// </li>
/// <li>
/// <p>0.036 </p>
/// </li>
/// <li>
/// <p>0.024 </p>
/// </li>
/// <li>
/// <p>0.012 </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicWorkforceTaskPrice {
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
    pub amount_in_usd: std::option::Option<crate::model::Usd>,
}
impl std::fmt::Debug for PublicWorkforceTaskPrice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicWorkforceTaskPrice");
        formatter.field("amount_in_usd", &self.amount_in_usd);
        formatter.finish()
    }
}
/// See [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
pub mod public_workforce_task_price {
    /// A builder for [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount_in_usd: std::option::Option<crate::model::Usd>,
    }
    impl Builder {
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker in United States dollars.</p>
        pub fn amount_in_usd(mut self, input: crate::model::Usd) -> Self {
            self.amount_in_usd = Some(input);
            self
        }
        pub fn set_amount_in_usd(mut self, input: std::option::Option<crate::model::Usd>) -> Self {
            self.amount_in_usd = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
        pub fn build(self) -> crate::model::PublicWorkforceTaskPrice {
            crate::model::PublicWorkforceTaskPrice {
                amount_in_usd: self.amount_in_usd,
            }
        }
    }
}
impl PublicWorkforceTaskPrice {
    /// Creates a new builder-style object to manufacture [`PublicWorkforceTaskPrice`](crate::model::PublicWorkforceTaskPrice)
    pub fn builder() -> crate::model::public_workforce_task_price::Builder {
        crate::model::public_workforce_task_price::Builder::default()
    }
}

/// <p>Represents an amount of money in United States dollars.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Usd {
    /// <p>The whole number of dollars in the amount.</p>
    pub dollars: i32,
    /// <p>The fractional portion, in cents, of the amount. </p>
    pub cents: i32,
    /// <p>Fractions of a cent, in tenths.</p>
    pub tenth_fractions_of_a_cent: i32,
}
impl std::fmt::Debug for Usd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Usd");
        formatter.field("dollars", &self.dollars);
        formatter.field("cents", &self.cents);
        formatter.field("tenth_fractions_of_a_cent", &self.tenth_fractions_of_a_cent);
        formatter.finish()
    }
}
/// See [`Usd`](crate::model::Usd)
pub mod usd {
    /// A builder for [`Usd`](crate::model::Usd)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dollars: std::option::Option<i32>,
        pub(crate) cents: std::option::Option<i32>,
        pub(crate) tenth_fractions_of_a_cent: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The whole number of dollars in the amount.</p>
        pub fn dollars(mut self, input: i32) -> Self {
            self.dollars = Some(input);
            self
        }
        pub fn set_dollars(mut self, input: std::option::Option<i32>) -> Self {
            self.dollars = input;
            self
        }
        /// <p>The fractional portion, in cents, of the amount. </p>
        pub fn cents(mut self, input: i32) -> Self {
            self.cents = Some(input);
            self
        }
        pub fn set_cents(mut self, input: std::option::Option<i32>) -> Self {
            self.cents = input;
            self
        }
        /// <p>Fractions of a cent, in tenths.</p>
        pub fn tenth_fractions_of_a_cent(mut self, input: i32) -> Self {
            self.tenth_fractions_of_a_cent = Some(input);
            self
        }
        pub fn set_tenth_fractions_of_a_cent(mut self, input: std::option::Option<i32>) -> Self {
            self.tenth_fractions_of_a_cent = input;
            self
        }
        /// Consumes the builder and constructs a [`Usd`](crate::model::Usd)
        pub fn build(self) -> crate::model::Usd {
            crate::model::Usd {
                dollars: self.dollars.unwrap_or_default(),
                cents: self.cents.unwrap_or_default(),
                tenth_fractions_of_a_cent: self.tenth_fractions_of_a_cent.unwrap_or_default(),
            }
        }
    }
}
impl Usd {
    /// Creates a new builder-style object to manufacture [`Usd`](crate::model::Usd)
    pub fn builder() -> crate::model::usd::Builder {
        crate::model::usd::Builder::default()
    }
}

/// <p>Configures how labels are consolidated across human workers and processes output data.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnnotationConsolidationConfig {
    /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
    /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one
    /// of the following Amazon SageMaker Ground Truth Lambda function ARNs for
    /// <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
    /// <p>
    /// <b>Bounding box</b> - Finds the most similar boxes from
    /// different workers based on the Jaccard index of the boxes.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Image classification</b> - Uses a variant of the
    /// Expectation Maximization approach to estimate the true class of an image based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Multi-label image classification</b> - Uses a variant of
    /// the Expectation Maximization approach to estimate the true classes of an image based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Semantic segmentation</b> - Treats each pixel in an image
    /// as a multi-class classification and treats pixel annotations from workers as "votes" for
    /// the correct label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Text classification</b> - Uses a variant of the
    /// Expectation Maximization approach to estimate the true class of text based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>rn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Multi-label text classification</b> - Uses a variant of
    /// the Expectation Maximization approach to estimate the true classes of text based on
    /// annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Named entity recognition</b> - Groups similar selections
    /// and calculates aggregate boundaries, resolving to most-assigned label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Classification</b> - Use this task type when you need workers to classify videos using
    /// predefined labels that you specify. Workers are shown videos and are asked to choose one
    /// label for each video.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Detection</b> - Use this task type to
    /// have workers identify and locate objects in a sequence of video frames (images extracted
    /// from a video) using bounding boxes. For example, you can use this task to ask workers to
    /// identify and localize various objects in a series of video frames, such as cars, bikes,
    /// and pedestrians.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Tracking</b> - Use this task type to
    /// have workers track the movement of objects in a sequence of video frames (images
    /// extracted from a video) using bounding boxes. For example, you can use this task to ask
    /// workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Object Detection</b> - Use this task type
    /// when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids
    /// around objects. For example, you can use this task type to ask workers to identify
    /// different types of objects in a point cloud, such as cars, bikes, and
    /// pedestrians.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Object Tracking</b> - Use this task type
    /// when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D
    /// point cloud frames. For example, you can use this task type to ask workers to track the
    /// movement of vehicles across multiple point cloud frames. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Semantic Segmentation</b> - Use this task
    /// type when you want workers to create a point-level semantic segmentation masks by
    /// painting objects in a 3D point cloud using different colors where each color is assigned
    /// to one of the classes you specify.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Use the following ARNs for Label Verification and Adjustment Jobs</b>
    /// </p>
    /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more,
    /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
    /// <p>
    /// <b>Semantic Segmentation Adjustment</b> - Treats each pixel
    /// in an image as a multi-class classification and treats pixel adjusted annotations from
    /// workers as "votes" for the correct label.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Semantic Segmentation Verification</b> - Uses a variant
    /// of the Expectation Maximization approach to estimate the true class of verification
    /// judgment for semantic segmentation labels based on annotations from individual
    /// workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Bounding Box Adjustment</b> - Finds the most similar
    /// boxes from different workers based on the Jaccard index of the adjusted
    /// annotations.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Bounding Box Verification</b> - Uses a variant of the
    /// Expectation Maximization approach to estimate the true class of verification judgement
    /// for bounding box labels based on annotations from individual workers.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Detection Adjustment</b> -
    /// Use this task type when you want workers to adjust bounding boxes that workers have added
    /// to video frames to classify and localize objects in a sequence of video frames.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame Object Tracking Adjustment</b> -
    /// Use this task type when you want workers to adjust bounding boxes that workers have added
    /// to video frames to track object movement across a sequence of video frames.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Object Detection Adjustment</b> - Use this
    /// task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Object Tracking Adjustment</b> - Use this
    /// task type when you want workers to adjust 3D cuboids around objects that appear in a
    /// sequence of 3D point cloud frames.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task
    /// type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    pub annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnnotationConsolidationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnnotationConsolidationConfig");
        formatter.field(
            "annotation_consolidation_lambda_arn",
            &self.annotation_consolidation_lambda_arn,
        );
        formatter.finish()
    }
}
/// See [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
pub mod annotation_consolidation_config {
    /// A builder for [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) annotation_consolidation_lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a Lambda function implements the logic for <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-annotation-consolidation.html">annotation consolidation</a> and to process output data.</p>
        /// <p>This parameter is required for all labeling jobs. For <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-task-types.html">built-in task types</a>, use one
        /// of the following Amazon SageMaker Ground Truth Lambda function ARNs for
        /// <code>AnnotationConsolidationLambdaArn</code>. For custom labeling workflows, see
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step3.html#sms-custom-templates-step3-postlambda">Post-annotation Lambda</a>. </p>
        /// <p>
        /// <b>Bounding box</b> - Finds the most similar boxes from
        /// different workers based on the Jaccard index of the boxes.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-BoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Image classification</b> - Uses a variant of the
        /// Expectation Maximization approach to estimate the true class of an image based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Multi-label image classification</b> - Uses a variant of
        /// the Expectation Maximization approach to estimate the true classes of an image based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-ImageMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Semantic segmentation</b> - Treats each pixel in an image
        /// as a multi-class classification and treats pixel annotations from workers as "votes" for
        /// the correct label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-SemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Text classification</b> - Uses a variant of the
        /// Expectation Maximization approach to estimate the true class of text based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>rn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Multi-label text classification</b> - Uses a variant of
        /// the Expectation Maximization approach to estimate the true classes of text based on
        /// annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-TextMultiClassMultiLabel</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Named entity recognition</b> - Groups similar selections
        /// and calculates aggregate boundaries, resolving to most-assigned label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-NamedEntityRecognition</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Classification</b> - Use this task type when you need workers to classify videos using
        /// predefined labels that you specify. Workers are shown videos and are asked to choose one
        /// label for each video.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoMultiClass</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Detection</b> - Use this task type to
        /// have workers identify and locate objects in a sequence of video frames (images extracted
        /// from a video) using bounding boxes. For example, you can use this task to ask workers to
        /// identify and localize various objects in a series of video frames, such as cars, bikes,
        /// and pedestrians.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Tracking</b> - Use this task type to
        /// have workers track the movement of objects in a sequence of video frames (images
        /// extracted from a video) using bounding boxes. For example, you can use this task to ask
        /// workers to track the movement of objects, such as cars, bikes, and pedestrians. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Object Detection</b> - Use this task type
        /// when you want workers to classify objects in a 3D point cloud by drawing 3D cuboids
        /// around objects. For example, you can use this task type to ask workers to identify
        /// different types of objects in a point cloud, such as cars, bikes, and
        /// pedestrians.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Object Tracking</b> - Use this task type
        /// when you want workers to draw 3D cuboids around objects that appear in a sequence of 3D
        /// point cloud frames. For example, you can use this task type to ask workers to track the
        /// movement of vehicles across multiple point cloud frames. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Semantic Segmentation</b> - Use this task
        /// type when you want workers to create a point-level semantic segmentation masks by
        /// painting objects in a 3D point cloud using different colors where each color is assigned
        /// to one of the classes you specify.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Use the following ARNs for Label Verification and Adjustment Jobs</b>
        /// </p>
        /// <p>Use label verification and adjustment jobs to review and adjust labels. To learn more,
        /// see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-verification-data.html">Verify and Adjust Labels </a>.</p>
        /// <p>
        /// <b>Semantic Segmentation Adjustment</b> - Treats each pixel
        /// in an image as a multi-class classification and treats pixel adjusted annotations from
        /// workers as "votes" for the correct label.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Semantic Segmentation Verification</b> - Uses a variant
        /// of the Expectation Maximization approach to estimate the true class of verification
        /// judgment for semantic segmentation labels based on annotations from individual
        /// workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Bounding Box Adjustment</b> - Finds the most similar
        /// boxes from different workers based on the Jaccard index of the adjusted
        /// annotations.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentBoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Bounding Box Verification</b> - Uses a variant of the
        /// Expectation Maximization approach to estimate the true class of verification judgement
        /// for bounding box labels based on annotations from individual workers.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-VerificationBoundingBox</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Detection Adjustment</b> -
        /// Use this task type when you want workers to adjust bounding boxes that workers have added
        /// to video frames to classify and localize objects in a sequence of video frames.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame Object Tracking Adjustment</b> -
        /// Use this task type when you want workers to adjust bounding boxes that workers have added
        /// to video frames to track object movement across a sequence of video frames.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-AdjustmentVideoObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Object Detection Adjustment</b> - Use this
        /// task type when you want workers to adjust 3D cuboids around objects in a 3D point cloud. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Object Tracking Adjustment</b> - Use this
        /// task type when you want workers to adjust 3D cuboids around objects that appear in a
        /// sequence of 3D point cloud frames.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>3D Point Cloud Semantic Segmentation Adjustment</b> - Use this task
        /// type when you want workers to adjust a point-level semantic segmentation masks using a paint tool.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-1:432418664414:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-east-2:266458841044:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:us-west-2:081040173940:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-1:568282634449:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-1:477331159723:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-2:454466003867:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-south-1:565803892007:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-central-1:203001061592:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-northeast-2:845288260483:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:eu-west-2:487402164563:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ap-southeast-1:377565633583:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>arn:aws:lambda:ca-central-1:918755190332:function:ACS-Adjustment3DPointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn annotation_consolidation_lambda_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = Some(input.into());
            self
        }
        pub fn set_annotation_consolidation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.annotation_consolidation_lambda_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
        pub fn build(self) -> crate::model::AnnotationConsolidationConfig {
            crate::model::AnnotationConsolidationConfig {
                annotation_consolidation_lambda_arn: self.annotation_consolidation_lambda_arn,
            }
        }
    }
}
impl AnnotationConsolidationConfig {
    /// Creates a new builder-style object to manufacture [`AnnotationConsolidationConfig`](crate::model::AnnotationConsolidationConfig)
    pub fn builder() -> crate::model::annotation_consolidation_config::Builder {
        crate::model::annotation_consolidation_config::Builder::default()
    }
}

/// <p>Provided configuration information for the worker UI for a labeling job. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiConfig {
    /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the
    /// template used to render the worker UI and tools for labeling job tasks. For more
    /// information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom
    /// Labeling Task Template</a>.</p>
    pub ui_template_s3_uri: std::option::Option<std::string::String>,
    /// <p>The ARN of the worker task template used to render the worker UI and tools for
    /// labeling job tasks.</p>
    /// <p>Use this parameter when you are creating a labeling job for 3D point cloud and video
    /// fram labeling jobs. Use your labeling job task type to select one of the following ARNs
    /// and use it with this parameter when you create a labeling job. Replace
    /// <code>aws-region</code> with the Amazon Web Services region you are creating your labeling job
    /// in.</p>
    /// <p>
    /// <b>3D Point Cloud HumanTaskUiArns</b>
    /// </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point
    /// cloud object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point
    /// cloud object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D
    /// point cloud semantic segmentation adjustment labeling jobs.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>Video Frame HumanTaskUiArns</b>
    /// </p>
    /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame
    /// object detection adjustment labeling jobs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame
    /// object tracking adjustment labeling jobs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code>
    /// </p>
    /// </li>
    /// </ul>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UiConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiConfig");
        formatter.field("ui_template_s3_uri", &self.ui_template_s3_uri);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.finish()
    }
}
/// See [`UiConfig`](crate::model::UiConfig)
pub mod ui_config {
    /// A builder for [`UiConfig`](crate::model::UiConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ui_template_s3_uri: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket location of the UI template, or worker task template. This is the
        /// template used to render the worker UI and tools for labeling job tasks. For more
        /// information about the contents of a UI template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-custom-templates-step2.html"> Creating Your Custom
        /// Labeling Task Template</a>.</p>
        pub fn ui_template_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.ui_template_s3_uri = Some(input.into());
            self
        }
        pub fn set_ui_template_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ui_template_s3_uri = input;
            self
        }
        /// <p>The ARN of the worker task template used to render the worker UI and tools for
        /// labeling job tasks.</p>
        /// <p>Use this parameter when you are creating a labeling job for 3D point cloud and video
        /// fram labeling jobs. Use your labeling job task type to select one of the following ARNs
        /// and use it with this parameter when you create a labeling job. Replace
        /// <code>aws-region</code> with the Amazon Web Services region you are creating your labeling job
        /// in.</p>
        /// <p>
        /// <b>3D Point Cloud HumanTaskUiArns</b>
        /// </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for 3D point cloud object detection and 3D point
        /// cloud object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud object tracking and 3D point
        /// cloud object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for 3D point cloud semantic segmentation and 3D
        /// point cloud semantic segmentation adjustment labeling jobs.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/PointCloudSemanticSegmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>Video Frame HumanTaskUiArns</b>
        /// </p>
        /// <p>Use this <code>HumanTaskUiArn</code> for video frame object detection and video frame
        /// object detection adjustment labeling jobs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:sagemaker:region:394669845002:human-task-ui/VideoObjectDetection</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p> Use this <code>HumanTaskUiArn</code> for video frame object tracking and video frame
        /// object tracking adjustment labeling jobs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>arn:aws:sagemaker:aws-region:394669845002:human-task-ui/VideoObjectTracking</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UiConfig`](crate::model::UiConfig)
        pub fn build(self) -> crate::model::UiConfig {
            crate::model::UiConfig {
                ui_template_s3_uri: self.ui_template_s3_uri,
                human_task_ui_arn: self.human_task_ui_arn,
            }
        }
    }
}
impl UiConfig {
    /// Creates a new builder-style object to manufacture [`UiConfig`](crate::model::UiConfig)
    pub fn builder() -> crate::model::ui_config::Builder {
        crate::model::ui_config::Builder::default()
    }
}

/// <p>Provides configuration information for auto-labeling of your data objects. A
/// <code>LabelingJobAlgorithmsConfig</code> object must be supplied in order to use
/// auto-labeling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobAlgorithmsConfig {
    /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You
    /// must select one of the following ARNs:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <i>Image classification</i>
    /// </p>
    /// <p>
    /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>Text classification</i>
    /// </p>
    /// <p>
    /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>Object detection</i>
    /// </p>
    /// <p>
    /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <i>Semantic Segmentation</i>
    /// </p>
    /// <p>
    /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code>
    /// </p>
    /// </li>
    /// </ul>
    pub labeling_job_algorithm_specification_arn: std::option::Option<std::string::String>,
    /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final
    /// model used for auto-labeling. You can use this model as the starting point for
    /// subsequent similar jobs by providing the ARN of the model here. </p>
    pub initial_active_learning_model_arn: std::option::Option<std::string::String>,
    /// <p>Provides configuration information for a labeling job.</p>
    pub labeling_job_resource_config: std::option::Option<crate::model::LabelingJobResourceConfig>,
}
impl std::fmt::Debug for LabelingJobAlgorithmsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobAlgorithmsConfig");
        formatter.field(
            "labeling_job_algorithm_specification_arn",
            &self.labeling_job_algorithm_specification_arn,
        );
        formatter.field(
            "initial_active_learning_model_arn",
            &self.initial_active_learning_model_arn,
        );
        formatter.field(
            "labeling_job_resource_config",
            &self.labeling_job_resource_config,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
pub mod labeling_job_algorithms_config {
    /// A builder for [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labeling_job_algorithm_specification_arn:
            std::option::Option<std::string::String>,
        pub(crate) initial_active_learning_model_arn: std::option::Option<std::string::String>,
        pub(crate) labeling_job_resource_config:
            std::option::Option<crate::model::LabelingJobResourceConfig>,
    }
    impl Builder {
        /// <p>Specifies the Amazon Resource Name (ARN) of the algorithm used for auto-labeling. You
        /// must select one of the following ARNs:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>Image classification</i>
        /// </p>
        /// <p>
        /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/image-classification</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Text classification</i>
        /// </p>
        /// <p>
        /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/text-classification</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Object detection</i>
        /// </p>
        /// <p>
        /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/object-detection</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Semantic Segmentation</i>
        /// </p>
        /// <p>
        /// <code>arn:aws:sagemaker:<i>region</i>:027400017018:labeling-job-algorithm-specification/semantic-segmentation</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn labeling_job_algorithm_specification_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.labeling_job_algorithm_specification_arn = Some(input.into());
            self
        }
        pub fn set_labeling_job_algorithm_specification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.labeling_job_algorithm_specification_arn = input;
            self
        }
        /// <p>At the end of an auto-label job Ground Truth sends the Amazon Resource Name (ARN) of the final
        /// model used for auto-labeling. You can use this model as the starting point for
        /// subsequent similar jobs by providing the ARN of the model here. </p>
        pub fn initial_active_learning_model_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.initial_active_learning_model_arn = Some(input.into());
            self
        }
        pub fn set_initial_active_learning_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.initial_active_learning_model_arn = input;
            self
        }
        /// <p>Provides configuration information for a labeling job.</p>
        pub fn labeling_job_resource_config(
            mut self,
            input: crate::model::LabelingJobResourceConfig,
        ) -> Self {
            self.labeling_job_resource_config = Some(input);
            self
        }
        pub fn set_labeling_job_resource_config(
            mut self,
            input: std::option::Option<crate::model::LabelingJobResourceConfig>,
        ) -> Self {
            self.labeling_job_resource_config = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
        pub fn build(self) -> crate::model::LabelingJobAlgorithmsConfig {
            crate::model::LabelingJobAlgorithmsConfig {
                labeling_job_algorithm_specification_arn: self
                    .labeling_job_algorithm_specification_arn,
                initial_active_learning_model_arn: self.initial_active_learning_model_arn,
                labeling_job_resource_config: self.labeling_job_resource_config,
            }
        }
    }
}
impl LabelingJobAlgorithmsConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobAlgorithmsConfig`](crate::model::LabelingJobAlgorithmsConfig)
    pub fn builder() -> crate::model::labeling_job_algorithms_config::Builder {
        crate::model::labeling_job_algorithms_config::Builder::default()
    }
}

/// <p>Configure encryption on the storage volume attached to the ML compute instance used to
/// run automated data labeling model training and inference. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobResourceConfig {
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume
    /// attached to the ML compute instance(s) that run the training and inference jobs used for
    /// automated data labeling. </p>
    /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with
    /// automated data labeling enabled using the API operation <code>CreateLabelingJob</code>.
    /// You cannot specify an Amazon Web Services KMS customer managed CMK to encrypt the storage volume used for
    /// automated data labeling model training and inference when you create a labeling job
    /// using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume
    /// Encryption</a>.</p>
    /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
    /// <ul>
    /// <li>
    /// <p>KMS Key ID</p>
    /// <p>
    /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Amazon Resource Name (ARN) of a KMS Key</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// </ul>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LabelingJobResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobResourceConfig");
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
pub mod labeling_job_resource_config {
    /// A builder for [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt data on the storage volume
        /// attached to the ML compute instance(s) that run the training and inference jobs used for
        /// automated data labeling. </p>
        /// <p>You can only specify a <code>VolumeKmsKeyId</code> when you create a labeling job with
        /// automated data labeling enabled using the API operation <code>CreateLabelingJob</code>.
        /// You cannot specify an Amazon Web Services KMS customer managed CMK to encrypt the storage volume used for
        /// automated data labeling model training and inference when you create a labeling job
        /// using the console. To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security.html">Output Data and Storage Volume
        /// Encryption</a>.</p>
        /// <p>The <code>VolumeKmsKeyId</code> can be any of the following formats:</p>
        /// <ul>
        /// <li>
        /// <p>KMS Key ID</p>
        /// <p>
        /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Amazon Resource Name (ARN) of a KMS Key</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
        pub fn build(self) -> crate::model::LabelingJobResourceConfig {
            crate::model::LabelingJobResourceConfig {
                volume_kms_key_id: self.volume_kms_key_id,
            }
        }
    }
}
impl LabelingJobResourceConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobResourceConfig`](crate::model::LabelingJobResourceConfig)
    pub fn builder() -> crate::model::labeling_job_resource_config::Builder {
        crate::model::labeling_job_resource_config::Builder::default()
    }
}

/// <p>A set of conditions for stopping a labeling job. If any of the conditions are met, the
/// job is automatically stopped. You can use these conditions to control the cost of data
/// labeling.</p>
/// <note>
/// <p>Labeling jobs fail after 30 days with an appropriate client error message.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobStoppingConditions {
    /// <p>The maximum number of objects that can be labeled by human workers.</p>
    pub max_human_labeled_object_count: std::option::Option<i32>,
    /// <p>The maximum number of input data objects that should be labeled.</p>
    pub max_percentage_of_input_dataset_labeled: std::option::Option<i32>,
}
impl std::fmt::Debug for LabelingJobStoppingConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobStoppingConditions");
        formatter.field(
            "max_human_labeled_object_count",
            &self.max_human_labeled_object_count,
        );
        formatter.field(
            "max_percentage_of_input_dataset_labeled",
            &self.max_percentage_of_input_dataset_labeled,
        );
        formatter.finish()
    }
}
/// See [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
pub mod labeling_job_stopping_conditions {
    /// A builder for [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_human_labeled_object_count: std::option::Option<i32>,
        pub(crate) max_percentage_of_input_dataset_labeled: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of objects that can be labeled by human workers.</p>
        pub fn max_human_labeled_object_count(mut self, input: i32) -> Self {
            self.max_human_labeled_object_count = Some(input);
            self
        }
        pub fn set_max_human_labeled_object_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_human_labeled_object_count = input;
            self
        }
        /// <p>The maximum number of input data objects that should be labeled.</p>
        pub fn max_percentage_of_input_dataset_labeled(mut self, input: i32) -> Self {
            self.max_percentage_of_input_dataset_labeled = Some(input);
            self
        }
        pub fn set_max_percentage_of_input_dataset_labeled(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_percentage_of_input_dataset_labeled = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
        pub fn build(self) -> crate::model::LabelingJobStoppingConditions {
            crate::model::LabelingJobStoppingConditions {
                max_human_labeled_object_count: self.max_human_labeled_object_count,
                max_percentage_of_input_dataset_labeled: self
                    .max_percentage_of_input_dataset_labeled,
            }
        }
    }
}
impl LabelingJobStoppingConditions {
    /// Creates a new builder-style object to manufacture [`LabelingJobStoppingConditions`](crate::model::LabelingJobStoppingConditions)
    pub fn builder() -> crate::model::labeling_job_stopping_conditions::Builder {
        crate::model::labeling_job_stopping_conditions::Builder::default()
    }
}

/// <p>Output configuration information for a labeling job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LabelingJobOutputConfig {
    /// <p>The Amazon S3 location to write output data.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
    /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS
    /// key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
    /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your
    /// role's account to encrypt your output data.</p>
    /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only
    /// allows objects with server-side encryption, set the condition key of
    /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer
    /// Guide.</i>
    /// </p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to
    /// do real time chaining to another streaming job and receive an Amazon SNS notifications each
    /// time a data object is submitted by a worker.</p>
    /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers
    /// complete labeling tasks, Ground Truth will send labeling task output data to the SNS output
    /// topic you specify here. </p>
    /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling
    /// Job</a>. </p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LabelingJobOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LabelingJobOutputConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.finish()
    }
}
/// See [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
pub mod labeling_job_output_config {
    /// A builder for [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 location to write output data.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service ID of the key used to encrypt the output data, if any.</p>
        /// <p>If you provide your own KMS key ID, you must add the required permissions to your KMS
        /// key described in <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-security-permission.html#sms-security-kms-permissions">Encrypt Output Data and Storage Volume with Amazon Web Services KMS</a>.</p>
        /// <p>If you don't provide a KMS key ID, Amazon SageMaker uses the default Amazon Web Services KMS key for Amazon S3 for your
        /// role's account to encrypt your output data.</p>
        /// <p>If you use a bucket policy with an <code>s3:PutObject</code> permission that only
        /// allows objects with server-side encryption, set the condition key of
        /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption Keys</a> in the <i>Amazon Simple Storage Service Developer
        /// Guide.</i>
        /// </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>An Amazon Simple Notification Service (Amazon SNS) output topic ARN. Provide a <code>SnsTopicArn</code> if you want to
        /// do real time chaining to another streaming job and receive an Amazon SNS notifications each
        /// time a data object is submitted by a worker.</p>
        /// <p>If you provide an <code>SnsTopicArn</code> in <code>OutputConfig</code>, when workers
        /// complete labeling tasks, Ground Truth will send labeling task output data to the SNS output
        /// topic you specify here. </p>
        /// <p>To learn more, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-streaming-labeling-job.html#sms-streaming-how-it-works-output-data">Receive Output Data from a Streaming Labeling
        /// Job</a>. </p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
        pub fn build(self) -> crate::model::LabelingJobOutputConfig {
            crate::model::LabelingJobOutputConfig {
                s3_output_path: self.s3_output_path,
                kms_key_id: self.kms_key_id,
                sns_topic_arn: self.sns_topic_arn,
            }
        }
    }
}
impl LabelingJobOutputConfig {
    /// Creates a new builder-style object to manufacture [`LabelingJobOutputConfig`](crate::model::LabelingJobOutputConfig)
    pub fn builder() -> crate::model::labeling_job_output_config::Builder {
        crate::model::labeling_job_output_config::Builder::default()
    }
}

/// <p>Specifies the configuration for a hyperparameter tuning job that uses one or more
/// previous hyperparameter tuning jobs as a starting point. The results of previous tuning
/// jobs are used to inform which combinations of hyperparameters to search over in the new
/// tuning job.</p>
/// <p>All training jobs launched by the new hyperparameter tuning job are evaluated by using
/// the objective metric, and the training job that performs the best is compared to the
/// best training jobs from the parent tuning jobs. From these, the training job that
/// performs the best as measured by the objective metric is returned as the overall best
/// training job.</p>
/// <note>
/// <p>All training jobs launched by parent hyperparameter tuning jobs and the new
/// hyperparameter tuning jobs count against the limit of training jobs for the tuning
/// job.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobWarmStartConfig {
    /// <p>An array of hyperparameter tuning jobs that are used as the starting point for the new
    /// hyperparameter tuning job. For more information about warm starting a hyperparameter
    /// tuning job, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-warm-start.html">Using a Previous
    /// Hyperparameter Tuning Job as a Starting Point</a>.</p>
    /// <p>Hyperparameter tuning jobs created before October 1, 2018 cannot be used as parent
    /// jobs for warm start tuning jobs.</p>
    pub parent_hyper_parameter_tuning_jobs:
        std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
    /// <p>Specifies one of the following:</p>
    /// <dl>
    /// <dt>IDENTICAL_DATA_AND_ALGORITHM</dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job uses the same input data and training
    /// image as the parent tuning jobs. You can change the hyperparameter ranges to
    /// search and the maximum number of training jobs that the hyperparameter
    /// tuning job launches. You cannot use a new version of the training algorithm,
    /// unless the changes in the new version do not affect the algorithm itself.
    /// For example, changes that improve logging or adding support for a different
    /// data format are allowed. You can also change hyperparameters from tunable to
    /// static, and from static to tunable, but the total number of static plus
    /// tunable hyperparameters must remain the same as it is in all parent jobs.
    /// The objective metric for the new tuning job must be the same as for all
    /// parent jobs.</p>
    /// </dd>
    /// <dt>TRANSFER_LEARNING</dt>
    /// <dd>
    /// <p>The new hyperparameter tuning job can include input data, hyperparameter
    /// ranges, maximum number of concurrent training jobs, and maximum number of
    /// training jobs that are different than those of its parent hyperparameter
    /// tuning jobs. The training image can also be a different version from the
    /// version used in the parent hyperparameter tuning job. You can also change
    /// hyperparameters from tunable to static, and from static to tunable, but the
    /// total number of static plus tunable hyperparameters must remain the same as
    /// it is in all parent jobs. The objective metric for the new tuning job must
    /// be the same as for all parent jobs.</p>
    /// </dd>
    /// </dl>
    pub warm_start_type: std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
}
impl std::fmt::Debug for HyperParameterTuningJobWarmStartConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobWarmStartConfig");
        formatter.field(
            "parent_hyper_parameter_tuning_jobs",
            &self.parent_hyper_parameter_tuning_jobs,
        );
        formatter.field("warm_start_type", &self.warm_start_type);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
pub mod hyper_parameter_tuning_job_warm_start_config {
    /// A builder for [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parent_hyper_parameter_tuning_jobs:
            std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
        pub(crate) warm_start_type:
            std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
    }
    impl Builder {
        pub fn parent_hyper_parameter_tuning_jobs(
            mut self,
            input: impl Into<crate::model::ParentHyperParameterTuningJob>,
        ) -> Self {
            let mut v = self.parent_hyper_parameter_tuning_jobs.unwrap_or_default();
            v.push(input.into());
            self.parent_hyper_parameter_tuning_jobs = Some(v);
            self
        }
        pub fn set_parent_hyper_parameter_tuning_jobs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParentHyperParameterTuningJob>>,
        ) -> Self {
            self.parent_hyper_parameter_tuning_jobs = input;
            self
        }
        /// <p>Specifies one of the following:</p>
        /// <dl>
        /// <dt>IDENTICAL_DATA_AND_ALGORITHM</dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job uses the same input data and training
        /// image as the parent tuning jobs. You can change the hyperparameter ranges to
        /// search and the maximum number of training jobs that the hyperparameter
        /// tuning job launches. You cannot use a new version of the training algorithm,
        /// unless the changes in the new version do not affect the algorithm itself.
        /// For example, changes that improve logging or adding support for a different
        /// data format are allowed. You can also change hyperparameters from tunable to
        /// static, and from static to tunable, but the total number of static plus
        /// tunable hyperparameters must remain the same as it is in all parent jobs.
        /// The objective metric for the new tuning job must be the same as for all
        /// parent jobs.</p>
        /// </dd>
        /// <dt>TRANSFER_LEARNING</dt>
        /// <dd>
        /// <p>The new hyperparameter tuning job can include input data, hyperparameter
        /// ranges, maximum number of concurrent training jobs, and maximum number of
        /// training jobs that are different than those of its parent hyperparameter
        /// tuning jobs. The training image can also be a different version from the
        /// version used in the parent hyperparameter tuning job. You can also change
        /// hyperparameters from tunable to static, and from static to tunable, but the
        /// total number of static plus tunable hyperparameters must remain the same as
        /// it is in all parent jobs. The objective metric for the new tuning job must
        /// be the same as for all parent jobs.</p>
        /// </dd>
        /// </dl>
        pub fn warm_start_type(
            mut self,
            input: crate::model::HyperParameterTuningJobWarmStartType,
        ) -> Self {
            self.warm_start_type = Some(input);
            self
        }
        pub fn set_warm_start_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobWarmStartType>,
        ) -> Self {
            self.warm_start_type = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
        pub fn build(self) -> crate::model::HyperParameterTuningJobWarmStartConfig {
            crate::model::HyperParameterTuningJobWarmStartConfig {
                parent_hyper_parameter_tuning_jobs: self.parent_hyper_parameter_tuning_jobs,
                warm_start_type: self.warm_start_type,
            }
        }
    }
}
impl HyperParameterTuningJobWarmStartConfig {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobWarmStartConfig`](crate::model::HyperParameterTuningJobWarmStartConfig)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_warm_start_config::Builder {
        crate::model::hyper_parameter_tuning_job_warm_start_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterTuningJobWarmStartType {
    IdenticalDataAndAlgorithm,
    TransferLearning,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterTuningJobWarmStartType {
    fn from(s: &str) -> Self {
        match s {
            "IdenticalDataAndAlgorithm" => {
                HyperParameterTuningJobWarmStartType::IdenticalDataAndAlgorithm
            }
            "TransferLearning" => HyperParameterTuningJobWarmStartType::TransferLearning,
            other => HyperParameterTuningJobWarmStartType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterTuningJobWarmStartType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterTuningJobWarmStartType::from(s))
    }
}
impl HyperParameterTuningJobWarmStartType {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterTuningJobWarmStartType::IdenticalDataAndAlgorithm => {
                "IdenticalDataAndAlgorithm"
            }
            HyperParameterTuningJobWarmStartType::TransferLearning => "TransferLearning",
            HyperParameterTuningJobWarmStartType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["IdenticalDataAndAlgorithm", "TransferLearning"]
    }
}
impl AsRef<str> for HyperParameterTuningJobWarmStartType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A previously completed or stopped hyperparameter tuning job to be used as a starting
/// point for a new hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentHyperParameterTuningJob {
    /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new
    /// hyperparameter tuning job.</p>
    pub hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentHyperParameterTuningJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentHyperParameterTuningJob");
        formatter.field(
            "hyper_parameter_tuning_job_name",
            &self.hyper_parameter_tuning_job_name,
        );
        formatter.finish()
    }
}
/// See [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
pub mod parent_hyper_parameter_tuning_job {
    /// A builder for [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hyper_parameter_tuning_job_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter tuning job to be used as a starting point for a new
        /// hyperparameter tuning job.</p>
        pub fn hyper_parameter_tuning_job_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = Some(input.into());
            self
        }
        pub fn set_hyper_parameter_tuning_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hyper_parameter_tuning_job_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
        pub fn build(self) -> crate::model::ParentHyperParameterTuningJob {
            crate::model::ParentHyperParameterTuningJob {
                hyper_parameter_tuning_job_name: self.hyper_parameter_tuning_job_name,
            }
        }
    }
}
impl ParentHyperParameterTuningJob {
    /// Creates a new builder-style object to manufacture [`ParentHyperParameterTuningJob`](crate::model::ParentHyperParameterTuningJob)
    pub fn builder() -> crate::model::parent_hyper_parameter_tuning_job::Builder {
        crate::model::parent_hyper_parameter_tuning_job::Builder::default()
    }
}

/// <p>Defines
/// the training jobs launched by a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTrainingJobDefinition {
    /// <p>The job definition name.</p>
    pub definition_name: std::option::Option<std::string::String>,
    /// <p>Defines the objective metric for a hyperparameter tuning job.
    /// Hyperparameter
    /// tuning uses the value of this metric to evaluate the training jobs it launches, and
    /// returns the training job that results in either the highest or lowest value for this
    /// metric, depending on the value you specify for the <code>Type</code>
    /// parameter.</p>
    pub tuning_objective: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
    /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a
    /// hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs
    /// with hyperparameter values within these ranges to find the combination of values that
    /// result in the training job with the best performance as measured by the objective metric
    /// of the hyperparameter tuning job.</p>
    /// <note>
    /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job
    /// can search over. Every possible value of a categorical parameter range counts
    /// against this limit.</p>
    /// </note>
    pub hyper_parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
    /// <p>Specifies the values of hyperparameters
    /// that
    /// do not change for the tuning job.</p>
    pub static_hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The <a>HyperParameterAlgorithmSpecification</a> object that
    /// specifies
    /// the resource algorithm to use for the training jobs that the tuning
    /// job launches.</p>
    pub algorithm_specification:
        std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
    /// <p>The Amazon Resource Name (ARN) of the
    /// IAM
    /// role associated with the training jobs that the tuning job
    /// launches.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An array of <a>Channel</a> objects that specify
    /// the
    /// input for the training jobs that the tuning job launches.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>The <a>VpcConfig</a> object that
    /// specifies
    /// the VPC that you want the training jobs that this hyperparameter
    /// tuning job launches to connect to. Control access to and from your
    /// training
    /// container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
    /// by Using an Amazon Virtual Private Cloud</a>.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Specifies the path to the Amazon S3 bucket where you
    /// store
    /// model artifacts from the training jobs that the tuning job
    /// launches.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The resources,
    /// including
    /// the compute instances and storage volumes, to use for the training
    /// jobs that the tuning job launches.</p>
    /// <p>Storage
    /// volumes store model artifacts and
    /// incremental
    /// states. Training algorithms might also use storage volumes for
    /// scratch
    /// space. If you want Amazon SageMaker to use the storage volume
    /// to store the training data, choose <code>File</code> as the
    /// <code>TrainingInputMode</code> in the algorithm specification. For distributed
    /// training algorithms, specify an instance count greater than 1.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also
    /// specifies how long a managed spot training job has to complete. When the job reaches the
    /// time limit, Amazon SageMaker ends the training job. Use this API to cap model training costs.</p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    /// <p>Isolates the training container. No inbound or outbound network calls can be made,
    /// except for calls between peers within a training cluster for distributed training. If
    /// network isolation is used for training jobs that are configured to use a VPC, Amazon SageMaker
    /// downloads and uploads customer data and model artifacts through the specified VPC, but
    /// the training container does not have network access.</p>
    pub enable_network_isolation: bool,
    /// <p>To encrypt all communications between ML compute instances in distributed training,
    /// choose <code>True</code>. Encryption provides greater security for distributed training,
    /// but training might take longer. How long it takes depends on the amount of communication
    /// between compute instances, especially if you use a deep learning algorithm in
    /// distributed training.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or
    /// not (<code>False</code>).</p>
    pub enable_managed_spot_training: bool,
    /// <p>Contains information about the output location for managed spot training checkpoint
    /// data. </p>
    pub checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
    /// <p>The number of times to retry the job when the job fails due to an
    /// <code>InternalServerError</code>.</p>
    pub retry_strategy: std::option::Option<crate::model::RetryStrategy>,
}
impl std::fmt::Debug for HyperParameterTrainingJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTrainingJobDefinition");
        formatter.field("definition_name", &self.definition_name);
        formatter.field("tuning_objective", &self.tuning_objective);
        formatter.field("hyper_parameter_ranges", &self.hyper_parameter_ranges);
        formatter.field("static_hyper_parameters", &self.static_hyper_parameters);
        formatter.field("algorithm_specification", &self.algorithm_specification);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.field("enable_network_isolation", &self.enable_network_isolation);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field(
            "enable_managed_spot_training",
            &self.enable_managed_spot_training,
        );
        formatter.field("checkpoint_config", &self.checkpoint_config);
        formatter.field("retry_strategy", &self.retry_strategy);
        formatter.finish()
    }
}
/// See [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
pub mod hyper_parameter_training_job_definition {
    /// A builder for [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) definition_name: std::option::Option<std::string::String>,
        pub(crate) tuning_objective:
            std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        pub(crate) hyper_parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
        pub(crate) static_hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) algorithm_specification:
            std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
        pub(crate) enable_network_isolation: std::option::Option<bool>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) enable_managed_spot_training: std::option::Option<bool>,
        pub(crate) checkpoint_config: std::option::Option<crate::model::CheckpointConfig>,
        pub(crate) retry_strategy: std::option::Option<crate::model::RetryStrategy>,
    }
    impl Builder {
        /// <p>The job definition name.</p>
        pub fn definition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.definition_name = Some(input.into());
            self
        }
        pub fn set_definition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.definition_name = input;
            self
        }
        /// <p>Defines the objective metric for a hyperparameter tuning job.
        /// Hyperparameter
        /// tuning uses the value of this metric to evaluate the training jobs it launches, and
        /// returns the training job that results in either the highest or lowest value for this
        /// metric, depending on the value you specify for the <code>Type</code>
        /// parameter.</p>
        pub fn tuning_objective(
            mut self,
            input: crate::model::HyperParameterTuningJobObjective,
        ) -> Self {
            self.tuning_objective = Some(input);
            self
        }
        pub fn set_tuning_objective(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        ) -> Self {
            self.tuning_objective = input;
            self
        }
        /// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a
        /// hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs
        /// with hyperparameter values within these ranges to find the combination of values that
        /// result in the training job with the best performance as measured by the objective metric
        /// of the hyperparameter tuning job.</p>
        /// <note>
        /// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job
        /// can search over. Every possible value of a categorical parameter range counts
        /// against this limit.</p>
        /// </note>
        pub fn hyper_parameter_ranges(mut self, input: crate::model::ParameterRanges) -> Self {
            self.hyper_parameter_ranges = Some(input);
            self
        }
        pub fn set_hyper_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::ParameterRanges>,
        ) -> Self {
            self.hyper_parameter_ranges = input;
            self
        }
        pub fn static_hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.static_hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.static_hyper_parameters = Some(hash_map);
            self
        }
        pub fn set_static_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.static_hyper_parameters = input;
            self
        }
        /// <p>The <a>HyperParameterAlgorithmSpecification</a> object that
        /// specifies
        /// the resource algorithm to use for the training jobs that the tuning
        /// job launches.</p>
        pub fn algorithm_specification(
            mut self,
            input: crate::model::HyperParameterAlgorithmSpecification,
        ) -> Self {
            self.algorithm_specification = Some(input);
            self
        }
        pub fn set_algorithm_specification(
            mut self,
            input: std::option::Option<crate::model::HyperParameterAlgorithmSpecification>,
        ) -> Self {
            self.algorithm_specification = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the
        /// IAM
        /// role associated with the training jobs that the tuning job
        /// launches.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        pub fn input_data_config(mut self, input: impl Into<crate::model::Channel>) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input.into());
            self.input_data_config = Some(v);
            self
        }
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The <a>VpcConfig</a> object that
        /// specifies
        /// the VPC that you want the training jobs that this hyperparameter
        /// tuning job launches to connect to. Control access to and from your
        /// training
        /// container by configuring the VPC. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html">Protect Training Jobs
        /// by Using an Amazon Virtual Private Cloud</a>.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Specifies the path to the Amazon S3 bucket where you
        /// store
        /// model artifacts from the training jobs that the tuning job
        /// launches.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The resources,
        /// including
        /// the compute instances and storage volumes, to use for the training
        /// jobs that the tuning job launches.</p>
        /// <p>Storage
        /// volumes store model artifacts and
        /// incremental
        /// states. Training algorithms might also use storage volumes for
        /// scratch
        /// space. If you want Amazon SageMaker to use the storage volume
        /// to store the training data, choose <code>File</code> as the
        /// <code>TrainingInputMode</code> in the algorithm specification. For distributed
        /// training algorithms, specify an instance count greater than 1.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model hyperparameter training job can run. It also
        /// specifies how long a managed spot training job has to complete. When the job reaches the
        /// time limit, Amazon SageMaker ends the training job. Use this API to cap model training costs.</p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// <p>Isolates the training container. No inbound or outbound network calls can be made,
        /// except for calls between peers within a training cluster for distributed training. If
        /// network isolation is used for training jobs that are configured to use a VPC, Amazon SageMaker
        /// downloads and uploads customer data and model artifacts through the specified VPC, but
        /// the training container does not have network access.</p>
        pub fn enable_network_isolation(mut self, input: bool) -> Self {
            self.enable_network_isolation = Some(input);
            self
        }
        pub fn set_enable_network_isolation(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_network_isolation = input;
            self
        }
        /// <p>To encrypt all communications between ML compute instances in distributed training,
        /// choose <code>True</code>. Encryption provides greater security for distributed training,
        /// but training might take longer. How long it takes depends on the amount of communication
        /// between compute instances, especially if you use a deep learning algorithm in
        /// distributed training.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>A Boolean indicating whether managed spot training is enabled (<code>True</code>) or
        /// not (<code>False</code>).</p>
        pub fn enable_managed_spot_training(mut self, input: bool) -> Self {
            self.enable_managed_spot_training = Some(input);
            self
        }
        pub fn set_enable_managed_spot_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_managed_spot_training = input;
            self
        }
        /// <p>Contains information about the output location for managed spot training checkpoint
        /// data. </p>
        pub fn checkpoint_config(mut self, input: crate::model::CheckpointConfig) -> Self {
            self.checkpoint_config = Some(input);
            self
        }
        pub fn set_checkpoint_config(
            mut self,
            input: std::option::Option<crate::model::CheckpointConfig>,
        ) -> Self {
            self.checkpoint_config = input;
            self
        }
        /// <p>The number of times to retry the job when the job fails due to an
        /// <code>InternalServerError</code>.</p>
        pub fn retry_strategy(mut self, input: crate::model::RetryStrategy) -> Self {
            self.retry_strategy = Some(input);
            self
        }
        pub fn set_retry_strategy(
            mut self,
            input: std::option::Option<crate::model::RetryStrategy>,
        ) -> Self {
            self.retry_strategy = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
        pub fn build(self) -> crate::model::HyperParameterTrainingJobDefinition {
            crate::model::HyperParameterTrainingJobDefinition {
                definition_name: self.definition_name,
                tuning_objective: self.tuning_objective,
                hyper_parameter_ranges: self.hyper_parameter_ranges,
                static_hyper_parameters: self.static_hyper_parameters,
                algorithm_specification: self.algorithm_specification,
                role_arn: self.role_arn,
                input_data_config: self.input_data_config,
                vpc_config: self.vpc_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                stopping_condition: self.stopping_condition,
                enable_network_isolation: self.enable_network_isolation.unwrap_or_default(),
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                enable_managed_spot_training: self.enable_managed_spot_training.unwrap_or_default(),
                checkpoint_config: self.checkpoint_config,
                retry_strategy: self.retry_strategy,
            }
        }
    }
}
impl HyperParameterTrainingJobDefinition {
    /// Creates a new builder-style object to manufacture [`HyperParameterTrainingJobDefinition`](crate::model::HyperParameterTrainingJobDefinition)
    pub fn builder() -> crate::model::hyper_parameter_training_job_definition::Builder {
        crate::model::hyper_parameter_training_job_definition::Builder::default()
    }
}

/// <p>Specifies
/// which
/// training algorithm to use for training jobs that a hyperparameter
/// tuning job launches and the metrics to monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterAlgorithmSpecification {
    /// <p> The registry path of the Docker image that contains the training algorithm. For
    /// information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms
    /// Provided by Amazon SageMaker: Common Parameters</a>. Amazon SageMaker supports both
    /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
    /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
    /// SageMaker</a>.</p>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>The input mode that the algorithm supports:
    /// File
    /// or Pipe. In File input mode, Amazon SageMaker downloads the training data from
    /// Amazon S3 to the
    /// storage
    /// volume that is attached to the training instance and mounts the directory to the Docker
    /// volume for the training container. In Pipe input mode, Amazon SageMaker streams
    /// data directly from Amazon S3 to the container. </p>
    /// <p>If you specify File mode, make sure that
    /// you
    /// provision the storage volume that is attached to the training instance with enough
    /// capacity to accommodate the training data downloaded from Amazon S3, the model artifacts, and
    /// intermediate
    /// information.</p>
    /// <p></p>
    /// <p>For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. </p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you
    /// specify a value for this parameter, do not specify a value for
    /// <code>TrainingImage</code>.</p>
    pub algorithm_name: std::option::Option<std::string::String>,
    /// <p>An array of <a>MetricDefinition</a> objects that specify the
    /// metrics
    /// that the algorithm emits.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
}
impl std::fmt::Debug for HyperParameterAlgorithmSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterAlgorithmSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("algorithm_name", &self.algorithm_name);
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.finish()
    }
}
/// See [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
pub mod hyper_parameter_algorithm_specification {
    /// A builder for [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) algorithm_name: std::option::Option<std::string::String>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    }
    impl Builder {
        /// <p> The registry path of the Docker image that contains the training algorithm. For
        /// information about Docker registry paths for built-in algorithms, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">Algorithms
        /// Provided by Amazon SageMaker: Common Parameters</a>. Amazon SageMaker supports both
        /// <code>registry/repository[:tag]</code> and <code>registry/repository[@digest]</code>
        /// image path formats. For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms.html">Using Your Own Algorithms with Amazon
        /// SageMaker</a>.</p>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>The input mode that the algorithm supports:
        /// File
        /// or Pipe. In File input mode, Amazon SageMaker downloads the training data from
        /// Amazon S3 to the
        /// storage
        /// volume that is attached to the training instance and mounts the directory to the Docker
        /// volume for the training container. In Pipe input mode, Amazon SageMaker streams
        /// data directly from Amazon S3 to the container. </p>
        /// <p>If you specify File mode, make sure that
        /// you
        /// provision the storage volume that is attached to the training instance with enough
        /// capacity to accommodate the training data downloaded from Amazon S3, the model artifacts, and
        /// intermediate
        /// information.</p>
        /// <p></p>
        /// <p>For more information about input modes, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>. </p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        /// <p>The name of the resource algorithm to use for the hyperparameter tuning job. If you
        /// specify a value for this parameter, do not specify a value for
        /// <code>TrainingImage</code>.</p>
        pub fn algorithm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.algorithm_name = Some(input.into());
            self
        }
        pub fn set_algorithm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.algorithm_name = input;
            self
        }
        pub fn metric_definitions(
            mut self,
            input: impl Into<crate::model::MetricDefinition>,
        ) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input.into());
            self.metric_definitions = Some(v);
            self
        }
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
        pub fn build(self) -> crate::model::HyperParameterAlgorithmSpecification {
            crate::model::HyperParameterAlgorithmSpecification {
                training_image: self.training_image,
                training_input_mode: self.training_input_mode,
                algorithm_name: self.algorithm_name,
                metric_definitions: self.metric_definitions,
            }
        }
    }
}
impl HyperParameterAlgorithmSpecification {
    /// Creates a new builder-style object to manufacture [`HyperParameterAlgorithmSpecification`](crate::model::HyperParameterAlgorithmSpecification)
    pub fn builder() -> crate::model::hyper_parameter_algorithm_specification::Builder {
        crate::model::hyper_parameter_algorithm_specification::Builder::default()
    }
}

/// <p>Specifies ranges of integer, continuous, and categorical hyperparameters that a
/// hyperparameter tuning job searches. The hyperparameter tuning job launches training jobs
/// with hyperparameter values within these ranges to find the combination of values that
/// result in the training job with the best performance as measured by the objective metric
/// of the hyperparameter tuning job.</p>
/// <note>
/// <p>You can specify a maximum of 20 hyperparameters that a hyperparameter tuning job
/// can search over. Every possible value of a categorical parameter range counts
/// against this limit.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterRanges {
    /// <p>The array of <a>IntegerParameterRange</a> objects that specify ranges of
    /// integer hyperparameters that a hyperparameter tuning job searches.</p>
    pub integer_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
    /// <p>The array of <a>ContinuousParameterRange</a> objects that specify ranges of
    /// continuous hyperparameters that a hyperparameter tuning job searches.</p>
    pub continuous_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
    /// <p>The array of <a>CategoricalParameterRange</a> objects that specify ranges
    /// of categorical hyperparameters that a hyperparameter tuning job searches.</p>
    pub categorical_parameter_ranges:
        std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
}
impl std::fmt::Debug for ParameterRanges {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterRanges");
        formatter.field("integer_parameter_ranges", &self.integer_parameter_ranges);
        formatter.field(
            "continuous_parameter_ranges",
            &self.continuous_parameter_ranges,
        );
        formatter.field(
            "categorical_parameter_ranges",
            &self.categorical_parameter_ranges,
        );
        formatter.finish()
    }
}
/// See [`ParameterRanges`](crate::model::ParameterRanges)
pub mod parameter_ranges {
    /// A builder for [`ParameterRanges`](crate::model::ParameterRanges)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integer_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
        pub(crate) continuous_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        pub(crate) categorical_parameter_ranges:
            std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
    }
    impl Builder {
        pub fn integer_parameter_ranges(
            mut self,
            input: impl Into<crate::model::IntegerParameterRange>,
        ) -> Self {
            let mut v = self.integer_parameter_ranges.unwrap_or_default();
            v.push(input.into());
            self.integer_parameter_ranges = Some(v);
            self
        }
        pub fn set_integer_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IntegerParameterRange>>,
        ) -> Self {
            self.integer_parameter_ranges = input;
            self
        }
        pub fn continuous_parameter_ranges(
            mut self,
            input: impl Into<crate::model::ContinuousParameterRange>,
        ) -> Self {
            let mut v = self.continuous_parameter_ranges.unwrap_or_default();
            v.push(input.into());
            self.continuous_parameter_ranges = Some(v);
            self
        }
        pub fn set_continuous_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContinuousParameterRange>>,
        ) -> Self {
            self.continuous_parameter_ranges = input;
            self
        }
        pub fn categorical_parameter_ranges(
            mut self,
            input: impl Into<crate::model::CategoricalParameterRange>,
        ) -> Self {
            let mut v = self.categorical_parameter_ranges.unwrap_or_default();
            v.push(input.into());
            self.categorical_parameter_ranges = Some(v);
            self
        }
        pub fn set_categorical_parameter_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CategoricalParameterRange>>,
        ) -> Self {
            self.categorical_parameter_ranges = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterRanges`](crate::model::ParameterRanges)
        pub fn build(self) -> crate::model::ParameterRanges {
            crate::model::ParameterRanges {
                integer_parameter_ranges: self.integer_parameter_ranges,
                continuous_parameter_ranges: self.continuous_parameter_ranges,
                categorical_parameter_ranges: self.categorical_parameter_ranges,
            }
        }
    }
}
impl ParameterRanges {
    /// Creates a new builder-style object to manufacture [`ParameterRanges`](crate::model::ParameterRanges)
    pub fn builder() -> crate::model::parameter_ranges::Builder {
        crate::model::parameter_ranges::Builder::default()
    }
}

/// <p>A list of categorical hyperparameters to tune.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoricalParameterRange {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the categories
    /// for
    /// the hyperparameter.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for CategoricalParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoricalParameterRange");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
pub mod categorical_parameter_range {
    /// A builder for [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the categorical hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
        pub fn build(self) -> crate::model::CategoricalParameterRange {
            crate::model::CategoricalParameterRange {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl CategoricalParameterRange {
    /// Creates a new builder-style object to manufacture [`CategoricalParameterRange`](crate::model::CategoricalParameterRange)
    pub fn builder() -> crate::model::categorical_parameter_range::Builder {
        crate::model::categorical_parameter_range::Builder::default()
    }
}

/// <p>A list of continuous hyperparameters to tune.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousParameterRange {
    /// <p>The name of the continuous hyperparameter to tune.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The minimum value for the hyperparameter.
    /// The
    /// tuning job uses floating-point values between this value and <code>MaxValue</code>for
    /// tuning.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values
    /// between <code>MinValue</code> value and this value for tuning.</p>
    pub max_value: std::option::Option<std::string::String>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For
    /// information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>Auto</dt>
    /// <dd>
    /// <p>Amazon SageMaker hyperparameter tuning chooses the best scale for the
    /// hyperparameter.</p>
    /// </dd>
    /// <dt>Linear</dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
    /// using a linear scale.</p>
    /// </dd>
    /// <dt>Logarithmic</dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
    /// using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater
    /// than 0.</p>
    /// </dd>
    /// <dt>ReverseLogarithmic</dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
    /// using a reverse logarithmic scale.</p>
    /// <p>Reverse logarithmic scaling works only for ranges that are entirely within
    /// the range 0<=x<1.0.</p>
    /// </dd>
    /// </dl>
    pub scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
}
impl std::fmt::Debug for ContinuousParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousParameterRange");
        formatter.field("name", &self.name);
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.field("scaling_type", &self.scaling_type);
        formatter.finish()
    }
}
/// See [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
pub mod continuous_parameter_range {
    /// A builder for [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
        pub(crate) scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
    }
    impl Builder {
        /// <p>The name of the continuous hyperparameter to tune.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The minimum value for the hyperparameter.
        /// The
        /// tuning job uses floating-point values between this value and <code>MaxValue</code>for
        /// tuning.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum value for the hyperparameter. The tuning job uses floating-point values
        /// between <code>MinValue</code> value and this value for tuning.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For
        /// information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>Auto</dt>
        /// <dd>
        /// <p>Amazon SageMaker hyperparameter tuning chooses the best scale for the
        /// hyperparameter.</p>
        /// </dd>
        /// <dt>Linear</dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
        /// using a linear scale.</p>
        /// </dd>
        /// <dt>Logarithmic</dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
        /// using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater
        /// than 0.</p>
        /// </dd>
        /// <dt>ReverseLogarithmic</dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
        /// using a reverse logarithmic scale.</p>
        /// <p>Reverse logarithmic scaling works only for ranges that are entirely within
        /// the range 0<=x<1.0.</p>
        /// </dd>
        /// </dl>
        pub fn scaling_type(mut self, input: crate::model::HyperParameterScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
        pub fn build(self) -> crate::model::ContinuousParameterRange {
            crate::model::ContinuousParameterRange {
                name: self.name,
                min_value: self.min_value,
                max_value: self.max_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl ContinuousParameterRange {
    /// Creates a new builder-style object to manufacture [`ContinuousParameterRange`](crate::model::ContinuousParameterRange)
    pub fn builder() -> crate::model::continuous_parameter_range::Builder {
        crate::model::continuous_parameter_range::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HyperParameterScalingType {
    Auto,
    Linear,
    Logarithmic,
    ReverseLogarithmic,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HyperParameterScalingType {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => HyperParameterScalingType::Auto,
            "Linear" => HyperParameterScalingType::Linear,
            "Logarithmic" => HyperParameterScalingType::Logarithmic,
            "ReverseLogarithmic" => HyperParameterScalingType::ReverseLogarithmic,
            other => HyperParameterScalingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HyperParameterScalingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HyperParameterScalingType::from(s))
    }
}
impl HyperParameterScalingType {
    pub fn as_str(&self) -> &str {
        match self {
            HyperParameterScalingType::Auto => "Auto",
            HyperParameterScalingType::Linear => "Linear",
            HyperParameterScalingType::Logarithmic => "Logarithmic",
            HyperParameterScalingType::ReverseLogarithmic => "ReverseLogarithmic",
            HyperParameterScalingType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Auto", "Linear", "Logarithmic", "ReverseLogarithmic"]
    }
}
impl AsRef<str> for HyperParameterScalingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>For a hyperparameter of the integer type, specifies the range
/// that
/// a hyperparameter tuning job searches.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegerParameterRange {
    /// <p>The name of the hyperparameter to search.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The minimum
    /// value
    /// of the hyperparameter to search.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum
    /// value
    /// of the hyperparameter to search.</p>
    pub max_value: std::option::Option<std::string::String>,
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For
    /// information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
    /// <dl>
    /// <dt>Auto</dt>
    /// <dd>
    /// <p>Amazon SageMaker hyperparameter tuning chooses the best scale for the
    /// hyperparameter.</p>
    /// </dd>
    /// <dt>Linear</dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
    /// using a linear scale.</p>
    /// </dd>
    /// <dt>Logarithmic</dt>
    /// <dd>
    /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
    /// using a logarithmic scale.</p>
    /// <p>Logarithmic scaling works only for ranges that have only values greater
    /// than 0.</p>
    /// </dd>
    /// </dl>
    pub scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
}
impl std::fmt::Debug for IntegerParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegerParameterRange");
        formatter.field("name", &self.name);
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.field("scaling_type", &self.scaling_type);
        formatter.finish()
    }
}
/// See [`IntegerParameterRange`](crate::model::IntegerParameterRange)
pub mod integer_parameter_range {
    /// A builder for [`IntegerParameterRange`](crate::model::IntegerParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
        pub(crate) scaling_type: std::option::Option<crate::model::HyperParameterScalingType>,
    }
    impl Builder {
        /// <p>The name of the hyperparameter to search.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The minimum
        /// value
        /// of the hyperparameter to search.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum
        /// value
        /// of the hyperparameter to search.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range. For
        /// information about choosing a hyperparameter scale, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>. One of the following values:</p>
        /// <dl>
        /// <dt>Auto</dt>
        /// <dd>
        /// <p>Amazon SageMaker hyperparameter tuning chooses the best scale for the
        /// hyperparameter.</p>
        /// </dd>
        /// <dt>Linear</dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
        /// using a linear scale.</p>
        /// </dd>
        /// <dt>Logarithmic</dt>
        /// <dd>
        /// <p>Hyperparameter tuning searches the values in the hyperparameter range by
        /// using a logarithmic scale.</p>
        /// <p>Logarithmic scaling works only for ranges that have only values greater
        /// than 0.</p>
        /// </dd>
        /// </dl>
        pub fn scaling_type(mut self, input: crate::model::HyperParameterScalingType) -> Self {
            self.scaling_type = Some(input);
            self
        }
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterScalingType>,
        ) -> Self {
            self.scaling_type = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterRange`](crate::model::IntegerParameterRange)
        pub fn build(self) -> crate::model::IntegerParameterRange {
            crate::model::IntegerParameterRange {
                name: self.name,
                min_value: self.min_value,
                max_value: self.max_value,
                scaling_type: self.scaling_type,
            }
        }
    }
}
impl IntegerParameterRange {
    /// Creates a new builder-style object to manufacture [`IntegerParameterRange`](crate::model::IntegerParameterRange)
    pub fn builder() -> crate::model::integer_parameter_range::Builder {
        crate::model::integer_parameter_range::Builder::default()
    }
}

/// <p>Defines the objective metric for a hyperparameter tuning job.
/// Hyperparameter
/// tuning uses the value of this metric to evaluate the training jobs it launches, and
/// returns the training job that results in either the highest or lowest value for this
/// metric, depending on the value you specify for the <code>Type</code>
/// parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobObjective {
    /// <p>Whether to
    /// minimize
    /// or maximize the objective metric.</p>
    pub r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
    /// <p>The
    /// name of the metric to use for the objective metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HyperParameterTuningJobObjective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobObjective");
        formatter.field("r#type", &self.r#type);
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
pub mod hyper_parameter_tuning_job_objective {
    /// A builder for [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether to
        /// minimize
        /// or maximize the objective metric.</p>
        pub fn r#type(mut self, input: crate::model::HyperParameterTuningJobObjectiveType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjectiveType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The
        /// name of the metric to use for the objective metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
        pub fn build(self) -> crate::model::HyperParameterTuningJobObjective {
            crate::model::HyperParameterTuningJobObjective {
                r#type: self.r#type,
                metric_name: self.metric_name,
            }
        }
    }
}
impl HyperParameterTuningJobObjective {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobObjective`](crate::model::HyperParameterTuningJobObjective)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_objective::Builder {
        crate::model::hyper_parameter_tuning_job_objective::Builder::default()
    }
}

/// <p>Configures a hyperparameter tuning job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterTuningJobConfig {
    /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values
    /// to use for the training job it launches. To use the Bayesian search strategy, set this
    /// to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For
    /// information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How
    /// Hyperparameter Tuning Works</a>.</p>
    pub strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
    /// <p>The <a>HyperParameterTuningJobObjective</a> object that specifies the
    /// objective
    /// metric for this tuning job.</p>
    pub hyper_parameter_tuning_job_objective:
        std::option::Option<crate::model::HyperParameterTuningJobObjective>,
    /// <p>The <a>ResourceLimits</a> object that specifies the
    /// maximum
    /// number of training jobs and parallel training jobs for this tuning
    /// job.</p>
    pub resource_limits: std::option::Option<crate::model::ResourceLimits>,
    /// <p>The <a>ParameterRanges</a> object that specifies the ranges of
    /// hyperparameters
    /// that this tuning job searches.</p>
    pub parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
    /// <p>Specifies whether to use early stopping for training jobs launched by the
    /// hyperparameter tuning job. This can be one of the following values (the default value is
    /// <code>OFF</code>):</p>
    /// <dl>
    /// <dt>OFF</dt>
    /// <dd>
    /// <p>Training jobs launched by the hyperparameter tuning job do not use early
    /// stopping.</p>
    /// </dd>
    /// <dt>AUTO</dt>
    /// <dd>
    /// <p>Amazon SageMaker stops training jobs launched by the hyperparameter tuning job when
    /// they are unlikely to perform better than previously completed training jobs.
    /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
    /// </dd>
    /// </dl>
    pub training_job_early_stopping_type:
        std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
    /// <p>The tuning job's completion criteria.</p>
    pub tuning_job_completion_criteria:
        std::option::Option<crate::model::TuningJobCompletionCriteria>,
}
impl std::fmt::Debug for HyperParameterTuningJobConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterTuningJobConfig");
        formatter.field("strategy", &self.strategy);
        formatter.field(
            "hyper_parameter_tuning_job_objective",
            &self.hyper_parameter_tuning_job_objective,
        );
        formatter.field("resource_limits", &self.resource_limits);
        formatter.field("parameter_ranges", &self.parameter_ranges);
        formatter.field(
            "training_job_early_stopping_type",
            &self.training_job_early_stopping_type,
        );
        formatter.field(
            "tuning_job_completion_criteria",
            &self.tuning_job_completion_criteria,
        );
        formatter.finish()
    }
}
/// See [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
pub mod hyper_parameter_tuning_job_config {
    /// A builder for [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) strategy: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        pub(crate) hyper_parameter_tuning_job_objective:
            std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        pub(crate) resource_limits: std::option::Option<crate::model::ResourceLimits>,
        pub(crate) parameter_ranges: std::option::Option<crate::model::ParameterRanges>,
        pub(crate) training_job_early_stopping_type:
            std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
        pub(crate) tuning_job_completion_criteria:
            std::option::Option<crate::model::TuningJobCompletionCriteria>,
    }
    impl Builder {
        /// <p>Specifies how hyperparameter tuning chooses the combinations of hyperparameter values
        /// to use for the training job it launches. To use the Bayesian search strategy, set this
        /// to <code>Bayesian</code>. To randomly search, set it to <code>Random</code>. For
        /// information about search strategies, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">How
        /// Hyperparameter Tuning Works</a>.</p>
        pub fn strategy(
            mut self,
            input: crate::model::HyperParameterTuningJobStrategyType,
        ) -> Self {
            self.strategy = Some(input);
            self
        }
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobStrategyType>,
        ) -> Self {
            self.strategy = input;
            self
        }
        /// <p>The <a>HyperParameterTuningJobObjective</a> object that specifies the
        /// objective
        /// metric for this tuning job.</p>
        pub fn hyper_parameter_tuning_job_objective(
            mut self,
            input: crate::model::HyperParameterTuningJobObjective,
        ) -> Self {
            self.hyper_parameter_tuning_job_objective = Some(input);
            self
        }
        pub fn set_hyper_parameter_tuning_job_objective(
            mut self,
            input: std::option::Option<crate::model::HyperParameterTuningJobObjective>,
        ) -> Self {
            self.hyper_parameter_tuning_job_objective = input;
            self
        }
        /// <p>The <a>ResourceLimits</a> object that specifies the
        /// maximum
        /// number of training jobs and parallel training jobs for this tuning
        /// job.</p>
        pub fn resource_limits(mut self, input: crate::model::ResourceLimits) -> Self {
            self.resource_limits = Some(input);
            self
        }
        pub fn set_resource_limits(
            mut self,
            input: std::option::Option<crate::model::ResourceLimits>,
        ) -> Self {
            self.resource_limits = input;
            self
        }
        /// <p>The <a>ParameterRanges</a> object that specifies the ranges of
        /// hyperparameters
        /// that this tuning job searches.</p>
        pub fn parameter_ranges(mut self, input: crate::model::ParameterRanges) -> Self {
            self.parameter_ranges = Some(input);
            self
        }
        pub fn set_parameter_ranges(
            mut self,
            input: std::option::Option<crate::model::ParameterRanges>,
        ) -> Self {
            self.parameter_ranges = input;
            self
        }
        /// <p>Specifies whether to use early stopping for training jobs launched by the
        /// hyperparameter tuning job. This can be one of the following values (the default value is
        /// <code>OFF</code>):</p>
        /// <dl>
        /// <dt>OFF</dt>
        /// <dd>
        /// <p>Training jobs launched by the hyperparameter tuning job do not use early
        /// stopping.</p>
        /// </dd>
        /// <dt>AUTO</dt>
        /// <dd>
        /// <p>Amazon SageMaker stops training jobs launched by the hyperparameter tuning job when
        /// they are unlikely to perform better than previously completed training jobs.
        /// For more information, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-early-stopping.html">Stop Training Jobs Early</a>.</p>
        /// </dd>
        /// </dl>
        pub fn training_job_early_stopping_type(
            mut self,
            input: crate::model::TrainingJobEarlyStoppingType,
        ) -> Self {
            self.training_job_early_stopping_type = Some(input);
            self
        }
        pub fn set_training_job_early_stopping_type(
            mut self,
            input: std::option::Option<crate::model::TrainingJobEarlyStoppingType>,
        ) -> Self {
            self.training_job_early_stopping_type = input;
            self
        }
        /// <p>The tuning job's completion criteria.</p>
        pub fn tuning_job_completion_criteria(
            mut self,
            input: crate::model::TuningJobCompletionCriteria,
        ) -> Self {
            self.tuning_job_completion_criteria = Some(input);
            self
        }
        pub fn set_tuning_job_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::TuningJobCompletionCriteria>,
        ) -> Self {
            self.tuning_job_completion_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
        pub fn build(self) -> crate::model::HyperParameterTuningJobConfig {
            crate::model::HyperParameterTuningJobConfig {
                strategy: self.strategy,
                hyper_parameter_tuning_job_objective: self.hyper_parameter_tuning_job_objective,
                resource_limits: self.resource_limits,
                parameter_ranges: self.parameter_ranges,
                training_job_early_stopping_type: self.training_job_early_stopping_type,
                tuning_job_completion_criteria: self.tuning_job_completion_criteria,
            }
        }
    }
}
impl HyperParameterTuningJobConfig {
    /// Creates a new builder-style object to manufacture [`HyperParameterTuningJobConfig`](crate::model::HyperParameterTuningJobConfig)
    pub fn builder() -> crate::model::hyper_parameter_tuning_job_config::Builder {
        crate::model::hyper_parameter_tuning_job_config::Builder::default()
    }
}

/// <p>The job completion criteria.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TuningJobCompletionCriteria {
    /// <p>The value of the objective metric.</p>
    pub target_objective_metric_value: std::option::Option<f32>,
}
impl std::fmt::Debug for TuningJobCompletionCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TuningJobCompletionCriteria");
        formatter.field(
            "target_objective_metric_value",
            &self.target_objective_metric_value,
        );
        formatter.finish()
    }
}
/// See [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
pub mod tuning_job_completion_criteria {
    /// A builder for [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_objective_metric_value: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The value of the objective metric.</p>
        pub fn target_objective_metric_value(mut self, input: f32) -> Self {
            self.target_objective_metric_value = Some(input);
            self
        }
        pub fn set_target_objective_metric_value(
            mut self,
            input: std::option::Option<f32>,
        ) -> Self {
            self.target_objective_metric_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
        pub fn build(self) -> crate::model::TuningJobCompletionCriteria {
            crate::model::TuningJobCompletionCriteria {
                target_objective_metric_value: self.target_objective_metric_value,
            }
        }
    }
}
impl TuningJobCompletionCriteria {
    /// Creates a new builder-style object to manufacture [`TuningJobCompletionCriteria`](crate::model::TuningJobCompletionCriteria)
    pub fn builder() -> crate::model::tuning_job_completion_criteria::Builder {
        crate::model::tuning_job_completion_criteria::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingJobEarlyStoppingType {
    Auto,
    Off,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TrainingJobEarlyStoppingType {
    fn from(s: &str) -> Self {
        match s {
            "Auto" => TrainingJobEarlyStoppingType::Auto,
            "Off" => TrainingJobEarlyStoppingType::Off,
            other => TrainingJobEarlyStoppingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TrainingJobEarlyStoppingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingJobEarlyStoppingType::from(s))
    }
}
impl TrainingJobEarlyStoppingType {
    pub fn as_str(&self) -> &str {
        match self {
            TrainingJobEarlyStoppingType::Auto => "Auto",
            TrainingJobEarlyStoppingType::Off => "Off",
            TrainingJobEarlyStoppingType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Auto", "Off"]
    }
}
impl AsRef<str> for TrainingJobEarlyStoppingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for user interface template information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UiTemplateInfo {
    /// <p>The URL for the user interface template.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>The SHA-256 digest of the contents of the template.</p>
    pub content_sha256: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UiTemplateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UiTemplateInfo");
        formatter.field("url", &self.url);
        formatter.field("content_sha256", &self.content_sha256);
        formatter.finish()
    }
}
/// See [`UiTemplateInfo`](crate::model::UiTemplateInfo)
pub mod ui_template_info {
    /// A builder for [`UiTemplateInfo`](crate::model::UiTemplateInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) content_sha256: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL for the user interface template.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The SHA-256 digest of the contents of the template.</p>
        pub fn content_sha256(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_sha256 = Some(input.into());
            self
        }
        pub fn set_content_sha256(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.content_sha256 = input;
            self
        }
        /// Consumes the builder and constructs a [`UiTemplateInfo`](crate::model::UiTemplateInfo)
        pub fn build(self) -> crate::model::UiTemplateInfo {
            crate::model::UiTemplateInfo {
                url: self.url,
                content_sha256: self.content_sha256,
            }
        }
    }
}
impl UiTemplateInfo {
    /// Creates a new builder-style object to manufacture [`UiTemplateInfo`](crate::model::UiTemplateInfo)
    pub fn builder() -> crate::model::ui_template_info::Builder {
        crate::model::ui_template_info::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HumanTaskUiStatus {
    Active,
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HumanTaskUiStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => HumanTaskUiStatus::Active,
            "Deleting" => HumanTaskUiStatus::Deleting,
            other => HumanTaskUiStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HumanTaskUiStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HumanTaskUiStatus::from(s))
    }
}
impl HumanTaskUiStatus {
    pub fn as_str(&self) -> &str {
        match self {
            HumanTaskUiStatus::Active => "Active",
            HumanTaskUiStatus::Deleting => "Deleting",
            HumanTaskUiStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Active", "Deleting"]
    }
}
impl AsRef<str> for HumanTaskUiStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about where human output will be stored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FlowDefinitionOutputConfig {
    /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
    /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I
    /// Output Data</a>.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
    /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FlowDefinitionOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FlowDefinitionOutputConfig");
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
pub mod flow_definition_output_config {
    /// A builder for [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 path where the object containing human output will be made available.</p>
        /// <p>To learn more about the format of Amazon A2I output data, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-output-data.html">Amazon A2I
        /// Output Data</a>.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// <p>The Amazon Key Management Service (KMS) key ID for server-side encryption.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
        pub fn build(self) -> crate::model::FlowDefinitionOutputConfig {
            crate::model::FlowDefinitionOutputConfig {
                s3_output_path: self.s3_output_path,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl FlowDefinitionOutputConfig {
    /// Creates a new builder-style object to manufacture [`FlowDefinitionOutputConfig`](crate::model::FlowDefinitionOutputConfig)
    pub fn builder() -> crate::model::flow_definition_output_config::Builder {
        crate::model::flow_definition_output_config::Builder::default()
    }
}

/// <p>Describes the work to be performed by human workers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopConfig {
    /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of
    /// workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create
    /// and Manage Workforces</a>.</p>
    pub workteam_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
    /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task
    /// template. You use this template to create a human task UI.</p>
    /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker
    /// Task Template</a>.</p>
    /// <p>To learn how to create a human task UI, which is a worker task template that can be used
    /// in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
    pub human_task_ui_arn: std::option::Option<std::string::String>,
    /// <p>A title for the human worker task.</p>
    pub task_title: std::option::Option<std::string::String>,
    /// <p>A description for the human worker task.</p>
    pub task_description: std::option::Option<std::string::String>,
    /// <p>The number of distinct workers who will perform the same task on each object.
    /// For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification
    /// labeling job, three workers will classify each input image.
    /// Increasing <code>TaskCount</code> can improve label accuracy.</p>
    pub task_count: std::option::Option<i32>,
    /// <p>The length of time that a task remains available for review by human workers.</p>
    pub task_availability_lifetime_in_seconds: std::option::Option<i32>,
    /// <p>The amount of time that a worker has to complete a task. The default value is 3,600
    /// seconds (1 hour).</p>
    pub task_time_limit_in_seconds: std::option::Option<i32>,
    /// <p>Keywords used to describe the task so that workers can discover the task.</p>
    pub task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
    /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and
    /// should be based on the complexity of the task; the longer it takes in your initial
    /// testing, the more you should offer.</p>
    /// <ul>
    /// <li>
    /// <p>0.036</p>
    /// </li>
    /// <li>
    /// <p>0.048</p>
    /// </li>
    /// <li>
    /// <p>0.060</p>
    /// </li>
    /// <li>
    /// <p>0.072</p>
    /// </li>
    /// <li>
    /// <p>0.120</p>
    /// </li>
    /// <li>
    /// <p>0.240</p>
    /// </li>
    /// <li>
    /// <p>0.360</p>
    /// </li>
    /// <li>
    /// <p>0.480</p>
    /// </li>
    /// <li>
    /// <p>0.600</p>
    /// </li>
    /// <li>
    /// <p>0.720</p>
    /// </li>
    /// <li>
    /// <p>0.840</p>
    /// </li>
    /// <li>
    /// <p>0.960</p>
    /// </li>
    /// <li>
    /// <p>1.080</p>
    /// </li>
    /// <li>
    /// <p>1.200</p>
    /// </li>
    /// </ul>
    /// <p>Use one of the following prices for image classification, text classification, and
    /// custom tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li>
    /// <p>0.012</p>
    /// </li>
    /// <li>
    /// <p>0.024</p>
    /// </li>
    /// <li>
    /// <p>0.036</p>
    /// </li>
    /// <li>
    /// <p>0.048</p>
    /// </li>
    /// <li>
    /// <p>0.060</p>
    /// </li>
    /// <li>
    /// <p>0.072</p>
    /// </li>
    /// <li>
    /// <p>0.120</p>
    /// </li>
    /// <li>
    /// <p>0.240</p>
    /// </li>
    /// <li>
    /// <p>0.360</p>
    /// </li>
    /// <li>
    /// <p>0.480</p>
    /// </li>
    /// <li>
    /// <p>0.600</p>
    /// </li>
    /// <li>
    /// <p>0.720</p>
    /// </li>
    /// <li>
    /// <p>0.840</p>
    /// </li>
    /// <li>
    /// <p>0.960</p>
    /// </li>
    /// <li>
    /// <p>1.080</p>
    /// </li>
    /// <li>
    /// <p>1.200</p>
    /// </li>
    /// </ul>
    /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US
    /// dollars.</p>
    /// <ul>
    /// <li>
    /// <p>0.840</p>
    /// </li>
    /// <li>
    /// <p>0.960</p>
    /// </li>
    /// <li>
    /// <p>1.080</p>
    /// </li>
    /// <li>
    /// <p>1.200</p>
    /// </li>
    /// </ul>
    /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon
    /// Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li>
    /// <p>2.400 </p>
    /// </li>
    /// <li>
    /// <p>2.280 </p>
    /// </li>
    /// <li>
    /// <p>2.160 </p>
    /// </li>
    /// <li>
    /// <p>2.040 </p>
    /// </li>
    /// <li>
    /// <p>1.920 </p>
    /// </li>
    /// <li>
    /// <p>1.800 </p>
    /// </li>
    /// <li>
    /// <p>1.680 </p>
    /// </li>
    /// <li>
    /// <p>1.560 </p>
    /// </li>
    /// <li>
    /// <p>1.440 </p>
    /// </li>
    /// <li>
    /// <p>1.320 </p>
    /// </li>
    /// <li>
    /// <p>1.200 </p>
    /// </li>
    /// <li>
    /// <p>1.080 </p>
    /// </li>
    /// <li>
    /// <p>0.960 </p>
    /// </li>
    /// <li>
    /// <p>0.840 </p>
    /// </li>
    /// <li>
    /// <p>0.720 </p>
    /// </li>
    /// <li>
    /// <p>0.600 </p>
    /// </li>
    /// <li>
    /// <p>0.480 </p>
    /// </li>
    /// <li>
    /// <p>0.360 </p>
    /// </li>
    /// <li>
    /// <p>0.240 </p>
    /// </li>
    /// <li>
    /// <p>0.120 </p>
    /// </li>
    /// <li>
    /// <p>0.072 </p>
    /// </li>
    /// <li>
    /// <p>0.060 </p>
    /// </li>
    /// <li>
    /// <p>0.048 </p>
    /// </li>
    /// <li>
    /// <p>0.036 </p>
    /// </li>
    /// <li>
    /// <p>0.024 </p>
    /// </li>
    /// <li>
    /// <p>0.012 </p>
    /// </li>
    /// </ul>
    /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon
    /// Augmented AI review tasks. Prices are in US dollars.</p>
    /// <ul>
    /// <li>
    /// <p>1.200 </p>
    /// </li>
    /// <li>
    /// <p>1.080 </p>
    /// </li>
    /// <li>
    /// <p>0.960 </p>
    /// </li>
    /// <li>
    /// <p>0.840 </p>
    /// </li>
    /// <li>
    /// <p>0.720 </p>
    /// </li>
    /// <li>
    /// <p>0.600 </p>
    /// </li>
    /// <li>
    /// <p>0.480 </p>
    /// </li>
    /// <li>
    /// <p>0.360 </p>
    /// </li>
    /// <li>
    /// <p>0.240 </p>
    /// </li>
    /// <li>
    /// <p>0.120 </p>
    /// </li>
    /// <li>
    /// <p>0.072 </p>
    /// </li>
    /// <li>
    /// <p>0.060 </p>
    /// </li>
    /// <li>
    /// <p>0.048 </p>
    /// </li>
    /// <li>
    /// <p>0.036 </p>
    /// </li>
    /// <li>
    /// <p>0.024 </p>
    /// </li>
    /// <li>
    /// <p>0.012 </p>
    /// </li>
    /// </ul>
    /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks.
    /// Prices are in US dollars.</p>
    /// <ul>
    /// <li>
    /// <p>1.200 </p>
    /// </li>
    /// <li>
    /// <p>1.080 </p>
    /// </li>
    /// <li>
    /// <p>0.960 </p>
    /// </li>
    /// <li>
    /// <p>0.840 </p>
    /// </li>
    /// <li>
    /// <p>0.720 </p>
    /// </li>
    /// <li>
    /// <p>0.600 </p>
    /// </li>
    /// <li>
    /// <p>0.480 </p>
    /// </li>
    /// <li>
    /// <p>0.360 </p>
    /// </li>
    /// <li>
    /// <p>0.240 </p>
    /// </li>
    /// <li>
    /// <p>0.120 </p>
    /// </li>
    /// <li>
    /// <p>0.072 </p>
    /// </li>
    /// <li>
    /// <p>0.060 </p>
    /// </li>
    /// <li>
    /// <p>0.048 </p>
    /// </li>
    /// <li>
    /// <p>0.036 </p>
    /// </li>
    /// <li>
    /// <p>0.024 </p>
    /// </li>
    /// <li>
    /// <p>0.012 </p>
    /// </li>
    /// </ul>
    pub public_workforce_task_price: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
}
impl std::fmt::Debug for HumanLoopConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopConfig");
        formatter.field("workteam_arn", &self.workteam_arn);
        formatter.field("human_task_ui_arn", &self.human_task_ui_arn);
        formatter.field("task_title", &self.task_title);
        formatter.field("task_description", &self.task_description);
        formatter.field("task_count", &self.task_count);
        formatter.field(
            "task_availability_lifetime_in_seconds",
            &self.task_availability_lifetime_in_seconds,
        );
        formatter.field(
            "task_time_limit_in_seconds",
            &self.task_time_limit_in_seconds,
        );
        formatter.field("task_keywords", &self.task_keywords);
        formatter.field(
            "public_workforce_task_price",
            &self.public_workforce_task_price,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopConfig`](crate::model::HumanLoopConfig)
pub mod human_loop_config {
    /// A builder for [`HumanLoopConfig`](crate::model::HumanLoopConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workteam_arn: std::option::Option<std::string::String>,
        pub(crate) human_task_ui_arn: std::option::Option<std::string::String>,
        pub(crate) task_title: std::option::Option<std::string::String>,
        pub(crate) task_description: std::option::Option<std::string::String>,
        pub(crate) task_count: std::option::Option<i32>,
        pub(crate) task_availability_lifetime_in_seconds: std::option::Option<i32>,
        pub(crate) task_time_limit_in_seconds: std::option::Option<i32>,
        pub(crate) task_keywords: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) public_workforce_task_price:
            std::option::Option<crate::model::PublicWorkforceTaskPrice>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of a team of workers. To learn more about the types of
        /// workforces and work teams you can create and use with Amazon A2I, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sms-workforce-management.html">Create
        /// and Manage Workforces</a>.</p>
        pub fn workteam_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.workteam_arn = Some(input.into());
            self
        }
        pub fn set_workteam_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workteam_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the human task user interface.</p>
        /// <p>You can use standard HTML and Crowd HTML Elements to create a custom worker task
        /// template. You use this template to create a human task UI.</p>
        /// <p>To learn how to create a custom HTML template, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-custom-templates.html">Create Custom Worker
        /// Task Template</a>.</p>
        /// <p>To learn how to create a human task UI, which is a worker task template that can be used
        /// in a flow definition, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-worker-template-console.html">Create and Delete a Worker Task Templates</a>.</p>
        pub fn human_task_ui_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.human_task_ui_arn = Some(input.into());
            self
        }
        pub fn set_human_task_ui_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_task_ui_arn = input;
            self
        }
        /// <p>A title for the human worker task.</p>
        pub fn task_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_title = Some(input.into());
            self
        }
        pub fn set_task_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_title = input;
            self
        }
        /// <p>A description for the human worker task.</p>
        pub fn task_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_description = Some(input.into());
            self
        }
        pub fn set_task_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_description = input;
            self
        }
        /// <p>The number of distinct workers who will perform the same task on each object.
        /// For example, if <code>TaskCount</code> is set to <code>3</code> for an image classification
        /// labeling job, three workers will classify each input image.
        /// Increasing <code>TaskCount</code> can improve label accuracy.</p>
        pub fn task_count(mut self, input: i32) -> Self {
            self.task_count = Some(input);
            self
        }
        pub fn set_task_count(mut self, input: std::option::Option<i32>) -> Self {
            self.task_count = input;
            self
        }
        /// <p>The length of time that a task remains available for review by human workers.</p>
        pub fn task_availability_lifetime_in_seconds(mut self, input: i32) -> Self {
            self.task_availability_lifetime_in_seconds = Some(input);
            self
        }
        pub fn set_task_availability_lifetime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.task_availability_lifetime_in_seconds = input;
            self
        }
        /// <p>The amount of time that a worker has to complete a task. The default value is 3,600
        /// seconds (1 hour).</p>
        pub fn task_time_limit_in_seconds(mut self, input: i32) -> Self {
            self.task_time_limit_in_seconds = Some(input);
            self
        }
        pub fn set_task_time_limit_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.task_time_limit_in_seconds = input;
            self
        }
        pub fn task_keywords(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.task_keywords.unwrap_or_default();
            v.push(input.into());
            self.task_keywords = Some(v);
            self
        }
        pub fn set_task_keywords(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.task_keywords = input;
            self
        }
        /// <p>Defines the amount of money paid to an Amazon Mechanical Turk worker for each task performed. </p>
        /// <p>Use one of the following prices for bounding box tasks. Prices are in US dollars and
        /// should be based on the complexity of the task; the longer it takes in your initial
        /// testing, the more you should offer.</p>
        /// <ul>
        /// <li>
        /// <p>0.036</p>
        /// </li>
        /// <li>
        /// <p>0.048</p>
        /// </li>
        /// <li>
        /// <p>0.060</p>
        /// </li>
        /// <li>
        /// <p>0.072</p>
        /// </li>
        /// <li>
        /// <p>0.120</p>
        /// </li>
        /// <li>
        /// <p>0.240</p>
        /// </li>
        /// <li>
        /// <p>0.360</p>
        /// </li>
        /// <li>
        /// <p>0.480</p>
        /// </li>
        /// <li>
        /// <p>0.600</p>
        /// </li>
        /// <li>
        /// <p>0.720</p>
        /// </li>
        /// <li>
        /// <p>0.840</p>
        /// </li>
        /// <li>
        /// <p>0.960</p>
        /// </li>
        /// <li>
        /// <p>1.080</p>
        /// </li>
        /// <li>
        /// <p>1.200</p>
        /// </li>
        /// </ul>
        /// <p>Use one of the following prices for image classification, text classification, and
        /// custom tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li>
        /// <p>0.012</p>
        /// </li>
        /// <li>
        /// <p>0.024</p>
        /// </li>
        /// <li>
        /// <p>0.036</p>
        /// </li>
        /// <li>
        /// <p>0.048</p>
        /// </li>
        /// <li>
        /// <p>0.060</p>
        /// </li>
        /// <li>
        /// <p>0.072</p>
        /// </li>
        /// <li>
        /// <p>0.120</p>
        /// </li>
        /// <li>
        /// <p>0.240</p>
        /// </li>
        /// <li>
        /// <p>0.360</p>
        /// </li>
        /// <li>
        /// <p>0.480</p>
        /// </li>
        /// <li>
        /// <p>0.600</p>
        /// </li>
        /// <li>
        /// <p>0.720</p>
        /// </li>
        /// <li>
        /// <p>0.840</p>
        /// </li>
        /// <li>
        /// <p>0.960</p>
        /// </li>
        /// <li>
        /// <p>1.080</p>
        /// </li>
        /// <li>
        /// <p>1.200</p>
        /// </li>
        /// </ul>
        /// <p>Use one of the following prices for semantic segmentation tasks. Prices are in US
        /// dollars.</p>
        /// <ul>
        /// <li>
        /// <p>0.840</p>
        /// </li>
        /// <li>
        /// <p>0.960</p>
        /// </li>
        /// <li>
        /// <p>1.080</p>
        /// </li>
        /// <li>
        /// <p>1.200</p>
        /// </li>
        /// </ul>
        /// <p>Use one of the following prices for Textract AnalyzeDocument Important Form Key Amazon
        /// Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li>
        /// <p>2.400 </p>
        /// </li>
        /// <li>
        /// <p>2.280 </p>
        /// </li>
        /// <li>
        /// <p>2.160 </p>
        /// </li>
        /// <li>
        /// <p>2.040 </p>
        /// </li>
        /// <li>
        /// <p>1.920 </p>
        /// </li>
        /// <li>
        /// <p>1.800 </p>
        /// </li>
        /// <li>
        /// <p>1.680 </p>
        /// </li>
        /// <li>
        /// <p>1.560 </p>
        /// </li>
        /// <li>
        /// <p>1.440 </p>
        /// </li>
        /// <li>
        /// <p>1.320 </p>
        /// </li>
        /// <li>
        /// <p>1.200 </p>
        /// </li>
        /// <li>
        /// <p>1.080 </p>
        /// </li>
        /// <li>
        /// <p>0.960 </p>
        /// </li>
        /// <li>
        /// <p>0.840 </p>
        /// </li>
        /// <li>
        /// <p>0.720 </p>
        /// </li>
        /// <li>
        /// <p>0.600 </p>
        /// </li>
        /// <li>
        /// <p>0.480 </p>
        /// </li>
        /// <li>
        /// <p>0.360 </p>
        /// </li>
        /// <li>
        /// <p>0.240 </p>
        /// </li>
        /// <li>
        /// <p>0.120 </p>
        /// </li>
        /// <li>
        /// <p>0.072 </p>
        /// </li>
        /// <li>
        /// <p>0.060 </p>
        /// </li>
        /// <li>
        /// <p>0.048 </p>
        /// </li>
        /// <li>
        /// <p>0.036 </p>
        /// </li>
        /// <li>
        /// <p>0.024 </p>
        /// </li>
        /// <li>
        /// <p>0.012 </p>
        /// </li>
        /// </ul>
        /// <p>Use one of the following prices for Rekognition DetectModerationLabels Amazon
        /// Augmented AI review tasks. Prices are in US dollars.</p>
        /// <ul>
        /// <li>
        /// <p>1.200 </p>
        /// </li>
        /// <li>
        /// <p>1.080 </p>
        /// </li>
        /// <li>
        /// <p>0.960 </p>
        /// </li>
        /// <li>
        /// <p>0.840 </p>
        /// </li>
        /// <li>
        /// <p>0.720 </p>
        /// </li>
        /// <li>
        /// <p>0.600 </p>
        /// </li>
        /// <li>
        /// <p>0.480 </p>
        /// </li>
        /// <li>
        /// <p>0.360 </p>
        /// </li>
        /// <li>
        /// <p>0.240 </p>
        /// </li>
        /// <li>
        /// <p>0.120 </p>
        /// </li>
        /// <li>
        /// <p>0.072 </p>
        /// </li>
        /// <li>
        /// <p>0.060 </p>
        /// </li>
        /// <li>
        /// <p>0.048 </p>
        /// </li>
        /// <li>
        /// <p>0.036 </p>
        /// </li>
        /// <li>
        /// <p>0.024 </p>
        /// </li>
        /// <li>
        /// <p>0.012 </p>
        /// </li>
        /// </ul>
        /// <p>Use one of the following prices for Amazon Augmented AI custom human review tasks.
        /// Prices are in US dollars.</p>
        /// <ul>
        /// <li>
        /// <p>1.200 </p>
        /// </li>
        /// <li>
        /// <p>1.080 </p>
        /// </li>
        /// <li>
        /// <p>0.960 </p>
        /// </li>
        /// <li>
        /// <p>0.840 </p>
        /// </li>
        /// <li>
        /// <p>0.720 </p>
        /// </li>
        /// <li>
        /// <p>0.600 </p>
        /// </li>
        /// <li>
        /// <p>0.480 </p>
        /// </li>
        /// <li>
        /// <p>0.360 </p>
        /// </li>
        /// <li>
        /// <p>0.240 </p>
        /// </li>
        /// <li>
        /// <p>0.120 </p>
        /// </li>
        /// <li>
        /// <p>0.072 </p>
        /// </li>
        /// <li>
        /// <p>0.060 </p>
        /// </li>
        /// <li>
        /// <p>0.048 </p>
        /// </li>
        /// <li>
        /// <p>0.036 </p>
        /// </li>
        /// <li>
        /// <p>0.024 </p>
        /// </li>
        /// <li>
        /// <p>0.012 </p>
        /// </li>
        /// </ul>
        pub fn public_workforce_task_price(
            mut self,
            input: crate::model::PublicWorkforceTaskPrice,
        ) -> Self {
            self.public_workforce_task_price = Some(input);
            self
        }
        pub fn set_public_workforce_task_price(
            mut self,
            input: std::option::Option<crate::model::PublicWorkforceTaskPrice>,
        ) -> Self {
            self.public_workforce_task_price = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopConfig`](crate::model::HumanLoopConfig)
        pub fn build(self) -> crate::model::HumanLoopConfig {
            crate::model::HumanLoopConfig {
                workteam_arn: self.workteam_arn,
                human_task_ui_arn: self.human_task_ui_arn,
                task_title: self.task_title,
                task_description: self.task_description,
                task_count: self.task_count,
                task_availability_lifetime_in_seconds: self.task_availability_lifetime_in_seconds,
                task_time_limit_in_seconds: self.task_time_limit_in_seconds,
                task_keywords: self.task_keywords,
                public_workforce_task_price: self.public_workforce_task_price,
            }
        }
    }
}
impl HumanLoopConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopConfig`](crate::model::HumanLoopConfig)
    pub fn builder() -> crate::model::human_loop_config::Builder {
        crate::model::human_loop_config::Builder::default()
    }
}

/// <p>Provides information about how and under what conditions SageMaker creates a human loop. If <code>HumanLoopActivationConfig</code> is not given, then all requests go to humans.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopActivationConfig {
    /// <p>Container structure for defining under what conditions SageMaker creates a human
    /// loop.</p>
    pub human_loop_activation_conditions_config:
        std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
}
impl std::fmt::Debug for HumanLoopActivationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopActivationConfig");
        formatter.field(
            "human_loop_activation_conditions_config",
            &self.human_loop_activation_conditions_config,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
pub mod human_loop_activation_config {
    /// A builder for [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_loop_activation_conditions_config:
            std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
    }
    impl Builder {
        /// <p>Container structure for defining under what conditions SageMaker creates a human
        /// loop.</p>
        pub fn human_loop_activation_conditions_config(
            mut self,
            input: crate::model::HumanLoopActivationConditionsConfig,
        ) -> Self {
            self.human_loop_activation_conditions_config = Some(input);
            self
        }
        pub fn set_human_loop_activation_conditions_config(
            mut self,
            input: std::option::Option<crate::model::HumanLoopActivationConditionsConfig>,
        ) -> Self {
            self.human_loop_activation_conditions_config = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
        pub fn build(self) -> crate::model::HumanLoopActivationConfig {
            crate::model::HumanLoopActivationConfig {
                human_loop_activation_conditions_config: self
                    .human_loop_activation_conditions_config,
            }
        }
    }
}
impl HumanLoopActivationConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopActivationConfig`](crate::model::HumanLoopActivationConfig)
    pub fn builder() -> crate::model::human_loop_activation_config::Builder {
        crate::model::human_loop_activation_config::Builder::default()
    }
}

/// <p>Defines under what conditions SageMaker creates a human loop. Used within . See  for the required
/// format of activation conditions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopActivationConditionsConfig {
    /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team.
    /// The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a>
    /// in the <i>Amazon SageMaker Developer Guide</i>.</p>
    pub human_loop_activation_conditions: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HumanLoopActivationConditionsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopActivationConditionsConfig");
        formatter.field(
            "human_loop_activation_conditions",
            &self.human_loop_activation_conditions,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
pub mod human_loop_activation_conditions_config {
    /// A builder for [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) human_loop_activation_conditions: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>JSON expressing use-case specific conditions declaratively. If any condition is matched, atomic tasks are created against the configured work team.
        /// The set of conditions is different for Rekognition and Textract. For more information about how to structure the JSON, see
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/a2i-human-fallback-conditions-json-schema.html">JSON Schema for Human Loop Activation Conditions in Amazon Augmented AI</a>
        /// in the <i>Amazon SageMaker Developer Guide</i>.</p>
        pub fn human_loop_activation_conditions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.human_loop_activation_conditions = Some(input.into());
            self
        }
        pub fn set_human_loop_activation_conditions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.human_loop_activation_conditions = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
        pub fn build(self) -> crate::model::HumanLoopActivationConditionsConfig {
            crate::model::HumanLoopActivationConditionsConfig {
                human_loop_activation_conditions: self.human_loop_activation_conditions,
            }
        }
    }
}
impl HumanLoopActivationConditionsConfig {
    /// Creates a new builder-style object to manufacture [`HumanLoopActivationConditionsConfig`](crate::model::HumanLoopActivationConditionsConfig)
    pub fn builder() -> crate::model::human_loop_activation_conditions_config::Builder {
        crate::model::human_loop_activation_conditions_config::Builder::default()
    }
}

/// <p>Container for configuring the source of human task requests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HumanLoopRequestSource {
    /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source.
    /// The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
    pub aws_managed_human_loop_request_source:
        std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
}
impl std::fmt::Debug for HumanLoopRequestSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HumanLoopRequestSource");
        formatter.field(
            "aws_managed_human_loop_request_source",
            &self.aws_managed_human_loop_request_source,
        );
        formatter.finish()
    }
}
/// See [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
pub mod human_loop_request_source {
    /// A builder for [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_managed_human_loop_request_source:
            std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
    }
    impl Builder {
        /// <p>Specifies whether Amazon Rekognition or Amazon Textract are used as the integration source.
        /// The default field settings and JSON parsing rules are different based on the integration source. Valid values:</p>
        pub fn aws_managed_human_loop_request_source(
            mut self,
            input: crate::model::AwsManagedHumanLoopRequestSource,
        ) -> Self {
            self.aws_managed_human_loop_request_source = Some(input);
            self
        }
        pub fn set_aws_managed_human_loop_request_source(
            mut self,
            input: std::option::Option<crate::model::AwsManagedHumanLoopRequestSource>,
        ) -> Self {
            self.aws_managed_human_loop_request_source = input;
            self
        }
        /// Consumes the builder and constructs a [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
        pub fn build(self) -> crate::model::HumanLoopRequestSource {
            crate::model::HumanLoopRequestSource {
                aws_managed_human_loop_request_source: self.aws_managed_human_loop_request_source,
            }
        }
    }
}
impl HumanLoopRequestSource {
    /// Creates a new builder-style object to manufacture [`HumanLoopRequestSource`](crate::model::HumanLoopRequestSource)
    pub fn builder() -> crate::model::human_loop_request_source::Builder {
        crate::model::human_loop_request_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsManagedHumanLoopRequestSource {
    RekognitionDetectModerationLabelsImageV3,
    TextractAnalyzeDocumentFormsV1,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AwsManagedHumanLoopRequestSource {
    fn from(s: &str) -> Self {
        match s {
            "AWS/Rekognition/DetectModerationLabels/Image/V3" => {
                AwsManagedHumanLoopRequestSource::RekognitionDetectModerationLabelsImageV3
            }
            "AWS/Textract/AnalyzeDocument/Forms/V1" => {
                AwsManagedHumanLoopRequestSource::TextractAnalyzeDocumentFormsV1
            }
            other => AwsManagedHumanLoopRequestSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AwsManagedHumanLoopRequestSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsManagedHumanLoopRequestSource::from(s))
    }
}
impl AwsManagedHumanLoopRequestSource {
    pub fn as_str(&self) -> &str {
        match self {
            AwsManagedHumanLoopRequestSource::RekognitionDetectModerationLabelsImageV3 => {
                "AWS/Rekognition/DetectModerationLabels/Image/V3"
            }
            AwsManagedHumanLoopRequestSource::TextractAnalyzeDocumentFormsV1 => {
                "AWS/Textract/AnalyzeDocument/Forms/V1"
            }
            AwsManagedHumanLoopRequestSource::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS/Rekognition/DetectModerationLabels/Image/V3",
            "AWS/Textract/AnalyzeDocument/Forms/V1",
        ]
    }
}
impl AsRef<str> for AwsManagedHumanLoopRequestSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataCaptureConfig {
    /// <p></p>
    pub enable_capture: bool,
    /// <p></p>
    pub initial_sampling_percentage: std::option::Option<i32>,
    /// <p></p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p></p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p></p>
    pub capture_options: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
    /// <p></p>
    pub capture_content_type_header: std::option::Option<crate::model::CaptureContentTypeHeader>,
}
impl std::fmt::Debug for DataCaptureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataCaptureConfig");
        formatter.field("enable_capture", &self.enable_capture);
        formatter.field(
            "initial_sampling_percentage",
            &self.initial_sampling_percentage,
        );
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("capture_options", &self.capture_options);
        formatter.field(
            "capture_content_type_header",
            &self.capture_content_type_header,
        );
        formatter.finish()
    }
}
/// See [`DataCaptureConfig`](crate::model::DataCaptureConfig)
pub mod data_capture_config {
    /// A builder for [`DataCaptureConfig`](crate::model::DataCaptureConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_capture: std::option::Option<bool>,
        pub(crate) initial_sampling_percentage: std::option::Option<i32>,
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) capture_options: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
        pub(crate) capture_content_type_header:
            std::option::Option<crate::model::CaptureContentTypeHeader>,
    }
    impl Builder {
        /// <p></p>
        pub fn enable_capture(mut self, input: bool) -> Self {
            self.enable_capture = Some(input);
            self
        }
        pub fn set_enable_capture(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_capture = input;
            self
        }
        /// <p></p>
        pub fn initial_sampling_percentage(mut self, input: i32) -> Self {
            self.initial_sampling_percentage = Some(input);
            self
        }
        pub fn set_initial_sampling_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_sampling_percentage = input;
            self
        }
        /// <p></p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p></p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        pub fn capture_options(mut self, input: impl Into<crate::model::CaptureOption>) -> Self {
            let mut v = self.capture_options.unwrap_or_default();
            v.push(input.into());
            self.capture_options = Some(v);
            self
        }
        pub fn set_capture_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CaptureOption>>,
        ) -> Self {
            self.capture_options = input;
            self
        }
        /// <p></p>
        pub fn capture_content_type_header(
            mut self,
            input: crate::model::CaptureContentTypeHeader,
        ) -> Self {
            self.capture_content_type_header = Some(input);
            self
        }
        pub fn set_capture_content_type_header(
            mut self,
            input: std::option::Option<crate::model::CaptureContentTypeHeader>,
        ) -> Self {
            self.capture_content_type_header = input;
            self
        }
        /// Consumes the builder and constructs a [`DataCaptureConfig`](crate::model::DataCaptureConfig)
        pub fn build(self) -> crate::model::DataCaptureConfig {
            crate::model::DataCaptureConfig {
                enable_capture: self.enable_capture.unwrap_or_default(),
                initial_sampling_percentage: self.initial_sampling_percentage,
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
                capture_options: self.capture_options,
                capture_content_type_header: self.capture_content_type_header,
            }
        }
    }
}
impl DataCaptureConfig {
    /// Creates a new builder-style object to manufacture [`DataCaptureConfig`](crate::model::DataCaptureConfig)
    pub fn builder() -> crate::model::data_capture_config::Builder {
        crate::model::data_capture_config::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptureContentTypeHeader {
    /// <p></p>
    pub csv_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p></p>
    pub json_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for CaptureContentTypeHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptureContentTypeHeader");
        formatter.field("csv_content_types", &self.csv_content_types);
        formatter.field("json_content_types", &self.json_content_types);
        formatter.finish()
    }
}
/// See [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
pub mod capture_content_type_header {
    /// A builder for [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) csv_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) json_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn csv_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.csv_content_types.unwrap_or_default();
            v.push(input.into());
            self.csv_content_types = Some(v);
            self
        }
        pub fn set_csv_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.csv_content_types = input;
            self
        }
        pub fn json_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.json_content_types.unwrap_or_default();
            v.push(input.into());
            self.json_content_types = Some(v);
            self
        }
        pub fn set_json_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.json_content_types = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
        pub fn build(self) -> crate::model::CaptureContentTypeHeader {
            crate::model::CaptureContentTypeHeader {
                csv_content_types: self.csv_content_types,
                json_content_types: self.json_content_types,
            }
        }
    }
}
impl CaptureContentTypeHeader {
    /// Creates a new builder-style object to manufacture [`CaptureContentTypeHeader`](crate::model::CaptureContentTypeHeader)
    pub fn builder() -> crate::model::capture_content_type_header::Builder {
        crate::model::capture_content_type_header::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CaptureOption {
    /// <p></p>
    pub capture_mode: std::option::Option<crate::model::CaptureMode>,
}
impl std::fmt::Debug for CaptureOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CaptureOption");
        formatter.field("capture_mode", &self.capture_mode);
        formatter.finish()
    }
}
/// See [`CaptureOption`](crate::model::CaptureOption)
pub mod capture_option {
    /// A builder for [`CaptureOption`](crate::model::CaptureOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capture_mode: std::option::Option<crate::model::CaptureMode>,
    }
    impl Builder {
        /// <p></p>
        pub fn capture_mode(mut self, input: crate::model::CaptureMode) -> Self {
            self.capture_mode = Some(input);
            self
        }
        pub fn set_capture_mode(
            mut self,
            input: std::option::Option<crate::model::CaptureMode>,
        ) -> Self {
            self.capture_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureOption`](crate::model::CaptureOption)
        pub fn build(self) -> crate::model::CaptureOption {
            crate::model::CaptureOption {
                capture_mode: self.capture_mode,
            }
        }
    }
}
impl CaptureOption {
    /// Creates a new builder-style object to manufacture [`CaptureOption`](crate::model::CaptureOption)
    pub fn builder() -> crate::model::capture_option::Builder {
        crate::model::capture_option::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CaptureMode {
    Input,
    Output,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CaptureMode {
    fn from(s: &str) -> Self {
        match s {
            "Input" => CaptureMode::Input,
            "Output" => CaptureMode::Output,
            other => CaptureMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CaptureMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CaptureMode::from(s))
    }
}
impl CaptureMode {
    pub fn as_str(&self) -> &str {
        match self {
            CaptureMode::Input => "Input",
            CaptureMode::Output => "Output",
            CaptureMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Input", "Output"]
    }
}
impl AsRef<str> for CaptureMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Identifies a model that you want to host and the resources chosen to deploy for
/// hosting it. If you are deploying multiple models, tell Amazon SageMaker how to distribute traffic
/// among the models by specifying variant weights. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariant {
    /// <p>The name of the production variant.</p>
    pub variant_name: std::option::Option<std::string::String>,
    /// <p>The name of the model that you want to host. This is the name that you specified
    /// when creating the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>Number of instances to launch initially.</p>
    pub initial_instance_count: std::option::Option<i32>,
    /// <p>The ML compute instance type.</p>
    pub instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
    /// <p>Determines initial traffic distribution among all of the models that you specify in
    /// the endpoint configuration. The traffic to a production variant is determined by the
    /// ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code>
    /// values across all ProductionVariants. If unspecified, it defaults to 1.0.
    /// </p>
    pub initial_variant_weight: std::option::Option<f32>,
    /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI
    /// instances provide on-demand GPU computing for inference. For more information, see
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic
    /// Inference in Amazon SageMaker</a>.</p>
    pub accelerator_type: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
    /// <p>Specifies configuration for a core dump from the model container when the process
    /// crashes.</p>
    pub core_dump_config: std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
}
impl std::fmt::Debug for ProductionVariant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariant");
        formatter.field("variant_name", &self.variant_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("initial_instance_count", &self.initial_instance_count);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("initial_variant_weight", &self.initial_variant_weight);
        formatter.field("accelerator_type", &self.accelerator_type);
        formatter.field("core_dump_config", &self.core_dump_config);
        formatter.finish()
    }
}
/// See [`ProductionVariant`](crate::model::ProductionVariant)
pub mod production_variant {
    /// A builder for [`ProductionVariant`](crate::model::ProductionVariant)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variant_name: std::option::Option<std::string::String>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) initial_instance_count: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<crate::model::ProductionVariantInstanceType>,
        pub(crate) initial_variant_weight: std::option::Option<f32>,
        pub(crate) accelerator_type:
            std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        pub(crate) core_dump_config:
            std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
    }
    impl Builder {
        /// <p>The name of the production variant.</p>
        pub fn variant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variant_name = Some(input.into());
            self
        }
        pub fn set_variant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.variant_name = input;
            self
        }
        /// <p>The name of the model that you want to host. This is the name that you specified
        /// when creating the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>Number of instances to launch initially.</p>
        pub fn initial_instance_count(mut self, input: i32) -> Self {
            self.initial_instance_count = Some(input);
            self
        }
        pub fn set_initial_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.initial_instance_count = input;
            self
        }
        /// <p>The ML compute instance type.</p>
        pub fn instance_type(mut self, input: crate::model::ProductionVariantInstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantInstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Determines initial traffic distribution among all of the models that you specify in
        /// the endpoint configuration. The traffic to a production variant is determined by the
        /// ratio of the <code>VariantWeight</code> to the sum of all <code>VariantWeight</code>
        /// values across all ProductionVariants. If unspecified, it defaults to 1.0.
        /// </p>
        pub fn initial_variant_weight(mut self, input: f32) -> Self {
            self.initial_variant_weight = Some(input);
            self
        }
        pub fn set_initial_variant_weight(mut self, input: std::option::Option<f32>) -> Self {
            self.initial_variant_weight = input;
            self
        }
        /// <p>The size of the Elastic Inference (EI) instance to use for the production variant. EI
        /// instances provide on-demand GPU computing for inference. For more information, see
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html">Using Elastic
        /// Inference in Amazon SageMaker</a>.</p>
        pub fn accelerator_type(
            mut self,
            input: crate::model::ProductionVariantAcceleratorType,
        ) -> Self {
            self.accelerator_type = Some(input);
            self
        }
        pub fn set_accelerator_type(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantAcceleratorType>,
        ) -> Self {
            self.accelerator_type = input;
            self
        }
        /// <p>Specifies configuration for a core dump from the model container when the process
        /// crashes.</p>
        pub fn core_dump_config(
            mut self,
            input: crate::model::ProductionVariantCoreDumpConfig,
        ) -> Self {
            self.core_dump_config = Some(input);
            self
        }
        pub fn set_core_dump_config(
            mut self,
            input: std::option::Option<crate::model::ProductionVariantCoreDumpConfig>,
        ) -> Self {
            self.core_dump_config = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariant`](crate::model::ProductionVariant)
        pub fn build(self) -> crate::model::ProductionVariant {
            crate::model::ProductionVariant {
                variant_name: self.variant_name,
                model_name: self.model_name,
                initial_instance_count: self.initial_instance_count,
                instance_type: self.instance_type,
                initial_variant_weight: self.initial_variant_weight,
                accelerator_type: self.accelerator_type,
                core_dump_config: self.core_dump_config,
            }
        }
    }
}
impl ProductionVariant {
    /// Creates a new builder-style object to manufacture [`ProductionVariant`](crate::model::ProductionVariant)
    pub fn builder() -> crate::model::production_variant::Builder {
        crate::model::production_variant::Builder::default()
    }
}

/// <p>Specifies configuration for a core dump from the model container when the process
/// crashes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProductionVariantCoreDumpConfig {
    /// <p>The Amazon S3 bucket to send the core dump to.</p>
    pub destination_s3_uri: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the core dump data at rest using
    /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
    /// formats: </p>
    /// <ul>
    /// <li>
    /// <p>// KMS Key ID</p>
    /// <p>
    /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// KMS Key Alias</p>
    /// <p>
    /// <code>"alias/ExampleAlias"</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p>
    /// <p>
    /// <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>If you use a KMS key ID or an alias of your master key, the Amazon SageMaker execution role must
    /// include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID,
    /// Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. Amazon SageMaker uses server-side
    /// encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket
    /// policy with an <code>s3:PutObject</code> permission that only allows objects with
    /// server-side encryption, set the condition key of
    /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption
    /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
    /// </p>
    /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
    /// <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more
    /// information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services
    /// KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProductionVariantCoreDumpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProductionVariantCoreDumpConfig");
        formatter.field("destination_s3_uri", &self.destination_s3_uri);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
pub mod production_variant_core_dump_config {
    /// A builder for [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket to send the core dump to.</p>
        pub fn destination_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_s3_uri = Some(input.into());
            self
        }
        pub fn set_destination_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_s3_uri = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to encrypt the core dump data at rest using
        /// Amazon S3 server-side encryption. The <code>KmsKeyId</code> can be any of the following
        /// formats: </p>
        /// <ul>
        /// <li>
        /// <p>// KMS Key ID</p>
        /// <p>
        /// <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// Amazon Resource Name (ARN) of a KMS Key</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// KMS Key Alias</p>
        /// <p>
        /// <code>"alias/ExampleAlias"</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>// Amazon Resource Name (ARN) of a KMS Key Alias</p>
        /// <p>
        /// <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you use a KMS key ID or an alias of your master key, the Amazon SageMaker execution role must
        /// include permissions to call <code>kms:Encrypt</code>. If you don't provide a KMS key ID,
        /// Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account. Amazon SageMaker uses server-side
        /// encryption with KMS-managed keys for <code>OutputDataConfig</code>. If you use a bucket
        /// policy with an <code>s3:PutObject</code> permission that only allows objects with
        /// server-side encryption, set the condition key of
        /// <code>s3:x-amz-server-side-encryption</code> to <code>"aws:kms"</code>. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">KMS-Managed Encryption
        /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
        /// </p>
        /// <p>The KMS key policy must grant permission to the IAM role that you specify in your
        /// <code>CreateEndpoint</code> and <code>UpdateEndpoint</code> requests. For more
        /// information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html">Using Key Policies in Amazon Web Services
        /// KMS</a> in the <i>Amazon Web Services Key Management Service Developer Guide</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
        pub fn build(self) -> crate::model::ProductionVariantCoreDumpConfig {
            crate::model::ProductionVariantCoreDumpConfig {
                destination_s3_uri: self.destination_s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl ProductionVariantCoreDumpConfig {
    /// Creates a new builder-style object to manufacture [`ProductionVariantCoreDumpConfig`](crate::model::ProductionVariantCoreDumpConfig)
    pub fn builder() -> crate::model::production_variant_core_dump_config::Builder {
        crate::model::production_variant_core_dump_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductionVariantAcceleratorType {
    MlEia1Large,
    MlEia1Medium,
    MlEia1Xlarge,
    MlEia2Large,
    MlEia2Medium,
    MlEia2Xlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProductionVariantAcceleratorType {
    fn from(s: &str) -> Self {
        match s {
            "ml.eia1.large" => ProductionVariantAcceleratorType::MlEia1Large,
            "ml.eia1.medium" => ProductionVariantAcceleratorType::MlEia1Medium,
            "ml.eia1.xlarge" => ProductionVariantAcceleratorType::MlEia1Xlarge,
            "ml.eia2.large" => ProductionVariantAcceleratorType::MlEia2Large,
            "ml.eia2.medium" => ProductionVariantAcceleratorType::MlEia2Medium,
            "ml.eia2.xlarge" => ProductionVariantAcceleratorType::MlEia2Xlarge,
            other => ProductionVariantAcceleratorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProductionVariantAcceleratorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductionVariantAcceleratorType::from(s))
    }
}
impl ProductionVariantAcceleratorType {
    pub fn as_str(&self) -> &str {
        match self {
            ProductionVariantAcceleratorType::MlEia1Large => "ml.eia1.large",
            ProductionVariantAcceleratorType::MlEia1Medium => "ml.eia1.medium",
            ProductionVariantAcceleratorType::MlEia1Xlarge => "ml.eia1.xlarge",
            ProductionVariantAcceleratorType::MlEia2Large => "ml.eia2.large",
            ProductionVariantAcceleratorType::MlEia2Medium => "ml.eia2.medium",
            ProductionVariantAcceleratorType::MlEia2Xlarge => "ml.eia2.xlarge",
            ProductionVariantAcceleratorType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ml.eia1.large",
            "ml.eia1.medium",
            "ml.eia1.xlarge",
            "ml.eia2.large",
            "ml.eia2.medium",
            "ml.eia2.xlarge",
        ]
    }
}
impl AsRef<str> for ProductionVariantAcceleratorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The output of a SageMaker Edge Manager deployable resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgePresetDeploymentOutput {
    /// <p>The deployment type created by SageMaker Edge Manager. Currently only
    /// supports Amazon Web Services IoT Greengrass Version 2 components.</p>
    pub r#type: std::option::Option<crate::model::EdgePresetDeploymentType>,
    /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
    pub artifact: std::option::Option<std::string::String>,
    /// <p>The status of the deployable resource.</p>
    pub status: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
    /// <p>Returns a message describing the status of the deployed resource.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EdgePresetDeploymentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgePresetDeploymentOutput");
        formatter.field("r#type", &self.r#type);
        formatter.field("artifact", &self.artifact);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
pub mod edge_preset_deployment_output {
    /// A builder for [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::EdgePresetDeploymentType>,
        pub(crate) artifact: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The deployment type created by SageMaker Edge Manager. Currently only
        /// supports Amazon Web Services IoT Greengrass Version 2 components.</p>
        pub fn r#type(mut self, input: crate::model::EdgePresetDeploymentType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the generated deployable resource.</p>
        pub fn artifact(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact = Some(input.into());
            self
        }
        pub fn set_artifact(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.artifact = input;
            self
        }
        /// <p>The status of the deployable resource.</p>
        pub fn status(mut self, input: crate::model::EdgePresetDeploymentStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EdgePresetDeploymentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Returns a message describing the status of the deployed resource.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
        pub fn build(self) -> crate::model::EdgePresetDeploymentOutput {
            crate::model::EdgePresetDeploymentOutput {
                r#type: self.r#type,
                artifact: self.artifact,
                status: self.status,
                status_message: self.status_message,
            }
        }
    }
}
impl EdgePresetDeploymentOutput {
    /// Creates a new builder-style object to manufacture [`EdgePresetDeploymentOutput`](crate::model::EdgePresetDeploymentOutput)
    pub fn builder() -> crate::model::edge_preset_deployment_output::Builder {
        crate::model::edge_preset_deployment_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EdgePresetDeploymentStatus {
    Completed,
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EdgePresetDeploymentStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => EdgePresetDeploymentStatus::Completed,
            "FAILED" => EdgePresetDeploymentStatus::Failed,
            other => EdgePresetDeploymentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EdgePresetDeploymentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EdgePresetDeploymentStatus::from(s))
    }
}
impl EdgePresetDeploymentStatus {
    pub fn as_str(&self) -> &str {
        match self {
            EdgePresetDeploymentStatus::Completed => "COMPLETED",
            EdgePresetDeploymentStatus::Failed => "FAILED",
            EdgePresetDeploymentStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED"]
    }
}
impl AsRef<str> for EdgePresetDeploymentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppNetworkAccessType {
    PublicInternetOnly,
    VpcOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AppNetworkAccessType {
    fn from(s: &str) -> Self {
        match s {
            "PublicInternetOnly" => AppNetworkAccessType::PublicInternetOnly,
            "VpcOnly" => AppNetworkAccessType::VpcOnly,
            other => AppNetworkAccessType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AppNetworkAccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppNetworkAccessType::from(s))
    }
}
impl AppNetworkAccessType {
    pub fn as_str(&self) -> &str {
        match self {
            AppNetworkAccessType::PublicInternetOnly => "PublicInternetOnly",
            AppNetworkAccessType::VpcOnly => "VpcOnly",
            AppNetworkAccessType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PublicInternetOnly", "VpcOnly"]
    }
}
impl AsRef<str> for AppNetworkAccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthMode {
    Iam,
    Sso,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AuthMode {
    fn from(s: &str) -> Self {
        match s {
            "IAM" => AuthMode::Iam,
            "SSO" => AuthMode::Sso,
            other => AuthMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AuthMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthMode::from(s))
    }
}
impl AuthMode {
    pub fn as_str(&self) -> &str {
        match self {
            AuthMode::Iam => "IAM",
            AuthMode::Sso => "SSO",
            AuthMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["IAM", "SSO"]
    }
}
impl AsRef<str> for AuthMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The model on the edge device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EdgeModel {
    /// <p>The name of the model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The model version.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The timestamp of the last data sample taken.</p>
    pub latest_sample_time: std::option::Option<smithy_types::Instant>,
    /// <p>The timestamp of the last inference that was made.</p>
    pub latest_inference: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for EdgeModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EdgeModel");
        formatter.field("model_name", &self.model_name);
        formatter.field("model_version", &self.model_version);
        formatter.field("latest_sample_time", &self.latest_sample_time);
        formatter.field("latest_inference", &self.latest_inference);
        formatter.finish()
    }
}
/// See [`EdgeModel`](crate::model::EdgeModel)
pub mod edge_model {
    /// A builder for [`EdgeModel`](crate::model::EdgeModel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) latest_sample_time: std::option::Option<smithy_types::Instant>,
        pub(crate) latest_inference: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The model version.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The timestamp of the last data sample taken.</p>
        pub fn latest_sample_time(mut self, input: smithy_types::Instant) -> Self {
            self.latest_sample_time = Some(input);
            self
        }
        pub fn set_latest_sample_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_sample_time = input;
            self
        }
        /// <p>The timestamp of the last inference that was made.</p>
        pub fn latest_inference(mut self, input: smithy_types::Instant) -> Self {
            self.latest_inference = Some(input);
            self
        }
        pub fn set_latest_inference(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_inference = input;
            self
        }
        /// Consumes the builder and constructs a [`EdgeModel`](crate::model::EdgeModel)
        pub fn build(self) -> crate::model::EdgeModel {
            crate::model::EdgeModel {
                model_name: self.model_name,
                model_version: self.model_version,
                latest_sample_time: self.latest_sample_time,
                latest_inference: self.latest_inference,
            }
        }
    }
}
impl EdgeModel {
    /// Creates a new builder-style object to manufacture [`EdgeModel`](crate::model::EdgeModel)
    pub fn builder() -> crate::model::edge_model::Builder {
        crate::model::edge_model::Builder::default()
    }
}

/// <p>The input for the data quality monitoring job. Currently endpoints are supported for
/// input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityJobInput {
    /// <p>Input object for the endpoint</p>
    pub endpoint_input: std::option::Option<crate::model::EndpointInput>,
}
impl std::fmt::Debug for DataQualityJobInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityJobInput");
        formatter.field("endpoint_input", &self.endpoint_input);
        formatter.finish()
    }
}
/// See [`DataQualityJobInput`](crate::model::DataQualityJobInput)
pub mod data_quality_job_input {
    /// A builder for [`DataQualityJobInput`](crate::model::DataQualityJobInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_input: std::option::Option<crate::model::EndpointInput>,
    }
    impl Builder {
        /// <p>Input object for the endpoint</p>
        pub fn endpoint_input(mut self, input: crate::model::EndpointInput) -> Self {
            self.endpoint_input = Some(input);
            self
        }
        pub fn set_endpoint_input(
            mut self,
            input: std::option::Option<crate::model::EndpointInput>,
        ) -> Self {
            self.endpoint_input = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityJobInput`](crate::model::DataQualityJobInput)
        pub fn build(self) -> crate::model::DataQualityJobInput {
            crate::model::DataQualityJobInput {
                endpoint_input: self.endpoint_input,
            }
        }
    }
}
impl DataQualityJobInput {
    /// Creates a new builder-style object to manufacture [`DataQualityJobInput`](crate::model::DataQualityJobInput)
    pub fn builder() -> crate::model::data_quality_job_input::Builder {
        crate::model::data_quality_job_input::Builder::default()
    }
}

/// <p>Information about the container that a data quality monitoring job runs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityAppSpecification {
    /// <p>The container image that the data quality monitoring job runs.</p>
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The entrypoint for a container used to run a monitoring job.</p>
    pub container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The arguments to send to the container that the monitoring job runs.</p>
    pub container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
    /// base64 decode the payload and convert it into a flatted json so that the built-in container
    /// can use the converted data. Applicable only for the built-in (first party)
    /// containers.</p>
    pub record_preprocessor_source_uri: std::option::Option<std::string::String>,
    /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
    /// Applicable only for the built-in (first party) containers.</p>
    pub post_analytics_processor_source_uri: std::option::Option<std::string::String>,
    /// <p>Sets the environment variables in the container that the monitoring job runs.</p>
    pub environment:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DataQualityAppSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityAppSpecification");
        formatter.field("image_uri", &self.image_uri);
        formatter.field("container_entrypoint", &self.container_entrypoint);
        formatter.field("container_arguments", &self.container_arguments);
        formatter.field(
            "record_preprocessor_source_uri",
            &self.record_preprocessor_source_uri,
        );
        formatter.field(
            "post_analytics_processor_source_uri",
            &self.post_analytics_processor_source_uri,
        );
        formatter.field("environment", &self.environment);
        formatter.finish()
    }
}
/// See [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
pub mod data_quality_app_specification {
    /// A builder for [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) container_entrypoint: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) container_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) record_preprocessor_source_uri: std::option::Option<std::string::String>,
        pub(crate) post_analytics_processor_source_uri: std::option::Option<std::string::String>,
        pub(crate) environment: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The container image that the data quality monitoring job runs.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        pub fn container_entrypoint(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_entrypoint.unwrap_or_default();
            v.push(input.into());
            self.container_entrypoint = Some(v);
            self
        }
        pub fn set_container_entrypoint(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_entrypoint = input;
            self
        }
        pub fn container_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.container_arguments.unwrap_or_default();
            v.push(input.into());
            self.container_arguments = Some(v);
            self
        }
        pub fn set_container_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.container_arguments = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called per row prior to running analysis. It can
        /// base64 decode the payload and convert it into a flatted json so that the built-in container
        /// can use the converted data. Applicable only for the built-in (first party)
        /// containers.</p>
        pub fn record_preprocessor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = Some(input.into());
            self
        }
        pub fn set_record_preprocessor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.record_preprocessor_source_uri = input;
            self
        }
        /// <p>An Amazon S3 URI to a script that is called after analysis has been performed.
        /// Applicable only for the built-in (first party) containers.</p>
        pub fn post_analytics_processor_source_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = Some(input.into());
            self
        }
        pub fn set_post_analytics_processor_source_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.post_analytics_processor_source_uri = input;
            self
        }
        pub fn environment(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.environment.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.environment = Some(hash_map);
            self
        }
        pub fn set_environment(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.environment = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
        pub fn build(self) -> crate::model::DataQualityAppSpecification {
            crate::model::DataQualityAppSpecification {
                image_uri: self.image_uri,
                container_entrypoint: self.container_entrypoint,
                container_arguments: self.container_arguments,
                record_preprocessor_source_uri: self.record_preprocessor_source_uri,
                post_analytics_processor_source_uri: self.post_analytics_processor_source_uri,
                environment: self.environment,
            }
        }
    }
}
impl DataQualityAppSpecification {
    /// Creates a new builder-style object to manufacture [`DataQualityAppSpecification`](crate::model::DataQualityAppSpecification)
    pub fn builder() -> crate::model::data_quality_app_specification::Builder {
        crate::model::data_quality_app_specification::Builder::default()
    }
}

/// <p>Configuration for monitoring constraints and monitoring statistics. These baseline
/// resources are compared against the results of the current job from the series of jobs
/// scheduled to collect data periodically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataQualityBaselineConfig {
    /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
    pub baselining_job_name: std::option::Option<std::string::String>,
    /// <p>The constraints resource for a monitoring job.</p>
    pub constraints_resource: std::option::Option<crate::model::MonitoringConstraintsResource>,
    /// <p>The statistics resource for a monitoring job.</p>
    pub statistics_resource: std::option::Option<crate::model::MonitoringStatisticsResource>,
}
impl std::fmt::Debug for DataQualityBaselineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataQualityBaselineConfig");
        formatter.field("baselining_job_name", &self.baselining_job_name);
        formatter.field("constraints_resource", &self.constraints_resource);
        formatter.field("statistics_resource", &self.statistics_resource);
        formatter.finish()
    }
}
/// See [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
pub mod data_quality_baseline_config {
    /// A builder for [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) baselining_job_name: std::option::Option<std::string::String>,
        pub(crate) constraints_resource:
            std::option::Option<crate::model::MonitoringConstraintsResource>,
        pub(crate) statistics_resource:
            std::option::Option<crate::model::MonitoringStatisticsResource>,
    }
    impl Builder {
        /// <p>The name of the job that performs baselining for the data quality monitoring job.</p>
        pub fn baselining_job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.baselining_job_name = Some(input.into());
            self
        }
        pub fn set_baselining_job_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.baselining_job_name = input;
            self
        }
        /// <p>The constraints resource for a monitoring job.</p>
        pub fn constraints_resource(
            mut self,
            input: crate::model::MonitoringConstraintsResource,
        ) -> Self {
            self.constraints_resource = Some(input);
            self
        }
        pub fn set_constraints_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringConstraintsResource>,
        ) -> Self {
            self.constraints_resource = input;
            self
        }
        /// <p>The statistics resource for a monitoring job.</p>
        pub fn statistics_resource(
            mut self,
            input: crate::model::MonitoringStatisticsResource,
        ) -> Self {
            self.statistics_resource = Some(input);
            self
        }
        pub fn set_statistics_resource(
            mut self,
            input: std::option::Option<crate::model::MonitoringStatisticsResource>,
        ) -> Self {
            self.statistics_resource = input;
            self
        }
        /// Consumes the builder and constructs a [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
        pub fn build(self) -> crate::model::DataQualityBaselineConfig {
            crate::model::DataQualityBaselineConfig {
                baselining_job_name: self.baselining_job_name,
                constraints_resource: self.constraints_resource,
                statistics_resource: self.statistics_resource,
            }
        }
    }
}
impl DataQualityBaselineConfig {
    /// Creates a new builder-style object to manufacture [`DataQualityBaselineConfig`](crate::model::DataQualityBaselineConfig)
    pub fn builder() -> crate::model::data_quality_baseline_config::Builder {
        crate::model::data_quality_baseline_config::Builder::default()
    }
}

/// <p>The <a>VpcConfig</a> configuration object that specifies the VPC that you
/// want the compilation jobs to connect to. For more information on
/// controlling access to your Amazon S3 buckets used for compilation job, see
/// <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/neo-vpc.html">Give Amazon SageMaker Compilation Jobs Access to Resources in Your Amazon VPC</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NeoVpcConfig {
    /// <p>The VPC security group IDs. IDs have the form of <code>sg-xxxxxxxx</code>.
    /// Specify the security groups for the VPC that is specified in the <code>Subnets</code> field.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the subnets in the VPC that you want to connect the
    /// compilation job to for accessing the model in Amazon S3.</p>
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for NeoVpcConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NeoVpcConfig");
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.field("subnets", &self.subnets);
        formatter.finish()
    }
}
/// See [`NeoVpcConfig`](crate::model::NeoVpcConfig)
pub mod neo_vpc_config {
    /// A builder for [`NeoVpcConfig`](crate::model::NeoVpcConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`NeoVpcConfig`](crate::model::NeoVpcConfig)
        pub fn build(self) -> crate::model::NeoVpcConfig {
            crate::model::NeoVpcConfig {
                security_group_ids: self.security_group_ids,
                subnets: self.subnets,
            }
        }
    }
}
impl NeoVpcConfig {
    /// Creates a new builder-style object to manufacture [`NeoVpcConfig`](crate::model::NeoVpcConfig)
    pub fn builder() -> crate::model::neo_vpc_config::Builder {
        crate::model::neo_vpc_config::Builder::default()
    }
}

/// <p>Contains information about the output location for the compiled model and the target
/// device that the model runs on. <code>TargetDevice</code> and <code>TargetPlatform</code>
/// are mutually exclusive, so you need to choose one between the two to specify your target
/// device or platform. If you cannot find your device you want to use from the
/// <code>TargetDevice</code> list, use <code>TargetPlatform</code> to describe the
/// platform of your edge device and <code>CompilerOptions</code> if there are specific
/// settings that are required or recommended to use for particular TargetPlatform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputConfig {
    /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For
    /// example, <code>s3://bucket-name/key-name-prefix</code>.</p>
    pub s3_output_location: std::option::Option<std::string::String>,
    /// <p>Identifies the target device or the machine learning instance that you want to run
    /// your model on after the compilation has completed. Alternatively, you can specify OS,
    /// architecture, and accelerator using <a>TargetPlatform</a> fields. It can be
    /// used instead of <code>TargetPlatform</code>.</p>
    pub target_device: std::option::Option<crate::model::TargetDevice>,
    /// <p>Contains information about a target platform that you want your model to run on, such
    /// as OS, architecture, and accelerators. It is an alternative of
    /// <code>TargetDevice</code>.</p>
    /// <p>The following examples show how to configure the <code>TargetPlatform</code> and
    /// <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
    /// <ul>
    /// <li>
    /// <p>Raspberry Pi 3 Model B+</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code>
    /// </p>
    /// <p>
    /// <code> "CompilerOptions": {'mattr': ['+neon']}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Jetson TX2</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator":
    /// "NVIDIA"},</code>
    /// </p>
    /// <p>
    /// <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1',
    /// 'cuda-ver': '10.0'}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>EC2 m5.2xlarge instance OS</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator":
    /// "NVIDIA"},</code>
    /// </p>
    /// <p>
    /// <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>RK3399</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator":
    /// "MALI"}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>ARMv7 phone (CPU)</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code>
    /// </p>
    /// <p>
    /// <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr':
    /// ['+neon']}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>ARMv8 phone (CPU)</p>
    /// <p>
    /// <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code>
    /// </p>
    /// <p>
    /// <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code>
    /// </p>
    /// </li>
    /// </ul>
    pub target_platform: std::option::Option<crate::model::TargetPlatform>,
    /// <p>Specifies additional parameters for compiler options in JSON format. The compiler
    /// options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators
    /// and highly recommended for CPU compilations. For any other cases, it is optional to
    /// specify <code>CompilerOptions.</code>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DTYPE</code>: Specifies the data type for the input. When compiling for
    /// <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch
    /// framework, provide the data type (dtype) of the model's input.
    /// <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified.
    /// Options for data type are:</p>
    /// <ul>
    /// <li>
    /// <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p>
    /// </li>
    /// <li>
    /// <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p>
    /// </li>
    /// </ul>
    /// <p> For example, <code>{"dtype" : "float32"}</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CPU</code>: Compilation for CPU supports the following compiler
    /// options.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu':
    /// 'skylake-avx512'}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon',
    /// '+vfpv4']}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARM</code>: Details of ARM CPU compilations.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NEON</code>: NEON is an implementation of the Advanced SIMD
    /// extension used in ARMv7 processors.</p>
    /// <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler
    /// options if compiling for ARM 32-bit platform with the NEON
    /// support.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following
    /// compiler options.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gpu_code</code>: Specifies the targeted architecture.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z.
    /// format.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cuda-ver</code>: Specifies the CUDA version in x.y
    /// format.</p>
    /// </li>
    /// </ul>
    /// <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver':
    /// '10.1'}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ANDROID</code>: Compilation for the Android OS supports the following
    /// compiler options:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ANDROID_PLATFORM</code>: Specifies the Android API levels.
    /// Available levels range from 21 to 29. For example,
    /// <code>{'ANDROID_PLATFORM': 28}</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler
    /// options if compiling for ARM 32-bit platform with NEON support.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options
    /// passed in as a JSON string. For example,
    /// <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>.
    /// </p>
    /// <p>For information about supported compiler options, see
    /// <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md">
    /// Neuron Compiler CLI</a>.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CoreML</code>: Compilation for the CoreML <a>OutputConfig$TargetDevice</a>
    /// supports the following compiler options:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>class_labels</code>: Specifies the classification labels file
    /// name inside input tar.gz file. For example,
    /// <code>{"class_labels": "imagenet_labels_1000.txt"}</code>.
    /// Labels inside the txt file should be separated by newlines.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following
    /// compiler options:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values
    /// are <code>"FP16"</code> and <code>"FP32"</code>. Default is
    /// <code>"FP32"</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel
    /// format. Defaults is TensorFlow's default signature def key.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>output_names</code>: Specifies a list of output tensor names for
    /// models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p>
    /// </li>
    /// </ul>
    /// <p>For example:
    /// <code>{"precision_mode": "FP32",  "output_names": ["output:0"]}</code>
    /// </p>
    /// </li>
    /// </ul>
    pub compiler_options: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption
    /// after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
    /// For more information, see
    /// <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption
    /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
    /// </p>    
    /// <p>The KmsKeyId can be any of the following formats: </p>
    /// <ul>
    /// <li>
    /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Key ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name: <code>alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name ARN:
    /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
    /// </p>
    /// </li>
    /// </ul>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputConfig");
        formatter.field("s3_output_location", &self.s3_output_location);
        formatter.field("target_device", &self.target_device);
        formatter.field("target_platform", &self.target_platform);
        formatter.field("compiler_options", &self.compiler_options);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`OutputConfig`](crate::model::OutputConfig)
pub mod output_config {
    /// A builder for [`OutputConfig`](crate::model::OutputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_output_location: std::option::Option<std::string::String>,
        pub(crate) target_device: std::option::Option<crate::model::TargetDevice>,
        pub(crate) target_platform: std::option::Option<crate::model::TargetPlatform>,
        pub(crate) compiler_options: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the S3 bucket where you want Amazon SageMaker to store the model artifacts. For
        /// example, <code>s3://bucket-name/key-name-prefix</code>.</p>
        pub fn s3_output_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_location = Some(input.into());
            self
        }
        pub fn set_s3_output_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_location = input;
            self
        }
        /// <p>Identifies the target device or the machine learning instance that you want to run
        /// your model on after the compilation has completed. Alternatively, you can specify OS,
        /// architecture, and accelerator using <a>TargetPlatform</a> fields. It can be
        /// used instead of <code>TargetPlatform</code>.</p>
        pub fn target_device(mut self, input: crate::model::TargetDevice) -> Self {
            self.target_device = Some(input);
            self
        }
        pub fn set_target_device(
            mut self,
            input: std::option::Option<crate::model::TargetDevice>,
        ) -> Self {
            self.target_device = input;
            self
        }
        /// <p>Contains information about a target platform that you want your model to run on, such
        /// as OS, architecture, and accelerators. It is an alternative of
        /// <code>TargetDevice</code>.</p>
        /// <p>The following examples show how to configure the <code>TargetPlatform</code> and
        /// <code>CompilerOptions</code> JSON strings for popular target platforms: </p>
        /// <ul>
        /// <li>
        /// <p>Raspberry Pi 3 Model B+</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM_EABIHF"},</code>
        /// </p>
        /// <p>
        /// <code> "CompilerOptions": {'mattr': ['+neon']}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Jetson TX2</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator":
        /// "NVIDIA"},</code>
        /// </p>
        /// <p>
        /// <code> "CompilerOptions": {'gpu-code': 'sm_62', 'trt-ver': '6.0.1',
        /// 'cuda-ver': '10.0'}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>EC2 m5.2xlarge instance OS</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "X86_64", "Accelerator":
        /// "NVIDIA"},</code>
        /// </p>
        /// <p>
        /// <code> "CompilerOptions": {'mcpu': 'skylake-avx512'}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>RK3399</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "LINUX", "Arch": "ARM64", "Accelerator":
        /// "MALI"}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>ARMv7 phone (CPU)</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM_EABI"},</code>
        /// </p>
        /// <p>
        /// <code> "CompilerOptions": {'ANDROID_PLATFORM': 25, 'mattr':
        /// ['+neon']}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>ARMv8 phone (CPU)</p>
        /// <p>
        /// <code>"TargetPlatform": {"Os": "ANDROID", "Arch": "ARM64"},</code>
        /// </p>
        /// <p>
        /// <code> "CompilerOptions": {'ANDROID_PLATFORM': 29}</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn target_platform(mut self, input: crate::model::TargetPlatform) -> Self {
            self.target_platform = Some(input);
            self
        }
        pub fn set_target_platform(
            mut self,
            input: std::option::Option<crate::model::TargetPlatform>,
        ) -> Self {
            self.target_platform = input;
            self
        }
        /// <p>Specifies additional parameters for compiler options in JSON format. The compiler
        /// options are <code>TargetPlatform</code> specific. It is required for NVIDIA accelerators
        /// and highly recommended for CPU compilations. For any other cases, it is optional to
        /// specify <code>CompilerOptions.</code>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DTYPE</code>: Specifies the data type for the input. When compiling for
        /// <code>ml_*</code> (except for <code>ml_inf</code>) instances using PyTorch
        /// framework, provide the data type (dtype) of the model's input.
        /// <code>"float32"</code> is used if <code>"DTYPE"</code> is not specified.
        /// Options for data type are:</p>
        /// <ul>
        /// <li>
        /// <p>float32: Use either <code>"float"</code> or <code>"float32"</code>.</p>
        /// </li>
        /// <li>
        /// <p>int64: Use either <code>"int64"</code> or <code>"long"</code>.</p>
        /// </li>
        /// </ul>
        /// <p> For example, <code>{"dtype" : "float32"}</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CPU</code>: Compilation for CPU supports the following compiler
        /// options.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>mcpu</code>: CPU micro-architecture. For example, <code>{'mcpu':
        /// 'skylake-avx512'}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>mattr</code>: CPU flags. For example, <code>{'mattr': ['+neon',
        /// '+vfpv4']}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARM</code>: Details of ARM CPU compilations.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NEON</code>: NEON is an implementation of the Advanced SIMD
        /// extension used in ARMv7 processors.</p>
        /// <p>For example, add <code>{'mattr': ['+neon']}</code> to the compiler
        /// options if compiling for ARM 32-bit platform with the NEON
        /// support.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NVIDIA</code>: Compilation for NVIDIA GPU supports the following
        /// compiler options.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gpu_code</code>: Specifies the targeted architecture.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>trt-ver</code>: Specifies the TensorRT versions in x.y.z.
        /// format.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cuda-ver</code>: Specifies the CUDA version in x.y
        /// format.</p>
        /// </li>
        /// </ul>
        /// <p>For example, <code>{'gpu-code': 'sm_72', 'trt-ver': '6.0.1', 'cuda-ver':
        /// '10.1'}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ANDROID</code>: Compilation for the Android OS supports the following
        /// compiler options:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ANDROID_PLATFORM</code>: Specifies the Android API levels.
        /// Available levels range from 21 to 29. For example,
        /// <code>{'ANDROID_PLATFORM': 28}</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>mattr</code>: Add <code>{'mattr': ['+neon']}</code> to compiler
        /// options if compiling for ARM 32-bit platform with NEON support.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INFERENTIA</code>: Compilation for target ml_inf1 uses compiler options
        /// passed in as a JSON string. For example,
        /// <code>"CompilerOptions": "\"--verbose 1 --num-neuroncores 2 -O2\""</code>.
        /// </p>
        /// <p>For information about supported compiler options, see
        /// <a href="https://github.com/aws/aws-neuron-sdk/blob/master/docs/neuron-cc/command-line-reference.md">
        /// Neuron Compiler CLI</a>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CoreML</code>: Compilation for the CoreML <a>OutputConfig$TargetDevice</a>
        /// supports the following compiler options:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>class_labels</code>: Specifies the classification labels file
        /// name inside input tar.gz file. For example,
        /// <code>{"class_labels": "imagenet_labels_1000.txt"}</code>.
        /// Labels inside the txt file should be separated by newlines.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EIA</code>: Compilation for the Elastic Inference Accelerator supports the following
        /// compiler options:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>precision_mode</code>: Specifies the precision of compiled artifacts. Supported values
        /// are <code>"FP16"</code> and <code>"FP32"</code>. Default is
        /// <code>"FP32"</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>signature_def_key</code>: Specifies the signature to use for models in SavedModel
        /// format. Defaults is TensorFlow's default signature def key.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>output_names</code>: Specifies a list of output tensor names for
        /// models in FrozenGraph format. Set at most one API field, either: <code>signature_def_key</code> or <code>output_names</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For example:
        /// <code>{"precision_mode": "FP32",  "output_names": ["output:0"]}</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn compiler_options(mut self, input: impl Into<std::string::String>) -> Self {
            self.compiler_options = Some(input.into());
            self
        }
        pub fn set_compiler_options(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compiler_options = input;
            self
        }
        /// <p>The Amazon Web Services Key Management Service key (Amazon Web Services KMS) that Amazon SageMaker uses to encrypt your output models with Amazon S3 server-side encryption
        /// after compilation job. If you don't provide a KMS key ID, Amazon SageMaker uses the default KMS key for Amazon S3 for your role's account.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingKMSEncryption.html">KMS-Managed Encryption
        /// Keys</a> in the <i>Amazon Simple Storage Service Developer Guide.</i>
        /// </p>    
        /// <p>The KmsKeyId can be any of the following formats: </p>
        /// <ul>
        /// <li>
        /// <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Key ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name: <code>alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name ARN:
        /// <code>arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputConfig`](crate::model::OutputConfig)
        pub fn build(self) -> crate::model::OutputConfig {
            crate::model::OutputConfig {
                s3_output_location: self.s3_output_location,
                target_device: self.target_device,
                target_platform: self.target_platform,
                compiler_options: self.compiler_options,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl OutputConfig {
    /// Creates a new builder-style object to manufacture [`OutputConfig`](crate::model::OutputConfig)
    pub fn builder() -> crate::model::output_config::Builder {
        crate::model::output_config::Builder::default()
    }
}

/// <p>Contains information about a target platform that you want your model to run on, such
/// as OS, architecture, and accelerators. It is an alternative of
/// <code>TargetDevice</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetPlatform {
    /// <p>Specifies a target platform OS.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>LINUX</code>: Linux-based operating systems.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ANDROID</code>: Android operating systems. Android API level can be
    /// specified using the <code>ANDROID_PLATFORM</code> compiler option. For example,
    /// <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code>
    /// </p>
    /// </li>
    /// </ul>
    pub os: std::option::Option<crate::model::TargetPlatformOs>,
    /// <p>Specifies a target platform architecture.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>X86_64</code>: 64-bit version of the x86 instruction set.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>X86</code>: 32-bit version of the x86 instruction set.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARM64</code>: ARMv8 64-bit CPU.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM
    /// platform.</p>
    /// </li>
    /// </ul>
    pub arch: std::option::Option<crate::model::TargetPlatformArch>,
    /// <p>Specifies a target platform accelerator (optional).</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires
    /// <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler
    /// options</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MALI</code>: ARM Mali graphics processor</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p>
    /// </li>
    /// </ul>
    pub accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
}
impl std::fmt::Debug for TargetPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetPlatform");
        formatter.field("os", &self.os);
        formatter.field("arch", &self.arch);
        formatter.field("accelerator", &self.accelerator);
        formatter.finish()
    }
}
/// See [`TargetPlatform`](crate::model::TargetPlatform)
pub mod target_platform {
    /// A builder for [`TargetPlatform`](crate::model::TargetPlatform)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) os: std::option::Option<crate::model::TargetPlatformOs>,
        pub(crate) arch: std::option::Option<crate::model::TargetPlatformArch>,
        pub(crate) accelerator: std::option::Option<crate::model::TargetPlatformAccelerator>,
    }
    impl Builder {
        /// <p>Specifies a target platform OS.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LINUX</code>: Linux-based operating systems.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ANDROID</code>: Android operating systems. Android API level can be
        /// specified using the <code>ANDROID_PLATFORM</code> compiler option. For example,
        /// <code>"CompilerOptions": {'ANDROID_PLATFORM': 28}</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn os(mut self, input: crate::model::TargetPlatformOs) -> Self {
            self.os = Some(input);
            self
        }
        pub fn set_os(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformOs>,
        ) -> Self {
            self.os = input;
            self
        }
        /// <p>Specifies a target platform architecture.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>X86_64</code>: 64-bit version of the x86 instruction set.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>X86</code>: 32-bit version of the x86 instruction set.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARM64</code>: ARMv8 64-bit CPU.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARM_EABIHF</code>: ARMv7 32-bit, Hard Float.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARM_EABI</code>: ARMv7 32-bit, Soft Float. Used by Android 32-bit ARM
        /// platform.</p>
        /// </li>
        /// </ul>
        pub fn arch(mut self, input: crate::model::TargetPlatformArch) -> Self {
            self.arch = Some(input);
            self
        }
        pub fn set_arch(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformArch>,
        ) -> Self {
            self.arch = input;
            self
        }
        /// <p>Specifies a target platform accelerator (optional).</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NVIDIA</code>: Nvidia graphics processing unit. It also requires
        /// <code>gpu-code</code>, <code>trt-ver</code>, <code>cuda-ver</code> compiler
        /// options</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MALI</code>: ARM Mali graphics processor</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INTEL_GRAPHICS</code>: Integrated Intel graphics</p>
        /// </li>
        /// </ul>
        pub fn accelerator(mut self, input: crate::model::TargetPlatformAccelerator) -> Self {
            self.accelerator = Some(input);
            self
        }
        pub fn set_accelerator(
            mut self,
            input: std::option::Option<crate::model::TargetPlatformAccelerator>,
        ) -> Self {
            self.accelerator = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetPlatform`](crate::model::TargetPlatform)
        pub fn build(self) -> crate::model::TargetPlatform {
            crate::model::TargetPlatform {
                os: self.os,
                arch: self.arch,
                accelerator: self.accelerator,
            }
        }
    }
}
impl TargetPlatform {
    /// Creates a new builder-style object to manufacture [`TargetPlatform`](crate::model::TargetPlatform)
    pub fn builder() -> crate::model::target_platform::Builder {
        crate::model::target_platform::Builder::default()
    }
}

/// <p>Contains information about the location of input model artifacts, the name and
/// shape
/// of the expected data inputs, and the framework in which the model was trained.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputConfig {
    /// <p>The S3 path where the model artifacts, which result from model training, are stored.
    /// This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>Specifies the name and shape of the expected data inputs for your trained model with a
    /// JSON dictionary form. The data inputs are <a>InputConfig$Framework</a>
    /// specific. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of
    /// the expected data inputs using a dictionary format for your trained model. The
    /// dictionary formats required for the console and CLI are different.</p>
    /// <ul>
    /// <li>
    /// <p>Examples for one input:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console,
    /// <code>{"input":[1,1024,1024,3]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI,
    /// <code>{\"input\":[1,1024,1024,3]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Examples for two inputs:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console, <code>{"data1": [1,28,28,1],
    /// "data2":[1,28,28,1]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI, <code>{\"data1\": [1,28,28,1],
    /// \"data2\":[1,28,28,1]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KERAS</code>: You must specify the name and shape (NCHW format) of
    /// expected data inputs using a dictionary format for your trained model. Note that
    /// while Keras model artifacts should be uploaded in NHWC (channel-last) format,
    /// <code>DataInputConfig</code> should be specified in NCHW (channel-first)
    /// format. The dictionary formats required for the console and CLI are
    /// different.</p>
    /// <ul>
    /// <li>
    /// <p>Examples for one input:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console,
    /// <code>{"input_1":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI,
    /// <code>{\"input_1\":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Examples for two inputs:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console, <code>{"input_1": [1,3,224,224],
    /// "input_2":[1,3,224,224]} </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI, <code>{\"input_1\": [1,3,224,224],
    /// \"input_2\":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of
    /// the expected data inputs in order using a dictionary format for your trained
    /// model. The dictionary formats required for the console and CLI are
    /// different.</p>
    /// <ul>
    /// <li>
    /// <p>Examples for one input:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console,
    /// <code>{"data":[1,3,1024,1024]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI,
    /// <code>{\"data\":[1,3,1024,1024]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Examples for two inputs:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console, <code>{"var1": [1,1,28,28],
    /// "var2":[1,1,28,28]} </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI, <code>{\"var1\": [1,1,28,28],
    /// \"var2\":[1,1,28,28]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PyTorch</code>: You can either specify the name and shape (NCHW format)
    /// of expected data inputs in order using a dictionary format for your trained
    /// model or you can specify the shape only using a list format. The dictionary
    /// formats required for the console and CLI are different. The list formats for the
    /// console and CLI are the same.</p>
    /// <ul>
    /// <li>
    /// <p>Examples for one input in dictionary format:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console,
    /// <code>{"input0":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI,
    /// <code>{\"input0\":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Example for one input in list format:
    /// <code>[[1,3,224,224]]</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Examples for two inputs in dictionary format:</p>
    /// <ul>
    /// <li>
    /// <p>If using the console, <code>{"input0":[1,3,224,224],
    /// "input1":[1,3,224,224]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>If using the CLI, <code>{\"input0\":[1,3,224,224],
    /// \"input1\":[1,3,224,224]} </code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Example for two inputs in list format: <code>[[1,3,224,224],
    /// [1,3,224,224]]</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>XGBOOST</code>: input data name and shape are not needed.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code>
    /// <a>OutputConfig$TargetDevice</a> (ML Model format):</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>.
    /// In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
    /// <ul>
    /// <li>
    /// <p>Range Dimension. You can use the Range Dimension feature if you know the input shape
    /// will be within some specific interval in that dimension,
    /// for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Enumerated shapes. Sometimes, the models are trained to work only on a select
    /// set of inputs. You can enumerate all supported input shapes,
    /// for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>default_shape</code>: Default input shape. You can set a default shape during
    /// conversion for both Range Dimension and Enumerated Shapes. For example
    /// <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>.
    /// By default, the converter generates an ML Model with inputs of type Tensor (MultiArray).
    /// User can set input type to be Image. Image input type requires additional input parameters
    /// such as <code>bias</code> and <code>scale</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p>
    /// </li>
    /// </ul>
    /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using
    /// <a>OutputConfig$CompilerOptions</a>. CoreML converter supports Tensorflow and PyTorch models.
    /// CoreML conversion examples:</p>
    /// <ul>
    /// <li>
    /// <p>Tensor type input:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape":
    /// [1,224,224,3]}}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Tensor type input without input name (PyTorch):</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape":
    /// [1,3,224,224]}]</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Image type input:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape":
    /// [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>Image type input without input name (PyTorch):</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape":
    /// [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for
    /// <code>ml_eia2</code>
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
    /// <ul>
    /// <li>
    /// <p>For TensorFlow models saved in the SavedModel format, specify the input names
    /// from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>.  
    /// Specify the <code>signature_def_key</code> in
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions">
    /// <code>OutputConfig:CompilerOptions</code>
    /// </a> if
    /// the model does not use TensorFlow's default signature def key. For example:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes  
    /// in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in
    /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions">
    /// <code>OutputConfig:CompilerOptions</code>
    /// </a>.
    /// For example:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    pub data_input_config: std::option::Option<std::string::String>,
    /// <p>Identifies the framework in which the model was trained. For example:
    /// TENSORFLOW.</p>
    pub framework: std::option::Option<crate::model::Framework>,
    /// <p>Specifies the framework version to use.</p>
    /// <p>This API field is only supported for PyTorch framework versions <code>1.4</code>,
    /// <code>1.5</code>, and <code>1.6</code> for
    /// cloud instance target devices: <code>ml_c4</code>, <code>ml_c5</code>, <code>ml_m4</code>,
    /// <code>ml_m5</code>, <code>ml_p2</code>, <code>ml_p3</code>, and <code>ml_g4dn</code>.</p>
    pub framework_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputConfig");
        formatter.field("s3_uri", &self.s3_uri);
        formatter.field("data_input_config", &self.data_input_config);
        formatter.field("framework", &self.framework);
        formatter.field("framework_version", &self.framework_version);
        formatter.finish()
    }
}
/// See [`InputConfig`](crate::model::InputConfig)
pub mod input_config {
    /// A builder for [`InputConfig`](crate::model::InputConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) data_input_config: std::option::Option<std::string::String>,
        pub(crate) framework: std::option::Option<crate::model::Framework>,
        pub(crate) framework_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 path where the model artifacts, which result from model training, are stored.
        /// This path must point to a single gzip compressed tar archive (.tar.gz suffix).</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>Specifies the name and shape of the expected data inputs for your trained model with a
        /// JSON dictionary form. The data inputs are <a>InputConfig$Framework</a>
        /// specific. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TensorFlow</code>: You must specify the name and shape (NHWC format) of
        /// the expected data inputs using a dictionary format for your trained model. The
        /// dictionary formats required for the console and CLI are different.</p>
        /// <ul>
        /// <li>
        /// <p>Examples for one input:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console,
        /// <code>{"input":[1,1024,1024,3]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI,
        /// <code>{\"input\":[1,1024,1024,3]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Examples for two inputs:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console, <code>{"data1": [1,28,28,1],
        /// "data2":[1,28,28,1]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI, <code>{\"data1\": [1,28,28,1],
        /// \"data2\":[1,28,28,1]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KERAS</code>: You must specify the name and shape (NCHW format) of
        /// expected data inputs using a dictionary format for your trained model. Note that
        /// while Keras model artifacts should be uploaded in NHWC (channel-last) format,
        /// <code>DataInputConfig</code> should be specified in NCHW (channel-first)
        /// format. The dictionary formats required for the console and CLI are
        /// different.</p>
        /// <ul>
        /// <li>
        /// <p>Examples for one input:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console,
        /// <code>{"input_1":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI,
        /// <code>{\"input_1\":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Examples for two inputs:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console, <code>{"input_1": [1,3,224,224],
        /// "input_2":[1,3,224,224]} </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI, <code>{\"input_1\": [1,3,224,224],
        /// \"input_2\":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MXNET/ONNX/DARKNET</code>: You must specify the name and shape (NCHW format) of
        /// the expected data inputs in order using a dictionary format for your trained
        /// model. The dictionary formats required for the console and CLI are
        /// different.</p>
        /// <ul>
        /// <li>
        /// <p>Examples for one input:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console,
        /// <code>{"data":[1,3,1024,1024]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI,
        /// <code>{\"data\":[1,3,1024,1024]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Examples for two inputs:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console, <code>{"var1": [1,1,28,28],
        /// "var2":[1,1,28,28]} </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI, <code>{\"var1\": [1,1,28,28],
        /// \"var2\":[1,1,28,28]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PyTorch</code>: You can either specify the name and shape (NCHW format)
        /// of expected data inputs in order using a dictionary format for your trained
        /// model or you can specify the shape only using a list format. The dictionary
        /// formats required for the console and CLI are different. The list formats for the
        /// console and CLI are the same.</p>
        /// <ul>
        /// <li>
        /// <p>Examples for one input in dictionary format:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console,
        /// <code>{"input0":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI,
        /// <code>{\"input0\":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Example for one input in list format:
        /// <code>[[1,3,224,224]]</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Examples for two inputs in dictionary format:</p>
        /// <ul>
        /// <li>
        /// <p>If using the console, <code>{"input0":[1,3,224,224],
        /// "input1":[1,3,224,224]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>If using the CLI, <code>{\"input0\":[1,3,224,224],
        /// \"input1\":[1,3,224,224]} </code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Example for two inputs in list format: <code>[[1,3,224,224],
        /// [1,3,224,224]]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>XGBOOST</code>: input data name and shape are not needed.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>DataInputConfig</code> supports the following parameters for <code>CoreML</code>
        /// <a>OutputConfig$TargetDevice</a> (ML Model format):</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>shape</code>: Input shape, for example <code>{"input_1": {"shape": [1,224,224,3]}}</code>.
        /// In addition to static input shapes, CoreML converter supports Flexible input shapes:</p>
        /// <ul>
        /// <li>
        /// <p>Range Dimension. You can use the Range Dimension feature if you know the input shape
        /// will be within some specific interval in that dimension,
        /// for example: <code>{"input_1": {"shape": ["1..10", 224, 224, 3]}}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Enumerated shapes. Sometimes, the models are trained to work only on a select
        /// set of inputs. You can enumerate all supported input shapes,
        /// for example: <code>{"input_1": {"shape": [[1, 224, 224, 3], [1, 160, 160, 3]]}}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>default_shape</code>: Default input shape. You can set a default shape during
        /// conversion for both Range Dimension and Enumerated Shapes. For example
        /// <code>{"input_1": {"shape": ["1..10", 224, 224, 3], "default_shape": [1, 224, 224, 3]}}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code>: Input type. Allowed values: <code>Image</code> and <code>Tensor</code>.
        /// By default, the converter generates an ML Model with inputs of type Tensor (MultiArray).
        /// User can set input type to be Image. Image input type requires additional input parameters
        /// such as <code>bias</code> and <code>scale</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>bias</code>: If the input type is an Image, you need to provide the bias vector.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>scale</code>: If the input type is an Image, you need to provide a scale factor.</p>
        /// </li>
        /// </ul>
        /// <p>CoreML <code>ClassifierConfig</code> parameters can be specified using
        /// <a>OutputConfig$CompilerOptions</a>. CoreML converter supports Tensorflow and PyTorch models.
        /// CoreML conversion examples:</p>
        /// <ul>
        /// <li>
        /// <p>Tensor type input:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape":
        /// [1,224,224,3]}}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Tensor type input without input name (PyTorch):</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape":
        /// [1,3,224,224]}]</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Image type input:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": {"input_1": {"shape": [[1,224,224,3], [1,160,160,3]], "default_shape":
        /// [1,224,224,3], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Image type input without input name (PyTorch):</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": [{"shape": [[1,3,224,224], [1,3,160,160]], "default_shape":
        /// [1,3,224,224], "type": "Image", "bias": [-1,-1,-1], "scale": 0.007843137255}]</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"CompilerOptions": {"class_labels": "imagenet_labels_1000.txt"}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        /// <p>Depending on the model format, <code>DataInputConfig</code> requires the following parameters for
        /// <code>ml_eia2</code>
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-TargetDevice">OutputConfig:TargetDevice</a>.</p>
        /// <ul>
        /// <li>
        /// <p>For TensorFlow models saved in the SavedModel format, specify the input names
        /// from <code>signature_def_key</code> and the input model shapes for <code>DataInputConfig</code>.  
        /// Specify the <code>signature_def_key</code> in
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions">
        /// <code>OutputConfig:CompilerOptions</code>
        /// </a> if
        /// the model does not use TensorFlow's default signature def key. For example:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": {"inputs": [1, 224, 224, 3]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"CompilerOptions": {"signature_def_key": "serving_custom"}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>For TensorFlow models saved as a frozen graph, specify the input tensor names and shapes  
        /// in <code>DataInputConfig</code> and the output tensor names for <code>output_names</code> in
        /// <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_OutputConfig.html#sagemaker-Type-OutputConfig-CompilerOptions">
        /// <code>OutputConfig:CompilerOptions</code>
        /// </a>.
        /// For example:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>"DataInputConfig": {"input_tensor:0": [1, 224, 224, 3]}</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>"CompilerOptions": {"output_names": ["output_tensor:0"]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn data_input_config(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_input_config = Some(input.into());
            self
        }
        pub fn set_data_input_config(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_input_config = input;
            self
        }
        /// <p>Identifies the framework in which the model was trained. For example:
        /// TENSORFLOW.</p>
        pub fn framework(mut self, input: crate::model::Framework) -> Self {
            self.framework = Some(input);
            self
        }
        pub fn set_framework(
            mut self,
            input: std::option::Option<crate::model::Framework>,
        ) -> Self {
            self.framework = input;
            self
        }
        /// <p>Specifies the framework version to use.</p>
        /// <p>This API field is only supported for PyTorch framework versions <code>1.4</code>,
        /// <code>1.5</code>, and <code>1.6</code> for
        /// cloud instance target devices: <code>ml_c4</code>, <code>ml_c5</code>, <code>ml_m4</code>,
        /// <code>ml_m5</code>, <code>ml_p2</code>, <code>ml_p3</code>, and <code>ml_g4dn</code>.</p>
        pub fn framework_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_version = Some(input.into());
            self
        }
        pub fn set_framework_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.framework_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InputConfig`](crate::model::InputConfig)
        pub fn build(self) -> crate::model::InputConfig {
            crate::model::InputConfig {
                s3_uri: self.s3_uri,
                data_input_config: self.data_input_config,
                framework: self.framework,
                framework_version: self.framework_version,
            }
        }
    }
}
impl InputConfig {
    /// Creates a new builder-style object to manufacture [`InputConfig`](crate::model::InputConfig)
    pub fn builder() -> crate::model::input_config::Builder {
        crate::model::input_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Framework {
    Darknet,
    Keras,
    Mxnet,
    Onnx,
    Pytorch,
    Sklearn,
    Tensorflow,
    Tflite,
    Xgboost,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Framework {
    fn from(s: &str) -> Self {
        match s {
            "DARKNET" => Framework::Darknet,
            "KERAS" => Framework::Keras,
            "MXNET" => Framework::Mxnet,
            "ONNX" => Framework::Onnx,
            "PYTORCH" => Framework::Pytorch,
            "SKLEARN" => Framework::Sklearn,
            "TENSORFLOW" => Framework::Tensorflow,
            "TFLITE" => Framework::Tflite,
            "XGBOOST" => Framework::Xgboost,
            other => Framework::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Framework {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Framework::from(s))
    }
}
impl Framework {
    pub fn as_str(&self) -> &str {
        match self {
            Framework::Darknet => "DARKNET",
            Framework::Keras => "KERAS",
            Framework::Mxnet => "MXNET",
            Framework::Onnx => "ONNX",
            Framework::Pytorch => "PYTORCH",
            Framework::Sklearn => "SKLEARN",
            Framework::Tensorflow => "TENSORFLOW",
            Framework::Tflite => "TFLITE",
            Framework::Xgboost => "XGBOOST",
            Framework::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "DARKNET",
            "KERAS",
            "MXNET",
            "ONNX",
            "PYTORCH",
            "SKLEARN",
            "TENSORFLOW",
            "TFLITE",
            "XGBOOST",
        ]
    }
}
impl AsRef<str> for Framework {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information to verify the integrity of stored model artifacts. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDigests {
    /// <p>Provides a hash value that uniquely identifies the stored model
    /// artifacts.</p>
    pub artifact_digest: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelDigests {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDigests");
        formatter.field("artifact_digest", &self.artifact_digest);
        formatter.finish()
    }
}
/// See [`ModelDigests`](crate::model::ModelDigests)
pub mod model_digests {
    /// A builder for [`ModelDigests`](crate::model::ModelDigests)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) artifact_digest: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides a hash value that uniquely identifies the stored model
        /// artifacts.</p>
        pub fn artifact_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_digest = Some(input.into());
            self
        }
        pub fn set_artifact_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_digest = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDigests`](crate::model::ModelDigests)
        pub fn build(self) -> crate::model::ModelDigests {
            crate::model::ModelDigests {
                artifact_digest: self.artifact_digest,
            }
        }
    }
}
impl ModelDigests {
    /// Creates a new builder-style object to manufacture [`ModelDigests`](crate::model::ModelDigests)
    pub fn builder() -> crate::model::model_digests::Builder {
        crate::model::model_digests::Builder::default()
    }
}

/// <p>Provides information about the endpoint of the model deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDeployResult {
    /// <p>The name of the endpoint to which the model has been deployed.</p>
    /// <note>
    /// <p>If model deployment fails, this field is omitted from the response.</p>
    /// </note>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelDeployResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDeployResult");
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`ModelDeployResult`](crate::model::ModelDeployResult)
pub mod model_deploy_result {
    /// A builder for [`ModelDeployResult`](crate::model::ModelDeployResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the endpoint to which the model has been deployed.</p>
        /// <note>
        /// <p>If model deployment fails, this field is omitted from the response.</p>
        /// </note>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDeployResult`](crate::model::ModelDeployResult)
        pub fn build(self) -> crate::model::ModelDeployResult {
            crate::model::ModelDeployResult {
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl ModelDeployResult {
    /// Creates a new builder-style object to manufacture [`ModelDeployResult`](crate::model::ModelDeployResult)
    pub fn builder() -> crate::model::model_deploy_result::Builder {
        crate::model::model_deploy_result::Builder::default()
    }
}

/// <p>Specifies how to generate the endpoint name for an automatic one-click Autopilot model
/// deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModelDeployConfig {
    /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click
    /// Autopilot model deployment; set to <code>False</code> otherwise. The default value is
    /// <code>False</code>.</p>
    /// <note>
    /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify
    /// the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
    /// </note>
    pub auto_generate_endpoint_name: bool,
    /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the
    /// endpoint name is not generated automatically.</p>
    /// <note>
    /// <p>Specify the <code>EndpointName</code> if and only if you set
    /// <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error
    /// is thrown.</p>
    /// </note>
    pub endpoint_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModelDeployConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModelDeployConfig");
        formatter.field(
            "auto_generate_endpoint_name",
            &self.auto_generate_endpoint_name,
        );
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.finish()
    }
}
/// See [`ModelDeployConfig`](crate::model::ModelDeployConfig)
pub mod model_deploy_config {
    /// A builder for [`ModelDeployConfig`](crate::model::ModelDeployConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_generate_endpoint_name: std::option::Option<bool>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Set to <code>True</code> to automatically generate an endpoint name for a one-click
        /// Autopilot model deployment; set to <code>False</code> otherwise. The default value is
        /// <code>False</code>.</p>
        /// <note>
        /// <p>If you set <code>AutoGenerateEndpointName</code> to <code>True</code>, do not specify
        /// the <code>EndpointName</code>; otherwise a 400 error is thrown.</p>
        /// </note>
        pub fn auto_generate_endpoint_name(mut self, input: bool) -> Self {
            self.auto_generate_endpoint_name = Some(input);
            self
        }
        pub fn set_auto_generate_endpoint_name(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_generate_endpoint_name = input;
            self
        }
        /// <p>Specifies the endpoint name to use for a one-click Autopilot model deployment if the
        /// endpoint name is not generated automatically.</p>
        /// <note>
        /// <p>Specify the <code>EndpointName</code> if and only if you set
        /// <code>AutoGenerateEndpointName</code> to <code>False</code>; otherwise a 400 error
        /// is thrown.</p>
        /// </note>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelDeployConfig`](crate::model::ModelDeployConfig)
        pub fn build(self) -> crate::model::ModelDeployConfig {
            crate::model::ModelDeployConfig {
                auto_generate_endpoint_name: self.auto_generate_endpoint_name.unwrap_or_default(),
                endpoint_name: self.endpoint_name,
            }
        }
    }
}
impl ModelDeployConfig {
    /// Creates a new builder-style object to manufacture [`ModelDeployConfig`](crate::model::ModelDeployConfig)
    pub fn builder() -> crate::model::model_deploy_config::Builder {
        crate::model::model_deploy_config::Builder::default()
    }
}

/// <p>The resolved attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResolvedAttributes {
    /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
    pub auto_ml_job_objective: std::option::Option<crate::model::AutoMlJobObjective>,
    /// <p>The problem type.</p>
    pub problem_type: std::option::Option<crate::model::ProblemType>,
    /// <p>How long a job is allowed to run, or how many candidates a job is allowed to
    /// generate.</p>
    pub completion_criteria: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
}
impl std::fmt::Debug for ResolvedAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResolvedAttributes");
        formatter.field("auto_ml_job_objective", &self.auto_ml_job_objective);
        formatter.field("problem_type", &self.problem_type);
        formatter.field("completion_criteria", &self.completion_criteria);
        formatter.finish()
    }
}
/// See [`ResolvedAttributes`](crate::model::ResolvedAttributes)
pub mod resolved_attributes {
    /// A builder for [`ResolvedAttributes`](crate::model::ResolvedAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_ml_job_objective: std::option::Option<crate::model::AutoMlJobObjective>,
        pub(crate) problem_type: std::option::Option<crate::model::ProblemType>,
        pub(crate) completion_criteria:
            std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
    }
    impl Builder {
        /// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
        pub fn auto_ml_job_objective(mut self, input: crate::model::AutoMlJobObjective) -> Self {
            self.auto_ml_job_objective = Some(input);
            self
        }
        pub fn set_auto_ml_job_objective(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobObjective>,
        ) -> Self {
            self.auto_ml_job_objective = input;
            self
        }
        /// <p>The problem type.</p>
        pub fn problem_type(mut self, input: crate::model::ProblemType) -> Self {
            self.problem_type = Some(input);
            self
        }
        pub fn set_problem_type(
            mut self,
            input: std::option::Option<crate::model::ProblemType>,
        ) -> Self {
            self.problem_type = input;
            self
        }
        /// <p>How long a job is allowed to run, or how many candidates a job is allowed to
        /// generate.</p>
        pub fn completion_criteria(
            mut self,
            input: crate::model::AutoMlJobCompletionCriteria,
        ) -> Self {
            self.completion_criteria = Some(input);
            self
        }
        pub fn set_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        ) -> Self {
            self.completion_criteria = input;
            self
        }
        /// Consumes the builder and constructs a [`ResolvedAttributes`](crate::model::ResolvedAttributes)
        pub fn build(self) -> crate::model::ResolvedAttributes {
            crate::model::ResolvedAttributes {
                auto_ml_job_objective: self.auto_ml_job_objective,
                problem_type: self.problem_type,
                completion_criteria: self.completion_criteria,
            }
        }
    }
}
impl ResolvedAttributes {
    /// Creates a new builder-style object to manufacture [`ResolvedAttributes`](crate::model::ResolvedAttributes)
    pub fn builder() -> crate::model::resolved_attributes::Builder {
        crate::model::resolved_attributes::Builder::default()
    }
}

/// <p>How long a job is allowed to run, or how many candidates a job is allowed to
/// generate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobCompletionCriteria {
    /// <p>The maximum number of times a training job is allowed to run.</p>
    pub max_candidates: std::option::Option<i32>,
    /// <p>The maximum time, in seconds, a training job is allowed to run as part of an AutoML job.</p>
    pub max_runtime_per_training_job_in_seconds: std::option::Option<i32>,
    /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
    pub max_auto_ml_job_runtime_in_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for AutoMlJobCompletionCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobCompletionCriteria");
        formatter.field("max_candidates", &self.max_candidates);
        formatter.field(
            "max_runtime_per_training_job_in_seconds",
            &self.max_runtime_per_training_job_in_seconds,
        );
        formatter.field(
            "max_auto_ml_job_runtime_in_seconds",
            &self.max_auto_ml_job_runtime_in_seconds,
        );
        formatter.finish()
    }
}
/// See [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
pub mod auto_ml_job_completion_criteria {
    /// A builder for [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_candidates: std::option::Option<i32>,
        pub(crate) max_runtime_per_training_job_in_seconds: std::option::Option<i32>,
        pub(crate) max_auto_ml_job_runtime_in_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of times a training job is allowed to run.</p>
        pub fn max_candidates(mut self, input: i32) -> Self {
            self.max_candidates = Some(input);
            self
        }
        pub fn set_max_candidates(mut self, input: std::option::Option<i32>) -> Self {
            self.max_candidates = input;
            self
        }
        /// <p>The maximum time, in seconds, a training job is allowed to run as part of an AutoML job.</p>
        pub fn max_runtime_per_training_job_in_seconds(mut self, input: i32) -> Self {
            self.max_runtime_per_training_job_in_seconds = Some(input);
            self
        }
        pub fn set_max_runtime_per_training_job_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_runtime_per_training_job_in_seconds = input;
            self
        }
        /// <p>The maximum runtime, in seconds, an AutoML job has to complete.</p>
        pub fn max_auto_ml_job_runtime_in_seconds(mut self, input: i32) -> Self {
            self.max_auto_ml_job_runtime_in_seconds = Some(input);
            self
        }
        pub fn set_max_auto_ml_job_runtime_in_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_auto_ml_job_runtime_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
        pub fn build(self) -> crate::model::AutoMlJobCompletionCriteria {
            crate::model::AutoMlJobCompletionCriteria {
                max_candidates: self.max_candidates,
                max_runtime_per_training_job_in_seconds: self
                    .max_runtime_per_training_job_in_seconds,
                max_auto_ml_job_runtime_in_seconds: self.max_auto_ml_job_runtime_in_seconds,
            }
        }
    }
}
impl AutoMlJobCompletionCriteria {
    /// Creates a new builder-style object to manufacture [`AutoMlJobCompletionCriteria`](crate::model::AutoMlJobCompletionCriteria)
    pub fn builder() -> crate::model::auto_ml_job_completion_criteria::Builder {
        crate::model::auto_ml_job_completion_criteria::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProblemType {
    BinaryClassification,
    MulticlassClassification,
    Regression,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProblemType {
    fn from(s: &str) -> Self {
        match s {
            "BinaryClassification" => ProblemType::BinaryClassification,
            "MulticlassClassification" => ProblemType::MulticlassClassification,
            "Regression" => ProblemType::Regression,
            other => ProblemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProblemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProblemType::from(s))
    }
}
impl ProblemType {
    pub fn as_str(&self) -> &str {
        match self {
            ProblemType::BinaryClassification => "BinaryClassification",
            ProblemType::MulticlassClassification => "MulticlassClassification",
            ProblemType::Regression => "Regression",
            ProblemType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "BinaryClassification",
            "MulticlassClassification",
            "Regression",
        ]
    }
}
impl AsRef<str> for ProblemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a metric to minimize or maximize as the objective of a job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobObjective {
    /// <p>The name of the objective metric used to measure the predictive quality of a machine
    /// learning system. This metric is optimized during training to provide the best estimate for
    /// model parameter values from data.</p>
    /// <p>Here are the options:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MSE</code>: The mean squared error (MSE) is the average of the squared
    /// differences between the predicted and actual values. It is used for regression. MSE
    /// values are always positive: the better a model is at predicting the actual values,
    /// the smaller the MSE value. When the data contains outliers, they tend to dominate the
    /// MSE, which might cause subpar prediction performance.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Accuracy</code>: The ratio of the number of correctly classified items to
    /// the total number of (correctly and incorrectly) classified items. It is used for
    /// binary and multiclass classification. It measures how close the predicted class
    /// values are to the actual values. Accuracy values vary between zero and one: one
    /// indicates perfect accuracy and zero indicates perfect inaccuracy.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It
    /// is used for binary classification into classes traditionally referred to as positive
    /// and negative. Predictions are said to be true when they match their actual (correct)
    /// class and false when they do not. Precision is the ratio of the true positive
    /// predictions to all positive predictions (including the false positives) in a data set
    /// and measures the quality of the prediction when it predicts the positive class.
    /// Recall (or sensitivity) is the ratio of the true positive predictions to all actual
    /// positive instances and measures how completely a model predicts the actual class
    /// members in a data set. The standard F1 score weighs precision and recall equally. But
    /// which metric is paramount typically depends on specific aspects of a problem. F1
    /// scores vary between zero and one: one indicates the best possible performance and
    /// zero the worst.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AUC</code>: The area under the curve (AUC) metric is used to compare and
    /// evaluate binary classification by algorithms such as logistic regression that return
    /// probabilities. A threshold is needed to map the probabilities into classifications.
    /// The relevant curve is the receiver operating characteristic curve that plots the true
    /// positive rate (TPR) of predictions (or recall) against the false positive rate (FPR)
    /// as a function of the threshold value, above which a prediction is considered
    /// positive. Increasing the threshold results in fewer false positives but more false
    /// negatives. AUC is the area under this receiver operating characteristic curve and so
    /// provides an aggregated measure of the model performance across all possible
    /// classification thresholds. The AUC score can also be interpreted as the probability
    /// that a randomly selected positive data point is more likely to be predicted positive
    /// than a randomly selected negative example. AUC scores vary between zero and one: a
    /// score of one indicates perfect accuracy and a score of one half indicates that the
    /// prediction is not better than a random classifier. Values under one half predict less
    /// accurately than a random predictor. But such consistently bad predictors can simply
    /// be inverted to obtain better than random predictors.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass
    /// classification. In this context, you have multiple classes to predict. You just
    /// calculate the precision and recall for each class as you did for the positive class
    /// in binary classification. Then, use these values to calculate the F1 score for each
    /// class and average them to obtain the F1macro score. F1macro scores vary between zero
    /// and one: one indicates the best possible performance and zero the worst.</p>
    /// </li>
    /// </ul>
    /// <p>If you do not specify a metric explicitly, the default behavior is to automatically
    /// use:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MSE</code>: for regression.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>F1</code>: for binary classification</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Accuracy</code>: for multiclass classification.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
}
impl std::fmt::Debug for AutoMlJobObjective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobObjective");
        formatter.field("metric_name", &self.metric_name);
        formatter.finish()
    }
}
/// See [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
pub mod auto_ml_job_objective {
    /// A builder for [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<crate::model::AutoMlMetricEnum>,
    }
    impl Builder {
        /// <p>The name of the objective metric used to measure the predictive quality of a machine
        /// learning system. This metric is optimized during training to provide the best estimate for
        /// model parameter values from data.</p>
        /// <p>Here are the options:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MSE</code>: The mean squared error (MSE) is the average of the squared
        /// differences between the predicted and actual values. It is used for regression. MSE
        /// values are always positive: the better a model is at predicting the actual values,
        /// the smaller the MSE value. When the data contains outliers, they tend to dominate the
        /// MSE, which might cause subpar prediction performance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Accuracy</code>: The ratio of the number of correctly classified items to
        /// the total number of (correctly and incorrectly) classified items. It is used for
        /// binary and multiclass classification. It measures how close the predicted class
        /// values are to the actual values. Accuracy values vary between zero and one: one
        /// indicates perfect accuracy and zero indicates perfect inaccuracy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>F1</code>: The F1 score is the harmonic mean of the precision and recall. It
        /// is used for binary classification into classes traditionally referred to as positive
        /// and negative. Predictions are said to be true when they match their actual (correct)
        /// class and false when they do not. Precision is the ratio of the true positive
        /// predictions to all positive predictions (including the false positives) in a data set
        /// and measures the quality of the prediction when it predicts the positive class.
        /// Recall (or sensitivity) is the ratio of the true positive predictions to all actual
        /// positive instances and measures how completely a model predicts the actual class
        /// members in a data set. The standard F1 score weighs precision and recall equally. But
        /// which metric is paramount typically depends on specific aspects of a problem. F1
        /// scores vary between zero and one: one indicates the best possible performance and
        /// zero the worst.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AUC</code>: The area under the curve (AUC) metric is used to compare and
        /// evaluate binary classification by algorithms such as logistic regression that return
        /// probabilities. A threshold is needed to map the probabilities into classifications.
        /// The relevant curve is the receiver operating characteristic curve that plots the true
        /// positive rate (TPR) of predictions (or recall) against the false positive rate (FPR)
        /// as a function of the threshold value, above which a prediction is considered
        /// positive. Increasing the threshold results in fewer false positives but more false
        /// negatives. AUC is the area under this receiver operating characteristic curve and so
        /// provides an aggregated measure of the model performance across all possible
        /// classification thresholds. The AUC score can also be interpreted as the probability
        /// that a randomly selected positive data point is more likely to be predicted positive
        /// than a randomly selected negative example. AUC scores vary between zero and one: a
        /// score of one indicates perfect accuracy and a score of one half indicates that the
        /// prediction is not better than a random classifier. Values under one half predict less
        /// accurately than a random predictor. But such consistently bad predictors can simply
        /// be inverted to obtain better than random predictors.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>F1macro</code>: The F1macro score applies F1 scoring to multiclass
        /// classification. In this context, you have multiple classes to predict. You just
        /// calculate the precision and recall for each class as you did for the positive class
        /// in binary classification. Then, use these values to calculate the F1 score for each
        /// class and average them to obtain the F1macro score. F1macro scores vary between zero
        /// and one: one indicates the best possible performance and zero the worst.</p>
        /// </li>
        /// </ul>
        /// <p>If you do not specify a metric explicitly, the default behavior is to automatically
        /// use:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MSE</code>: for regression.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>F1</code>: for binary classification</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Accuracy</code>: for multiclass classification.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::AutoMlMetricEnum) -> Self {
            self.metric_name = Some(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::AutoMlMetricEnum>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
        pub fn build(self) -> crate::model::AutoMlJobObjective {
            crate::model::AutoMlJobObjective {
                metric_name: self.metric_name,
            }
        }
    }
}
impl AutoMlJobObjective {
    /// Creates a new builder-style object to manufacture [`AutoMlJobObjective`](crate::model::AutoMlJobObjective)
    pub fn builder() -> crate::model::auto_ml_job_objective::Builder {
        crate::model::auto_ml_job_objective::Builder::default()
    }
}

/// <p>The artifacts that are generated during an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobArtifacts {
    /// <p>The URL of the notebook location.</p>
    pub candidate_definition_notebook_location: std::option::Option<std::string::String>,
    /// <p>The URL of the notebook location.</p>
    pub data_exploration_notebook_location: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMlJobArtifacts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobArtifacts");
        formatter.field(
            "candidate_definition_notebook_location",
            &self.candidate_definition_notebook_location,
        );
        formatter.field(
            "data_exploration_notebook_location",
            &self.data_exploration_notebook_location,
        );
        formatter.finish()
    }
}
/// See [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
pub mod auto_ml_job_artifacts {
    /// A builder for [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) candidate_definition_notebook_location: std::option::Option<std::string::String>,
        pub(crate) data_exploration_notebook_location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL of the notebook location.</p>
        pub fn candidate_definition_notebook_location(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.candidate_definition_notebook_location = Some(input.into());
            self
        }
        pub fn set_candidate_definition_notebook_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.candidate_definition_notebook_location = input;
            self
        }
        /// <p>The URL of the notebook location.</p>
        pub fn data_exploration_notebook_location(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.data_exploration_notebook_location = Some(input.into());
            self
        }
        pub fn set_data_exploration_notebook_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_exploration_notebook_location = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
        pub fn build(self) -> crate::model::AutoMlJobArtifacts {
            crate::model::AutoMlJobArtifacts {
                candidate_definition_notebook_location: self.candidate_definition_notebook_location,
                data_exploration_notebook_location: self.data_exploration_notebook_location,
            }
        }
    }
}
impl AutoMlJobArtifacts {
    /// Creates a new builder-style object to manufacture [`AutoMlJobArtifacts`](crate::model::AutoMlJobArtifacts)
    pub fn builder() -> crate::model::auto_ml_job_artifacts::Builder {
        crate::model::auto_ml_job_artifacts::Builder::default()
    }
}

/// <p>A collection of settings used for an AutoML job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlJobConfig {
    /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to
    /// generate.</p>
    pub completion_criteria: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
    /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
    pub security_config: std::option::Option<crate::model::AutoMlSecurityConfig>,
}
impl std::fmt::Debug for AutoMlJobConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlJobConfig");
        formatter.field("completion_criteria", &self.completion_criteria);
        formatter.field("security_config", &self.security_config);
        formatter.finish()
    }
}
/// See [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
pub mod auto_ml_job_config {
    /// A builder for [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) completion_criteria:
            std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        pub(crate) security_config: std::option::Option<crate::model::AutoMlSecurityConfig>,
    }
    impl Builder {
        /// <p>How long an AutoML job is allowed to run, or how many candidates a job is allowed to
        /// generate.</p>
        pub fn completion_criteria(
            mut self,
            input: crate::model::AutoMlJobCompletionCriteria,
        ) -> Self {
            self.completion_criteria = Some(input);
            self
        }
        pub fn set_completion_criteria(
            mut self,
            input: std::option::Option<crate::model::AutoMlJobCompletionCriteria>,
        ) -> Self {
            self.completion_criteria = input;
            self
        }
        /// <p>The security configuration for traffic encryption or Amazon VPC settings.</p>
        pub fn security_config(mut self, input: crate::model::AutoMlSecurityConfig) -> Self {
            self.security_config = Some(input);
            self
        }
        pub fn set_security_config(
            mut self,
            input: std::option::Option<crate::model::AutoMlSecurityConfig>,
        ) -> Self {
            self.security_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
        pub fn build(self) -> crate::model::AutoMlJobConfig {
            crate::model::AutoMlJobConfig {
                completion_criteria: self.completion_criteria,
                security_config: self.security_config,
            }
        }
    }
}
impl AutoMlJobConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlJobConfig`](crate::model::AutoMlJobConfig)
    pub fn builder() -> crate::model::auto_ml_job_config::Builder {
        crate::model::auto_ml_job_config::Builder::default()
    }
}

/// <p>Security options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlSecurityConfig {
    /// <p>The key used to encrypt stored data.</p>
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p>Whether to use traffic encryption between the container layers.</p>
    pub enable_inter_container_traffic_encryption: bool,
    /// <p>The VPC configuration.</p>
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl std::fmt::Debug for AutoMlSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlSecurityConfig");
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.field(
            "enable_inter_container_traffic_encryption",
            &self.enable_inter_container_traffic_encryption,
        );
        formatter.field("vpc_config", &self.vpc_config);
        formatter.finish()
    }
}
/// See [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
pub mod auto_ml_security_config {
    /// A builder for [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) enable_inter_container_traffic_encryption: std::option::Option<bool>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The key used to encrypt stored data.</p>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p>Whether to use traffic encryption between the container layers.</p>
        pub fn enable_inter_container_traffic_encryption(mut self, input: bool) -> Self {
            self.enable_inter_container_traffic_encryption = Some(input);
            self
        }
        pub fn set_enable_inter_container_traffic_encryption(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.enable_inter_container_traffic_encryption = input;
            self
        }
        /// <p>The VPC configuration.</p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
        pub fn build(self) -> crate::model::AutoMlSecurityConfig {
            crate::model::AutoMlSecurityConfig {
                volume_kms_key_id: self.volume_kms_key_id,
                enable_inter_container_traffic_encryption: self
                    .enable_inter_container_traffic_encryption
                    .unwrap_or_default(),
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl AutoMlSecurityConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlSecurityConfig`](crate::model::AutoMlSecurityConfig)
    pub fn builder() -> crate::model::auto_ml_security_config::Builder {
        crate::model::auto_ml_security_config::Builder::default()
    }
}

/// <p>The output data configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlOutputDataConfig {
    /// <p>The Amazon Web Services KMS encryption key ID.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
    pub s3_output_path: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMlOutputDataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlOutputDataConfig");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("s3_output_path", &self.s3_output_path);
        formatter.finish()
    }
}
/// See [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
pub mod auto_ml_output_data_config {
    /// A builder for [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) s3_output_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services KMS encryption key ID.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon S3 output path. Must be 128 characters or less.</p>
        pub fn s3_output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_output_path = Some(input.into());
            self
        }
        pub fn set_s3_output_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_output_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
        pub fn build(self) -> crate::model::AutoMlOutputDataConfig {
            crate::model::AutoMlOutputDataConfig {
                kms_key_id: self.kms_key_id,
                s3_output_path: self.s3_output_path,
            }
        }
    }
}
impl AutoMlOutputDataConfig {
    /// Creates a new builder-style object to manufacture [`AutoMlOutputDataConfig`](crate::model::AutoMlOutputDataConfig)
    pub fn builder() -> crate::model::auto_ml_output_data_config::Builder {
        crate::model::auto_ml_output_data_config::Builder::default()
    }
}

/// <p>A channel is a named input source that training algorithms can consume. For more
/// information, see .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlChannel {
    /// <p>The data source for an AutoML channel.</p>
    pub data_source: std::option::Option<crate::model::AutoMlDataSource>,
    /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is
    /// <code>None</code>.</p>
    pub compression_type: std::option::Option<crate::model::CompressionType>,
    /// <p>The name of the target variable in supervised learning, usually represented by
    /// 'y'.</p>
    pub target_attribute_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMlChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlChannel");
        formatter.field("data_source", &self.data_source);
        formatter.field("compression_type", &self.compression_type);
        formatter.field("target_attribute_name", &self.target_attribute_name);
        formatter.finish()
    }
}
/// See [`AutoMlChannel`](crate::model::AutoMlChannel)
pub mod auto_ml_channel {
    /// A builder for [`AutoMlChannel`](crate::model::AutoMlChannel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_source: std::option::Option<crate::model::AutoMlDataSource>,
        pub(crate) compression_type: std::option::Option<crate::model::CompressionType>,
        pub(crate) target_attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data source for an AutoML channel.</p>
        pub fn data_source(mut self, input: crate::model::AutoMlDataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::AutoMlDataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>You can use <code>Gzip</code> or <code>None</code>. The default value is
        /// <code>None</code>.</p>
        pub fn compression_type(mut self, input: crate::model::CompressionType) -> Self {
            self.compression_type = Some(input);
            self
        }
        pub fn set_compression_type(
            mut self,
            input: std::option::Option<crate::model::CompressionType>,
        ) -> Self {
            self.compression_type = input;
            self
        }
        /// <p>The name of the target variable in supervised learning, usually represented by
        /// 'y'.</p>
        pub fn target_attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_attribute_name = Some(input.into());
            self
        }
        pub fn set_target_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_attribute_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlChannel`](crate::model::AutoMlChannel)
        pub fn build(self) -> crate::model::AutoMlChannel {
            crate::model::AutoMlChannel {
                data_source: self.data_source,
                compression_type: self.compression_type,
                target_attribute_name: self.target_attribute_name,
            }
        }
    }
}
impl AutoMlChannel {
    /// Creates a new builder-style object to manufacture [`AutoMlChannel`](crate::model::AutoMlChannel)
    pub fn builder() -> crate::model::auto_ml_channel::Builder {
        crate::model::auto_ml_channel::Builder::default()
    }
}

/// <p>The data source for the Autopilot job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMlDataSource {
    /// <p>The Amazon S3 location of the input data.</p>
    /// <note>
    /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
    /// </note>
    pub s3_data_source: std::option::Option<crate::model::AutoMls3DataSource>,
}
impl std::fmt::Debug for AutoMlDataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMlDataSource");
        formatter.field("s3_data_source", &self.s3_data_source);
        formatter.finish()
    }
}
/// See [`AutoMlDataSource`](crate::model::AutoMlDataSource)
pub mod auto_ml_data_source {
    /// A builder for [`AutoMlDataSource`](crate::model::AutoMlDataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_source: std::option::Option<crate::model::AutoMls3DataSource>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the input data.</p>
        /// <note>
        /// <p>The input data must be in CSV format and contain at least 500 rows.</p>
        /// </note>
        pub fn s3_data_source(mut self, input: crate::model::AutoMls3DataSource) -> Self {
            self.s3_data_source = Some(input);
            self
        }
        pub fn set_s3_data_source(
            mut self,
            input: std::option::Option<crate::model::AutoMls3DataSource>,
        ) -> Self {
            self.s3_data_source = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMlDataSource`](crate::model::AutoMlDataSource)
        pub fn build(self) -> crate::model::AutoMlDataSource {
            crate::model::AutoMlDataSource {
                s3_data_source: self.s3_data_source,
            }
        }
    }
}
impl AutoMlDataSource {
    /// Creates a new builder-style object to manufacture [`AutoMlDataSource`](crate::model::AutoMlDataSource)
    pub fn builder() -> crate::model::auto_ml_data_source::Builder {
        crate::model::auto_ml_data_source::Builder::default()
    }
}

/// <p>The Amazon S3 data source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoMls3DataSource {
    /// <p>The data type.</p>
    pub s3_data_type: std::option::Option<crate::model::AutoMls3DataType>,
    /// <p>The URL to the Amazon S3 data source.</p>
    pub s3_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoMls3DataSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoMls3DataSource");
        formatter.field("s3_data_type", &self.s3_data_type);
        formatter.field("s3_uri", &self.s3_uri);
        formatter.finish()
    }
}
/// See [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
pub mod auto_mls3_data_source {
    /// A builder for [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_data_type: std::option::Option<crate::model::AutoMls3DataType>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data type.</p>
        pub fn s3_data_type(mut self, input: crate::model::AutoMls3DataType) -> Self {
            self.s3_data_type = Some(input);
            self
        }
        pub fn set_s3_data_type(
            mut self,
            input: std::option::Option<crate::model::AutoMls3DataType>,
        ) -> Self {
            self.s3_data_type = input;
            self
        }
        /// <p>The URL to the Amazon S3 data source.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
        pub fn build(self) -> crate::model::AutoMls3DataSource {
            crate::model::AutoMls3DataSource {
                s3_data_type: self.s3_data_type,
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl AutoMls3DataSource {
    /// Creates a new builder-style object to manufacture [`AutoMls3DataSource`](crate::model::AutoMls3DataSource)
    pub fn builder() -> crate::model::auto_mls3_data_source::Builder {
        crate::model::auto_mls3_data_source::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoMls3DataType {
    ManifestFile,
    S3Prefix,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoMls3DataType {
    fn from(s: &str) -> Self {
        match s {
            "ManifestFile" => AutoMls3DataType::ManifestFile,
            "S3Prefix" => AutoMls3DataType::S3Prefix,
            other => AutoMls3DataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoMls3DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoMls3DataType::from(s))
    }
}
impl AutoMls3DataType {
    pub fn as_str(&self) -> &str {
        match self {
            AutoMls3DataType::ManifestFile => "ManifestFile",
            AutoMls3DataType::S3Prefix => "S3Prefix",
            AutoMls3DataType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ManifestFile", "S3Prefix"]
    }
}
impl AsRef<str> for AutoMls3DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the validation and image scan statuses of the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmStatusDetails {
    /// <p>The status of algorithm validation.</p>
    pub validation_statuses: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
    /// <p>The status of the scan of the algorithm's Docker image container.</p>
    pub image_scan_statuses: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
}
impl std::fmt::Debug for AlgorithmStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmStatusDetails");
        formatter.field("validation_statuses", &self.validation_statuses);
        formatter.field("image_scan_statuses", &self.image_scan_statuses);
        formatter.finish()
    }
}
/// See [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
pub mod algorithm_status_details {
    /// A builder for [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_statuses:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        pub(crate) image_scan_statuses:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
    }
    impl Builder {
        pub fn validation_statuses(
            mut self,
            input: impl Into<crate::model::AlgorithmStatusItem>,
        ) -> Self {
            let mut v = self.validation_statuses.unwrap_or_default();
            v.push(input.into());
            self.validation_statuses = Some(v);
            self
        }
        pub fn set_validation_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        ) -> Self {
            self.validation_statuses = input;
            self
        }
        pub fn image_scan_statuses(
            mut self,
            input: impl Into<crate::model::AlgorithmStatusItem>,
        ) -> Self {
            let mut v = self.image_scan_statuses.unwrap_or_default();
            v.push(input.into());
            self.image_scan_statuses = Some(v);
            self
        }
        pub fn set_image_scan_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmStatusItem>>,
        ) -> Self {
            self.image_scan_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
        pub fn build(self) -> crate::model::AlgorithmStatusDetails {
            crate::model::AlgorithmStatusDetails {
                validation_statuses: self.validation_statuses,
                image_scan_statuses: self.image_scan_statuses,
            }
        }
    }
}
impl AlgorithmStatusDetails {
    /// Creates a new builder-style object to manufacture [`AlgorithmStatusDetails`](crate::model::AlgorithmStatusDetails)
    pub fn builder() -> crate::model::algorithm_status_details::Builder {
        crate::model::algorithm_status_details::Builder::default()
    }
}

/// <p>Represents the overall status of an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmStatusItem {
    /// <p>The name of the algorithm for which the overall status is being reported.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status.</p>
    pub status: std::option::Option<crate::model::DetailedAlgorithmStatus>,
    /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlgorithmStatusItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmStatusItem");
        formatter.field("name", &self.name);
        formatter.field("status", &self.status);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
pub mod algorithm_status_item {
    /// A builder for [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DetailedAlgorithmStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the algorithm for which the overall status is being reported.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current status.</p>
        pub fn status(mut self, input: crate::model::DetailedAlgorithmStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DetailedAlgorithmStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>if the overall status is <code>Failed</code>, the reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
        pub fn build(self) -> crate::model::AlgorithmStatusItem {
            crate::model::AlgorithmStatusItem {
                name: self.name,
                status: self.status,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl AlgorithmStatusItem {
    /// Creates a new builder-style object to manufacture [`AlgorithmStatusItem`](crate::model::AlgorithmStatusItem)
    pub fn builder() -> crate::model::algorithm_status_item::Builder {
        crate::model::algorithm_status_item::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetailedAlgorithmStatus {
    Completed,
    Failed,
    InProgress,
    NotStarted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DetailedAlgorithmStatus {
    fn from(s: &str) -> Self {
        match s {
            "Completed" => DetailedAlgorithmStatus::Completed,
            "Failed" => DetailedAlgorithmStatus::Failed,
            "InProgress" => DetailedAlgorithmStatus::InProgress,
            "NotStarted" => DetailedAlgorithmStatus::NotStarted,
            other => DetailedAlgorithmStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DetailedAlgorithmStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetailedAlgorithmStatus::from(s))
    }
}
impl DetailedAlgorithmStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DetailedAlgorithmStatus::Completed => "Completed",
            DetailedAlgorithmStatus::Failed => "Failed",
            DetailedAlgorithmStatus::InProgress => "InProgress",
            DetailedAlgorithmStatus::NotStarted => "NotStarted",
            DetailedAlgorithmStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Completed", "Failed", "InProgress", "NotStarted"]
    }
}
impl AsRef<str> for DetailedAlgorithmStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies configurations for one or more training jobs that Amazon SageMaker runs to test the
/// algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmValidationSpecification {
    /// <p>The IAM roles that Amazon SageMaker uses to run the training jobs.</p>
    pub validation_role: std::option::Option<std::string::String>,
    /// <p>An array of <code>AlgorithmValidationProfile</code> objects, each of which specifies a
    /// training job and batch transform job that Amazon SageMaker runs to validate your algorithm.</p>
    pub validation_profiles:
        std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
}
impl std::fmt::Debug for AlgorithmValidationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmValidationSpecification");
        formatter.field("validation_role", &self.validation_role);
        formatter.field("validation_profiles", &self.validation_profiles);
        formatter.finish()
    }
}
/// See [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
pub mod algorithm_validation_specification {
    /// A builder for [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) validation_role: std::option::Option<std::string::String>,
        pub(crate) validation_profiles:
            std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
    }
    impl Builder {
        /// <p>The IAM roles that Amazon SageMaker uses to run the training jobs.</p>
        pub fn validation_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.validation_role = Some(input.into());
            self
        }
        pub fn set_validation_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.validation_role = input;
            self
        }
        pub fn validation_profiles(
            mut self,
            input: impl Into<crate::model::AlgorithmValidationProfile>,
        ) -> Self {
            let mut v = self.validation_profiles.unwrap_or_default();
            v.push(input.into());
            self.validation_profiles = Some(v);
            self
        }
        pub fn set_validation_profiles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlgorithmValidationProfile>>,
        ) -> Self {
            self.validation_profiles = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
        pub fn build(self) -> crate::model::AlgorithmValidationSpecification {
            crate::model::AlgorithmValidationSpecification {
                validation_role: self.validation_role,
                validation_profiles: self.validation_profiles,
            }
        }
    }
}
impl AlgorithmValidationSpecification {
    /// Creates a new builder-style object to manufacture [`AlgorithmValidationSpecification`](crate::model::AlgorithmValidationSpecification)
    pub fn builder() -> crate::model::algorithm_validation_specification::Builder {
        crate::model::algorithm_validation_specification::Builder::default()
    }
}

/// <p>Defines a training job and a batch transform job that Amazon SageMaker runs to validate your
/// algorithm.</p>
/// <p>The data provided in the validation profile is made available to your buyers on Amazon Web Services
/// Marketplace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlgorithmValidationProfile {
    /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters.
    /// Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
    pub profile_name: std::option::Option<std::string::String>,
    /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that
    /// Amazon SageMaker runs to validate your algorithm.</p>
    pub training_job_definition: std::option::Option<crate::model::TrainingJobDefinition>,
    /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that
    /// Amazon SageMaker runs to validate your algorithm.</p>
    pub transform_job_definition: std::option::Option<crate::model::TransformJobDefinition>,
}
impl std::fmt::Debug for AlgorithmValidationProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlgorithmValidationProfile");
        formatter.field("profile_name", &self.profile_name);
        formatter.field("training_job_definition", &self.training_job_definition);
        formatter.field("transform_job_definition", &self.transform_job_definition);
        formatter.finish()
    }
}
/// See [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
pub mod algorithm_validation_profile {
    /// A builder for [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_name: std::option::Option<std::string::String>,
        pub(crate) training_job_definition:
            std::option::Option<crate::model::TrainingJobDefinition>,
        pub(crate) transform_job_definition:
            std::option::Option<crate::model::TransformJobDefinition>,
    }
    impl Builder {
        /// <p>The name of the profile for the algorithm. The name must have 1 to 63 characters.
        /// Valid characters are a-z, A-Z, 0-9, and - (hyphen).</p>
        pub fn profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_name = Some(input.into());
            self
        }
        pub fn set_profile_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_name = input;
            self
        }
        /// <p>The <code>TrainingJobDefinition</code> object that describes the training job that
        /// Amazon SageMaker runs to validate your algorithm.</p>
        pub fn training_job_definition(
            mut self,
            input: crate::model::TrainingJobDefinition,
        ) -> Self {
            self.training_job_definition = Some(input);
            self
        }
        pub fn set_training_job_definition(
            mut self,
            input: std::option::Option<crate::model::TrainingJobDefinition>,
        ) -> Self {
            self.training_job_definition = input;
            self
        }
        /// <p>The <code>TransformJobDefinition</code> object that describes the transform job that
        /// Amazon SageMaker runs to validate your algorithm.</p>
        pub fn transform_job_definition(
            mut self,
            input: crate::model::TransformJobDefinition,
        ) -> Self {
            self.transform_job_definition = Some(input);
            self
        }
        pub fn set_transform_job_definition(
            mut self,
            input: std::option::Option<crate::model::TransformJobDefinition>,
        ) -> Self {
            self.transform_job_definition = input;
            self
        }
        /// Consumes the builder and constructs a [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
        pub fn build(self) -> crate::model::AlgorithmValidationProfile {
            crate::model::AlgorithmValidationProfile {
                profile_name: self.profile_name,
                training_job_definition: self.training_job_definition,
                transform_job_definition: self.transform_job_definition,
            }
        }
    }
}
impl AlgorithmValidationProfile {
    /// Creates a new builder-style object to manufacture [`AlgorithmValidationProfile`](crate::model::AlgorithmValidationProfile)
    pub fn builder() -> crate::model::algorithm_validation_profile::Builder {
        crate::model::algorithm_validation_profile::Builder::default()
    }
}

/// <p>Defines the input needed to run a training job using the algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingJobDefinition {
    /// <p>The input mode used by the algorithm for the training job. For the input modes that
    /// Amazon SageMaker algorithms support, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
    /// <p>If an algorithm supports the <code>File</code> input mode, Amazon SageMaker downloads the training
    /// data from S3 to the provisioned ML storage Volume, and mounts the directory to docker
    /// volume for training container. If an algorithm supports the <code>Pipe</code> input
    /// mode, Amazon SageMaker streams data directly from S3 to the container.</p>
    pub training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
    /// <p>The hyperparameters used for the training job.</p>
    pub hyper_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An array of <code>Channel</code> objects, each of which specifies an input
    /// source.</p>
    pub input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
    /// <p>the path to the S3 bucket where you want to store model artifacts. Amazon SageMaker creates
    /// subfolders for the artifacts.</p>
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The resources, including the ML compute instances and ML storage volumes, to use for
    /// model training.</p>
    pub resource_config: std::option::Option<crate::model::ResourceConfig>,
    /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
    /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
    /// ends the training job. Use this API to cap model training costs.</p>
    /// <p>To stop a job, Amazon SageMaker sends the algorithm the SIGTERM signal, which delays job
    /// termination for 120 seconds. Algorithms can use this 120-second window to save the model
    /// artifacts.</p>
    pub stopping_condition: std::option::Option<crate::model::StoppingCondition>,
}
impl std::fmt::Debug for TrainingJobDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingJobDefinition");
        formatter.field("training_input_mode", &self.training_input_mode);
        formatter.field("hyper_parameters", &self.hyper_parameters);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("resource_config", &self.resource_config);
        formatter.field("stopping_condition", &self.stopping_condition);
        formatter.finish()
    }
}
/// See [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
pub mod training_job_definition {
    /// A builder for [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_input_mode: std::option::Option<crate::model::TrainingInputMode>,
        pub(crate) hyper_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) input_data_config: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) resource_config: std::option::Option<crate::model::ResourceConfig>,
        pub(crate) stopping_condition: std::option::Option<crate::model::StoppingCondition>,
    }
    impl Builder {
        /// <p>The input mode used by the algorithm for the training job. For the input modes that
        /// Amazon SageMaker algorithms support, see <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">Algorithms</a>.</p>
        /// <p>If an algorithm supports the <code>File</code> input mode, Amazon SageMaker downloads the training
        /// data from S3 to the provisioned ML storage Volume, and mounts the directory to docker
        /// volume for training container. If an algorithm supports the <code>Pipe</code> input
        /// mode, Amazon SageMaker streams data directly from S3 to the container.</p>
        pub fn training_input_mode(mut self, input: crate::model::TrainingInputMode) -> Self {
            self.training_input_mode = Some(input);
            self
        }
        pub fn set_training_input_mode(
            mut self,
            input: std::option::Option<crate::model::TrainingInputMode>,
        ) -> Self {
            self.training_input_mode = input;
            self
        }
        pub fn hyper_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.hyper_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.hyper_parameters = Some(hash_map);
            self
        }
        pub fn set_hyper_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.hyper_parameters = input;
            self
        }
        pub fn input_data_config(mut self, input: impl Into<crate::model::Channel>) -> Self {
            let mut v = self.input_data_config.unwrap_or_default();
            v.push(input.into());
            self.input_data_config = Some(v);
            self
        }
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Channel>>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>the path to the S3 bucket where you want to store model artifacts. Amazon SageMaker creates
        /// subfolders for the artifacts.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The resources, including the ML compute instances and ML storage volumes, to use for
        /// model training.</p>
        pub fn resource_config(mut self, input: crate::model::ResourceConfig) -> Self {
            self.resource_config = Some(input);
            self
        }
        pub fn set_resource_config(
            mut self,
            input: std::option::Option<crate::model::ResourceConfig>,
        ) -> Self {
            self.resource_config = input;
            self
        }
        /// <p>Specifies a limit to how long a model training job can run. It also specifies how long
        /// a managed Spot training job has to complete. When the job reaches the time limit, Amazon SageMaker
        /// ends the training job. Use this API to cap model training costs.</p>
        /// <p>To stop a job, Amazon SageMaker sends the algorithm the SIGTERM signal, which delays job
        /// termination for 120 seconds. Algorithms can use this 120-second window to save the model
        /// artifacts.</p>
        pub fn stopping_condition(mut self, input: crate::model::StoppingCondition) -> Self {
            self.stopping_condition = Some(input);
            self
        }
        pub fn set_stopping_condition(
            mut self,
            input: std::option::Option<crate::model::StoppingCondition>,
        ) -> Self {
            self.stopping_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
        pub fn build(self) -> crate::model::TrainingJobDefinition {
            crate::model::TrainingJobDefinition {
                training_input_mode: self.training_input_mode,
                hyper_parameters: self.hyper_parameters,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                resource_config: self.resource_config,
                stopping_condition: self.stopping_condition,
            }
        }
    }
}
impl TrainingJobDefinition {
    /// Creates a new builder-style object to manufacture [`TrainingJobDefinition`](crate::model::TrainingJobDefinition)
    pub fn builder() -> crate::model::training_job_definition::Builder {
        crate::model::training_job_definition::Builder::default()
    }
}

/// <p>Defines how the algorithm is used for a training job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TrainingSpecification {
    /// <p>The Amazon ECR registry path of the Docker image that contains the training
    /// algorithm.</p>
    pub training_image: std::option::Option<std::string::String>,
    /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for
    /// training.</p>
    pub training_image_digest: std::option::Option<std::string::String>,
    /// <p>A list of the <code>HyperParameterSpecification</code> objects, that define the
    /// supported hyperparameters. This is required if the algorithm supports automatic model
    /// tuning.></p>
    pub supported_hyper_parameters:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
    /// <p>A list of the instance types that this algorithm can use for training.</p>
    pub supported_training_instance_types:
        std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
    /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers
    /// can't request more than one instance during training.</p>
    pub supports_distributed_training: bool,
    /// <p>A list of <code>MetricDefinition</code> objects, which are used for parsing metrics
    /// generated by the algorithm.</p>
    pub metric_definitions: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
    /// <p>A list of <code>ChannelSpecification</code> objects, which specify the input sources
    /// to be used by the algorithm.</p>
    pub training_channels: std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
    /// <p>A list of the metrics that the algorithm emits that can be used as the objective
    /// metric in a hyperparameter tuning job.</p>
    pub supported_tuning_job_objective_metrics:
        std::option::Option<std::vec::Vec<crate::model::HyperParameterTuningJobObjective>>,
}
impl std::fmt::Debug for TrainingSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TrainingSpecification");
        formatter.field("training_image", &self.training_image);
        formatter.field("training_image_digest", &self.training_image_digest);
        formatter.field(
            "supported_hyper_parameters",
            &self.supported_hyper_parameters,
        );
        formatter.field(
            "supported_training_instance_types",
            &self.supported_training_instance_types,
        );
        formatter.field(
            "supports_distributed_training",
            &self.supports_distributed_training,
        );
        formatter.field("metric_definitions", &self.metric_definitions);
        formatter.field("training_channels", &self.training_channels);
        formatter.field(
            "supported_tuning_job_objective_metrics",
            &self.supported_tuning_job_objective_metrics,
        );
        formatter.finish()
    }
}
/// See [`TrainingSpecification`](crate::model::TrainingSpecification)
pub mod training_specification {
    /// A builder for [`TrainingSpecification`](crate::model::TrainingSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) training_image: std::option::Option<std::string::String>,
        pub(crate) training_image_digest: std::option::Option<std::string::String>,
        pub(crate) supported_hyper_parameters:
            std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
        pub(crate) supported_training_instance_types:
            std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
        pub(crate) supports_distributed_training: std::option::Option<bool>,
        pub(crate) metric_definitions:
            std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        pub(crate) training_channels:
            std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
        pub(crate) supported_tuning_job_objective_metrics:
            std::option::Option<std::vec::Vec<crate::model::HyperParameterTuningJobObjective>>,
    }
    impl Builder {
        /// <p>The Amazon ECR registry path of the Docker image that contains the training
        /// algorithm.</p>
        pub fn training_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image = Some(input.into());
            self
        }
        pub fn set_training_image(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image = input;
            self
        }
        /// <p>An MD5 hash of the training algorithm that identifies the Docker image used for
        /// training.</p>
        pub fn training_image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.training_image_digest = Some(input.into());
            self
        }
        pub fn set_training_image_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.training_image_digest = input;
            self
        }
        pub fn supported_hyper_parameters(
            mut self,
            input: impl Into<crate::model::HyperParameterSpecification>,
        ) -> Self {
            let mut v = self.supported_hyper_parameters.unwrap_or_default();
            v.push(input.into());
            self.supported_hyper_parameters = Some(v);
            self
        }
        pub fn set_supported_hyper_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HyperParameterSpecification>>,
        ) -> Self {
            self.supported_hyper_parameters = input;
            self
        }
        pub fn supported_training_instance_types(
            mut self,
            input: impl Into<crate::model::TrainingInstanceType>,
        ) -> Self {
            let mut v = self.supported_training_instance_types.unwrap_or_default();
            v.push(input.into());
            self.supported_training_instance_types = Some(v);
            self
        }
        pub fn set_supported_training_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrainingInstanceType>>,
        ) -> Self {
            self.supported_training_instance_types = input;
            self
        }
        /// <p>Indicates whether the algorithm supports distributed training. If set to false, buyers
        /// can't request more than one instance during training.</p>
        pub fn supports_distributed_training(mut self, input: bool) -> Self {
            self.supports_distributed_training = Some(input);
            self
        }
        pub fn set_supports_distributed_training(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.supports_distributed_training = input;
            self
        }
        pub fn metric_definitions(
            mut self,
            input: impl Into<crate::model::MetricDefinition>,
        ) -> Self {
            let mut v = self.metric_definitions.unwrap_or_default();
            v.push(input.into());
            self.metric_definitions = Some(v);
            self
        }
        pub fn set_metric_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDefinition>>,
        ) -> Self {
            self.metric_definitions = input;
            self
        }
        pub fn training_channels(
            mut self,
            input: impl Into<crate::model::ChannelSpecification>,
        ) -> Self {
            let mut v = self.training_channels.unwrap_or_default();
            v.push(input.into());
            self.training_channels = Some(v);
            self
        }
        pub fn set_training_channels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChannelSpecification>>,
        ) -> Self {
            self.training_channels = input;
            self
        }
        pub fn supported_tuning_job_objective_metrics(
            mut self,
            input: impl Into<crate::model::HyperParameterTuningJobObjective>,
        ) -> Self {
            let mut v = self
                .supported_tuning_job_objective_metrics
                .unwrap_or_default();
            v.push(input.into());
            self.supported_tuning_job_objective_metrics = Some(v);
            self
        }
        pub fn set_supported_tuning_job_objective_metrics(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::HyperParameterTuningJobObjective>,
            >,
        ) -> Self {
            self.supported_tuning_job_objective_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingSpecification`](crate::model::TrainingSpecification)
        pub fn build(self) -> crate::model::TrainingSpecification {
            crate::model::TrainingSpecification {
                training_image: self.training_image,
                training_image_digest: self.training_image_digest,
                supported_hyper_parameters: self.supported_hyper_parameters,
                supported_training_instance_types: self.supported_training_instance_types,
                supports_distributed_training: self
                    .supports_distributed_training
                    .unwrap_or_default(),
                metric_definitions: self.metric_definitions,
                training_channels: self.training_channels,
                supported_tuning_job_objective_metrics: self.supported_tuning_job_objective_metrics,
            }
        }
    }
}
impl TrainingSpecification {
    /// Creates a new builder-style object to manufacture [`TrainingSpecification`](crate::model::TrainingSpecification)
    pub fn builder() -> crate::model::training_specification::Builder {
        crate::model::training_specification::Builder::default()
    }
}

/// <p>Defines a named input source, called a channel, to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelSpecification {
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the channel.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates whether the channel is required by the algorithm.</p>
    pub is_required: bool,
    /// <p>The supported MIME types for the data.</p>
    pub supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The allowed compression types, if data compression is used.</p>
    pub supported_compression_types:
        std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
    /// <p>The allowed input mode, either FILE or PIPE.</p>
    /// <p>In FILE mode, Amazon SageMaker copies the data from the input source onto the local
    /// Amazon Elastic Block Store (Amazon EBS) volumes before starting your training algorithm.
    /// This is the most commonly used input mode.</p>
    /// <p>In PIPE mode, Amazon SageMaker streams input data from the source directly to your
    /// algorithm without using the EBS volume.</p>
    pub supported_input_modes: std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
}
impl std::fmt::Debug for ChannelSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelSpecification");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_required", &self.is_required);
        formatter.field("supported_content_types", &self.supported_content_types);
        formatter.field(
            "supported_compression_types",
            &self.supported_compression_types,
        );
        formatter.field("supported_input_modes", &self.supported_input_modes);
        formatter.finish()
    }
}
/// See [`ChannelSpecification`](crate::model::ChannelSpecification)
pub mod channel_specification {
    /// A builder for [`ChannelSpecification`](crate::model::ChannelSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_required: std::option::Option<bool>,
        pub(crate) supported_content_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supported_compression_types:
            std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
        pub(crate) supported_input_modes:
            std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
    }
    impl Builder {
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the channel.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Indicates whether the channel is required by the algorithm.</p>
        pub fn is_required(mut self, input: bool) -> Self {
            self.is_required = Some(input);
            self
        }
        pub fn set_is_required(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required = input;
            self
        }
        pub fn supported_content_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supported_content_types.unwrap_or_default();
            v.push(input.into());
            self.supported_content_types = Some(v);
            self
        }
        pub fn set_supported_content_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supported_content_types = input;
            self
        }
        pub fn supported_compression_types(
            mut self,
            input: impl Into<crate::model::CompressionType>,
        ) -> Self {
            let mut v = self.supported_compression_types.unwrap_or_default();
            v.push(input.into());
            self.supported_compression_types = Some(v);
            self
        }
        pub fn set_supported_compression_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CompressionType>>,
        ) -> Self {
            self.supported_compression_types = input;
            self
        }
        pub fn supported_input_modes(
            mut self,
            input: impl Into<crate::model::TrainingInputMode>,
        ) -> Self {
            let mut v = self.supported_input_modes.unwrap_or_default();
            v.push(input.into());
            self.supported_input_modes = Some(v);
            self
        }
        pub fn set_supported_input_modes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrainingInputMode>>,
        ) -> Self {
            self.supported_input_modes = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelSpecification`](crate::model::ChannelSpecification)
        pub fn build(self) -> crate::model::ChannelSpecification {
            crate::model::ChannelSpecification {
                name: self.name,
                description: self.description,
                is_required: self.is_required.unwrap_or_default(),
                supported_content_types: self.supported_content_types,
                supported_compression_types: self.supported_compression_types,
                supported_input_modes: self.supported_input_modes,
            }
        }
    }
}
impl ChannelSpecification {
    /// Creates a new builder-style object to manufacture [`ChannelSpecification`](crate::model::ChannelSpecification)
    pub fn builder() -> crate::model::channel_specification::Builder {
        crate::model::channel_specification::Builder::default()
    }
}

/// <p>Defines a hyperparameter to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HyperParameterSpecification {
    /// <p>The name of this hyperparameter. The name must be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the hyperparameter.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>,
    /// <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
    pub r#type: std::option::Option<crate::model::ParameterType>,
    /// <p>The allowed range for this hyperparameter.</p>
    pub range: std::option::Option<crate::model::ParameterRange>,
    /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning
    /// job.</p>
    pub is_tunable: bool,
    /// <p>Indicates whether this hyperparameter is required.</p>
    pub is_required: bool,
    /// <p>The default value for this hyperparameter. If a default value is specified, a
    /// hyperparameter cannot be required.</p>
    pub default_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HyperParameterSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HyperParameterSpecification");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("range", &self.range);
        formatter.field("is_tunable", &self.is_tunable);
        formatter.field("is_required", &self.is_required);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
pub mod hyper_parameter_specification {
    /// A builder for [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ParameterType>,
        pub(crate) range: std::option::Option<crate::model::ParameterRange>,
        pub(crate) is_tunable: std::option::Option<bool>,
        pub(crate) is_required: std::option::Option<bool>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of this hyperparameter. The name must be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the hyperparameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of this hyperparameter. The valid types are <code>Integer</code>,
        /// <code>Continuous</code>, <code>Categorical</code>, and <code>FreeText</code>.</p>
        pub fn r#type(mut self, input: crate::model::ParameterType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ParameterType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The allowed range for this hyperparameter.</p>
        pub fn range(mut self, input: crate::model::ParameterRange) -> Self {
            self.range = Some(input);
            self
        }
        pub fn set_range(
            mut self,
            input: std::option::Option<crate::model::ParameterRange>,
        ) -> Self {
            self.range = input;
            self
        }
        /// <p>Indicates whether this hyperparameter is tunable in a hyperparameter tuning
        /// job.</p>
        pub fn is_tunable(mut self, input: bool) -> Self {
            self.is_tunable = Some(input);
            self
        }
        pub fn set_is_tunable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_tunable = input;
            self
        }
        /// <p>Indicates whether this hyperparameter is required.</p>
        pub fn is_required(mut self, input: bool) -> Self {
            self.is_required = Some(input);
            self
        }
        pub fn set_is_required(mut self, input: std::option::Option<bool>) -> Self {
            self.is_required = input;
            self
        }
        /// <p>The default value for this hyperparameter. If a default value is specified, a
        /// hyperparameter cannot be required.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
        pub fn build(self) -> crate::model::HyperParameterSpecification {
            crate::model::HyperParameterSpecification {
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                range: self.range,
                is_tunable: self.is_tunable.unwrap_or_default(),
                is_required: self.is_required.unwrap_or_default(),
                default_value: self.default_value,
            }
        }
    }
}
impl HyperParameterSpecification {
    /// Creates a new builder-style object to manufacture [`HyperParameterSpecification`](crate::model::HyperParameterSpecification)
    pub fn builder() -> crate::model::hyper_parameter_specification::Builder {
        crate::model::hyper_parameter_specification::Builder::default()
    }
}

/// <p>Defines the possible values for categorical, continuous, and integer hyperparameters
/// to be used by an algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterRange {
    /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible
    /// values for an integer hyperparameter.</p>
    pub integer_parameter_range_specification:
        std::option::Option<crate::model::IntegerParameterRangeSpecification>,
    /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible
    /// values for a continuous hyperparameter.</p>
    pub continuous_parameter_range_specification:
        std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
    /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible
    /// values for a categorical hyperparameter.</p>
    pub categorical_parameter_range_specification:
        std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
}
impl std::fmt::Debug for ParameterRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterRange");
        formatter.field(
            "integer_parameter_range_specification",
            &self.integer_parameter_range_specification,
        );
        formatter.field(
            "continuous_parameter_range_specification",
            &self.continuous_parameter_range_specification,
        );
        formatter.field(
            "categorical_parameter_range_specification",
            &self.categorical_parameter_range_specification,
        );
        formatter.finish()
    }
}
/// See [`ParameterRange`](crate::model::ParameterRange)
pub mod parameter_range {
    /// A builder for [`ParameterRange`](crate::model::ParameterRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) integer_parameter_range_specification:
            std::option::Option<crate::model::IntegerParameterRangeSpecification>,
        pub(crate) continuous_parameter_range_specification:
            std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
        pub(crate) categorical_parameter_range_specification:
            std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
    }
    impl Builder {
        /// <p>A <code>IntegerParameterRangeSpecification</code> object that defines the possible
        /// values for an integer hyperparameter.</p>
        pub fn integer_parameter_range_specification(
            mut self,
            input: crate::model::IntegerParameterRangeSpecification,
        ) -> Self {
            self.integer_parameter_range_specification = Some(input);
            self
        }
        pub fn set_integer_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::IntegerParameterRangeSpecification>,
        ) -> Self {
            self.integer_parameter_range_specification = input;
            self
        }
        /// <p>A <code>ContinuousParameterRangeSpecification</code> object that defines the possible
        /// values for a continuous hyperparameter.</p>
        pub fn continuous_parameter_range_specification(
            mut self,
            input: crate::model::ContinuousParameterRangeSpecification,
        ) -> Self {
            self.continuous_parameter_range_specification = Some(input);
            self
        }
        pub fn set_continuous_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::ContinuousParameterRangeSpecification>,
        ) -> Self {
            self.continuous_parameter_range_specification = input;
            self
        }
        /// <p>A <code>CategoricalParameterRangeSpecification</code> object that defines the possible
        /// values for a categorical hyperparameter.</p>
        pub fn categorical_parameter_range_specification(
            mut self,
            input: crate::model::CategoricalParameterRangeSpecification,
        ) -> Self {
            self.categorical_parameter_range_specification = Some(input);
            self
        }
        pub fn set_categorical_parameter_range_specification(
            mut self,
            input: std::option::Option<crate::model::CategoricalParameterRangeSpecification>,
        ) -> Self {
            self.categorical_parameter_range_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterRange`](crate::model::ParameterRange)
        pub fn build(self) -> crate::model::ParameterRange {
            crate::model::ParameterRange {
                integer_parameter_range_specification: self.integer_parameter_range_specification,
                continuous_parameter_range_specification: self
                    .continuous_parameter_range_specification,
                categorical_parameter_range_specification: self
                    .categorical_parameter_range_specification,
            }
        }
    }
}
impl ParameterRange {
    /// Creates a new builder-style object to manufacture [`ParameterRange`](crate::model::ParameterRange)
    pub fn builder() -> crate::model::parameter_range::Builder {
        crate::model::parameter_range::Builder::default()
    }
}

/// <p>Defines the possible values for a categorical hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CategoricalParameterRangeSpecification {
    /// <p>The allowed categories for the hyperparameter.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for CategoricalParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CategoricalParameterRangeSpecification");
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
pub mod categorical_parameter_range_specification {
    /// A builder for [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
        pub fn build(self) -> crate::model::CategoricalParameterRangeSpecification {
            crate::model::CategoricalParameterRangeSpecification {
                values: self.values,
            }
        }
    }
}
impl CategoricalParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`CategoricalParameterRangeSpecification`](crate::model::CategoricalParameterRangeSpecification)
    pub fn builder() -> crate::model::categorical_parameter_range_specification::Builder {
        crate::model::categorical_parameter_range_specification::Builder::default()
    }
}

/// <p>Defines the possible values for a continuous hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousParameterRangeSpecification {
    /// <p>The minimum floating-point value allowed.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum floating-point value allowed.</p>
    pub max_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContinuousParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousParameterRangeSpecification");
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.finish()
    }
}
/// See [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
pub mod continuous_parameter_range_specification {
    /// A builder for [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The minimum floating-point value allowed.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum floating-point value allowed.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
        pub fn build(self) -> crate::model::ContinuousParameterRangeSpecification {
            crate::model::ContinuousParameterRangeSpecification {
                min_value: self.min_value,
                max_value: self.max_value,
            }
        }
    }
}
impl ContinuousParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`ContinuousParameterRangeSpecification`](crate::model::ContinuousParameterRangeSpecification)
    pub fn builder() -> crate::model::continuous_parameter_range_specification::Builder {
        crate::model::continuous_parameter_range_specification::Builder::default()
    }
}

/// <p>Defines the possible values for an integer hyperparameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IntegerParameterRangeSpecification {
    /// <p>The minimum integer value allowed.</p>
    pub min_value: std::option::Option<std::string::String>,
    /// <p>The maximum integer value allowed.</p>
    pub max_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IntegerParameterRangeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IntegerParameterRangeSpecification");
        formatter.field("min_value", &self.min_value);
        formatter.field("max_value", &self.max_value);
        formatter.finish()
    }
}
/// See [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
pub mod integer_parameter_range_specification {
    /// A builder for [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_value: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The minimum integer value allowed.</p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// <p>The maximum integer value allowed.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// Consumes the builder and constructs a [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
        pub fn build(self) -> crate::model::IntegerParameterRangeSpecification {
            crate::model::IntegerParameterRangeSpecification {
                min_value: self.min_value,
                max_value: self.max_value,
            }
        }
    }
}
impl IntegerParameterRangeSpecification {
    /// Creates a new builder-style object to manufacture [`IntegerParameterRangeSpecification`](crate::model::IntegerParameterRangeSpecification)
    pub fn builder() -> crate::model::integer_parameter_range_specification::Builder {
        crate::model::integer_parameter_range_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterType {
    Categorical,
    Continuous,
    FreeText,
    Integer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterType {
    fn from(s: &str) -> Self {
        match s {
            "Categorical" => ParameterType::Categorical,
            "Continuous" => ParameterType::Continuous,
            "FreeText" => ParameterType::FreeText,
            "Integer" => ParameterType::Integer,
            other => ParameterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParameterType::from(s))
    }
}
impl ParameterType {
    pub fn as_str(&self) -> &str {
        match self {
            ParameterType::Categorical => "Categorical",
            ParameterType::Continuous => "Continuous",
            ParameterType::FreeText => "FreeText",
            ParameterType::Integer => "Integer",
            ParameterType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Categorical", "Continuous", "FreeText", "Integer"]
    }
}
impl AsRef<str> for ParameterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The retention policy for data stored on an Amazon Elastic File System (EFS) volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RetentionPolicy {
    /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
    /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
    pub home_efs_file_system: std::option::Option<crate::model::RetentionType>,
}
impl std::fmt::Debug for RetentionPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RetentionPolicy");
        formatter.field("home_efs_file_system", &self.home_efs_file_system);
        formatter.finish()
    }
}
/// See [`RetentionPolicy`](crate::model::RetentionPolicy)
pub mod retention_policy {
    /// A builder for [`RetentionPolicy`](crate::model::RetentionPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) home_efs_file_system: std::option::Option<crate::model::RetentionType>,
    }
    impl Builder {
        /// <p>The default is <code>Retain</code>, which specifies to keep the data stored on the EFS volume.</p>
        /// <p>Specify <code>Delete</code> to delete the data stored on the EFS volume.</p>
        pub fn home_efs_file_system(mut self, input: crate::model::RetentionType) -> Self {
            self.home_efs_file_system = Some(input);
            self
        }
        pub fn set_home_efs_file_system(
            mut self,
            input: std::option::Option<crate::model::RetentionType>,
        ) -> Self {
            self.home_efs_file_system = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionPolicy`](crate::model::RetentionPolicy)
        pub fn build(self) -> crate::model::RetentionPolicy {
            crate::model::RetentionPolicy {
                home_efs_file_system: self.home_efs_file_system,
            }
        }
    }
}
impl RetentionPolicy {
    /// Creates a new builder-style object to manufacture [`RetentionPolicy`](crate::model::RetentionPolicy)
    pub fn builder() -> crate::model::retention_policy::Builder {
        crate::model::retention_policy::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RetentionType {
    Delete,
    Retain,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RetentionType {
    fn from(s: &str) -> Self {
        match s {
            "Delete" => RetentionType::Delete,
            "Retain" => RetentionType::Retain,
            other => RetentionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RetentionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RetentionType::from(s))
    }
}
impl RetentionType {
    pub fn as_str(&self) -> &str {
        match self {
            RetentionType::Delete => "Delete",
            RetentionType::Retain => "Retain",
            RetentionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Delete", "Retain"]
    }
}
impl AsRef<str> for RetentionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
